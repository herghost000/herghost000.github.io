{"meta":{"title":"ZackAddy's Blog - 不积跬步，无以至千里；不积小流，无以成江海","subtitle":"在线修仙","description":"记录与分享笔记","author":"ZackAddy","url":"https://www.zackaddy.xin"},"pages":[{"title":"ABOUT","date":"2020-02-29T03:31:55.000Z","updated":"2020-08-07T14:10:11.901Z","comments":true,"path":"about/index.html","permalink":"https://www.zackaddy.xin/about/index.html","excerpt":"","text":"嗨。。我叫扎克，是一名码农，我一直都热衷于帮助别人。我住在中国，在某个国家做软件开发。我喜欢创造新事物，喜欢和别人一起工作。 我的工作理念是，与其他开发人员和利益相关者的沟通和协作是一个成功项目的关键，为工作使用合适的工具。编程语言只是一种工具，我总是试图学习新的东西。我认为自己现在很先进。当然，学习新知识总是很有趣的。 技术兴趣： (JavaScript, Flutter, C/C++, Assembly, Sinatra, MySql, Nginx, Redis, DevOps, Linux, Golang, Manchine Learning) 联系邮箱=&gt; 77209302@qq.com^_^"},{"title":"categories","date":"2020-02-27T08:05:45.000Z","updated":"2020-08-07T14:10:11.909Z","comments":true,"path":"categories/index.html","permalink":"https://www.zackaddy.xin/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-24T07:40:24.000Z","updated":"2020-08-07T14:10:11.912Z","comments":true,"path":"tags/index.html","permalink":"https://www.zackaddy.xin/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.901Z","comments":true,"path":"categories/8086汇编/index.html","permalink":"https://www.zackaddy.xin/categories/8086汇编/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-02T04:00:00.000Z","updated":"2020-08-07T14:10:11.902Z","comments":true,"path":"categories/Cocos Creator/index.html","permalink":"https://www.zackaddy.xin/categories/Cocos Creator/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.902Z","comments":true,"path":"categories/C/index.html","permalink":"https://www.zackaddy.xin/categories/C/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.902Z","comments":true,"path":"categories/Cpp设计模式/index.html","permalink":"https://www.zackaddy.xin/categories/Cpp设计模式/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.902Z","comments":true,"path":"categories/Cpp/index.html","permalink":"https://www.zackaddy.xin/categories/Cpp/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.903Z","comments":true,"path":"categories/Flutter Widget/index.html","permalink":"https://www.zackaddy.xin/categories/Flutter Widget/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.904Z","comments":true,"path":"categories/Java/index.html","permalink":"https://www.zackaddy.xin/categories/Java/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.903Z","comments":true,"path":"categories/Golang/index.html","permalink":"https://www.zackaddy.xin/categories/Golang/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-30T07:30:30.000Z","updated":"2020-08-07T14:10:11.904Z","comments":true,"path":"categories/LinearAlgebra/index.html","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.905Z","comments":true,"path":"categories/Lua/index.html","permalink":"https://www.zackaddy.xin/categories/Lua/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.904Z","comments":true,"path":"categories/JavaScript/index.html","permalink":"https://www.zackaddy.xin/categories/JavaScript/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.904Z","comments":true,"path":"categories/Linux驱动/index.html","permalink":"https://www.zackaddy.xin/categories/Linux驱动/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-04-01T07:30:30.000Z","updated":"2020-08-07T14:10:11.905Z","comments":true,"path":"categories/Mysql/index.html","permalink":"https://www.zackaddy.xin/categories/Mysql/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-06-01T07:30:30.000Z","updated":"2020-08-07T14:10:11.906Z","comments":true,"path":"categories/Nginx/index.html","permalink":"https://www.zackaddy.xin/categories/Nginx/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.905Z","comments":true,"path":"categories/MFC/index.html","permalink":"https://www.zackaddy.xin/categories/MFC/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-20T07:30:30.000Z","updated":"2020-08-07T14:17:49.287Z","comments":true,"path":"categories/OpenGL/index.html","permalink":"https://www.zackaddy.xin/categories/OpenGL/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-08-01T07:30:30.000Z","updated":"2020-08-07T14:10:11.906Z","comments":true,"path":"categories/PHP/index.html","permalink":"https://www.zackaddy.xin/categories/PHP/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.907Z","comments":true,"path":"categories/React/index.html","permalink":"https://www.zackaddy.xin/categories/React/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.906Z","comments":true,"path":"categories/Python/index.html","permalink":"https://www.zackaddy.xin/categories/Python/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.907Z","comments":true,"path":"categories/STL/index.html","permalink":"https://www.zackaddy.xin/categories/STL/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-05-01T07:30:30.000Z","updated":"2020-08-07T14:10:11.907Z","comments":true,"path":"categories/Redis/index.html","permalink":"https://www.zackaddy.xin/categories/Redis/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.908Z","comments":true,"path":"categories/Smali汇编/index.html","permalink":"https://www.zackaddy.xin/categories/Smali汇编/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.909Z","comments":true,"path":"categories/Windows PE/index.html","permalink":"https://www.zackaddy.xin/categories/Windows PE/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.908Z","comments":true,"path":"categories/Vue/index.html","permalink":"https://www.zackaddy.xin/categories/Vue/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.909Z","comments":true,"path":"categories/Windows驱动/index.html","permalink":"https://www.zackaddy.xin/categories/Windows驱动/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.909Z","comments":true,"path":"categories/Windows内核/index.html","permalink":"https://www.zackaddy.xin/categories/Windows内核/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.911Z","comments":true,"path":"categories/代码重构/index.html","permalink":"https://www.zackaddy.xin/categories/代码重构/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.910Z","comments":true,"path":"categories/x86汇编/index.html","permalink":"https://www.zackaddy.xin/categories/x86汇编/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.911Z","comments":true,"path":"categories/计算机网络/index.html","permalink":"https://www.zackaddy.xin/categories/计算机网络/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.911Z","comments":true,"path":"categories/数据结构/index.html","permalink":"https://www.zackaddy.xin/categories/数据结构/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-24T07:30:30.000Z","updated":"2020-08-07T14:10:11.912Z","comments":true,"path":"categories/逆向分析/index.html","permalink":"https://www.zackaddy.xin/categories/逆向分析/index.html","excerpt":"","text":""}],"posts":[{"title":"77、OpenGL 之阴影映射","slug":"OpenGL/77、OpenGL 之阴影映射","date":"2020-06-28T06:00:00.000Z","updated":"2020-08-07T14:20:18.841Z","comments":true,"path":"2020/06/28/OpenGL/77、OpenGL 之阴影映射/","link":"","permalink":"https://www.zackaddy.xin/2020/06/28/OpenGL/77、OpenGL 之阴影映射/","excerpt":"","text":"OpenGL 之阴影映射阴影贴图（Shadow mapping）是在三维计算机图形中加入阴影的过程。阴影贴图的概念最初是由 Lance Williams 于 1978年在“在曲面上投射阴影”这篇论文中提出的。从那时开始，这种方法就已经用于场景预渲染、实时甚至是许多游戏设备以及高端电脑游戏中。在Pixar 的RenderMan 中就使用了阴影贴图技术，同样，在 玩具总动员 这样的游戏中也使用了这项技术。 像素与以纹理形式保存的光照深度缓冲区或者深度图像比较，通过这种方式计算像素是否处于光源照射范围之内，从而生成阴影。(引自维基百科) 原理阴影贴图是一种使用深度纹理来为渲染阴影提供解决方案的多通道计算。它的关键是，就是用投射光源代替最终视口来观察场景。通过移动视口到光源位置，可以观察到这个位置每个东西都是明亮的，因为从光的角度来看是没有阴影的。从光源的角度将场景的深度渲染到一张深度缓冲区中，我们可以在场景中获得一张阴影或者无阴影的贴图，一张阴影贴图。 一 首先将摄像机设置到光源所在的位置(观察方向面对场景，此时叫摄像机观察矩阵为观察矩阵1”，同时设置合理的投影矩阵(这里称此矩阵为投影矩阵1)。 二 然后对与景进行第二次绘制.此次绘制将每个可以看见的片元(可以观察到指的是片元到光源间无遮挡)到光源的距离记录到一幅纹理图中的对应像素中，供后面的步骤使用。 三 接着将摄像机恢复到实际摄像机所处的位置，绘制场景。此次绘制时将前面步骤产生的纹理采用投影贴图的方式应用到场景中，进行投影贴图时采用的投影矩阵为投影矩阵1、观察矩阵为观察矩阵1. 四 绘制每个片元时，根据投影贴图纹理采样的结果换算出光源与此片元连线中距光源最近的片元距离(ZA)，再计算出此片元距光源的实际距离(ZB)。若ZB〉ZA，则需要绘制的片元处于阴影中，采用阴影的颜色着色，否则此片兀不在阴影中，进行既定的光照着色。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"76、OpenGL 之gamma校正","slug":"OpenGL/76、OpenGL 之gamma校正","date":"2020-06-28T05:00:00.000Z","updated":"2020-08-07T14:20:18.837Z","comments":true,"path":"2020/06/28/OpenGL/76、OpenGL 之gamma校正/","link":"","permalink":"https://www.zackaddy.xin/2020/06/28/OpenGL/76、OpenGL 之gamma校正/","excerpt":"","text":"OpenGL 之gamma校正人眼感光特性由于我们生活的世界中的景物亮度变化范围非常大。比如在晚上微弱的光线下我们要能及时发现危险；在正午的阳光下要能清晰分辨出物体。我们人类必须适应巨大的亮度差才能存活下来。 人眼可感知的亮度范围为 10^-2 ~ 10^6 cd/m^2 （坎德拉每平米）,可感受范围达10^8 。 顺带提一下， cd/m^2 为国际计量标准的亮度单位，具体的亮度可见下表： 光源 亮度（cd/m^2） 光源 亮度（cd/m^2） 太阳 1.6 x 10^9 便利店招牌 150 弧光灯 1.5 x 10^8 台灯下的白纸 50 白丝灯 50000 霓虹灯 8 多云天气 35000 蜡烛 7.5 日光灯 12000 月光 2.5 月球表面 1000 夜空 0.001 金属卤化灯物 1500 值得一提的是，人眼的感光能力是随着外界环境光的强弱来自动调节的：比如在昏暗的房间里，我没看到的烛光是明亮的，但是同样的烛光在正午阳光下，我们甚至连火苗都看不见；当晚上突然开灯的时候会觉得灯光刺眼，要隔一阵子才能适应灯光。在适中的环境亮度下，人眼识别的亮度范围在 [公式] 这个数量级。 这说明人眼对亮度变化的反应随着光的增加而减弱。实验表明，人眼的这种特性近似于 Log 函数，若用 I 表示亮度，S 表示人眼反应，那么两者之间的对应关系为： （公式 1） S = a * log I 其中 a 为常数。 可以看出人眼对暗部的变化比较敏感 过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度,约为输入电压的2.2次幂的亮度，这叫做监视器Gamma。 基于这个特性，我们对gamma进行校正，假设颜色为0.5，我们对其取gamma倒数次方，0.5^(1/2.2)","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"75、OpenGL 之高级光照Blinn-Phong","slug":"OpenGL/75、OpenGL 之高级光照Blinn-Phong","date":"2020-06-27T06:00:00.000Z","updated":"2020-08-07T14:20:18.832Z","comments":true,"path":"2020/06/27/OpenGL/75、OpenGL 之高级光照Blinn-Phong/","link":"","permalink":"https://www.zackaddy.xin/2020/06/27/OpenGL/75、OpenGL 之高级光照Blinn-Phong/","excerpt":"","text":"OpenGL 之高级光照Blinn-Phong冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为1.0时地板会出现的效果： 可以看到，在镜面高光区域的边缘出现了一道很明显的断层。 1977年，James F. Blinn在冯氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。 当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。 现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。 获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了： 123vec3 lightDir = normalize(lightPos - FragPos);vec3 viewDir = normalize(viewPos - FragPos);vec3 halfwayDir = normalize(lightDir + viewDir); 接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方： 12float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);vec3 specular = lightColor * spec; 除此之外Blinn-Phong模型就没什么好说的了，Blinn-Phong与冯氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。 在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为0.5时的对比： 除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的2到4倍。 下面是冯氏着色反光度为8.0，Blinn-Phong着色反光度为32.0时的一个对比： 你可以看到，Blinn-Phong的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但Blinn-Phong模型通常会产出更真实的结果。 这里，我们使用了一个简单的片段着色器，让我们能够在冯氏反射与Blinn-Phong反射间进行切换： 1234567891011121314void main()&#123; [...] float spec = 0.0; if(blinn) &#123; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0); &#125; else &#123; vec3 reflectDir = reflect(-lightDir, normal); spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0); &#125; 源码1.advanced_lighting.vs 12345678910111213141516171819202122#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;// declare an interface block; see 'Advanced GLSL' for what these are.out VS_OUT &#123; vec3 FragPos; vec3 Normal; vec2 TexCoords;&#125; vs_out;uniform mat4 projection;uniform mat4 view;void main()&#123; vs_out.FragPos = aPos; vs_out.Normal = aNormal; vs_out.TexCoords = aTexCoords; gl_Position = projection * view * vec4(aPos, 1.0);&#125; 1.advanced_lighting.fs 1234567891011121314151617181920212223242526272829303132333435363738394041#version 330 coreout vec4 FragColor;in VS_OUT &#123; vec3 FragPos; vec3 Normal; vec2 TexCoords;&#125; fs_in;uniform sampler2D floorTexture;uniform vec3 lightPos;uniform vec3 viewPos;uniform bool blinn;void main()&#123; vec3 color = texture(floorTexture, fs_in.TexCoords).rgb; // ambient vec3 ambient = 0.05 * color; // diffuse vec3 lightDir = normalize(lightPos - fs_in.FragPos); vec3 normal = normalize(fs_in.Normal); float diff = max(dot(lightDir, normal), 0.0); vec3 diffuse = diff * color; // specular vec3 viewDir = normalize(viewPos - fs_in.FragPos); vec3 reflectDir = reflect(-lightDir, normal); float spec = 0.0; if(blinn) &#123; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0); &#125; else &#123; vec3 reflectDir = reflect(-lightDir, normal); spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0); &#125; vec3 specular = vec3(0.3) * spec; // assuming bright white light color FragColor = vec4(ambient + diffuse + specular, 1.0);&#125; lighting.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;stb_image.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;learnopengl/shader_m.h&gt;#include &lt;learnopengl/camera.h&gt;#include &lt;learnopengl/model.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;bool blinn = false;bool blinnKeyPressed = false;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // build and compile shaders // ------------------------- Shader shader(\"1.advanced_lighting.vs\", \"1.advanced_lighting.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float planeVertices[] = &#123; // positions // normals // texcoords 10.0f, -0.5f, 10.0f, 0.0f, 1.0f, 0.0f, 10.0f, 0.0f, -10.0f, -0.5f, 10.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -10.0f, -0.5f, -10.0f, 0.0f, 1.0f, 0.0f, 0.0f, 10.0f, 10.0f, -0.5f, 10.0f, 0.0f, 1.0f, 0.0f, 10.0f, 0.0f, -10.0f, -0.5f, -10.0f, 0.0f, 1.0f, 0.0f, 0.0f, 10.0f, 10.0f, -0.5f, -10.0f, 0.0f, 1.0f, 0.0f, 10.0f, 10.0f &#125;; // plane VAO unsigned int planeVAO, planeVBO; glGenVertexArrays(1, &amp;planeVAO); glGenBuffers(1, &amp;planeVBO); glBindVertexArray(planeVAO); glBindBuffer(GL_ARRAY_BUFFER, planeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), planeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glBindVertexArray(0); // load textures // ------------- unsigned int floorTexture = loadTexture(FileSystem::getPath(\"resources/textures/wood.png\").c_str()); // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); // lighting info // ------------- glm::vec3 lightPos(0.0f, 0.0f, 0.0f); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw objects shader.use(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); shader.setMat4(\"projection\", projection); shader.setMat4(\"view\", view); // set light uniforms shader.setVec3(\"viewPos\", camera.Position); shader.setVec3(\"lightPos\", lightPos); shader.setInt(\"blinn\", blinn); // floor glBindVertexArray(planeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, floorTexture); glDrawArrays(GL_TRIANGLES, 0, 6); std::cout &lt;&lt; (blinn ? \"Blinn-Phong\" : \"Phong\") &lt;&lt; std::endl; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;planeVAO); glDeleteBuffers(1, &amp;planeVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime); if (glfwGetKey(window, GLFW_KEY_B) == GLFW_PRESS &amp;&amp; !blinnKeyPressed) &#123; blinn = !blinn; blinnKeyPressed = true; &#125; if (glfwGetKey(window, GLFW_KEY_B) == GLFW_RELEASE) &#123; blinnKeyPressed = false; &#125;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); // for this tutorial: use GL_CLAMP_TO_EDGE to prevent semi-transparent borders. Due to interpolation it takes texels from next repeat glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"74、OpenGL 之MSAA.md","slug":"OpenGL/74、OpenGL 之MSAA.md","date":"2020-06-27T05:00:00.000Z","updated":"2020-08-07T14:20:18.827Z","comments":true,"path":"2020/06/27/OpenGL/74、OpenGL 之MSAA.md/","link":"","permalink":"https://www.zackaddy.xin/2020/06/27/OpenGL/74、OpenGL 之MSAA.md/","excerpt":"","text":"OpenGL 之MSAA如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。 大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW同样给了我们这个功能，我们所要做的只是提示(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲。这可以在创建窗口之前调用glfwWindowHint来完成。 1glfwWindowHint(GLFW_SAMPLES, 4); 只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用glEnable来启用多重采样。因为多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘： 离屏MSAA如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。 多重采样纹理附件为了创建一个支持储存多个采样点的纹理，我们使用glTexImage2DMultisample来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。 123glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0); 它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。 我们使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。 1glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, 0); 当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。 多重采样渲染缓冲对象和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为glRenderbufferStorageMultisample就可以了。 1glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH24_STENCIL8, width, height); 函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是4。 渲染到多重采样帧缓冲渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。 一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过glBlitFramebuffer来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。 glBlitFramebuffer会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到GL_FRAMEBUFFER时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。 123glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); 如果现在再来渲染这个程序，我们会得到与之前完全一样的结果：一个使用MSAA显示出来的橄榄绿色的立方体，而且锯齿边缘明显减少了： 但如果我们想要使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情呢？我们不能直接在片段着色器中使用多重采样的纹理。但我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的FBO中。然后用这个普通的颜色附件来做后期处理，从而达到我们的目的。然而，这也意味着我们需要生成一个新的FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通2D纹理。这个过程的伪代码是这样的： 123456789101112131415161718192021222324unsigned int msFBO = CreateFBOWithMultiSampledAttachments();// 使用普通的纹理颜色附件创建一个新的FBO...glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, 0);...while(!glfwWindowShouldClose(window))&#123; ... glBindFramebuffer(msFBO); ClearFrameBuffer(); DrawScene(); // 将多重采样缓冲还原到中介FBO上 glBindFramebuffer(GL_READ_FRAMEBUFFER, msFBO); glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO); glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST); // 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理 glBindFramebuffer(GL_FRAMEBUFFER, 0); ClearFramebuffer(); glBindTexture(GL_TEXTURE_2D, screenTexture); DrawPostProcessingQuad(); ... &#125; 如果现在再实现帧缓冲教程中的后期处理效果，我们就能够在一个几乎没有锯齿的场景纹理上进行后期处理了。如果施加模糊的核滤镜，看起来将会是这样： 因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是边缘检测这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"73、OpenGL 之什么是抗锯齿与多重采样","slug":"OpenGL/73、OpenGL 之什么是抗锯齿与多重采样","date":"2020-06-26T06:00:00.000Z","updated":"2020-08-07T14:20:18.822Z","comments":true,"path":"2020/06/26/OpenGL/73、OpenGL 之什么是抗锯齿与多重采样/","link":"","permalink":"https://www.zackaddy.xin/2020/06/26/OpenGL/73、OpenGL 之什么是抗锯齿与多重采样/","excerpt":"","text":"OpenGL 之什么是抗锯齿与多重采样什么是抗锯齿 可能不是非常明显，但如果你离近仔细观察立方体的边缘，你就应该能够看到锯齿状的图案。如果放大的话，你会看到下面的图案： 这很明显不是我们想要在最终程序中所实现的效果。你能够清楚看见形成边缘的像素。这种现象被称之为走样(Aliasing)。有很多种抗锯齿（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更平滑的边缘。 最开始我们有一种叫做超采样抗锯齿(Super Sample Anti-aliasing, SSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。 然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample Anti-aliasing, MSAA)。它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。 什么是多重采样为了理解什么是多重采样(Multisampling)，以及它是如何解决锯齿问题的，我们有必要更加深入地了解OpenGL光栅器的工作方式。 光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。 这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。 你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的： 由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。 多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。 上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖住了三角形。 ==采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。== 从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。 MSAA真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。 这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子： 这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。 简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果： 对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。 不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。 我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但你现在应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"72、OpenGL 之实例化数组","slug":"OpenGL/72、OpenGL 之实例化数组","date":"2020-06-26T05:00:00.000Z","updated":"2020-08-07T14:20:18.818Z","comments":true,"path":"2020/06/26/OpenGL/72、OpenGL 之实例化数组/","link":"","permalink":"https://www.zackaddy.xin/2020/06/26/OpenGL/72、OpenGL 之实例化数组/","excerpt":"","text":"OpenGL 之实例化数组虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过100个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的uniform数据大小上限。它的一个代替方案是实例化数组(Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。 使用顶点属性时，顶点着色器的每次运行都会让GLSL获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。 为了给你一个实例化数组的例子，我们将使用之前的例子，并将偏移量uniform数组设置为一个实例化数组。我们需要在顶点着色器中再添加一个顶点属性： 123456789101112#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aOffset;out vec3 fColor;void main()&#123; gl_Position = vec4(aPos + aOffset, 0.0, 1.0); fColor = aColor;&#125; 我们不再使用gl_InstanceID，现在不需要索引一个uniform数组就能够直接使用offset属性了。 因为实例化数组和position与color变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将（上一部分的）translations数组存到一个新的缓冲对象中： 12345unsigned int instanceVBO;glGenBuffers(1, &amp;instanceVBO);glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * 100, &amp;translations[0], GL_STATIC_DRAW);glBindBuffer(GL_ARRAY_BUFFER, 0); 之后我们还需要设置它的顶点属性指针，并启用顶点属性： 12345glEnableVertexAttribArray(2);glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);glBindBuffer(GL_ARRAY_BUFFER, 0); glVertexAttribDivisor(2, 1); 这段代码很有意思的地方在于最后一行，我们调用了glVertexAttribDivisor。这个函数告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)。默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。我们将属性除数设置为1，是在告诉OpenGL，处于位置值2的顶点属性是一个实例化数组。 如果我们现在使用glDrawArraysInstanced，再次渲染四边形，会得到以下输出： 这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。 为了更有趣一点，我们也可以使用gl_InstanceID，从右上到左下逐渐缩小四边形： 123456void main()&#123; vec2 pos = aPos * (gl_InstanceID / 100.0); gl_Position = vec4(pos + aOffset, 0.0, 1.0); fColor = aColor;&#125; 结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID会越来越接近100，四边形也就越来越接近原始大小。像这样将实例化数组与gl_InstanceID结合使用是完全可行的。 示例10.1.instancing.vs 123456789101112#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aOffset;out vec3 fColor;void main()&#123; fColor = aColor; gl_Position = vec4(aPos + aOffset, 0.0, 1.0);&#125; 10.1.instancing.fs 123456789#version 330 coreout vec4 FragColor;in vec3 fColor;void main()&#123; FragColor = vec4(fColor, 1.0);&#125; instancing_quads.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"10.1.instancing.vs\", \"10.1.instancing.fs\"); // generate a list of 100 quad locations/translation-vectors // --------------------------------------------------------- glm::vec2 translations[100]; int index = 0; float offset = 0.1f; for (int y = -10; y &lt; 10; y += 2) &#123; for (int x = -10; x &lt; 10; x += 2) &#123; glm::vec2 translation; translation.x = (float)x / 10.0f + offset; translation.y = (float)y / 10.0f + offset; translations[index++] = translation; &#125; &#125; // store instance data in an array buffer // -------------------------------------- unsigned int instanceVBO; glGenBuffers(1, &amp;instanceVBO); glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(glm::vec2) * 100, &amp;translations[0], GL_STATIC_DRAW); glBindBuffer(GL_ARRAY_BUFFER, 0); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float quadVertices[] = &#123; // positions // colors -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, -0.05f, -0.05f, 0.0f, 0.0f, 1.0f, -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, 0.05f, 0.05f, 0.0f, 1.0f, 1.0f &#125;; unsigned int quadVAO, quadVBO; glGenVertexArrays(1, &amp;quadVAO); glGenBuffers(1, &amp;quadVBO); glBindVertexArray(quadVAO); glBindBuffer(GL_ARRAY_BUFFER, quadVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(2 * sizeof(float))); // also set instance data glEnableVertexAttribArray(2); glBindBuffer(GL_ARRAY_BUFFER, instanceVBO); // this attribute comes from a different vertex buffer glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0); glBindBuffer(GL_ARRAY_BUFFER, 0); glVertexAttribDivisor(2, 1); // tell OpenGL this is an instanced vertex attribute. // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw 100 instanced quads shader.use(); glBindVertexArray(quadVAO); glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100); // 100 triangles of 6 vertices each glBindVertexArray(0); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;quadVAO); glDeleteBuffers(1, &amp;quadVBO); glfwTerminate(); return 0;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"71、OpenGL 之实例化","slug":"OpenGL/71、OpenGL 之实例化","date":"2020-06-25T06:00:00.000Z","updated":"2020-08-07T14:20:18.814Z","comments":true,"path":"2020/06/25/OpenGL/71、OpenGL 之实例化/","link":"","permalink":"https://www.zackaddy.xin/2020/06/25/OpenGL/71、OpenGL 之实例化/","excerpt":"","text":"OpenGL 之实例化假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。 如果我们需要渲染大量物体时，代码看起来会像这样： 12345for(unsigned int i = 0; i &lt; amount_of_models_to_draw; i++)&#123; DoSomePreparations(); // 绑定VAO，绑定纹理，设置uniform等 glDrawArrays(GL_TRIANGLES, 0, amount_of_vertices);&#125; 如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。 如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。 实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。 这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。 在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。比如说，我们正在渲染第43个实例，那么顶点着色器中它的gl_InstanceID将会是42。因为每个实例都有唯一的ID，我们可以建立一个数组，将ID与位置值对应起来，将每个实例放置在世界的不同位置。 为了体验一下实例化绘制，我们将会在标准化设备坐标系中使用一个渲染调用，绘制100个2D四边形。我们会索引一个包含100个偏移向量的uniform数组，将偏移值加到每个实例化的四边形上。最终的结果是一个排列整齐的四边形网格： 每个四边形由2个三角形所组成，一共有6个顶点。每个顶点包含一个2D的标准化设备坐标位置向量和一个颜色向量。 下面就是这个例子使用的顶点数据，为了大量填充屏幕，每个三角形都很小： 12345678910float quadVertices[] = &#123; // 位置 // 颜色 -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, -0.05f, -0.05f, 0.0f, 0.0f, 1.0f, -0.05f, 0.05f, 1.0f, 0.0f, 0.0f, 0.05f, -0.05f, 0.0f, 1.0f, 0.0f, 0.05f, 0.05f, 0.0f, 1.0f, 1.0f &#125;; 片段着色器会从顶点着色器接受颜色向量，并将其设置为它的颜色输出，来实现四边形的颜色： 123456789#version 330 coreout vec4 FragColor;in vec3 fColor;void main()&#123; FragColor = vec4(fColor, 1.0);&#125; 到现在都没有什么新内容，但从顶点着色器开始就变得很有趣了： 1234567891011121314#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;out vec3 fColor;uniform vec2 offsets[100];void main()&#123; vec2 offset = offsets[gl_InstanceID]; gl_Position = vec4(aPos + offset, 0.0, 1.0); fColor = aColor;&#125; 这里我们定义了一个叫做offsets的数组，它包含100个偏移向量。在顶点着色器中，我们会使用gl_InstanceID来索引offsets数组，获取每个实例的偏移向量。如果我们要实例化绘制100个四边形，仅使用这个顶点着色器我们就能得到100个位于不同位置的四边形。 当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套for循环计算： 12345678910111213glm::vec2 translations[100];int index = 0;float offset = 0.1f;for(int y = -10; y &lt; 10; y += 2)&#123; for(int x = -10; x &lt; 10; x += 2) &#123; glm::vec2 translation; translation.x = (float)x / 10.0f + offset; translation.y = (float)y / 10.0f + offset; translations[index++] = translation; &#125;&#125; 这里，我们创建100个位移向量，表示10x10网格上的所有位置。除了生成translations数组之外，我们还需要将数据转移到顶点着色器的uniform数组中： 123456789shader.use();for(unsigned int i = 0; i &lt; 100; i++)&#123; stringstream ss; string index; ss &lt;&lt; i; index = ss.str(); shader.setVec2((\"offsets[\" + index + \"]\").c_str(), translations[i]);&#125; 在这一段代码中，我们将for循环的计数器i转换为一个string，我们可以用它来动态创建位置值的字符串，用于uniform位置值的索引。接下来，我们会对offsets uniform数组中的每一项设置对应的位移向量。 现在所有的准备工作都做完了，我们可以开始渲染四边形了。对于实例化渲染，我们使用glDrawArraysInstanced或glDrawElementsInstanced。因为我们使用的不是索引缓冲，我们会调用glDrawArrays版本的函数： 12glBindVertexArray(quadVAO);glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 100); glDrawArraysInstanced的参数和glDrawArrays完全一样，除了最后多了个参数用来设置需要绘制的实例数量。因为我们想要在10x10网格中显示100个四边形，我们将它设置为100.运行代码之后，你应该能得到熟悉的100个五彩的四边形。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"70、OpenGL 之几何着色器","slug":"OpenGL/70、OpenGL 之几何着色器","date":"2020-06-25T05:00:00.000Z","updated":"2020-08-07T14:20:18.809Z","comments":true,"path":"2020/06/25/OpenGL/70、OpenGL 之几何着色器/","link":"","permalink":"https://www.zackaddy.xin/2020/06/25/OpenGL/70、OpenGL 之几何着色器/","excerpt":"","text":"OpenGL 之几何着色器 几何着色器的输入是一个图元（如点或三角形）的一组顶点。 几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。 它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。12345678910111213#version 330 corelayout (points) in;layout (line_strip, max_vertices = 2) out;void main() &#123; gl_Position = gl_in[0].gl_Position + vec4(-0.1, 0.0, 0.0, 0.0); EmitVertex(); gl_Position = gl_in[0].gl_Position + vec4( 0.1, 0.0, 0.0, 0.0); EmitVertex(); EndPrimitive();&#125; 在几何着色器的顶部，我们需要声明从顶点着色器输入的图元类型。这需要在in关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值： points：绘制GL_POINTS图元时（1）。 lines：绘制GL_LINES或GL_LINE_STRIP时（2） lines_adjacency：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4） triangles：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3） triangles_adjacency：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6） 我们还需要指定几何着色器输出的图元类型，这需要在out关键字前面加一个布局修饰符。和输入布局修饰符一样，输出布局修饰符也可以接受几个图元值： points line_strip triangle_strip max_vertices为最大输出顶点数 每次我们调用EmitVertex时，gl_Position中的向量会被添加到图元中来。 当EndPrimitive被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。 房子示例 9.1.geometry_shader.vs 12345678910111213#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec3 aColor;out VS_OUT &#123; vec3 color;&#125; vs_out;void main()&#123; vs_out.color = aColor; gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); &#125; 9.1.geometry_shader.gs 123456789101112131415161718192021222324252627282930#version 330 corelayout (points) in;layout (triangle_strip, max_vertices = 5) out;in VS_OUT &#123; vec3 color;&#125; gs_in[];out vec3 fColor;void build_house(vec4 position)&#123; fColor = gs_in[0].color; // gs_in[0] since there's only one input vertex gl_Position = position + vec4(-0.2, -0.2, 0.0, 0.0); // 1:bottom-left EmitVertex(); gl_Position = position + vec4( 0.2, -0.2, 0.0, 0.0); // 2:bottom-right EmitVertex(); gl_Position = position + vec4(-0.2, 0.2, 0.0, 0.0); // 3:top-left EmitVertex(); gl_Position = position + vec4( 0.2, 0.2, 0.0, 0.0); // 4:top-right EmitVertex(); gl_Position = position + vec4( 0.0, 0.4, 0.0, 0.0); // 5:top fColor = vec3(1.0, 1.0, 1.0); EmitVertex(); EndPrimitive();&#125;void main() &#123; build_house(gl_in[0].gl_Position);&#125; 9.1.geometry_shader.fs 123456789#version 330 coreout vec4 FragColor;in vec3 fColor;void main()&#123; FragColor = vec4(fColor, 1.0); &#125; geometry_shader_houses.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"9.1.geometry_shader.vs\", \"9.1.geometry_shader.fs\", \"9.1.geometry_shader.gs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float points[] = &#123; -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, // top-left 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, // top-right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, // bottom-right -0.5f, -0.5f, 1.0f, 1.0f, 0.0f // bottom-left &#125;; unsigned int VBO, VAO; glGenBuffers(1, &amp;VBO); glGenVertexArrays(1, &amp;VAO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(points), &amp;points, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), 0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(2 * sizeof(float))); glBindVertexArray(0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw points shader.use(); glBindVertexArray(VAO); glDrawArrays(GL_POINTS, 0, 4); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glfwTerminate(); return 0;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"69、OpenGL 之GLSL使用Uniform缓冲","slug":"OpenGL/69、OpenGL 之GLSL使用Uniform缓冲","date":"2020-06-24T06:00:00.000Z","updated":"2020-08-07T14:20:18.804Z","comments":true,"path":"2020/06/24/OpenGL/69、OpenGL 之GLSL使用Uniform缓冲/","link":"","permalink":"https://www.zackaddy.xin/2020/06/24/OpenGL/69、OpenGL 之GLSL使用Uniform缓冲/","excerpt":"","text":"OpenGL 之GLSL使用Uniform缓冲首先如何才能让OpenGL ES知道哪个Uniform缓冲对应的是哪个Uniform块呢？这里使用的便是绑定点的知识(Binding)，如下。 可以看出，每一个Uniform缓冲对象都是绑定到对应的绑定点的，不同的着色器在使用对应的Uniform缓冲时，只需对应到相应Uniform缓冲的绑定点即可。 首先，我们需要调用glGenBuffers，创建一个Uniform缓冲对象。一旦我们有了一个缓冲对象，我们需要将它绑定到GL_UNIFORM_BUFFER目标，并调用glBufferData，分配足够的内存。 12345unsigned int uboExampleBlock;glGenBuffers(1, &amp;uboExampleBlock);glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);glBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // 分配152字节的内存glBindBuffer(GL_UNIFORM_BUFFER, 0); 从OpenGL 4.2版本起，你也可以添加一个布局标识符，显式地将Uniform块的绑定点储存在着色器中，这样就不用再调用glGetUniformBlockIndex和glUniformBlockBinding了。下面的代码显式地设置了Lights Uniform块的绑定点。 1layout(std140, binding = 3) uniform Lights &#123; ... &#125;; 使用glBindBufferBase或glBindBufferRange来完成。 123glBindBufferBase(GL_UNIFORM_BUFFER, 3, uboExampleBlock); // 或glBindBufferRange(GL_UNIFORM_BUFFER, 3, uboExampleBlock, 0, 152); shader中Uniform块链接到绑定点3： 12unsigned int matrices_index = glGetUniformBlockIndex(shaderA.ID, \"Matrices\"); glUniformBlockBinding(shaderA.ID, matrices_index, 3); 写入数据 123glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection)); glBindBuffer(GL_UNIFORM_BUFFER, 0); 示例8.red.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0, 1.0, 0.0, 1.0);&#125; 8.advanced_glsl.vs 1234567891011121314#version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices&#123; mat4 projection; mat4 view;&#125;;uniform mat4 model;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; cubemaps_skybox.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shaderRed(\"8.advanced_glsl.vs\", \"8.red.fs\"); Shader shaderGreen(\"8.advanced_glsl.vs\", \"8.green.fs\"); Shader shaderBlue(\"8.advanced_glsl.vs\", \"8.blue.fs\"); Shader shaderYellow(\"8.advanced_glsl.vs\", \"8.yellow.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); // configure a uniform buffer object // --------------------------------- // first. We get the relevant block indices unsigned int uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, \"Matrices\"); unsigned int uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, \"Matrices\"); unsigned int uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, \"Matrices\"); unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, \"Matrices\"); // then we link each shader's uniform block to this uniform binding point glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, 3); glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, 3); glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, 3); glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 3); // Now actually create the buffer unsigned int uboMatrices; glGenBuffers(1, &amp;uboMatrices); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW); glBindBuffer(GL_UNIFORM_BUFFER, 0); // define the range of the buffer that links to a uniform binding point glBindBufferRange(GL_UNIFORM_BUFFER, 3, uboMatrices, 0, 2 * sizeof(glm::mat4)); // store the projection matrix (we only do this once now) (note: we're not using zoom anymore by changing the FoV) glm::mat4 projection = glm::perspective(45.0f, (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection)); glBindBuffer(GL_UNIFORM_BUFFER, 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // set the view and projection matrix in the uniform block - we only have to do this once per loop iteration. glm::mat4 view = camera.GetViewMatrix(); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(view)); glBindBuffer(GL_UNIFORM_BUFFER, 0); // draw 4 cubes // RED glBindVertexArray(cubeVAO); shaderRed.use(); glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f)); // move top-left shaderRed.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // GREEN shaderGreen.use(); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(0.75f, 0.75f, 0.0f)); // move top-right shaderGreen.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // YELLOW shaderYellow.use(); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(-0.75f, -0.75f, 0.0f)); // move bottom-left shaderYellow.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // BLUE shaderBlue.use(); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(0.75f, -0.75f, 0.0f)); // move bottom-right shaderBlue.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteBuffers(1, &amp;cubeVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125; Uniform缓冲对象比起独立的uniform有很多好处。 第一，一次设置很多uniform会比一个一个设置多个uniform要快很多。 第二，比起在多个着色器中修改同样的uniform，在Uniform缓冲中修改一次会更容易一些。 最后一个好处可能不会立即显现，如果使用Uniform缓冲对象的话，你可以在着色器中使用更多的uniform。OpenGL限制了它能够处理的uniform数量，这可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS来查询。当使用Uniform缓冲对象时，最大的数量会更高。所以，当你达到了uniform的最大数量时（比如再做骨骼动画(Skeletal Animation)的时候），你总是可以选择使用Uniform缓冲对象。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"68、OpenGL 之GLSL的Uniform缓冲对象与块布局","slug":"OpenGL/68、OpenGL 之GLSL的Uniform缓冲对象与块布局","date":"2020-06-24T05:00:00.000Z","updated":"2020-08-07T14:20:18.800Z","comments":true,"path":"2020/06/24/OpenGL/68、OpenGL 之GLSL的Uniform缓冲对象与块布局/","link":"","permalink":"https://www.zackaddy.xin/2020/06/24/OpenGL/68、OpenGL 之GLSL的Uniform缓冲对象与块布局/","excerpt":"","text":"OpenGL 之GLSL的Uniform缓冲对象与块布局Uniform缓冲对象OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。 因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。 首先，我们将使用一个简单的顶点着色器，将projection和view矩阵存储到所谓的Uniform块(Uniform Block)中： 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices&#123; mat4 projection; mat4 view;&#125;;uniform mat4 model;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 我们声明了一个叫做Matrices的Uniform块，它储存了两个4x4矩阵。Uniform块中的变量可以直接访问，不需要加块名作为前缀。接下来，我们在OpenGL代码中将这些矩阵值存入缓冲中，每个声明了这个Uniform块的着色器都能够访问这些矩阵。 你现在可能会在想layout (std140)这个语句是什么意思。它的意思是说，当前定义的Uniform块对它的内容使用一个特定的内存布局。这个语句设置了Uniform块布局(Uniform Block Layout)。 Uniform块布局Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。 假设着色器中有以下的这个Uniform块： 123456789layout (std140) uniform ExampleBlock&#123; float value; vec3 vector; mat4 matrix; float values[3]; bool boolean; int integer;&#125;; 我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。这个特性本身很棒，但是会对我们造成麻烦。 默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。因为我们无法知道每个uniform变量的偏移量，我们也就不知道如何准确地填充我们的Uniform缓冲了。我们能够使用像是glGetUniformIndices这样的函数来查询这个信息，但这超出本节的范围了。 虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。 每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。 布局规则的原文可以在OpenGL的Uniform缓冲规范这里找到，但我们将会在下面列出最常见的规则。GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。 类型 布局规则 标量，比如int和bool 每个标量的基准对齐量为N。 向量 2N或者4N。这意味着vec3的基准对齐量为4N。 标量或向量的数组 每个元素的基准对齐量与vec4的相同。 矩阵 储存为列向量的数组，每个向量的基准对齐量与vec4的相同。 结构体 等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。 和OpenGL大多数的规范一样，使用例子就能更容易地理解。我们会使用之前引入的那个叫做ExampleBlock的Uniform块，并使用std140布局计算出每个成员的对齐偏移量： 123456789101112131415layout (std140) uniform ExampleBlock&#123; // 基准对齐量 // 对齐偏移量 float value; // 4 // 0 vec3 vector; // 16 // 16 (必须是16的倍数，所以 4-&gt;16) mat4 matrix; // 16 // 32 (列 0) // 16 // 48 (列 1) // 16 // 64 (列 2) // 16 // 80 (列 3) float values[3]; // 16 // 96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148&#125;; 使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。 通过在Uniform块定义之前添加layout (std140)语句，我们告诉OpenGL这个Uniform块使用的是std140布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过shared布局了，剩下的一个布局是packed。当使用紧凑(Packed)布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。 shared（共享布局）：默认情况下，GLSL都会使用这个布局，共享一但硬件定义了偏移量，它们在整个程序中都是共享的，使用shared布局时，允许GLSL对Uniform块中的变量的存储位置进行变动，共享布局可以节省很多空间的优化。 std140布局：std140布局中确定每个变量的偏移都是基于一系列的规则而决定的，这显示的声明了每个变量类型的内存布局，需要我们手动去计算每个变量的偏移量。 packed（紧凑布局）：是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的，所以这种布局是无法共享的，不满足Uniform Buffer的使用需求。在使用Uniform缓冲时我们需要知道每个变量的字节和偏移量，每一个变量的大小都是确定的，我们在学习任何一门语言的初始都会学习变量的大小（字节），例如int类型的变量所占字节为4 Byte。但是Uniform块中变量的间距是无法确定的，这就允许硬件能够将变量放置在合适的位置，例如，一些硬件可能会将一个向量a放在float b之后，其他的硬件可能会将向量a放在float b之前。这个特性虽然合理的安排了变量的存储，但是却给我们使用Uniform缓冲带来了麻烦，因为有了这个特性，我们就无法知道整个Uniform块所占的字节，在初始分配Uniform缓冲时也无法合理的进行分配。为了满足我们Uniform缓冲的需要，我们使用的Uniform块通常都为std140布局，这就需要我们手动去计算每个变量的偏移量，这里便涉及到字节对齐的概念。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"67、OpenGL 之GLSL接口块","slug":"OpenGL/67、OpenGL 之GLSL接口块","date":"2020-06-23T06:00:00.000Z","updated":"2020-08-07T14:20:18.796Z","comments":true,"path":"2020/06/23/OpenGL/67、OpenGL 之GLSL接口块/","link":"","permalink":"https://www.zackaddy.xin/2020/06/23/OpenGL/67、OpenGL 之GLSL接口块/","excerpt":"","text":"OpenGL 之GLSL接口块为了帮助我们管理这些变量，GLSL为我们提供了一个叫做接口块(Interface Block)的东西，来方便我们组合这些变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。 123456789101112131415161718#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;out VS_OUT&#123; vec2 TexCoords;&#125; vs_out;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0); vs_out.TexCoords = aTexCoords;&#125; 我们还需要在下一个着色器，即片段着色器，中定义一个输入接口块。块名(Block Name)应该是和着色器中一样的（VS_OUT），但实例名(Instance Name)（顶点着色器中用的是vs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为vs_out。 1234567891011121314#version 330 coreout vec4 FragColor;in VS_OUT&#123; vec2 TexCoords;&#125; fs_in;uniform sampler2D texture;void main()&#123; FragColor = texture(texture, fs_in.TexCoords); &#125; 只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。这是帮助你管理代码的又一个有用特性，它在几何着色器这样穿插特定着色器阶段的场景下会很有用。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"66、OpenGL 之GLSL内建变量","slug":"OpenGL/66、OpenGL 之GLSL内建变量","date":"2020-06-23T05:00:00.000Z","updated":"2020-08-07T14:20:18.792Z","comments":true,"path":"2020/06/23/OpenGL/66、OpenGL 之GLSL内建变量/","link":"","permalink":"https://www.zackaddy.xin/2020/06/23/OpenGL/66、OpenGL 之GLSL内建变量/","excerpt":"","text":"OpenGL 之GLSL内建变量顶点着色器变量我们已经接触过其中的两个了：顶点着色器的输出向量gl_Position，和片段着色器的gl_FragCoord。 gl_PointSize我们能够选用的其中一个图元是GL_POINTS，如果使用它的话，每一个顶点都是一个图元，都会被渲染为一个点。我们可以通过OpenGL的glPointSize函数来设置渲染出来的点的大小，但我们也可以在顶点着色器中修改这个值。 GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。 在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE： 1glEnable(GL_PROGRAM_POINT_SIZE); 一个简单的例子就是将点的大小设置为裁剪空间位置的z值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。 12345void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0); gl_PointSize = gl_Position.z; &#125; gl_VertexIDgl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个有趣的输入变量，我们只能对它进行读取，它叫做gl_VertexID。 整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。 1234567891011121314#version 420 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 projection;uniform mat4 view;out vec4 pColor;void main()&#123; gl_Position = projection * view * model * vec4(aPos , 1.0f); gl_PointSize = abs(aPos.z) * 10; pColor = vec4(gl_VertexID / 12.0f + 0.1f , gl_VertexID / 3.0f + 0.1f , gl_VertexID / 8.0f + 0.1f, 1.0f);&#125; 12345678#version 420 coreout vec4 FragColor;in vec4 pColor;void main()&#123; FragColor = pColor;&#125; 由于顶点 ID 不同，所以亮度不同 片段着色器变量在片段着色器中，我们也能访问到一些有趣的变量。GLSL提供给我们两个有趣的输入变量：gl_FragCoord和gl_FrontFacing。 gl_FragCoordgl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。 1234567void main()&#123; if(gl_FragCoord.x &lt; 400) FragColor = vec4(1.0, 0.0, 0.0, 1.0); else FragColor = vec4(0.0, 1.0, 0.0, 1.0); &#125; 因为窗口的宽度是800。当一个像素的x坐标小于400时，它一定在窗口的左侧，所以我们给它一个不同的颜色 gl_FrontFacing如果我们不使用面剔除，那么gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分 gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是true，否则就是false。比如说，我们可以这样子创建一个立方体，在内部和外部使用不同的纹理： 123456789101112131415#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D frontTexture;uniform sampler2D backTexture;void main()&#123; if(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords); else FragColor = texture(backTexture, TexCoords);&#125; gl_FragDepthGLSL提供给我们一个叫做gl_FragDepth的输出变量，我们可以使用它来在着色器内设置片段的深度值。 要想设置深度值，我们直接写入一个0.0到1.0之间的float值到输出变量就可以了： 1gl_FragDepth = 0.0; // 这个片段现在的深度值为 0.0 只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。 它被禁用的原因是，OpenGL无法在片段着色器运行之前得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。 在写入gl_FragDepth时，你就需要考虑到它所带来的性能影响。然而，从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量： 1layout (depth_&lt;condition&gt;) out float gl_FragDepth; 条件 描述 any 默认值。提前深度测试是禁用的，你会损失很多性能 greater 你只能让深度值比gl_FragCoord.z更大 less 你只能让深度值比gl_FragCoord.z更小 unchanged 如果你要写入gl_FragDepth，你将只能写入gl_FragCoord.z的值 下面这个例子中，我们对片段的深度值进行了递增，但仍然也保留了一些提前深度测试 123456789#version 420 core // 注意GLSL的版本！out vec4 FragColor;layout (depth_greater) out float gl_FragDepth;void main()&#123; FragColor = vec4(1.0); gl_FragDepth = gl_FragCoord.z + 0.1;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"65、OpenGL 之高级数据","slug":"OpenGL/65、OpenGL 之高级数据","date":"2020-06-22T06:00:00.000Z","updated":"2020-08-07T14:20:18.788Z","comments":true,"path":"2020/06/22/OpenGL/65、OpenGL 之高级数据/","link":"","permalink":"https://www.zackaddy.xin/2020/06/22/OpenGL/65、OpenGL 之高级数据/","excerpt":"","text":"OpenGL 之高级数据到目前为止，我们一直是调用glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。 我们也可以使用glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。 1glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &amp;data); // 范围： [24, 24 + sizeof(data)] 将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针，供我们操作： 1234567891011float data[] = &#123; 0.5f, 1.0f, -0.35f ...&#125;;glBindBuffer(GL_ARRAY_BUFFER, buffer);// 获取指针void *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);// 复制数据到内存memcpy(ptr, data, sizeof(data));// 记得告诉OpenGL我们不再需要这个指针了glUnmapBuffer(GL_ARRAY_BUFFER); 分批顶点数据通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了交错(Interleave)处理，也就是说，我们将每一个顶点的位置、发现和/或纹理坐标紧密放置在一起。既然我们现在已经对缓冲有了更多的了解，我们可以采取另一种方式。 我们可以做的是，将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。 当从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式会是更简单的解决方案，我们可以很容易使用glBufferSubData函数实现： 1234567float positions[] = &#123; ... &#125;;float normals[] = &#123; ... &#125;;float tex[] = &#123; ... &#125;;// 填充缓冲glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &amp;positions);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &amp;normals);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &amp;tex); 这样子我们就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。我们仍可以将它们合并为一个大的数组，再使用glBufferData来填充缓冲，但对于这种工作，使用glBufferSubData会更合适一点。 我们还需要更新顶点属性指针来反映这些改变： 1234glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions))); glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals))); 这给了我们设置顶点属性的另一种方法。使用哪种方法都不会对OpenGL有什么立刻的好处，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。 复制缓冲glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。这个函数的原型如下： 12void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size); 接下来glCopyBufferSubData会从readtarget中读取size大小的数据，并将其写入writetarget缓冲的writeoffset偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲： 1234float vertexData[] = &#123; ... &#125;;glBindBuffer(GL_COPY_READ_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData)); 我们也可以只将writetarget缓冲绑定为新的缓冲目标类型之一： 1234float vertexData[] = &#123; ... &#125;;glBindBuffer(GL_ARRAY_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, sizeof(vertexData));","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"64、OpenGL 之立方体贴图与反射和折射","slug":"OpenGL/64、OpenGL 之立方体贴图与反射和折射","date":"2020-06-22T05:00:00.000Z","updated":"2020-08-07T14:20:18.783Z","comments":true,"path":"2020/06/22/OpenGL/64、OpenGL 之立方体贴图与反射和折射/","link":"","permalink":"https://www.zackaddy.xin/2020/06/22/OpenGL/64、OpenGL 之立方体贴图与反射和折射/","excerpt":"","text":"OpenGL 之立方体贴图与反射和折射 我们根据观察方向向量I¯和物体的法向量N¯，来计算反射向量R¯。我们可以使用GLSL内建的reflect函数来计算这个反射向量。最终的R¯向量将会作为索引/采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。 因为我们已经在场景中配置好天空盒了，创建反射效果并不会很难。我们将会改变箱子的片段着色器，让箱子有反射性： 123456789101112131415#version 330 coreout vec4 FragColor;in vec3 Normal;in vec3 Position;uniform vec3 cameraPos;uniform samplerCube skybox;void main()&#123; vec3 I = normalize(Position - cameraPos); vec3 R = reflect(I, normalize(Normal)); FragColor = vec4(texture(skybox, R).rgb, 1.0);&#125; 我们先计算了观察/摄像机方向向量I，并使用它来计算反射向量R，之后我们将使用R来从天空盒立方体贴图中采样。注意，我们现在又有了片段的插值Normal和Position变量，所以我们需要更新一下顶点着色器。 1234567891011121314151617#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out vec3 Normal;out vec3 Position;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; Normal = mat3(transpose(inverse(model))) * aNormal; Position = vec3(model * vec4(aPos, 1.0)); gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 我们现在使用了一个法向量，所以我们将再次使用法线矩阵(Normal Matrix)来变换它们。Position输出向量是一个世界空间的位置向量。顶点着色器的这个Position输出将用来在片段着色器内计算观察方向向量。 因为我们使用了法线，你还需要更新一下顶点数据，并更新属性指针。还要记得去设置cameraPos这个uniform。 接下来，我们在渲染箱子之前先绑定立方体贴图纹理： 123glBindVertexArray(cubeVAO);glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTexture); glDrawArrays(GL_TRIANGLES, 0, 36); 6.1.cubemaps.vs 1234567891011121314151617#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out vec3 Normal;out vec3 Position;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; Normal = mat3(transpose(inverse(model))) * aNormal; Position = vec3(model * vec4(aPos, 1.0)); gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 6.1.cubemaps.fs 123456789101112131415#version 330 coreout vec4 FragColor;in vec3 Normal;in vec3 Position;uniform vec3 cameraPos;uniform samplerCube skybox;void main()&#123; vec3 I = normalize(Position - cameraPos); vec3 R = reflect(I, normalize(Normal)); FragColor = vec4(texture(skybox, R).rgb, 1.0);&#125; 6.1.skybox.vs 1234567891011121314#version 330 corelayout (location = 0) in vec3 aPos;out vec3 TexCoords;uniform mat4 projection;uniform mat4 view;void main()&#123; TexCoords = aPos; vec4 pos = projection * view * vec4(aPos, 1.0); gl_Position = pos.xyww;&#125; 6.1.skybox.fs 1234567891011#version 330 coreout vec4 FragColor;in vec3 TexCoords;uniform samplerCube skybox;void main()&#123; FragColor = texture(skybox, TexCoords);&#125; cubemaps_skybox.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);unsigned int loadCubemap(vector&lt;std::string&gt; faces);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"6.1.cubemaps.vs\", \"6.1.cubemaps.fs\"); Shader skyboxShader(\"6.1.skybox.vs\", \"6.1.skybox.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // normals -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f &#125;; float skyboxVertices[] = &#123; // positions -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float))); // skybox VAO unsigned int skyboxVAO, skyboxVBO; glGenVertexArrays(1, &amp;skyboxVAO); glGenBuffers(1, &amp;skyboxVBO); glBindVertexArray(skyboxVAO); glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &amp;skyboxVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); // load textures // ------------- unsigned int cubeTexture = loadTexture(\"container.jpg\"); vector&lt;std::string&gt; faces &#123; \"./skybox/right.jpg\", \"./skybox/left.jpg\", \"./skybox/top.jpg\", \"./skybox/bottom.jpg\", \"./skybox/front.jpg\", \"./skybox/back.jpg\", &#125;; unsigned int cubemapTexture = loadCubemap(faces); // shader configuration // -------------------- shader.use(); shader.setInt(\"skybox\", 0); skyboxShader.use(); skyboxShader.setInt(\"skybox\", 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw scene as normal shader.use(); glm::mat4 model = glm::mat4(1.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); shader.setMat4(\"model\", model); shader.setMat4(\"view\", view); shader.setMat4(\"projection\", projection); shader.setVec3(\"cameraPos\", camera.Position); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); // draw skybox as last glDepthFunc(GL_LEQUAL); // change depth function so depth test passes when values are equal to depth buffer's content skyboxShader.use(); view = glm::mat4(glm::mat3(camera.GetViewMatrix())); // remove translation from the view matrix skyboxShader.setMat4(\"view\", view); skyboxShader.setMat4(\"projection\", projection); // skybox cube glBindVertexArray(skyboxVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); glDepthFunc(GL_LESS); // set depth function back to default // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;skyboxVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;skyboxVAO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;// loads a cubemap texture from 6 individual texture faces// order:// +X (right)// -X (left)// +Y (top)// -Y (bottom)// +Z (front) // -Z (back)// -------------------------------------------------------unsigned int loadCubemap(vector&lt;std::string&gt; faces)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); int width, height, nrChannels; for (unsigned int i = 0; i &lt; faces.size(); i++) &#123; unsigned char *data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Cubemap texture failed to load at path: \" &lt;&lt; faces[i] &lt;&lt; std::endl; stbi_image_free(data); &#125; &#125; glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); return textureID;&#125; 折射环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。 折射是通过斯涅尔定律(Snell’s Law)来描述的，使用环境贴图的话看起来像是这样： 同样，我们有一个观察向量I¯，一个法向量N¯，而这次是折射向量R¯。可以看到，观察向量的方向轻微弯曲了。弯折后的向量R¯将会用来从立方体贴图中采样。 折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。 折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到： 材质 折射率 空气 1.00 水 1.33 冰 1.309 玻璃 1.52 钻石 2.42 我们使用这些折射率来计算光传播的两种材质间的比值。在我们的例子中，光线/视线从空气进入玻璃（如果我们假设箱子是玻璃制的），所以比值为1.00/1.52=0.658。 我们已经绑定了立方体贴图，提供了顶点数据和法线，并设置了摄像机位置的uniform。唯一要修改的就是片段着色器： 1234567void main()&#123; float ratio = 1.00 / 1.52; vec3 I = normalize(Position - cameraPos); vec3 R = refract(I, normalize(Normal), ratio); FragColor = vec4(texture(skybox, R).rgb, 1.0);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"63、OpenGL 之立方体贴图与天空盒","slug":"OpenGL/63、OpenGL 之立方体贴图与天空盒","date":"2020-06-21T06:00:00.000Z","updated":"2020-08-07T14:20:18.779Z","comments":true,"path":"2020/06/21/OpenGL/63、OpenGL 之立方体贴图与天空盒/","link":"","permalink":"https://www.zackaddy.xin/2020/06/21/OpenGL/63、OpenGL 之立方体贴图与天空盒/","excerpt":"","text":"OpenGL 之立方体贴图将多个纹理组合起来映射到一张纹理上的一种纹理类型：立方体贴图(Cube Map)。 创建立方体贴图立方体贴图是和其它纹理一样的，所以如果想创建一个立方体贴图的话，我们需要生成一个纹理，并将其绑定到纹理目标上，之后再做其它的纹理操作。这次要绑定到GL_TEXTURE_CUBE_MAP： 123unsigned int textureID;glGenTextures(1, &amp;textureID);glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); 因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，参数和之前教程中很类似。但这一次我们将纹理目标(target)参数设置为立方体贴图的一个特定的面，告诉OpenGL我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次glTexImage2D。 由于我们有6个面，OpenGL给我们提供了6个特殊的纹理目标，专门对应立方体贴图的一个面。 纹理目标 方位 GL_TEXTURE_CUBE_MAP_POSITIVE_X 右 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 左 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 上 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 下 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 后 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 前 和OpenGL的很多枚举(Enum)一样，它们背后的int值是线性递增的，所以如果我们有一个纹理位置的数组或者vector，我们就可以从GL_TEXTURE_CUBE_MAP_POSITIVE_X开始遍历它们，在每个迭代中对枚举值加1，遍历了整个纹理目标： 12345678910int width, height, nrChannels;unsigned char *data; for(unsigned int i = 0; i &lt; textures_faces.size(); i++)&#123; data = stbi_load(textures_faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data );&#125; 这里我们有一个叫做textures_faces的vector，它包含了立方体贴图所需的所有纹理路径，并以表中的顺序排列。这将为当前绑定的立方体贴图中的每个面生成一个纹理。 因为立方体贴图和其它纹理没什么不同，我们也需要设定它的环绕和过滤方式： 12345glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); 不要被GL_TEXTURE_WRAP_R吓到，它仅仅是为纹理的R坐标设置了环绕方式，它对应的是纹理的第三个维度（和位置的z一样）。我们将环绕方式设置为GL_CLAMP_TO_EDGE，这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），所以通过使用GL_CLAMP_TO_EDGE，OpenGL将在我们对两个面之间采样的时候，永远返回它们的边界值。 在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图，这和普通的2D纹理没什么区别。 在片段着色器中，我们使用了一个不同类型的采样器，samplerCube，我们将使用texture函数使用它进行采样，但这次我们将使用一个vec3的方向向量而不是vec2。使用立方体贴图的片段着色器会像是这样的： 1234567in vec3 textureDir; // 代表3D纹理坐标的方向向量uniform samplerCube cubemap; // 立方体贴图的纹理采样器void main()&#123; FragColor = texture(cubemap, textureDir);&#125; 天空盒 https://learnopengl-cn.github.io/data/skybox.rar 因为天空盒本身就是一个立方体贴图，加载天空盒和之前加载立方体贴图时并没有什么不同。为了加载天空盒，我们将使用下面的函数，它接受一个包含6个纹理路径的vector： 12345678910111213141516171819202122232425262728293031unsigned int loadCubemap(vector&lt;std::string&gt; faces)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); int width, height, nrChannels; for (unsigned int i = 0; i &lt; faces.size(); i++) &#123; unsigned char *data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data ); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Cubemap texture failed to load at path: \" &lt;&lt; faces[i] &lt;&lt; std::endl; stbi_image_free(data); &#125; &#125; glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); return textureID;&#125; 函数本身应该很熟悉了。它基本就是上一部分中立方体贴图的代码，只不过合并到了一个便于管理的函数中。 之后，在调用这个函数之前，我们需要将合适的纹理路径按照立方体贴图枚举指定的顺序加载到一个vector中。 12345678910vector&lt;std::string&gt; faces&#123; \"right.jpg\", \"left.jpg\", \"top.jpg\", \"bottom.jpg\", \"front.jpg\", \"back.jpg\"&#125;;unsigned int cubemapTexture = loadCubemap(faces); 6.1.cubemaps.vs 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 6.1.cubemaps.fs 1234567891011#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; FragColor = texture(texture1, TexCoords);&#125; 6.1.skybox.vs 1234567891011121314#version 330 corelayout (location = 0) in vec3 aPos;out vec3 TexCoords;uniform mat4 projection;uniform mat4 view;void main()&#123; TexCoords = aPos; vec4 pos = projection * view * vec4(aPos, 1.0); gl_Position = pos.xyww;&#125; 6.1.skybox.fs 1234567891011#version 330 coreout vec4 FragColor;in vec3 TexCoords;uniform samplerCube skybox;void main()&#123; FragColor = texture(skybox, TexCoords);&#125; cubemaps_skybox.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);unsigned int loadCubemap(vector&lt;std::string&gt; faces);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"6.1.cubemaps.vs\", \"6.1.cubemaps.fs\"); Shader skyboxShader(\"6.1.skybox.vs\", \"6.1.skybox.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // texture Coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; float skyboxVertices[] = &#123; // positions -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // skybox VAO unsigned int skyboxVAO, skyboxVBO; glGenVertexArrays(1, &amp;skyboxVAO); glGenBuffers(1, &amp;skyboxVBO); glBindVertexArray(skyboxVAO); glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &amp;skyboxVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); // load textures // ------------- unsigned int cubeTexture = loadTexture(\"container.jpg\"); vector&lt;std::string&gt; faces &#123; \"./skybox/right.jpg\", \"./skybox/left.jpg\", \"./skybox/top.jpg\", \"./skybox/bottom.jpg\", \"./skybox/front.jpg\", \"./skybox/back.jpg\", &#125;; unsigned int cubemapTexture = loadCubemap(faces); // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); skyboxShader.use(); skyboxShader.setInt(\"skybox\", 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw scene as normal shader.use(); glm::mat4 model = glm::mat4(1.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); shader.setMat4(\"model\", model); shader.setMat4(\"view\", view); shader.setMat4(\"projection\", projection); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); // draw skybox as last glDepthFunc(GL_LEQUAL); // change depth function so depth test passes when values are equal to depth buffer's content skyboxShader.use(); view = glm::mat4(glm::mat3(camera.GetViewMatrix())); // remove translation from the view matrix skyboxShader.setMat4(\"view\", view); skyboxShader.setMat4(\"projection\", projection); // skybox cube glBindVertexArray(skyboxVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); glDepthFunc(GL_LESS); // set depth function back to default // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;skyboxVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;skyboxVAO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;// loads a cubemap texture from 6 individual texture faces// order:// +X (right)// -X (left)// +Y (top)// -Y (bottom)// +Z (front) // -Z (back)// -------------------------------------------------------unsigned int loadCubemap(vector&lt;std::string&gt; faces)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); int width, height, nrChannels; for (unsigned int i = 0; i &lt; faces.size(); i++) &#123; unsigned char *data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Cubemap texture failed to load at path: \" &lt;&lt; faces[i] &lt;&lt; std::endl; stbi_image_free(data); &#125; &#125; glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"62、OpenGL 之渲染到纹理的后期处理","slug":"OpenGL/62、OpenGL 之渲染到纹理的后期处理","date":"2020-06-21T05:00:00.000Z","updated":"2020-08-07T14:20:18.774Z","comments":true,"path":"2020/06/21/OpenGL/62、OpenGL 之渲染到纹理的后期处理/","link":"","permalink":"https://www.zackaddy.xin/2020/06/21/OpenGL/62、OpenGL 之渲染到纹理的后期处理/","excerpt":"","text":"OpenGL 之渲染到纹理的后期处理整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果 反相我们将会从屏幕纹理中取颜色值，然后用1.0减去它，对它进行反相： 1234void main()&#123; FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0);&#125; 灰度另外一个很有趣的效果是，移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化(Grayscale)。很简单的实现方式是，取所有的颜色分量，将它们平均化： 123456void main()&#123; FragColor = texture(screenTexture, TexCoords); float average = (FragColor.r + FragColor.g + FragColor.b) / 3.0; FragColor = vec4(average, average, average, 1.0);&#125; 这已经能创造很好的结果了，但人眼会对绿色更加敏感一些，而对蓝色不那么敏感，所以为了获取物理上更精确的效果，我们需要使用加权的(Weighted)通道： 123456void main()&#123; FragColor = texture(screenTexture, TexCoords); float average = 0.2126 * FragColor.r + 0.7152 * FragColor.g + 0.0722 * FragColor.b; FragColor = vec4(average, average, average, 1.0);&#125; 在更复杂的场景中，这样的加权灰度效果会更真实一点。 更多效果请看 https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/05%20Framebuffers/#_9","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"61、OpenGL 之渲染到纹理","slug":"OpenGL/61、OpenGL 之渲染到纹理","date":"2020-06-20T06:00:00.000Z","updated":"2020-08-07T14:20:18.769Z","comments":true,"path":"2020/06/20/OpenGL/61、OpenGL 之渲染到纹理/","link":"","permalink":"https://www.zackaddy.xin/2020/06/20/OpenGL/61、OpenGL 之渲染到纹理/","excerpt":"","text":"渲染到纹理我们将会将场景渲染到一个附加到帧缓冲对象上的颜色纹理中，之后将在一个横跨整个屏幕的四边形上绘制这个纹理。这样视觉输出和没使用帧缓冲时是完全一样的，但这次是打印到了一个四边形上。 5.1.framebuffers.vs 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 5.1.framebuffers.fs 1234567891011#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; FragColor = texture(texture1, TexCoords);&#125; 5.1.framebuffers_screen.vs 1234567891011#version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;void main()&#123; TexCoords = aTexCoords; gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); &#125; 5.1.framebuffers_screen.fs 123456789101112#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D screenTexture;void main()&#123; vec3 col = texture(screenTexture, TexCoords).rgb; FragColor = vec4(col, 1.0);&#125; framebuffers.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"5.1.framebuffers.vs\", \"5.1.framebuffers.fs\"); Shader screenShader(\"5.1.framebuffers_screen.vs\", \"5.1.framebuffers_screen.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // texture Coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; float planeVertices[] = &#123; // positions // texture Coords 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, 5.0f, 0.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, -5.0f, 2.0f, 2.0f &#125;; float quadVertices[] = &#123; // vertex attributes for a quad that fills the entire screen in Normalized Device Coordinates. // positions // texCoords -1.0f, 1.0f, 0.0f, 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, -1.0f, 1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // plane VAO unsigned int planeVAO, planeVBO; glGenVertexArrays(1, &amp;planeVAO); glGenBuffers(1, &amp;planeVBO); glBindVertexArray(planeVAO); glBindBuffer(GL_ARRAY_BUFFER, planeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), &amp;planeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // screen quad VAO unsigned int quadVAO, quadVBO; glGenVertexArrays(1, &amp;quadVAO); glGenBuffers(1, &amp;quadVBO); glBindVertexArray(quadVAO); glBindBuffer(GL_ARRAY_BUFFER, quadVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &amp;quadVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float))); // load textures // ------------- unsigned int cubeTexture = loadTexture(\"container.jpg\"); unsigned int floorTexture = loadTexture(\"metal.png\"); // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); screenShader.use(); screenShader.setInt(\"screenTexture\", 0); // framebuffer configuration // ------------------------- unsigned int framebuffer; glGenFramebuffers(1, &amp;framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // create a color attachment texture unsigned int textureColorbuffer; glGenTextures(1, &amp;textureColorbuffer); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0); // create a renderbuffer object for depth and stencil attachment (we won't be sampling these) unsigned int rbo; glGenRenderbuffers(1, &amp;rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT); // use a single renderbuffer object for both a depth AND stencil buffer. glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // now actually attach it // now that we actually created the framebuffer and added all attachments we want to check if it is actually complete now if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) cout &lt;&lt; \"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\" &lt;&lt; endl; glBindFramebuffer(GL_FRAMEBUFFER, 0); // draw as wireframe //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ // bind to framebuffer and draw scene as we normally would to color texture glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glEnable(GL_DEPTH_TEST); // enable depth testing (is disabled for rendering screen-space quad) // make sure we clear the framebuffer's content glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); shader.use(); glm::mat4 model = glm::mat4(1.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); shader.setMat4(\"view\", view); shader.setMat4(\"projection\", projection); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // floor glBindVertexArray(planeVAO); glBindTexture(GL_TEXTURE_2D, floorTexture); shader.setMat4(\"model\", glm::mat4(1.0f)); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); // now bind back to default framebuffer and draw a quad plane with the attached framebuffer color texture glBindFramebuffer(GL_FRAMEBUFFER, 0); glDisable(GL_DEPTH_TEST); // disable depth test so screen-space quad isn't discarded due to depth test. // clear all relevant buffers glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // set clear color to white (not really necessery actually, since we won't be able to see behind the quad anyways) glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); glBindVertexArray(quadVAO); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); // use the color attachment texture as the texture of the quad plane glDrawArrays(GL_TRIANGLES, 0, 6); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;planeVAO); glDeleteVertexArrays(1, &amp;quadVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;planeVBO); glDeleteBuffers(1, &amp;quadVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"60、OpenGL 之帧缓冲附件","slug":"OpenGL/60、OpenGL 之帧缓冲附件","date":"2020-06-20T05:00:00.000Z","updated":"2020-08-07T14:20:18.765Z","comments":true,"path":"2020/06/20/OpenGL/60、OpenGL 之帧缓冲附件/","link":"","permalink":"https://www.zackaddy.xin/2020/06/20/OpenGL/60、OpenGL 之帧缓冲附件/","excerpt":"","text":"OpenGL 之帧缓冲附件帧缓冲并不包含缓冲数据的内存，它只是包含颜色缓冲区、深度缓冲区、模板缓冲区的附加点。这些对象才是真正的缓冲，它们被称之为附件。绑定到帧缓冲的这个过程叫做“附加”。 OpenGL定义，一个帧缓冲对象包括有 多个颜色缓冲附件， 一个深度缓冲附件， 一个模板缓冲附件。 此外OpenGL定义，一个完整的帧缓冲对象至少要有一个颜色附件，否则将无法被使用。 纹理附件用一个纹理对象来作为一个附件，这称之为纹理附件。所有渲染操作的结果将会被储存在这个纹理图像中。 在RBO出来之前，是只能使用纹理作为附件的，但RBO并不意味着纹理附件就“过时”了，纹理附件的优点在于纹理是一种标准格式，在片段着色器中我们可以快速读取到纹理上的像素。（读取比RBO快） 为帧缓冲创建一个纹理和创建一个普通的纹理差不多： 12345678unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 主要的区别就是，我们将维度设置为了屏幕大小（尽管这不是必须的），并且我们给纹理的data参数传递了NULL。对于这个纹理，我们仅仅分配了内存而没有填充它。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。 ==如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在渲染到你的帧缓冲之前）再次调用glViewport，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。== 现在我们已经创建好一个纹理了，要做的最后一件事就是将它附加到帧缓冲上了： 1glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); glFrameBufferTexture2D有以下的参数： target：帧缓冲的目标（绘制、读取或者两者皆有） attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。 textarget：你希望附加的纹理类型 texture：要附加的纹理本身 level：多级渐远纹理的级别。我们将它保留为0。 除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。 也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子可以在下面找到： 123456glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); 渲染缓冲对象附件渲染缓冲对象（Render Buffer Object，RBO）是后来者，这是为了解决帧缓冲渲染到纹理时，纹理使用标准格式，所以速度可能较慢。 而RBO使用OpenGL原生的格式存储像素值，因此它针对屏幕外渲染进行了优化。换句话，绘制到RBO比绘制到纹理要快得多，即写入数据/复制数据会更快。 而它的缺点也在于像素用的是原生的、与实现相关的格式，因此从RBO读取比从纹理读取要困难得多。 在深度测试和模板测试中，我们只关心测试结果，通常我们不需要从深度或模板中采样，所以对于深度缓冲对象和模板缓冲对象我们一般采用RBO。 渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。 渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。 因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。 创建一个渲染缓冲对象的代码和帧缓冲的代码很类似： 12unsigned int rbo;glGenRenderbuffers(1, &amp;rbo); 类似，我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的rbo： 1glBindRenderbuffer(GL_RENDERBUFFER, rbo); 由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。 创建一个深度和模板渲染缓冲对象可以通过调用glRenderbufferStorage函数来完成： 1glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); 创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为图像使用的，而不是纹理那样的通用数据缓冲(General Purpose Data Buffer)。这里我们选择GL_DEPTH24_STENCIL8作为内部格式，它封装了24位的深度和8位的模板缓冲。 最后一件事就是附加这个渲染缓冲对象： 1glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); 渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"59、OpenGL 之帧缓冲","slug":"OpenGL/59、OpenGL 之帧缓冲","date":"2020-06-19T06:00:00.000Z","updated":"2020-08-07T14:20:18.761Z","comments":true,"path":"2020/06/19/OpenGL/59、OpenGL 之帧缓冲/","link":"","permalink":"https://www.zackaddy.xin/2020/06/19/OpenGL/59、OpenGL 之帧缓冲/","excerpt":"","text":"OpenGL 之帧缓冲简介所谓帧缓冲是做什么用的，就是用来存储渲染数据的地方，可以理解为显存。几何数据（顶点坐标、纹理坐标等）和纹理经过一系列渲染管道最终计算出屏幕上的所有像素点，它们需要一个地方来存放，这个地方就是帧缓冲。帧缓冲中的数据会被显示器读取来刷新显示 创建窗口时OpenGL会自动创建一个默认帧缓冲，专门用于该窗口的渲染显示。其它的需要用户创建自定义帧缓冲。 帧缓冲中包括有颜色缓冲区、深度缓冲区、模板缓冲区这三类缓冲区。 屏幕缓冲用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。 帧缓冲这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存中。 OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。 OpenGL窗口的表面被称作“帧缓冲区”。 帧缓冲区(显存)：是由像素组成的二维数组，每一个存储单元对应屏幕上的一个像素，整个帧缓冲对应一帧图像即当前屏幕画面。帧缓冲通常包括：颜色缓冲，深度缓冲，模板缓冲和累积缓冲。这些缓冲区可能是在一块内存区域，也可能单独分开，看硬件。 自定义的帧缓冲区也包含颜色缓冲区、深度和模板缓冲区，这些逻辑上的缓冲区（logical buffers）在FBO中称之为可附加的图像(framebuffer-attachable images)，他们是可以附加到FBO的二维像素数组（2D arrays of pixels ）。 FBO中包含一个以上的颜色附加点，但只有一个深度和模板附加点 离屏渲染在默认帧缓冲中绘制对象，这叫当前屏幕渲染（On-screen Rendering）。 把渲染计算结果放在非默认帧缓冲中，这叫离屏渲染（Off-screen Rendering）。一般要将自定义缓帧缓冲的数据渲染出来，还需要切回默认帧缓冲，取出自定义帧缓冲的颜色附件，再将其渲染。 创建一个帧缓冲使用一个叫做glGenFramebuffers的函数来创建一个帧缓冲对象(Framebuffer Object, FBO)： 12unsigned int fbo;glGenFramebuffers(1, &amp;fbo); 使用glBindFramebuffer来绑定帧缓冲。 1glBindFramebuffer(GL_FRAMEBUFFER, fbo); 在绑定到GL_FRAMEBUFFER目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。 我们也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER，将一个帧缓冲分别绑定到读取目标或写入目标。 绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。 大部分情况你都不需要区分它们，通常都会使用GL_FRAMEBUFFER，绑定到两个上。 一个完整的帧缓冲需要满足以下的条件： 附加至少一个缓冲（颜色、深度或模板缓冲）。 至少有一个颜色附件(Attachment)。 所有的附件都必须是完整的（保留了内存）。 每个缓冲都应该有相同的样本数。 在完成所有的条件之后，我们可以以GL_FRAMEBUFFER为参数调用glCheckFramebufferStatus，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是GL_FRAMEBUFFER_COMPLETE，帧缓冲就是完整的了。 12if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE) // 执行胜利的舞蹈 之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到0。 1glBindFramebuffer(GL_FRAMEBUFFER, 0); 在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象： 1glDeleteFramebuffers(1, &amp;fbo); 在完整性检查执行之前，我们需要给帧缓冲附加一个附件。附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象(Renderbuffer Object)。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"58、OpenGL 之面剔除","slug":"OpenGL/58、OpenGL 之面剔除","date":"2020-06-19T05:00:00.000Z","updated":"2020-08-07T14:20:18.757Z","comments":true,"path":"2020/06/19/OpenGL/58、OpenGL 之面剔除/","link":"","permalink":"https://www.zackaddy.xin/2020/06/19/OpenGL/58、OpenGL 之面剔除/","excerpt":"","text":"OpenGL 之面剔除现在我们用 OpenGL 绘制了如下的立方体： 不管我们怎么旋转立方体，从任何一个方向去看它，最多都只能看到三个面。 那么对于 OpenGL 来说，那看不到的另外三个面完全可以不用绘制它，从而提高绘制的性能。 面剔除既然现在要把看不到的面丢弃，那么问题就来了： 如何去确定哪个面看得到，哪个面看不到呢？ 在 OpenGL 中允许检查所有正面朝向观察者的面，并渲染它们，而丢弃所有背向观察者的面，这就可以节省片段着色器的运行。 所以，我们要做的就是告诉 OpenGL 哪个面是正面，哪个面是背面。 通过顶点连接顺序确定正反面当我们通过三角形来绘制形状时，会定义顶点连接的顺序，它可能是顺时针或逆时针。 上图中，左侧三角形就是顺时针方向，右侧就是逆时针方向。 而 OpenGL 就是利用这个三角形的顺时针或逆时针方向来决定三角形是正面还是反面。 默认情况下，逆时针的顶点连接顺序被定义为三角形的正面 逆时针或顺时针都是相对于观察者方向的 当定义顶点顺序时，应该想象对应的三角形是面向你的，所以定义的三角形顶点方向应该逆时针的。 这样定义的好处在于三角形顶点的实际连接顺序是在光栅化阶段进行的，也就是顶点着色器运行之后，这些顶点就是以观察者视角所见的了。 对于上图，左侧三角形 1 -&gt; 2 -&gt;3 的连接顺序是顺时针的，这是在观察者位于屏幕前看到的，如果观察者位于屏幕后，连接顺序依旧是 1 -&gt; 2 -&gt; 3 ，那么就是逆时针了。 这也是为什么说，定义三角形顶点顺序时要假设三角形是面向你的，保证逆时针定义，并且可以根据观察者方向的改变，顺时针和逆时针方向会发生改变。 如下图： 三角形的顶点顺序都 1 -&gt; 2 -&gt; 3，当我们定义这个顺序时，都是假设观察者正面向这个三角形呢，所以都是逆时针定义的。 但是从右侧眼镜处来观察，右侧三角形方向是逆时针的，左侧三角形方向是顺时针的，这就是因为对于右侧三角形来说，观察者方向和当初定义顺序时的假设方向一致，而对于左侧三角形，观察者方向就和定义顺序时的假设方向相反了，所以从反方向来看就成了顺时针了。 这样一来，在面剔除的优化下，右侧面可见，左侧面不可见了，也就是面向观察者的正面可见，反面不可见了。 看了好多文章，都没有讲：为什么要逆时针定义三角形方向，但是观察时却成了顺时针了，就是因为当初定义的逆时针方向其实是和观察者方向挂钩的。 当上图的观察者方向变成了左侧，那么顶点连接顺序都还是 1 -&gt; 2 -&gt; 3 的情况下，左侧三角形的顺序就和当初定义顶点顺序一样成了逆时针可见，而右侧的三角形顶点顺序就成了顺时针不可见。 明白了这一点，就对于面剔除更加清晰了。 具体使用在 OpenGL 中可以通过如下方法开启面剔除： 1glEnable(GL_CULL_FACE) 默认情况下，面剔除是关闭的。 开启面剔除后，所有的背向观察者的面都会被丢弃，节省渲染性能。 另外，OpenGL 还提供了其他功能来选择要剔除的面。 glCullFace 有三个模式可选： GL_BACK：只剔除背向面 GL_FRONT：只剔除正向面 GL_FRONT_AND_BACK：剔除正向面和背向面 glCullFace 的初始值是 GL_BACK，只剔除背向面。 除了需要剔除的面之外，还可以通过调用 glFrontFace 方法告诉 OpenGL 将顺时针的面（而不是逆时针的面）定义为正向面。 glFrontFace 它有两个选项： GL_CCW：代表逆时针方向为正向面 GL_CW：代表顺时针方向为正向面 glFrontFace 模式值是 GL_CCW，逆时针方向为正向面。 现假设开启面剔除，并且剔除正向，顺时针为正向： 123glEnable(GL_CULL_FACE);glCullFace(GL_FRONT);glFrontFace(GL_CW); ==一定要注意：定义三角形顶点的时候，右手成坐标系不要动，把自己想象成正面对着这个三角形来定义== 顶点数据如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344float cubeVertices[] = &#123; // Back face -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, // Front face -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, // Left face -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, // Right face 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, // Bottom face -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, // Top face -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f &#125;;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"57、OpenGL 之渲染半透明纹理","slug":"OpenGL/57、OpenGL 之渲染半透明纹理","date":"2020-06-18T06:00:00.000Z","updated":"2020-08-07T14:20:18.752Z","comments":true,"path":"2020/06/18/OpenGL/57、OpenGL 之渲染半透明纹理/","link":"","permalink":"https://www.zackaddy.xin/2020/06/18/OpenGL/57、OpenGL 之渲染半透明纹理/","excerpt":"","text":"OpenGL 之渲染半透明纹理既然我们已经知道OpenGL是如何处理混合的了，是时候将我们的知识运用到实战中了，我们将会在场景中添加几个半透明的窗户。我们将使用本节开始的那个场景，但是这次不再是渲染草的纹理了，我们现在将使用本节开始时的那个透明的窗户纹理。 首先，在初始化时我们启用混合，并设定相应的混合函数： 12glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原： 1234567891011#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; FragColor = texture(texture1, TexCoords);&#125; 现在（每当OpenGL渲染了一个片段时）它都会将当前片段的颜色和当前颜色缓冲中的片段颜色根据alpha值来进行混合。由于窗户纹理的玻璃部分是半透明的，我们应该能通窗户中看到背后的场景了。 如果你仔细看的话，你可能会注意到有些不对劲。最前面窗户的透明部分遮蔽了背后的窗户？这为什么会发生呢？ 发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。 ==注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。== 不要打乱顺序要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下： 先绘制所有不透明的物体。 对所有透明的物体排序。 按顺序绘制所有透明的物体。 排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来我们把距离和它对应的位置向量存储到一个STL库的map数据结构中。map会自动根据键值(Key)对它的值排序，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。 123456std::map&lt;float, glm::vec3&gt; sorted;for (unsigned int i = 0; i &lt; windows.size(); i++)&#123; float distance = glm::length(camera.Position - windows[i]); sorted[distance] = windows[i];&#125; 结果就是一个排序后的容器对象，它根据distance键值从低到高储存了每个窗户的位置。 之后，这次在渲染的时候，我们将以逆序（从远到近）从map中获取值，之后以正确的顺序绘制对应的窗户： 1234567for(std::map&lt;float,glm::vec3&gt;::reverse_iterator it = sorted.rbegin(); it != sorted.rend(); ++it) &#123; model = glm::mat4(); model = glm::translate(model, it-&gt;second); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6);&#125; 我们使用了map的一个反向迭代器(Reverse Iterator)，反向遍历其中的条目，并将每个窗户四边形位移到对应的窗户位置上。这是排序透明物体的一个比较简单的实现，它能够修复之前的问题，现在场景看起来是这样的： 虽然按照距离排序物体这种方法对我们这个场景能够正常工作，但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。 在场景中排序物体是一个很困难的技术，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度(Order Independent Transparency, OIT) 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;stb_image.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;learnopengl/shader_m.h&gt;#include &lt;learnopengl/camera.h&gt;#include &lt;learnopengl/model.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // build and compile shaders // ------------------------- Shader shader(\"3.2.blending.vs\", \"3.2.blending.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // texture Coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; float planeVertices[] = &#123; // positions // texture Coords 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, 5.0f, 0.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, -5.0f, 2.0f, 2.0f &#125;; float transparentVertices[] = &#123; // positions // texture Coords (swapped y coordinates because texture is flipped upside down) 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.0f, 1.0f, 0.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // plane VAO unsigned int planeVAO, planeVBO; glGenVertexArrays(1, &amp;planeVAO); glGenBuffers(1, &amp;planeVBO); glBindVertexArray(planeVAO); glBindBuffer(GL_ARRAY_BUFFER, planeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), &amp;planeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // transparent VAO unsigned int transparentVAO, transparentVBO; glGenVertexArrays(1, &amp;transparentVAO); glGenBuffers(1, &amp;transparentVBO); glBindVertexArray(transparentVAO); glBindBuffer(GL_ARRAY_BUFFER, transparentVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(transparentVertices), transparentVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glBindVertexArray(0); // load textures // ------------- unsigned int cubeTexture = loadTexture(FileSystem::getPath(\"resources/textures/marble.jpg\").c_str()); unsigned int floorTexture = loadTexture(FileSystem::getPath(\"resources/textures/metal.png\").c_str()); unsigned int transparentTexture = loadTexture(FileSystem::getPath(\"resources/textures/window.png\").c_str()); // transparent window locations // -------------------------------- vector&lt;glm::vec3&gt; windows &#123; glm::vec3(-1.5f, 0.0f, -0.48f), glm::vec3( 1.5f, 0.0f, 0.51f), glm::vec3( 0.0f, 0.0f, 0.7f), glm::vec3(-0.3f, 0.0f, -2.3f), glm::vec3( 0.5f, 0.0f, -0.6f) &#125;; // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // sort the transparent windows before rendering // --------------------------------------------- std::map&lt;float, glm::vec3&gt; sorted; for (unsigned int i = 0; i &lt; windows.size(); i++) &#123; float distance = glm::length(camera.Position - windows[i]); sorted[distance] = windows[i]; &#125; // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw objects shader.use(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 model = glm::mat4(1.0f); shader.setMat4(\"projection\", projection); shader.setMat4(\"view\", view); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // floor glBindVertexArray(planeVAO); glBindTexture(GL_TEXTURE_2D, floorTexture); model = glm::mat4(1.0f); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6); // windows (from furthest to nearest) glBindVertexArray(transparentVAO); glBindTexture(GL_TEXTURE_2D, transparentTexture); for (std::map&lt;float, glm::vec3&gt;::reverse_iterator it = sorted.rbegin(); it != sorted.rend(); ++it) &#123; model = glm::mat4(1.0f); model = glm::translate(model, it-&gt;second); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;planeVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;planeVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); // for this tutorial: use GL_CLAMP_TO_EDGE to prevent semi-transparent borders. Due to interpolation it takes texels from next repeat glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"56、OpenGL 之混合三","slug":"OpenGL/56、OpenGL 之混合三","date":"2020-06-18T05:00:00.000Z","updated":"2020-08-07T14:20:18.748Z","comments":true,"path":"2020/06/18/OpenGL/56、OpenGL 之混合三/","link":"","permalink":"https://www.zackaddy.xin/2020/06/18/OpenGL/56、OpenGL 之混合三/","excerpt":"","text":"OpenGL 之混合三简介混合是一种常用的技巧，通常可以用来实现半透明。但其实它也是十分灵活的，你可以通过不同的设置得到不同的混合结果，产生一些有趣或者奇怪的图象。 混合是什么呢？混合就是把两种颜色混在一起。具体一点，就是把某一像素位置原来的颜色和将要画上去的颜色，通过某种方式混在一起，从而实现特殊的效果。 假设我们需要绘制这样一个场景：透过红色的玻璃去看绿色的物体，那么可以先绘制绿色的物体，再绘制红色玻璃。在绘制红色玻璃的时候，利用“混合”功能，把将要绘制上去的红色和原来的绿色进行混合，于是得到一种新的颜色，看上去就好像玻璃是半透明的。 要使用OpenGL的混合功能，只需要调用：glEnable(GL_BLEND);即可。 要关闭OpenGL的混合功能，只需要调用：glDisable(GL_BLEND);即可。 注意：只有在RGBA模式下，才可以使用混合功能，颜色索引模式下是无法使用混合功能的。 一、源因子和目标因子前面我们已经提到，混合需要把原来的颜色和将要画上去的颜色找出来，经过某种方式处理后得到一种新的颜色。这里把将要画上去的颜色称为“源颜色”，把原来的颜色称为“目标颜色”。OpenGL会把源颜色和目标颜色各自取出，并乘以一个系数（源颜色乘以的系数称为“源因子”，目标颜色乘以的系数称为“目标因子”），然后相加，这样就得到了新的颜色。（也可以不是相加，新版本的OpenGL可以设置运算方式，包括加、减、取两者中较大的、取两者中较小的、逻辑运算等，但我们这里为了简单起见，不讨论这个了）下面用数学公式来表达一下这个运算方式。假设源颜色的四个分量（指红色，绿色，蓝色，alpha值）是(Rs, Gs, Bs, As)，目标颜色的四个分量是(Rd, Gd, Bd, Ad)，又设源因子为(Sr, Sg, Sb, Sa)，目标因子为(Dr, Dg, Db, Da)。则混合产生的新颜色可以表示为： (RsSr+RdDr, GsSg+GdDg, BsSb+BdDb, AsSa+AdDa)当然了，如果颜色的某一分量超过了1.0，则它会被自动截取为1.0，不需要考虑越界的问题。 源因子和目标因子是可以通过glBlendFunc函数来进行设置的。glBlendFunc有两个参数，前者表示源因子，后者表示目标因子。这两个参数可以是多种值，下面介绍比较常用的几种。 123456GL_ZERO： 表示使用0.0作为因子，实际上相当于不使用这种颜色参与混合运算。GL_ONE： 表示使用1.0作为因子，实际上相当于完全的使用了这种颜色参与混合运算。GL_SRC_ALPHA：表示使用源颜色的alpha值来作为因子。GL_DST_ALPHA：表示使用目标颜色的alpha值来作为因子。GL_ONE_MINUS_SRC_ALPHA：表示用1.0减去源颜色的alpha值来作为因子。GL_ONE_MINUS_DST_ALPHA：表示用1.0减去目标颜色的alpha值来作为因子。 除此以外，还有GL_SRC_COLOR（把源颜色的四个分量分别作为因子的四个分量）、GL_ONE_MINUS_SRC_COLOR、GL_DST_COLOR、GL_ONE_MINUS_DST_COLOR等，前两个在OpenGL旧版本中只能用于设置目标因子，后两个在OpenGL旧版本中只能用于设置源因子。新版本的OpenGL则没有这个限制，并且支持新的GL_CONST_COLOR（设定一种常数颜色，将其四个分量分别作为因子的四个分量）、GL_ONE_MINUS_CONST_COLOR、GL_CONST_ALPHA、GL_ONE_MINUS_CONST_ALPHA。另外还有GL_SRC_ALPHA_SATURATE。新版本的OpenGL还允许颜色的alpha值和RGB值采用不同的混合因子。但这些都不是我们现在所需要了解的。毕竟这还是入门教材，不需要整得太复杂~ 举例来说： 如果设置了glBlendFunc(GL_ONE, GL_ZERO);，则表示完全使用源颜色，完全不使用目标颜色，因此画面效果和不使用混合的时候一致（当然效率可能会低一点点）。如果没有设置源因子和目标因子，则默认情况就是这样的设置。 如果设置了glBlendFunc(GL_ZERO, GL_ONE);，则表示完全不使用源颜色，因此无论你想画什么，最后都不会被画上去了。（但这并不是说这样设置就没有用，有些时候可能有特殊用途） 如果设置了glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);，则表示源颜色乘以自身的alpha值，目标颜色乘以1.0减去源颜色的alpha值，这样一来，源颜色的alpha值越大，则产生的新颜色中源颜色所占比例就越大，而目标颜色所占比例则减小。这种情况下，我们可以简单的将源颜色的alpha值理解为“不透明度”。这也是混合时最常用的方式。 如果设置了glBlendFunc(GL_ONE, GL_ONE);，则表示完全使用源颜色和目标颜色，最终的颜色实际上就是两种颜色的简单相加。例如红色(1, 0, 0)和绿色(0, 1, 0)相加得到(1, 1, 0)，结果为黄色。 注意：所谓源颜色和目标颜色，是跟绘制的顺序有关的。假如先绘制了一个红色的物体，再在其上绘制绿色的物体。则绿色是源颜色，红色是目标颜色。如果顺序反过来，则红色就是源颜色，绿色才是目标颜色。在绘制时，应该注意顺序，使得绘制的源颜色与设置的源因子对应，目标颜色与设置的目标因子对应。不要被混乱的顺序搞晕了。 二、二维图形混合举例下面看一个简单的例子，实现将两种不同的颜色混合在一起。为了便于观察，我们绘制两个矩形：glRectf(-1, -1, 0.5, 0.5);glRectf(-0.5, -0.5, 1, 1);，这两个矩形有一个重叠的区域，便于我们观察混合的效果。先来看看使用glBlendFunc(GL_ONE, GL_ZERO);的，它的结果与不使用混合时相同。 1234567891011121314void myDisplay(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glEnable(GL_BLEND); glBlendFunc(GL_ONE, GL_ZERO); glColor4f(1, 0, 0, 0.5); glRectf(-1, -1, 0.5, 0.5); glColor4f(0, 1, 0, 0.5); glRectf(-0.5, -0.5, 1, 1); glutSwapBuffers();&#125; 尝试把glBlendFunc的参数修改为glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);以及glBlendFunc(GL_ONE, GL_ONE);，观察效果。第一种情况下，效果与没有使用混合时相同，后绘制的图形会覆盖先绘制的图形。第二种情况下，alpha被当作“不透明度”，由于被设置为0.5，所以两个矩形看上去都是半透明的，乃至于看到黑色背景。第三种是将颜色相加，红色和绿色相加得到黄色。 三、实现三维混合也许你迫不及待的想要绘制一个三维的带有半透明物体的场景了。但是现在恐怕还不行，还有一点是在进行三维场景的混合时必须注意的，那就是深度缓冲。深度缓冲是这样一段数据，它记录了每一个像素距离观察者有多近。在启用深度缓冲测试的情况下，如果将要绘制的像素比原来的像素更近，则像素将被绘制。否则，像素就会被忽略掉，不进行绘制。这在绘制不透明的物体时非常有用——不管是先绘制近的物体再绘制远的物体，还是先绘制远的物体再绘制近的物体，或者干脆以混乱的顺序进行绘制，最后的显示结果总是近的物体遮住远的物体。然而在你需要实现半透明效果时，发现一切都不是那么美好了。如果你绘制了一个近距离的半透明物体，则它在深度缓冲区内保留了一些信息，使得远处的物体将无法再被绘制出来。虽然半透明的物体仍然半透明，但透过它看到的却不是正确的内容了。 要解决以上问题，需要在绘制半透明物体时将深度缓冲区设置为只读，这样一来，虽然半透明物体被绘制上去了，深度缓冲区还保持在原来的状态。如果再有一个物体出现在半透明物体之后，在不透明物体之前，则它也可以被绘制（因为此时深度缓冲区中记录的是那个不透明物体的深度）。以后再要绘制不透明物体时，只需要再将深度缓冲区设置为可读可写的形式即可。嗯？你问我怎么绘制一个一部分半透明一部分不透明的物体？这个好办，只需要把物体分为两个部分，一部分全是半透明的，一部分全是不透明的，分别绘制就可以了。 即使使用了以上技巧，我们仍然不能随心所欲的按照混乱顺序来进行绘制。必须是先绘制不透明的物体，然后绘制透明的物体。否则，假设背景为蓝色，近处一块红色玻璃，中间一个绿色物体。如果先绘制红色半透明玻璃的话，它先和蓝色背景进行混合，则以后绘制中间的绿色物体时，想单独与红色玻璃混合已经不能实现了。总结起来，绘制顺序就是：首先绘制所有不透明的物体。如果两个物体都是不透明的，则谁先谁后都没有关系。然后，将深度缓冲区设置为只读。接下来，绘制所有半透明的物体。如果两个物体都是半透明的，则谁先谁后只需要根据自己的意愿（注意了，先绘制的将成为“目标颜色”，后绘制的将成为“源颜色”，所以绘制的顺序将会对结果造成一些影响）。最后，将深度缓冲区设置为可读可写形式。调用glDepthMask(GL_FALSE);可将深度缓冲区设置为只读形式。调用glDepthMask(GL_TRUE);可将深度缓冲区设置为可读可写形式。一些网上的教程，包括大名鼎鼎的NeHe教程，都在使用三维混合时直接将深度缓冲区禁用，即调用glDisable(GL_DEPTH_TEST);。这样做并不正确。如果先绘制一个不透明的物体，再在其背后绘制半透明物体，本来后面的半透明物体将不会被显示（被不透明的物体遮住了），但如果禁用深度缓冲，则它仍然将会显示，并进行混合。NeHe提到某些显卡在使用glDepthMask函数时可能存在一些问题，但可能是由于我的阅历有限，并没有发现这样的情况。 那么，实际的演示一下吧。我们来绘制一些半透明和不透明的球体。假设有三个球体，一个红色不透明的，一个绿色半透明的，一个蓝色半透明的。红色最远，绿色在中间，蓝色最近。根据前面所讲述的内容，红色不透明球体必须首先绘制，而绿色和蓝色则可以随意修改顺序。这里为了演示不注意设置深度缓冲的危害，我们故意先绘制最近的蓝色球体，再绘制绿色球体。为了让这些球体有一点立体感，我们使用光照。在(1, 1, -1)处设置一个白色的光源。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void setLight(void)&#123; static const GLfloat light_position[] = &#123;1.0f, 1.0f, -1.0f, 1.0f&#125;; static const GLfloat light_ambient[] = &#123;0.2f, 0.2f, 0.2f, 1.0f&#125;; static const GLfloat light_diffuse[] = &#123;1.0f, 1.0f, 1.0f, 1.0f&#125;; static const GLfloat light_specular[] = &#123;1.0f, 1.0f, 1.0f, 1.0f&#125;; glLightfv(GL_LIGHT0, GL_POSITION, light_position); glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient); glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse); glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular); glEnable(GL_LIGHT0); glEnable(GL_LIGHTING); glEnable(GL_DEPTH_TEST);&#125;每一个球体颜色不同。所以它们的材质也都不同。这里用一个函数来设置材质。void setMatirial(const GLfloat mat_diffuse[4], GLfloat mat_shininess)&#123; static const GLfloat mat_specular[] = &#123;0.0f, 0.0f, 0.0f, 1.0f&#125;; static const GLfloat mat_emission[] = &#123;0.0f, 0.0f, 0.0f, 1.0f&#125;; glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, mat_diffuse); glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission); glMaterialf (GL_FRONT, GL_SHININESS, mat_shininess);&#125;有了这两个函数，我们就可以根据前面的知识写出整个程序代码了。这里只给出了绘制的部分，其它部分大家可以自行完成。void myDisplay(void)&#123; // 定义一些材质颜色 const static GLfloat red_color[] = &#123;1.0f, 0.0f, 0.0f, 1.0f&#125;; const static GLfloat green_color[] = &#123;0.0f, 1.0f, 0.0f, 0.3333f&#125;; const static GLfloat blue_color[] = &#123;0.0f, 0.0f, 1.0f, 0.5f&#125;; // 清除屏幕 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 启动混合并设置混合因子 glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // 设置光源 setLight(); // 以(0, 0, 0.5)为中心，绘制一个半径为.3的不透明红色球体（离观察者最远） setMatirial(red_color, 30.0); glPushMatrix(); glTranslatef(0.0f, 0.0f, 0.5f); glutSolidSphere(0.3, 30, 30); glPopMatrix(); // 下面将绘制半透明物体了，因此将深度缓冲设置为只读 glDepthMask(GL_FALSE); // 以(0.2, 0, -0.5)为中心，绘制一个半径为.2的半透明蓝色球体（离观察者最近） setMatirial(blue_color, 30.0); glPushMatrix(); glTranslatef(0.2f, 0.0f, -0.5f); glutSolidSphere(0.2, 30, 30); glPopMatrix(); // 以(0.1, 0, 0)为中心，绘制一个半径为.15的半透明绿色球体（在前两个球体之间） setMatirial(green_color, 30.0); glPushMatrix(); glTranslatef(0.1, 0, 0); glutSolidSphere(0.15, 30, 30); glPopMatrix(); // 完成半透明物体的绘制，将深度缓冲区恢复为可读可写的形式 glDepthMask(GL_TRUE); glutSwapBuffers();&#125; 也可以将上面两处glDepthMask删去，结果会看到最近的蓝色球虽然是半透明的，但它的背后直接就是红色球了，中间的绿色球没有被正确绘制。 小结：本课介绍了OpenGL混合功能的相关知识。 混合就是在绘制时，不是直接把新的颜色覆盖在原来旧的颜色上，而是将新的颜色与旧的颜色经过一定的运算，从而产生新的颜色。新的颜色称为源颜色，原来旧的颜色称为目标颜色。传统意义上的混合，是将源颜色乘以源因子，目标颜色乘以目标因子，然后相加。 源因子和目标因子是可以设置的。源因子和目标因子设置的不同直接导致混合结果的不同。将源颜色的alpha值作为源因子，用1.0减去源颜色alpha值作为目标因子，是一种常用的方式。这时候，源颜色的alpha值相当于“不透明度”的作用。利用这一特点可以绘制出一些半透明的物体。 在进行混合时，绘制的顺序十分重要。因为在绘制时，正要绘制上去的是源颜色，原来存在的是目标颜色，因此先绘制的物体就成为目标颜色，后来绘制的则成为源颜色。绘制的顺序要考虑清楚，将目标颜色和设置的目标因子相对应，源颜色和设置的源因子相对应。 在进行三维混合时，不仅要考虑源因子和目标因子，还应该考虑深度缓冲区。必须先绘制所有不透明的物体，再绘制半透明的物体。在绘制半透明物体时前，还需要将深度缓冲区设置为只读形式，否则可能出现画面错误。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"55、OpenGL 之混合二","slug":"OpenGL/55、OpenGL 之混合二","date":"2020-06-17T06:00:00.000Z","updated":"2020-08-07T14:20:18.744Z","comments":true,"path":"2020/06/17/OpenGL/55、OpenGL 之混合二/","link":"","permalink":"https://www.zackaddy.xin/2020/06/17/OpenGL/55、OpenGL 之混合二/","excerpt":"","text":"OpenGL 之混合二虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，我们可以启用GL_BLEND来启用混合： 1glEnable(GL_BLEND); 启用了混合之后，我们需要告诉OpenGL它该如何混合。 OpenGL中的混合是通过下面这个方程来实现的： 123456789C_&#123;result&#125; = C_&#123;source&#125; * F_&#123;source&#125; + C_&#123;destination&#125; * F_&#123;destination&#125; C_&#123;source&#125;：源颜色向量。这是源自纹理的颜色向量。C_&#123;destination&#125;：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。F_&#123;source&#125;：源因子值。指定了alpha值对源颜色的影响。F_&#123;destination&#125;：目标因子值。指定了alpha值对目标颜色的影响。 片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子： 我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。 问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的alpha值，所以我们想要将Fsrc设置为源颜色向量的alpha值，也就是0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60%，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以我们将Fdestination设置为1减去源颜色向量的alpha值。这个方程变成了： 1234567891011C_&#123;result&#125; = \\begin&#123;pmatrix&#125; 0.0 \\\\ 1.0 \\\\ 0.0 \\\\ 0.6 \\end&#123;pmatrix&#125; * 0.6 + \\begin&#123;pmatrix&#125; 1.0 \\\\ 0.0 \\\\ 0.0 \\\\ 1.0\\end&#123;pmatrix&#125; * (1 - 0.6) 结果就是重叠方形的片段包含了一个60%绿色，40%红色的一种脏兮兮的颜色： 最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。 这样子很不错，但我们该如何让OpenGL使用这样的因子呢？正好有一个专门的函数，叫做glBlendFunc。 glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数颜色向量C¯constant可以通过glBlendColor函数来另外设置。 选项 值 GL_ZERO 因子等于0 GL_ONE 因子等于1 GL_SRC_COLOR 因子等于源颜色向量C¯source GL_ONE_MINUS_SRC_COLOR 因子等于1−C¯source GL_DST_COLOR 因子等于目标颜色向量C¯destination GL_ONE_MINUS_DST_COLOR 因子等于1−C¯destination GL_SRC_ALPHA 因子等于C¯source的alpha分量 GL_ONE_MINUS_SRC_ALPHA 因子等于1− C¯source的alpha分量 GL_DST_ALPHA 因子等于C¯destination的alpha分量 GL_ONE_MINUS_DST_ALPHA 因子等于1− C¯destination的alpha分量 GL_CONSTANT_COLOR 因子等于常数颜色向量C¯constant GL_ONE_MINUS_CONSTANT_COLOR 因子等于1−C¯constant GL_CONSTANT_ALPHA 因子等于C¯constant的alpha分量 GL_ONE_MINUS_CONSTANT_ALPHA 因子等于1− C¯constant的alpha分量 为了获得之前两个方形的混合结果，我们需要使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子。这将会产生以下的glBlendFunc： 1glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 也可以使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项： 1glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO); 这个函数和我们之前设置的那样设置了RGB分量，但这样只能让最终的alpha分量被源颜色向量的alpha值所影响到。 OpenGL甚至给了我们更多的灵活性，允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项： 12345GL\\_FUNC\\_ADD：默认选项，将两个分量相加：C_&#123;result&#125; = Src + Dst。GL\\_FUNC\\_SUBTRACT：将两个分量相减： C_&#123;result&#125; = Src − Dst。GL\\_FUNC\\_REVERSE\\_SUBTRACT：将两个分量相减，但顺序相反：C_&#123;result&#125; = Dst − Src。 通常我们都可以省略调用glBlendEquation，因为GL_FUNC_ADD对大部分的操作来说都是我们希望的混合方程，但如果你真的想打破主流，其它的方程也可能符合你的要求。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"54、OpenGL 之混合一","slug":"OpenGL/54、OpenGL 之混合一","date":"2020-06-17T05:00:00.000Z","updated":"2020-08-07T14:20:18.739Z","comments":true,"path":"2020/06/17/OpenGL/54、OpenGL 之混合一/","link":"","permalink":"https://www.zackaddy.xin/2020/06/17/OpenGL/54、OpenGL 之混合一/","excerpt":"","text":"OpenGL 之混合一OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 丢弃片段有些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。 下面这个纹理正是这样的，它要么是完全不透明的（alpha值为1.0），要么是完全透明的（alpha值为0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。 所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃(Discard)显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。 要想加载有alpha值的纹理，我们并不需要改很多东西，stb_image在纹理有alpha通道的时候会自动加载，但我们仍要在纹理生成过程中告诉OpenGL，我们的纹理现在使用alpha通道了： 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); 同样，保证你在片段着色器中获取了纹理的全部4个颜色分量，而不仅仅是RGB分量： 12345void main()&#123; // FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0); FragColor = texture(texture1, TexCoords);&#125; 既然我们已经知道该如何加载透明的纹理了，是时候将它带入实战了，我们将会在深度测试小节的场景中加入几棵草。 我们会创建一个vector，向里面添加几个glm::vec3变量来代表草的位置： 123456vector&lt;glm::vec3&gt; vegetation;vegetation.push_back(glm::vec3(-1.5f, 0.0f, -0.48f));vegetation.push_back(glm::vec3( 1.5f, 0.0f, 0.51f));vegetation.push_back(glm::vec3( 0.0f, 0.0f, 0.7f));vegetation.push_back(glm::vec3(-0.3f, 0.0f, -2.3f));vegetation.push_back(glm::vec3( 0.5f, 0.0f, -0.6f)); 每个草都被渲染到了一个四边形上，贴上草的纹理。这并不能完美地表示3D的草，但这比加载复杂的模型要快多了。使用一些小技巧，比如在同一个位置加入一些旋转后的草四边形，你仍然能获得比较好的结果的。 因为草的纹理是添加到四边形对象上的，我们还需要创建另外一个VAO，填充VBO，设置正确的顶点属性指针。接下来，在绘制完地板和两个立方体后，我们将会绘制草： 123456789glBindVertexArray(vegetationVAO);glBindTexture(GL_TEXTURE_2D, grassTexture); for(unsigned int i = 0; i &lt; vegetation.size(); i++) &#123; model = glm::mat4(1.0f); model = glm::translate(model, vegetation[i]); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6);&#125; 运行程序你将看到： 出现这种情况是因为OpenGL默认是不知道怎么处理alpha值的，更不知道什么时候应该丢弃片段。我们需要自己手动来弄。幸运的是，有了着色器，这还是非常容易的。GLSL给了我们discard命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。有了这个指令，我们就能够在片段着色器中检测一个片段的alpha值是否低于某个阈值，如果是的话，则丢弃这个片段，就好像它不存在一样： 1234567891011121314#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; vec4 texColor = texture(texture1, TexCoords); if(texColor.a &lt; 0.1) discard; FragColor = texColor;&#125; 这里，我们检测被采样的纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。现在它看起来就正常了： ==注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE：== 12glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); 源码3.1.blending.vs 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 3.1.blending.fs 1234567891011121314#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; vec4 texColor = texture(texture1, TexCoords); if(texColor.a &lt; 0.1) discard; FragColor = texColor;&#125; blending_discard.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader shader(\"3.1.blending.vs\", \"3.1.blending.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // texture Coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; float planeVertices[] = &#123; // positions // texture Coords 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, 5.0f, 0.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, -5.0f, 2.0f, 2.0f &#125;; float transparentVertices[] = &#123; // positions // texture Coords (swapped y coordinates because texture is flipped upside down) 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.0f, 1.0f, 0.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // plane VAO unsigned int planeVAO, planeVBO; glGenVertexArrays(1, &amp;planeVAO); glGenBuffers(1, &amp;planeVBO); glBindVertexArray(planeVAO); glBindBuffer(GL_ARRAY_BUFFER, planeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), &amp;planeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); // transparent VAO unsigned int transparentVAO, transparentVBO; glGenVertexArrays(1, &amp;transparentVAO); glGenBuffers(1, &amp;transparentVBO); glBindVertexArray(transparentVAO); glBindBuffer(GL_ARRAY_BUFFER, transparentVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(transparentVertices), transparentVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glBindVertexArray(0); // load textures // ------------- unsigned int cubeTexture = loadTexture(\"marble.jpg\"); unsigned int floorTexture = loadTexture(\"metal.png\"); unsigned int transparentTexture = loadTexture(\"grass.png\"); // transparent vegetation locations // -------------------------------- vector&lt;glm::vec3&gt; vegetation &#123; glm::vec3(-1.5f, 0.0f, -0.48f), glm::vec3(1.5f, 0.0f, 0.51f), glm::vec3(0.0f, 0.0f, 0.7f), glm::vec3(-0.3f, 0.0f, -2.3f), glm::vec3(0.5f, 0.0f, -0.6f) &#125;; // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // draw objects shader.use(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 model = glm::mat4(1.0f); shader.setMat4(\"projection\", projection); shader.setMat4(\"view\", view); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // floor glBindVertexArray(planeVAO); glBindTexture(GL_TEXTURE_2D, floorTexture); model = glm::mat4(1.0f); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6); // vegetation glBindVertexArray(transparentVAO); glBindTexture(GL_TEXTURE_2D, transparentTexture); for (unsigned int i = 0; i &lt; vegetation.size(); i++) &#123; model = glm::mat4(1.0f); model = glm::translate(model, vegetation[i]); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 6); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;planeVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;planeVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); // for this tutorial: use GL_CLAMP_TO_EDGE to prevent semi-transparent borders. Due to interpolation it takes texels from next repeat glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"53、OpenGL 之物体轮廓","slug":"OpenGL/53、OpenGL 之物体轮廓","date":"2020-06-16T06:00:00.000Z","updated":"2020-08-07T14:20:18.735Z","comments":true,"path":"2020/06/16/OpenGL/53、OpenGL 之物体轮廓/","link":"","permalink":"https://www.zackaddy.xin/2020/06/16/OpenGL/53、OpenGL 之物体轮廓/","excerpt":"","text":"OpenGL 之物体轮廓这里将会展示一个使用模板测试就可以完成的有用特性，它叫做物体轮廓(Object Outlining)。 所以我们首先来创建一个很简单的片段着色器，它会输出一个边框颜色。我们简单地给它设置一个硬编码的颜色值，将这个着色器命名为shaderSingleColor： 1234void main()&#123; FragColor = vec4(0.04, 0.28, 0.26, 1.0);&#125; 我们只想给那两个箱子加上边框，所以我们让地板不参与这个过程。我们希望首先绘制地板，再绘制两个箱子（并写入模板缓冲），之后绘制放大的箱子（并丢弃覆盖了之前绘制的箱子片段的那些片段）。 我们首先启用模板测试，并设置测试通过或失败时的行为： 12glEnable(GL_STENCIL_TEST);glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); 如果其中的一个测试失败了，我们什么都不做，我们仅仅保留当前储存在模板缓冲中的值。如果模板测试和深度测试都通过了，那么我们希望将储存的模板值设置为参考值，参考值能够通过glStencilFunc来设置，我们之后会设置为1。 我们将模板缓冲清除为0，对箱子中所有绘制的片段，将模板值更新为1： 1234glStencilFunc(GL_ALWAYS, 1, 0xFF); // 所有的片段都应该更新模板缓冲glStencilMask(0xFF); // 启用模板缓冲写入normalShader.use();DrawTwoContainers(); 通过使用GL_ALWAYS模板测试函数，我们保证了箱子的每个片段都会将模板缓冲的模板值更新为1。因为片段永远会通过模板测试，在绘制片段的地方，模板缓冲会被更新为参考值。 现在模板缓冲在箱子被绘制的地方都更新为1了，我们将要绘制放大的箱子，但这次要禁用模板缓冲的写入： 12345glStencilFunc(GL_NOTEQUAL, 1, 0xFF);glStencilMask(0x00); // 禁止模板缓冲的写入glDisable(GL_DEPTH_TEST);shaderSingleColor.use(); DrawTwoScaledUpContainers(); 我们将模板函数设置为GL_NOTEQUAL，它会保证我们只绘制箱子上模板值不为1的部分，即只绘制箱子在之前绘制的箱子之外的部分。注意我们也禁用了深度测试，让放大的箱子，即边框，不会被地板所覆盖。 记得要在完成之后重新启用深度缓冲。 场景中物体轮廓的完整步骤会看起来像这样： 1234567891011121314151617181920glEnable(GL_DEPTH_TEST);glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); glStencilMask(0x00); // 记得保证我们在绘制地板的时候不会更新模板缓冲normalShader.use();DrawFloor() glStencilFunc(GL_ALWAYS, 1, 0xFF); glStencilMask(0xFF); DrawTwoContainers();glStencilFunc(GL_NOTEQUAL, 1, 0xFF);glStencilMask(0x00); glDisable(GL_DEPTH_TEST);shaderSingleColor.use(); DrawTwoScaledUpContainers();glStencilMask(0xFF);glEnable(GL_DEPTH_TEST); 只要你理解了模板缓冲背后的大体思路，这个代码片段就不是那么难理解了。如果还是不能理解的话，尝试再次仔细阅读之前的部分，并尝试通过上面使用的范例，完全理解每个函数的功能。 源码2.stencil_testing.vs 123456789101112131415#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0f);&#125; 2.stencil_testing.fs 1234567891011#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; FragColor = texture(texture1, TexCoords);&#125; 2.stencil_single_color.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(0.04, 0.28, 0.26, 1.0);&#125; stencil_testing.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = (float)SCR_WIDTH / 2.0;float lastY = (float)SCR_HEIGHT / 2.0;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); glDepthFunc(GL_LESS); glEnable(GL_STENCIL_TEST); glStencilFunc(GL_NOTEQUAL, 1, 0xFF); glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE); // build and compile shaders // ------------------------- Shader shader(\"2.stencil_testing.vs\", \"2.stencil_testing.fs\"); Shader shaderSingleColor(\"2.stencil_testing.vs\", \"2.stencil_single_color.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float cubeVertices[] = &#123; // positions // texture Coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; float planeVertices[] = &#123; // positions // texture Coords (note we set these higher than 1 (together with GL_REPEAT as texture wrapping mode). this will cause the floor texture to repeat) 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, 5.0f, 0.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, 5.0f, 2.0f, 0.0f, -5.0f, -0.5f, -5.0f, 0.0f, 2.0f, 5.0f, -0.5f, -5.0f, 2.0f, 2.0f &#125;; // cube VAO unsigned int cubeVAO, cubeVBO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;cubeVBO); glBindVertexArray(cubeVAO); glBindBuffer(GL_ARRAY_BUFFER, cubeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), &amp;cubeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glBindVertexArray(0); // plane VAO unsigned int planeVAO, planeVBO; glGenVertexArrays(1, &amp;planeVAO); glGenBuffers(1, &amp;planeVBO); glBindVertexArray(planeVAO); glBindBuffer(GL_ARRAY_BUFFER, planeVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(planeVertices), &amp;planeVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glBindVertexArray(0); // load textures // ------------- unsigned int cubeTexture = loadTexture(\"marble.jpg\"); unsigned int floorTexture = loadTexture(\"metal.png\"); // shader configuration // -------------------- shader.use(); shader.setInt(\"texture1\", 0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); // don't forget to clear the stencil buffer! // set uniforms shaderSingleColor.use(); glm::mat4 model = glm::mat4(1.0f); glm::mat4 view = camera.GetViewMatrix(); glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); shaderSingleColor.setMat4(\"view\", view); shaderSingleColor.setMat4(\"projection\", projection); shader.use(); shader.setMat4(\"view\", view); shader.setMat4(\"projection\", projection); // draw floor as normal, but don't write the floor to the stencil buffer, we only care about the containers. We set its mask to 0x00 to not write to the stencil buffer. glStencilMask(0x00); // floor glBindVertexArray(planeVAO); glBindTexture(GL_TEXTURE_2D, floorTexture); shader.setMat4(\"model\", glm::mat4(1.0f)); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); // 1st. render pass, draw objects as normal, writing to the stencil buffer // -------------------------------------------------------------------- glStencilFunc(GL_ALWAYS, 1, 0xFF); glStencilMask(0xFF); // cubes glBindVertexArray(cubeVAO); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, cubeTexture); model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f)); shader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); // 2nd. render pass: now draw slightly scaled versions of the objects, this time disabling stencil writing. // Because the stencil buffer is now filled with several 1s. The parts of the buffer that are 1 are not drawn, thus only drawing // the objects' size differences, making it look like borders. // ----------------------------------------------------------------------------------------------------------------------------- glStencilFunc(GL_NOTEQUAL, 1, 0xFF); glStencilMask(0x00); glDisable(GL_DEPTH_TEST); shaderSingleColor.use(); float scale = 1.1; // cubes glBindVertexArray(cubeVAO); glBindTexture(GL_TEXTURE_2D, cubeTexture); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(-1.0f, 0.0f, -1.0f)); model = glm::scale(model, glm::vec3(scale, scale, scale)); shaderSingleColor.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(2.0f, 0.0f, 0.0f)); model = glm::scale(model, glm::vec3(scale, scale, scale)); shaderSingleColor.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); glBindVertexArray(0); glStencilMask(0xFF); glStencilFunc(GL_ALWAYS, 0, 0xFF); glEnable(GL_DEPTH_TEST); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;planeVAO); glDeleteBuffers(1, &amp;cubeVBO); glDeleteBuffers(1, &amp;planeVBO); glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"52、OpenGL 之模板函数","slug":"OpenGL/52、OpenGL 之模板函数","date":"2020-06-16T05:00:00.000Z","updated":"2020-08-07T14:20:18.731Z","comments":true,"path":"2020/06/16/OpenGL/52、OpenGL 之模板函数/","link":"","permalink":"https://www.zackaddy.xin/2020/06/16/OpenGL/52、OpenGL 之模板函数/","excerpt":"","text":"OpenGL 之模板函数和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：glStencilFunc和glStencilOp。 glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数： func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。 常量 含义 GL_NEVER 从不通过蒙板测试 GL_ALWAYS 总是通过蒙板测试 GL_LESS 只有参考值&lt;(蒙板缓存区的值&amp;mask)时才通过 GL_LEQUAL 只有参考值&lt;=(蒙板缓存区的值&amp;mask)时才通过 GL_EQUAL 只有参考值=(蒙板缓存区的值&amp;mask)时才通过 GL_GEQUAL 只有参考值&gt;=(蒙板缓存区的值&amp;mask)时才通过 GL_GREATER 只有参考值&gt;(蒙板缓存区的值&amp;mask)时才通过 GL_NOTEQUAL 只有参考值!=(蒙板缓存区的值&amp;mask)时才通过 ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。 mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。 在一开始的那个简单的模板例子中，函数被设置为： 1glStencilFunc(GL_EQUAL, 1, 0xFF) 这会告诉OpenGL，只要一个片段的模板值等于(GL_EQUAL)参考值1，片段将会通过测试并被绘制，否则会被丢弃。 但是glStencilFunc仅仅描述了OpenGL应该对模板缓冲内容做什么，而不是我们应该如何更新缓冲。这就需要glStencilOp这个函数了。 glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个选项，我们能够设定每个选项应该采取的行为： sfail：模板测试失败时采取的行为。 dpfail：模板测试通过，但深度测试失败时采取的行为。 dppass：模板测试和深度测试都通过时采取的行为。 每个选项都可以选用以下的其中一种行为： 行为 描述 GL_KEEP 保持当前储存的模板值 GL_ZERO 将模板值设置为0 GL_REPLACE 将模板值设置为glStencilFunc函数设置的ref值 GL_INCR 如果模板值小于最大值则将模板值加1 GL_INCR_WRAP 与GL_INCR一样，但如果模板值超过了最大值则归零 GL_DECR 如果模板值大于最小值则将模板值减1 GL_DECR_WRAP 与GL_DECR一样，但如果模板值小于0则将其设置为最大值 GL_INVERT 按位翻转当前的模板缓冲值 默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。 所以，通过使用glStencilFunc和glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"51、OpenGL 之模板测试","slug":"OpenGL/51、OpenGL 之模板测试","date":"2020-06-15T06:00:00.000Z","updated":"2020-08-07T14:20:18.726Z","comments":true,"path":"2020/06/15/OpenGL/51、OpenGL 之模板测试/","link":"","permalink":"https://www.zackaddy.xin/2020/06/15/OpenGL/51、OpenGL 之模板测试/","excerpt":"","text":"OpenGL 之模板测试简介当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。 模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。 一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。 ==每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。== 实例模板缓冲的一个简单的例子如下： 模板缓冲首先会被清除为0，之后在模板缓冲中使用1填充了一个空心矩形。场景中的片段将会只在片段的模板值为1的时候会被渲染（其它的都被丢弃了）。 模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们写入了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以读取这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下： 启用模板缓冲的写入。 渲染物体，更新模板缓冲的内容。 禁用模板缓冲的写入。 渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。 所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。 你可以启用GL_STENCIL_TEST来启用模板测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。 1glEnable(GL_STENCIL_TEST); 注意，和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); 和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。 12glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入） 大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"50、OpenGL 之深度冲突","slug":"OpenGL/50、OpenGL 之深度冲突","date":"2020-06-15T05:00:00.000Z","updated":"2020-08-07T14:20:18.721Z","comments":true,"path":"2020/06/15/OpenGL/50、OpenGL 之深度冲突/","link":"","permalink":"https://www.zackaddy.xin/2020/06/15/OpenGL/50、OpenGL 之深度冲突/","excerpt":"","text":"OpenGL 之深度冲突一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。 在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是共面的(Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。 如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹： 深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突、 防止深度冲突第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。 第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。 另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。 我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"49、OpenGL 之深度缓冲的可视化","slug":"OpenGL/49、OpenGL 之深度缓冲的可视化","date":"2020-06-14T06:00:00.000Z","updated":"2020-08-07T14:20:18.717Z","comments":true,"path":"2020/06/14/OpenGL/49、OpenGL 之深度缓冲的可视化/","link":"","permalink":"https://www.zackaddy.xin/2020/06/14/OpenGL/49、OpenGL 之深度缓冲的可视化/","excerpt":"","text":"OpenGL 之深度缓冲的可视化我们知道片段着色器中，内建gl_FragCoord向量的z值包含了那个特定片段的深度值。如果我们将这个深度值输出为颜色，我们可以显示场景中所有片段的深度值。我们可以根据片段的深度值返回一个颜色向量来完成这一工作： 1234void main()&#123; FragColor = vec4(vec3(gl_FragCoord.z), 1.0);&#125; 如果你再次运行程序的话，你可能会注意到所有东西都是白色的，看起来就想我们所有的深度值都是最大的1.0。所以为什么没有靠近0.0（即变暗）的深度值呢？ 你可能还记得在上一部分中说到，屏幕空间中的深度值是非线性的，即它在z值很小的时候有很高的精度，而z值很大的时候有较低的精度。片段的深度值会随着距离迅速增加，所以几乎所有的顶点的深度值都是接近于1.0的。如果我们小心地靠近物体，你可能会最终注意到颜色会渐渐变暗，显示它们的z值在逐渐变小： 这很清楚地展示了深度值的非线性性质。近处的物体比起远处的物体对深度值有着更大的影响。只需要移动几厘米就能让颜色从暗完全变白。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"48、OpenGL 之深度值精度","slug":"OpenGL/48、OpenGL 之深度值精度","date":"2020-06-14T05:00:00.000Z","updated":"2020-08-07T14:20:18.714Z","comments":true,"path":"2020/06/14/OpenGL/48、OpenGL 之深度值精度/","link":"","permalink":"https://www.zackaddy.xin/2020/06/14/OpenGL/48、OpenGL 之深度值精度/","excerpt":"","text":"OpenGL 之深度值精度深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。 观察空间的z值可能是投影平截头体的近平面(Near)和远平面(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。 下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值： 1F_&#123;depth&#125; = \\dfrac&#123;z - near&#125;&#123;far - near&#125; 这里的near和far值是我们之前提供给投影矩阵设置可视平截头体的（见坐标系统）那个 near 和 far 值。 这个方程需要平截头体中的一个z值，并将它变换到了[0, 1]的范围中。 z值和对应的深度值之间的关系可以在下图中看到： 注意所有的方程都会将非常近的物体的深度值设置为接近0.0的值，而当物体非常接近远平面的时候，它的深度值会非常接近1.0。 然而，在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 1/z 成正比的。它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。 由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的： 1F_&#123;depth&#125; = \\dfrac&#123;1/z - 1/near&#125;&#123;1/far - 1/near&#125; 如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中0.5的值并不代表着物体的z值是位于平截头体的中间了，这个顶点的z值实际上非常接近近平面！你可以在下图中看到z值和最终的深度缓冲值之间的非线性关系： 可以看到，深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。 如果我们想要可视化深度缓冲的话，非线性方程的效果很快就会变得很清楚。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"47、OpenGL 之深度测试","slug":"OpenGL/47、OpenGL 之深度测试","date":"2020-06-13T06:00:00.000Z","updated":"2020-08-07T14:20:18.709Z","comments":true,"path":"2020/06/13/OpenGL/47、OpenGL 之深度测试/","link":"","permalink":"https://www.zackaddy.xin/2020/06/13/OpenGL/47、OpenGL 之深度测试/","excerpt":"","text":"OpenGL 之深度测试简介深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。 深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。 当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。 深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。 提前深度测试现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。 片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。 深度测试启用深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它： 1glEnable(GL_DEPTH_TEST); 当它启用的时候，如果一个片段通过了深度测试的话，OpenGL会在深度缓冲中储存该片段的z值；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为GL_FALSE就可以了： 1glDepthMask(GL_FALSE); 注意这只在深度测试被启用的时候才有效果。 深度测试函数OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）： 1glDepthFunc(GL_LESS); 这个函数接受下面表格中的比较运算符： 函数 描述 GL_ALWAYS 永远通过深度测试 GL_NEVER 永远不通过深度测试 GL_LESS 在片段深度值小于缓冲的深度值时通过测试 GL_EQUAL 在片段深度值等于缓冲区的深度值时通过测试 GL_LEQUAL 在片段深度值小于等于缓冲区的深度值时通过测试 GL_GREATER 在片段深度值大于缓冲区的深度值时通过测试 GL_NOTEQUAL 在片段深度值不等于缓冲区的深度值时通过测试 GL_GEQUAL 在片段深度值大于等于缓冲区的深度值时通过测试 默认情况下使用的深度函数是GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。 在源代码中，我们将深度函数改为GL_ALWAYS： 12glEnable(GL_DEPTH_TEST);glDepthFunc(GL_ALWAYS); 这将会模拟我们没有启用深度测试时所得到的结果。 深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。 因为我们是最后渲染地板的，它会覆盖所有的箱子片段： 将它重新设置为GL_LESS，这会将场景还原为原有的样子：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"46、OpenGL 之深度缓冲详解","slug":"OpenGL/46、OpenGL 之深度缓冲详解","date":"2020-06-13T05:00:00.000Z","updated":"2020-08-07T14:20:18.705Z","comments":true,"path":"2020/06/13/OpenGL/46、OpenGL 之深度缓冲详解/","link":"","permalink":"https://www.zackaddy.xin/2020/06/13/OpenGL/46、OpenGL 之深度缓冲详解/","excerpt":"","text":"OpenGL 之深度缓冲详解1. 深度缓冲概念深度缓冲区与帧缓冲区相对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。 2. 何为深度深度其实就是该象素点在3d世界中距离摄象机的距离（绘制坐标），深度缓存中存储着每个象素点（绘制在屏幕上的）的深度值！深度值（Z值）越大，则离摄像机越远。 3. 为什么需要深度？在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。 4. 深度缓冲原理深度缓冲区原理就是把一个距离观察平面(近裁剪面)的深度值(或距离)与窗口中的每个像素相关联。首先，使用glClear(GL_DEPTH_BUFFER_BIT),把所有像素的深度值设置为最大值(一般是远裁剪面)。然后，在场景中以任意次序绘制所有物体。硬件或者软件所执行的图形计算把每一个绘制表面转换为窗口上一些像素的集合，此时并不考虑是否被其他物体遮挡。其次，OpenGL会计算这些表面和观察平面的距离。如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值&lt;原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，他颜色值和深度将被丢弃。为了启动深度缓冲区，必须先启动它，即glEnable(GL_DEPTH_TEST)。每次绘制场景之前，需要先清除深度缓冲区，即glClear(GL_DEPTH_BUFFER_BIT)，然后以任意次序绘制场景中的物体。 5. 深度测试在默认情况是将需要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新帧缓存中对应像素的颜色值。但是可以使用glDepthFunc(func)来对这种默认测试方式进行修改。其中参数func的值可以为GL_NEVER（没有处理）、GL_ALWAYS（处理所有）、GL_LESS（小于）、GL_LEQUAL（小于等于）、GL_EQUAL（等于）、GL_GEQUAL（大于等于）、GL_GREATER（大于）或GL_NOTEQUAL（不等于），其中默认值是GL_LESS。一般来将，使用glDepthFunc(GL_LEQUAL);来表达一般物体之间的遮挡关系。 6. 所带来的弊端启用了深度测试，那么这就不适用于同时绘制不透明物体。当需要绘制半透明物体时，需注意，在绘制半透明物体时前，还需要利用glDepthMask(GL_FALSE)将深度缓冲区设置为只读形式，否则可能出现画面错误。为什么呢，因为画透明物体时，将使用混色，这时就不能继续使用深度模式，而是利用混色函数来进行混合。这一来，就可以使用混合函数绘制半透明物体了。 7. 深入像素的深度值是由视矩阵和投影矩阵决定的。在近裁平面上的像素深度值为0，在远裁平面上的像素的深度值为1。场景中的每个对象都需进行绘制，通常最靠近相机的像素会被保留，这些对象阻挡了在它们后面的对象的可见性。深度缓冲通常还包含stencil bits – 所以深度缓冲又被叫做depth-stencil缓冲。深度缓冲总是32 bits，但可以用不同的方式组合，类似于纹理格式。常用的深度格式是Depth32，这种格式中32 bits都用来存储深度信息。另一个常用格式是DepthFormat.Depth24Stencil8，这种格式中24 bits用于深度计算而8 bits用于模版缓冲（stencil buffer）。 8. 补充内容颜色缓冲区（COLOR_BUFFER）就是帧缓冲区（FRAME_BUFFER）,你需要渲染的场景最终每一个像素都要写入该缓冲区,然后由它在渲染到屏幕上显示.","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"45、OpenGL 之 Vanilla 搭建OpenGL渲染环境","slug":"OpenGL/45、OpenGL 之 Vanilla 搭建OpenGL渲染环境","date":"2020-06-12T06:00:00.000Z","updated":"2020-08-07T14:20:18.700Z","comments":true,"path":"2020/06/12/OpenGL/45、OpenGL 之 Vanilla 搭建OpenGL渲染环境/","link":"","permalink":"https://www.zackaddy.xin/2020/06/12/OpenGL/45、OpenGL 之 Vanilla 搭建OpenGL渲染环境/","excerpt":"","text":"OpenGL 之 Vanilla 搭建OpenGL渲染环境PIXELFORMATDESCRIPTOR在创建一个图形操作表之前，首先必须设置像素格式。像素格式含有设备绘图界面的属性，这些属性包括绘图界面是用RGBA模式还是颜色表模式，像素缓存是用单缓存还是双缓存，以及颜色位数、深度缓存和模板缓存所用的位数，还有其它一些属性信息。 每个OpenGL显示设备都支持一种指定的像素格式。一般用一个名为PIXELFORMATDESCRIPTOR的结构来表示某个特殊的像素格式，这个结构包含26个属性信息。 wglCreateContext函数创建一个新的OpenGL渲染描述表,此描述表必须适用于绘制到由hdc返回的设备。这个渲染描述表将有和设备上下文(dc)一样的像素格式。 wglMakeCurrentwglMakeCurrent 函数设定OpenGL当前线程的渲染环境。以后这个线程所有的OpenGL调用都是在这个hdc标识的设备上绘制。你也可以使用wglMakeCurrent 函数来改变调用线程的当前渲染环境，使之不再是当前的渲染环境。 绘制一个点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;windows.h&gt;#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#include &lt;tchar.h&gt;#pragma comment(lib,\"opengl32.lib\")#pragma comment(lib,\"glu32.lib\")LRESULT CALLBACK GLWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch (msg) &#123; case WM_CLOSE: PostQuitMessage(0); break; &#125; return DefWindowProc(hwnd, msg, wParam, lParam);&#125;INT WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)&#123; // 注册窗口类 WNDCLASSEX wndclass; wndclass.cbClsExtra = 0; wndclass.cbSize = sizeof(WNDCLASSEX); wndclass.cbWndExtra = 0; wndclass.hbrBackground = NULL; wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hIcon = NULL; wndclass.hIconSm = NULL; wndclass.hInstance = hInstance; wndclass.lpfnWndProc = GLWindowProc; wndclass.lpszClassName = _T(\"GLWindow\"); wndclass.lpszMenuName = NULL; wndclass.style = CS_VREDRAW | CS_HREDRAW; ATOM atom = RegisterClassEx(&amp;wndclass); if (!atom) &#123; return 0; &#125; // 创建窗口 HWND hwnd = CreateWindowEx(NULL, _T(\"GLWindow\"), _T(\"OpenGL Window\"), WS_OVERLAPPEDWINDOW, 100, 100, 800, 600, NULL, NULL, hInstance, NULL); // 得到设备环境句柄 HDC dc = GetDC(hwnd); // 像素结构 PIXELFORMATDESCRIPTOR pfd; memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR)); pfd.nVersion = 1; pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); pfd.cColorBits = 32; pfd.cDepthBits = 24; pfd.cStencilBits = 8; pfd.iPixelType = PFD_TYPE_RGBA; pfd.iLayerType = PFD_MAIN_PLANE; pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER; // 提供像素格式描述符并由windows选择系统存在或接近的像素格式 int pixelFormat = ChoosePixelFormat(dc, &amp;pfd); SetPixelFormat(dc, pixelFormat, &amp;pfd); HGLRC rc = wglCreateContext(dc); wglMakeCurrent(dc, rc);//setup opengl context complete //opengl init glMatrixMode(GL_PROJECTION); // 下一步设置投影矩阵 gluPerspective(45.0f, 800.0f / 600.0f, 0.1f, 100.0f); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); // 用一个4×4的单位矩阵来替换模型视图矩阵 glClearColor(0.1, 0.4, 0.6, 1.0);//set \"clear color\" for background //show window ShowWindow(hwnd, SW_SHOW); UpdateWindow(hwnd); MSG msg; while (true) &#123; if (PeekMessage(&amp;msg, NULL, NULL, NULL, PM_REMOVE)) &#123; if (msg.message == WM_QUIT) &#123; break; &#125; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; //draw scene glClear(GL_COLOR_BUFFER_BIT); glColor4ub(255, 255, 255, 255); glPointSize(20.0f); glBegin(GL_POINTS); glVertex3f(0.0f, 0.0f, -0.5f); glEnd(); //present scene SwapBuffers(dc); &#125; return 0;&#125; 绘制线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;windows.h&gt;#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#include &lt;tchar.h&gt;#pragma comment(lib,\"opengl32.lib\")#pragma comment(lib,\"glu32.lib\")LRESULT CALLBACK GLWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch (msg) &#123; case WM_CLOSE: PostQuitMessage(0); break; &#125; return DefWindowProc(hwnd, msg, wParam, lParam);&#125;INT WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)&#123; // 注册窗口类 WNDCLASSEX wndclass; wndclass.cbClsExtra = 0; wndclass.cbSize = sizeof(WNDCLASSEX); wndclass.cbWndExtra = 0; wndclass.hbrBackground = NULL; wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hIcon = NULL; wndclass.hIconSm = NULL; wndclass.hInstance = hInstance; wndclass.lpfnWndProc = GLWindowProc; wndclass.lpszClassName = _T(\"GLWindow\"); wndclass.lpszMenuName = NULL; wndclass.style = CS_VREDRAW | CS_HREDRAW; ATOM atom = RegisterClassEx(&amp;wndclass); if (!atom) &#123; return 0; &#125; // 创建窗口 HWND hwnd = CreateWindowEx(NULL, _T(\"GLWindow\"), _T(\"OpenGL Window\"), WS_OVERLAPPEDWINDOW, 100, 100, 800, 600, NULL, NULL, hInstance, NULL); // 得到设备环境句柄 HDC dc = GetDC(hwnd); // 像素结构 PIXELFORMATDESCRIPTOR pfd; memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR)); pfd.nVersion = 1; pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); pfd.cColorBits = 32; pfd.cDepthBits = 24; pfd.cStencilBits = 8; pfd.iPixelType = PFD_TYPE_RGBA; pfd.iLayerType = PFD_MAIN_PLANE; pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER; // 提供像素格式描述符并由windows选择系统存在或接近的像素格式 int pixelFormat = ChoosePixelFormat(dc, &amp;pfd); SetPixelFormat(dc, pixelFormat, &amp;pfd); HGLRC rc = wglCreateContext(dc); wglMakeCurrent(dc, rc);//setup opengl context complete //opengl init glMatrixMode(GL_PROJECTION); // 下一步设置投影矩阵 gluPerspective(45.0f, 800.0f / 600.0f, 0.1f, 100.0f); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); // 用一个4×4的单位矩阵来替换模型视图矩阵 glClearColor(0.1, 0.4, 0.6, 1.0);//set \"clear color\" for background //show window ShowWindow(hwnd, SW_SHOW); UpdateWindow(hwnd); MSG msg; while (true) &#123; if (PeekMessage(&amp;msg, NULL, NULL, NULL, PM_REMOVE)) &#123; if (msg.message == WM_QUIT) &#123; break; &#125; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; //draw scene glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_LINE_STRIP);//start to draw something glColor4ub(255, 0, 0, 255); glVertex3f(0.0f, 0.0f, -10.0f); glColor4ub(0, 255, 0, 255); glVertex3f(-5.0f, 0.0f, -10.0f); glColor4ub(0, 0, 255, 255); glVertex3f(-5.0f, -2.0f, -10.0f); glEnd();//end //present scene SwapBuffers(dc); &#125; return 0;&#125; 三角形 STRIP 偶数环绕规则 T = [N - 1, N - 2, N] 奇数环绕规则 T = [N - 2, N - 1, N] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;windows.h&gt;#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#pragma comment(lib,\"opengl32.lib\")#pragma comment(lib,\"glu32.lib\")LRESULT CALLBACK GLWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch (msg) &#123; case WM_CLOSE: PostQuitMessage(0); break; &#125; return DefWindowProc(hwnd,msg,wParam,lParam);&#125;INT WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)&#123; //register window WNDCLASSEX wndclass; wndclass.cbClsExtra = 0; wndclass.cbSize = sizeof(WNDCLASSEX); wndclass.cbWndExtra = 0; wndclass.hbrBackground = NULL; wndclass.hCursor = LoadCursor(NULL,IDC_ARROW); wndclass.hIcon = NULL; wndclass.hIconSm = NULL; wndclass.hInstance = hInstance; wndclass.lpfnWndProc = GLWindowProc; wndclass.lpszClassName = L\"GLWindow\"; wndclass.lpszMenuName = NULL; wndclass.style = CS_VREDRAW | CS_HREDRAW; ATOM atom = RegisterClassEx(&amp;wndclass); if (!atom) &#123; return 0; &#125; //create window HWND hwnd = CreateWindowEx(NULL,L\"GLWindow\",L\"OpenGL Window\",WS_OVERLAPPEDWINDOW, 100,100,800,600,NULL,NULL,hInstance,NULL); //create opengl render context HDC dc = GetDC(hwnd); PIXELFORMATDESCRIPTOR pfd; memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR)); pfd.nVersion = 1; pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR); pfd.cColorBits = 32; pfd.cDepthBits = 24; pfd.cStencilBits = 8; pfd.iPixelType = PFD_TYPE_RGBA; pfd.iLayerType = PFD_MAIN_PLANE; pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER; int pixelFormat = ChoosePixelFormat(dc, &amp;pfd); SetPixelFormat(dc, pixelFormat, &amp;pfd); HGLRC rc = wglCreateContext(dc); wglMakeCurrent(dc, rc);//setup opengl context complete //opengl init glMatrixMode(GL_PROJECTION);//tell the gpu processer that i would select the projection matrix gluPerspective(50.0f, 800.0f / 600.0f, 0.1f, 1000.0f);//set some values to projection matrix glMatrixMode(GL_MODELVIEW);//tell .... model view matrix glLoadIdentity(); glClearColor(0.1f,0.4f,0.6f,1.0f);//set \"clear color\" for background //show window ShowWindow(hwnd, SW_SHOW); UpdateWindow(hwnd); glEnable(GL_CULL_FACE); //front face : ccw -&gt; counter clock wind MSG msg; while (true) &#123; if (PeekMessage(&amp;msg,NULL,NULL,NULL,PM_REMOVE)) &#123; if (msg.message==WM_QUIT) &#123; break; &#125; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; //draw scene glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_TRIANGLE_FAN);//start to draw something n-2 glColor4ub(255, 0, 0, 255); glVertex3f(0.0f, 0.0f, -10.0f); glColor4ub(0, 0, 255, 255); glVertex3f(-5.0f, -2.0f, -10.0f); glColor4ub(0, 255, 0, 255); glVertex3f(-3.0f, -2.0f, -10.0f); glColor4ub(0, 0, 255, 255); glVertex3f(-1.0f, -2.0f, -10.0f); glColor4ub(0, 255, 255, 255); glVertex3f(2.0f, -2.0f, -10.0f); glEnd();//end //present scene SwapBuffers(dc); &#125; return 0;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"44、OpenGL 之模型","slug":"OpenGL/44、OpenGL 之模型","date":"2020-06-12T05:00:00.000Z","updated":"2020-08-07T14:20:18.695Z","comments":true,"path":"2020/06/12/OpenGL/44、OpenGL 之模型/","link":"","permalink":"https://www.zackaddy.xin/2020/06/12/OpenGL/44、OpenGL 之模型/","excerpt":"","text":"OpenGL 之模型现在是时候接触Assimp并创建实际的加载和转换代码了。 现在创建另一个类来完整地表示一个模型，或者说是包含多个网格，甚至是多个物体的模型。 一个包含木制阳台、塔楼、甚至游泳池的房子可能仍会被加载为一个模型。我们会使用Assimp来加载模型，并将它转换(Translate)至多个Mesh对象。 1234567891011121314151617181920class Model &#123; public: /* 函数 */ Model(char *path) &#123; loadModel(path); &#125; void Draw(Shader shader); private: /* 模型数据 */ vector&lt;Mesh&gt; meshes; string directory; /* 函数 */ void loadModel(string path); void processNode(aiNode *node, const aiScene *scene); Mesh processMesh(aiMesh *mesh, const aiScene *scene); vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName);&#125;; Model类包含了一个Mesh对象的vector（译注：这里指的是C++中的vector模板类，之后遇到均不译），构造器需要我们给它一个文件路径。在构造器中，它会直接通过loadModel来加载文件。私有函数将会处理Assimp导入过程中的一部分，我们很快就会介绍它们。我们还将储存文件路径的目录，在之后加载纹理的时候还会用到它。 Draw函数没有什么特别之处，基本上就是遍历了所有网格，并调用它们各自的Draw函数。 12345void Draw(Shader shader)&#123; for(unsigned int i = 0; i &lt; meshes.size(); i++) meshes[i].Draw(shader);&#125; 导入3D模型到OpenGL在loadModel中，我们使用Assimp来加载模型至Assimp的一个叫做scene的数据结构中。 首先我们需要包含Assimp对应的头文件，这样编译器就不会抱怨我们了。 123#include &lt;assimp/Importer.hpp&gt;#include &lt;assimp/scene.h&gt;#include &lt;assimp/postprocess.h&gt; Assimp很棒的一点在于，它抽象掉了加载不同文件格式的所有技术细节，只需要一行代码就能完成所有的工作： 12Assimp::Importer importer;const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); 我们首先声明了Assimp命名空间内的一个Importer，之后调用了它的ReadFile函数。 这个函数需要一个文件路径，它的第二个参数是一些后期处理(Post-processing)的选项。 除了加载文件之外，Assimp允许我们设定一些选项来强制它对导入的数据做一些额外的计算或操作。 通过设定aiProcess_Triangulate，我们告诉Assimp，如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形。 aiProcess_FlipUVs将在处理的时候翻转y轴的纹理坐标（你可能还记得我们在纹理教程中说过，在OpenGL中大部分的图像的y轴都是反的，所以这个后期处理选项将会修复这个）。 其它一些比较有用的选项有： aiProcess_GenNormals：如果模型不包含法向量的话，就为每个顶点创建法线。 aiProcess_SplitLargeMeshes：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。 aiProcess_OptimizeMeshes：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。 实际上使用Assimp加载模型是非常容易的（你也可以看到）。困难的是之后使用返回的场景对象将加载的数据转换到一个Mesh对象的数组。 完整的loadModel函数将会是这样的： 1234567891011121314void loadModel(string path)&#123; Assimp::Importer import; const aiScene *scene = import.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); if(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) &#123; cout &lt;&lt; \"ERROR::ASSIMP::\" &lt;&lt; import.GetErrorString() &lt;&lt; endl; return; &#125; directory = path.substr(0, path.find_last_of('/')); processNode(scene-&gt;mRootNode, scene);&#125; 在我们加载了模型之后，我们会检查场景和其根节点不为null，并且检查了它的一个标记(Flag)，来查看返回的数据是不是不完整的。如果遇到了任何错误，我们都会通过导入器的GetErrorString函数来报告错误并返回。我们也获取了文件路径的目录路径。 如果什么错误都没有发生，我们希望处理场景中的所有节点，所以我们将第一个节点（根节点）传入了递归的processNode函数。 因为每个节点（可能）包含有多个子节点，我们希望首先处理参数中的节点，再继续处理该节点所有的子节点，以此类推。 这正符合一个递归结构，所以我们将定义一个递归函数。 递归函数在做一些处理之后，使用不同的参数递归调用这个函数自身，直到某个条件被满足停止递归。 在我们的例子中退出条件(Exit Condition)是所有的节点都被处理完毕。 你可能还记得Assimp的结构中，每个节点包含了一系列的网格索引，每个索引指向场景对象中的那个特定网格。 我们接下来就想去获取这些网格索引，获取每个网格，处理每个网格，接着对每个节点的子节点重复这一过程。processNode函数的内容如下： 1234567891011121314void processNode(aiNode *node, const aiScene *scene)&#123; // 处理节点所有的网格（如果有的话） for(unsigned int i = 0; i &lt; node-&gt;mNumMeshes; i++) &#123; aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; meshes.push_back(processMesh(mesh, scene)); &#125; // 接下来对它的子节点重复这一过程 for(unsigned int i = 0; i &lt; node-&gt;mNumChildren; i++) &#123; processNode(node-&gt;mChildren[i], scene); &#125;&#125; 我们首先检查每个节点的网格索引，并索引场景的mMeshes数组来获取对应的网格。返回的网格将会传递到processMesh函数中，它会返回一个Mesh对象，我们可以将它存储在meshes列表/vector。 所有网格都被处理之后，我们会遍历节点的所有子节点，并对它们调用相同的processMesh函数。当一个节点不再有任何子节点之后，这个函数将会停止执行。 从Assimp到网格将一个aiMesh对象转化为我们自己的网格对象不是那么困难。我们要做的只是访问网格的相关属性并将它们储存到我们自己的对象中。processMesh函数的大体结构如下： 1234567891011121314151617181920212223Mesh processMesh(aiMesh *mesh, const aiScene *scene)&#123; vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; for(unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; i++) &#123; Vertex vertex; // 处理顶点位置、法线和纹理坐标 ... vertices.push_back(vertex); &#125; // 处理索引 ... // 处理材质 if(mesh-&gt;mMaterialIndex &gt;= 0) &#123; ... &#125; return Mesh(vertices, indices, textures);&#125; 处理网格的过程主要有三部分：获取所有的顶点数据，获取它们的网格索引，并获取相关的材质数据。处理后的数据将会储存在三个vector当中，我们会利用它们构建一个Mesh对象，并返回它到函数的调用者那里。 获取顶点数据非常简单，我们定义了一个Vertex结构体，我们将在每个迭代之后将它加到vertices数组中。我们会遍历网格中的所有顶点（使用mesh-&gt;mNumVertices来获取）。在每个迭代中，我们希望使用所有的相关数据填充这个结构体。顶点的位置是这样处理的： 12345glm::vec3 vector; vector.x = mesh-&gt;mVertices[i].x;vector.y = mesh-&gt;mVertices[i].y;vector.z = mesh-&gt;mVertices[i].z; vertex.Position = vector; 注意我们为了传输Assimp的数据，我们定义了一个vec3的临时变量。使用这样一个临时变量的原因是Assimp对向量、矩阵、字符串等都有自己的一套数据类型，它们并不能完美地转换到GLM的数据类型中。 Assimp将它的顶点位置数组叫做mVertices，这其实并不是那么直观。 处理法线的步骤也是差不多的： 1234vector.x = mesh-&gt;mNormals[i].x;vector.y = mesh-&gt;mNormals[i].y;vector.z = mesh-&gt;mNormals[i].z;vertex.Normal = vector; 纹理坐标的处理也大体相似，但Assimp允许一个模型在一个顶点上有最多8个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标。我们同样也想检查网格是否真的包含了纹理坐标（可能并不会一直如此） 123456789if(mesh-&gt;mTextureCoords[0]) // 网格是否有纹理坐标？&#123; glm::vec2 vec; vec.x = mesh-&gt;mTextureCoords[0][i].x; vec.y = mesh-&gt;mTextureCoords[0][i].y; vertex.TexCoords = vec;&#125;else vertex.TexCoords = glm::vec2(0.0f, 0.0f); vertex结构体现在已经填充好了需要的顶点属性，我们会在迭代的最后将它压入vertices这个vector的尾部。这个过程会对每个网格的顶点都重复一遍。 索引Assimp的接口定义了每个网格都有一个面(Face)数组，每个面代表了一个图元，在我们的例子中（由于使用了aiProcess_Triangulate选项）它总是三角形。一个面包含了多个索引，它们定义了在每个图元中，我们应该绘制哪个顶点，并以什么顺序绘制，所以如果我们遍历了所有的面，并储存了面的索引到indices这个vector中就可以了。 123456for(unsigned int i = 0; i &lt; mesh-&gt;mNumFaces; i++)&#123; aiFace face = mesh-&gt;mFaces[i]; for(unsigned int j = 0; j &lt; face.mNumIndices; j++) indices.push_back(face.mIndices[j]);&#125; 所有的外部循环都结束了，我们现在有了一系列的顶点和索引数据，它们可以用来通过glDrawElements函数来绘制网格。然而，为了结束这个话题，并且对网格提供一些细节，我们还需要处理网格的材质。 材质和节点一样，一个网格只包含了一个指向材质对象的索引。如果想要获取网格真正的材质，我们还需要索引场景的mMaterials数组。网格材质索引位于它的mMaterialIndex属性中，我们同样可以用它来检测一个网格是否包含有材质： 12345678910if(mesh-&gt;mMaterialIndex &gt;= 0)&#123; aiMaterial *material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex]; vector&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, \"texture_diffuse\"); textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end()); vector&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, \"texture_specular\"); textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());&#125; 我们首先从场景的mMaterials数组中获取aiMaterial对象。接下来我们希望加载网格的漫反射和/或镜面光贴图。一个材质对象的内部对每种纹理类型都存储了一个纹理位置数组。不同的纹理类型都以aiTextureType_为前缀。我们使用一个叫做loadMaterialTextures的工具函数来从材质中获取纹理。这个函数将会返回一个Texture结构体的vector，我们将在模型的textures vector的尾部之后存储它。 loadMaterialTextures函数遍历了给定纹理类型的所有纹理位置，获取了纹理的文件位置，并加载并和生成了纹理，将信息储存在了一个Vertex结构体中。它看起来会像这样： 123456789101112131415vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName)&#123; vector&lt;Texture&gt; textures; for(unsigned int i = 0; i &lt; mat-&gt;GetTextureCount(type); i++) &#123; aiString str; mat-&gt;GetTexture(type, i, &amp;str); Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str; textures.push_back(texture); &#125; return textures;&#125; 我们首先通过GetTextureCount函数检查储存在材质中纹理的数量，这个函数需要一个纹理类型。我们会使用GetTexture获取每个纹理的文件位置，它会将结果储存在一个aiString中。我们接下来使用另外一个叫做TextureFromFile的工具函数，它将会（用stb_image.h）加载一个纹理并返回该纹理的ID。如果你不确定这样的代码是如何写出来的话，可以查看最后的完整代码。 注意，我们假设了模型文件中纹理文件的路径是相对于模型文件的本地(Local)路径，比如说与模型文件处于同一目录下。我们可以将纹理位置字符串拼接到之前（在loadModel中）获取的目录字符串上，来获取完整的纹理路径（这也是为什么GetTexture函数也需要一个目录字符串）。 在网络上找到的某些模型会对纹理位置使用绝对(Absolute)路径，这就不能在每台机器上都工作了。在这种情况下，你可能会需要手动修改这个文件，来让它对纹理使用本地路径（如果可能的话）。 这就是使用Assimp导入模型的全部了。 重大优化这还没有完全结束，因为我们还想做出一个重大的（但不是完全必须的）优化。大多数场景都会在多个网格中重用部分纹理。还是想想一个房子，它的墙壁有着花岗岩的纹理。这个纹理也可以被应用到地板、天花板、楼梯、桌子，甚至是附近的一口井上。加载纹理并不是一个开销不大的操作，在我们当前的实现中，即便同样的纹理已经被加载过很多遍了，对每个网格仍会加载并生成一个新的纹理。这很快就会变成模型加载实现的性能瓶颈。 所以我们会对模型的代码进行调整，将所有加载过的纹理全局储存，每当我们想加载一个纹理的时候，首先去检查它有没有被加载过。如果有的话，我们会直接使用那个纹理，并跳过整个加载流程，来为我们省下很多处理能力。为了能够比较纹理，我们还需要储存它们的路径： 12345struct Texture &#123; unsigned int id; string type; aiString path; // 我们储存纹理的路径用于与其它纹理进行比较&#125;; 接下来我们将所有加载过的纹理储存在另一个vector中，在模型类的顶部声明为一个私有变量： 1vector&lt;Texture&gt; textures_loaded; 之后，在loadMaterialTextures函数中，我们希望将纹理的路径与储存在textures_loaded这个vector中的所有纹理进行比较，看看当前纹理的路径是否与其中的一个相同。如果是的话，则跳过纹理加载/生成的部分，直接使用定位到的纹理结构体为网格的纹理。更新后的函数如下： 1234567891011121314151617181920212223242526272829vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName)&#123; vector&lt;Texture&gt; textures; for(unsigned int i = 0; i &lt; mat-&gt;GetTextureCount(type); i++) &#123; aiString str; mat-&gt;GetTexture(type, i, &amp;str); bool skip = false; for(unsigned int j = 0; j &lt; textures_loaded.size(); j++) &#123; if(std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0) &#123; textures.push_back(textures_loaded[j]); skip = true; break; &#125; &#125; if(!skip) &#123; // 如果纹理还没有被加载，则加载它 Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str.C_Str(); textures.push_back(texture); textures_loaded.push_back(texture); // 添加到已加载的纹理中 &#125; &#125; return textures;&#125; 所以现在我们不仅有了个灵活的模型加载系统，我们也获得了一个加载对象很快的优化版本。 有些版本的Assimp在使用调试版本或者使用IDE的调试模式下加载模型会非常缓慢，所以在你遇到缓慢的加载速度时，可以试试使用发布版本。 源码模型下载地址：https://learnopengl-cn.github.io/data/nanosuit.rar mesh.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#ifndef MESH_H#define MESH_H#include &lt;glad/glad.h&gt; // holds all OpenGL type declarations#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include \"shader.h\"#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Vertex &#123; // position glm::vec3 Position; // normal glm::vec3 Normal; // texCoords glm::vec2 TexCoords; // tangent glm::vec3 Tangent; // bitangent glm::vec3 Bitangent;&#125;;struct Texture &#123; unsigned int id; string type; string path;&#125;;class Mesh &#123;public: // mesh Data vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; unsigned int VAO; // constructor Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures) &#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; // now that we have all the required data, set the vertex buffers and its attribute pointers. setupMesh(); &#125; // render the mesh void Draw(Shader &amp;shader) &#123; // bind appropriate textures unsigned int diffuseNr = 1; unsigned int specularNr = 1; unsigned int normalNr = 1; unsigned int heightNr = 1; for (unsigned int i = 0; i &lt; textures.size(); i++) &#123; glActiveTexture(GL_TEXTURE0 + i); // active proper texture unit before binding // retrieve texture number (the N in diffuse_textureN) string number; string name = textures[i].type; if (name == \"texture_diffuse\") number = std::to_string(diffuseNr++); else if (name == \"texture_specular\") number = std::to_string(specularNr++); // transfer unsigned int to stream else if (name == \"texture_normal\") number = std::to_string(normalNr++); // transfer unsigned int to stream else if (name == \"texture_height\") number = std::to_string(heightNr++); // transfer unsigned int to stream // now set the sampler to the correct texture unit glUniform1i(glGetUniformLocation(shader.ID, (name + number).c_str()), i); // and finally bind the texture glBindTexture(GL_TEXTURE_2D, textures[i].id); &#125; // draw mesh glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0); // always good practice to set everything back to defaults once configured. glActiveTexture(GL_TEXTURE0); &#125;private: // render data unsigned int VBO, EBO; // initializes all the buffer objects/arrays void setupMesh() &#123; // create buffers/arrays glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); // load data into vertex buffers glBindBuffer(GL_ARRAY_BUFFER, VBO); // A great thing about structs is that their memory layout is sequential for all its items. // The effect is that we can simply pass a pointer to the struct and it translates perfectly to a glm::vec3/2 array which // again translates to 3/2 floats which translates to a byte array. glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW); // set the vertex attribute pointers // vertex Positions glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); // vertex tangent glEnableVertexAttribArray(3); glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent)); // vertex bitangent glEnableVertexAttribArray(4); glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Bitangent)); glBindVertexArray(0); &#125;&#125;;#endif model.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#ifndef MODEL_H#define MODEL_H#include &lt;glad/glad.h&gt; #include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include &lt;assimp/Importer.hpp&gt;#include &lt;assimp/scene.h&gt;#include &lt;assimp/postprocess.h&gt;#include \"mesh.h\"#include \"shader.h\"#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;unsigned int TextureFromFile(const char *path, const string &amp;directory, bool gamma = false);class Model&#123;public: // model data vector&lt;Texture&gt; textures_loaded; // stores all the textures loaded so far, optimization to make sure textures aren't loaded more than once. vector&lt;Mesh&gt; meshes; string directory; bool gammaCorrection; // constructor, expects a filepath to a 3D model. Model(string const &amp;path, bool gamma = false) : gammaCorrection(gamma) &#123; loadModel(path); &#125; // draws the model, and thus all its meshes void Draw(Shader &amp;shader) &#123; for (unsigned int i = 0; i &lt; meshes.size(); i++) meshes[i].Draw(shader); &#125;private: // loads a model with supported ASSIMP extensions from file and stores the resulting meshes in the meshes vector. void loadModel(string const &amp;path) &#123; // read file via ASSIMP Assimp::Importer importer; const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace); // check for errors if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) // if is Not Zero &#123; cout &lt;&lt; \"ERROR::ASSIMP:: \" &lt;&lt; importer.GetErrorString() &lt;&lt; endl; return; &#125; // retrieve the directory path of the filepath directory = path.substr(0, path.find_last_of('/')); // process ASSIMP's root node recursively processNode(scene-&gt;mRootNode, scene); &#125; // processes a node in a recursive fashion. Processes each individual mesh located at the node and repeats this process on its children nodes (if any). void processNode(aiNode *node, const aiScene *scene) &#123; // process each mesh located at the current node for (unsigned int i = 0; i &lt; node-&gt;mNumMeshes; i++) &#123; // the node object only contains indices to index the actual objects in the scene. // the scene contains all the data, node is just to keep stuff organized (like relations between nodes). aiMesh* mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; meshes.push_back(processMesh(mesh, scene)); &#125; // after we've processed all of the meshes (if any) we then recursively process each of the children nodes for (unsigned int i = 0; i &lt; node-&gt;mNumChildren; i++) &#123; processNode(node-&gt;mChildren[i], scene); &#125; &#125; Mesh processMesh(aiMesh *mesh, const aiScene *scene) &#123; // data to fill vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; // walk through each of the mesh's vertices for (unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; i++) &#123; Vertex vertex; glm::vec3 vector; // we declare a placeholder vector since assimp uses its own vector class that doesn't directly convert to glm's vec3 class so we transfer the data to this placeholder glm::vec3 first. // positions vector.x = mesh-&gt;mVertices[i].x; vector.y = mesh-&gt;mVertices[i].y; vector.z = mesh-&gt;mVertices[i].z; vertex.Position = vector; // normals vector.x = mesh-&gt;mNormals[i].x; vector.y = mesh-&gt;mNormals[i].y; vector.z = mesh-&gt;mNormals[i].z; vertex.Normal = vector; // texture coordinates if (mesh-&gt;mTextureCoords[0]) // does the mesh contain texture coordinates? &#123; glm::vec2 vec; // a vertex can contain up to 8 different texture coordinates. We thus make the assumption that we won't // use models where a vertex can have multiple texture coordinates so we always take the first set (0). vec.x = mesh-&gt;mTextureCoords[0][i].x; vec.y = mesh-&gt;mTextureCoords[0][i].y; vertex.TexCoords = vec; &#125; else vertex.TexCoords = glm::vec2(0.0f, 0.0f); // tangent vector.x = mesh-&gt;mTangents[i].x; vector.y = mesh-&gt;mTangents[i].y; vector.z = mesh-&gt;mTangents[i].z; vertex.Tangent = vector; // bitangent vector.x = mesh-&gt;mBitangents[i].x; vector.y = mesh-&gt;mBitangents[i].y; vector.z = mesh-&gt;mBitangents[i].z; vertex.Bitangent = vector; vertices.push_back(vertex); &#125; // now wak through each of the mesh's faces (a face is a mesh its triangle) and retrieve the corresponding vertex indices. for (unsigned int i = 0; i &lt; mesh-&gt;mNumFaces; i++) &#123; aiFace face = mesh-&gt;mFaces[i]; // retrieve all indices of the face and store them in the indices vector for (unsigned int j = 0; j &lt; face.mNumIndices; j++) indices.push_back(face.mIndices[j]); &#125; // process materials aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex]; // we assume a convention for sampler names in the shaders. Each diffuse texture should be named // as 'texture_diffuseN' where N is a sequential number ranging from 1 to MAX_SAMPLER_NUMBER. // Same applies to other texture as the following list summarizes: // diffuse: texture_diffuseN // specular: texture_specularN // normal: texture_normalN // 1. diffuse maps vector&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, \"texture_diffuse\"); textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end()); // 2. specular maps vector&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, \"texture_specular\"); textures.insert(textures.end(), specularMaps.begin(), specularMaps.end()); // 3. normal maps std::vector&lt;Texture&gt; normalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, \"texture_normal\"); textures.insert(textures.end(), normalMaps.begin(), normalMaps.end()); // 4. height maps std::vector&lt;Texture&gt; heightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, \"texture_height\"); textures.insert(textures.end(), heightMaps.begin(), heightMaps.end()); // return a mesh object created from the extracted mesh data return Mesh(vertices, indices, textures); &#125; // checks all material textures of a given type and loads the textures if they're not loaded yet. // the required info is returned as a Texture struct. vector&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName) &#123; vector&lt;Texture&gt; textures; for (unsigned int i = 0; i &lt; mat-&gt;GetTextureCount(type); i++) &#123; aiString str; mat-&gt;GetTexture(type, i, &amp;str); // check if texture was loaded before and if so, continue to next iteration: skip loading a new texture bool skip = false; for (unsigned int j = 0; j &lt; textures_loaded.size(); j++) &#123; if (std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0) &#123; textures.push_back(textures_loaded[j]); skip = true; // a texture with the same filepath has already been loaded, continue to next one. (optimization) break; &#125; &#125; if (!skip) &#123; // if texture hasn't been loaded already, load it Texture texture; texture.id = TextureFromFile(str.C_Str(), this-&gt;directory); texture.type = typeName; texture.path = str.C_Str(); textures.push_back(texture); textures_loaded.push_back(texture); // store it as texture loaded for entire model, to ensure we won't unnecesery load duplicate textures. &#125; &#125; return textures; &#125;&#125;;unsigned int TextureFromFile(const char *path, const string &amp;directory, bool gamma)&#123; string filename = string(path); filename = directory + '/' + filename; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(filename.c_str(), &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;#endif 1.model_loading.vs 12345678910111213141516#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; TexCoords = aTexCoords; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.model_loading.fs 1234567891011#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture_diffuse1;void main()&#123; FragColor = texture(texture_diffuse1, TexCoords);&#125; model_loading.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include \"shader.h\"#include \"camera.h\"#include \"model.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // tell stb_image.h to flip loaded texture's on the y-axis (before loading model). stbi_set_flip_vertically_on_load(true); // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile shaders // ------------------------- Shader ourShader(\"1.model_loading.vs\", \"1.model_loading.fs\"); // load models // ----------- Model ourModel(\"objects/backpack/nanosuit.obj\"); // draw in wireframe //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.05f, 0.05f, 0.05f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // don't forget to enable shader before setting uniforms ourShader.use(); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); ourShader.setMat4(\"projection\", projection); ourShader.setMat4(\"view\", view); // render the loaded model glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, glm::vec3(0.0f, 0.0f, 0.0f)); // translate it down so it's at the center of the scene model = glm::scale(model, glm::vec3(1.0f, 1.0f, 1.0f)); // it's a bit too big for our scene, so scale it down ourShader.setMat4(\"model\", model); ourModel.Draw(ourShader); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"43、OpenGL 之网格","slug":"OpenGL/43、OpenGL 之网格","date":"2020-06-11T06:00:00.000Z","updated":"2020-08-07T14:20:18.690Z","comments":true,"path":"2020/06/11/OpenGL/43、OpenGL 之网格/","link":"","permalink":"https://www.zackaddy.xin/2020/06/11/OpenGL/43、OpenGL 之网格/","excerpt":"","text":"OpenGL 之网格简介当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。 通常每个模型都由几个子模型/形状组合而成。 组合模型的每个单独的形状就叫做一个网格(Mesh)。 比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。 一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。 通过使用Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。我们最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。 网格(Mesh)代表的是单个的可绘制实体，我们现在先来定义一个我们自己的网格类。 一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射/镜面光贴图）。 既然我们有了一个网格类的最低需求，我们可以在OpenGL中定义一个顶点了： 12345struct Vertex &#123; glm::vec3 Position; glm::vec3 Normal; glm::vec2 TexCoords;&#125;; 我们将所有需要的向量储存到一个叫做Vertex的结构体中，我们可以用它来索引每个顶点属性。除了Vertex结构体之外，我们还需要将纹理数据整理到一个Texture结构体中。 1234struct Texture &#123; unsigned int id; string type;&#125;; 我们储存了纹理的id以及它的类型，比如是漫反射贴图或者是镜面光贴图。 知道了顶点和纹理的实现，我们可以开始定义网格类的结构了： 123456789101112131415class Mesh &#123; public: /* 网格数据 */ vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; /* 函数 */ Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures); void Draw(Shader shader); private: /* 渲染数据 */ unsigned int VAO, VBO, EBO; /* 函数 */ void setupMesh();&#125;; 你可以看到这个类并不复杂。在构造器中，我们将所有必须的数据赋予了网格，我们在setupMesh函数中初始化缓冲，并最终使用Draw函数来绘制网格。注意我们将一个着色器传入了Draw函数中，将着色器传入网格类中可以让我们在绘制之前设置一些uniform（像是链接采样器到纹理单元）。 构造器的内容非常易于理解。我们只需要使用构造器的参数设置类的公有变量就可以了。我们在构造器中还调用了setupMesh函数： 12345678Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures)&#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; setupMesh();&#125; 初始化由于有了构造器，我们现在有一大列的网格数据用于渲染。在此之前我们还必须配置正确的缓冲，并通过顶点属性指针定义顶点着色器的布局。现在你应该对这些概念都很熟悉了，但我们这次会稍微有一点变动，使用结构体中的顶点数据： 123456789101112131415161718192021222324252627void setupMesh()&#123; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW); // 顶点位置 glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // 顶点法线 glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // 顶点纹理坐标 glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); glBindVertexArray(0);&#125; 代码应该和你所想得没什么不同，但有了Vertex结构体的帮助，我们使用了一些小技巧。 C++结构体有一个很棒的特性，它们的内存布局是连续的(Sequential)。也就是说，如果我们将结构体作为一个数据数组使用，那么它将会以顺序排列结构体的变量，这将会直接转换为我们在数组缓冲中所需要的float（实际上是字节）数组。比如说，如果我们有一个填充后的Vertex结构体，那么它的内存布局将会等于： 12345Vertex vertex;vertex.Position = glm::vec3(0.2f, 0.4f, 0.6f);vertex.Normal = glm::vec3(0.0f, 1.0f, 0.0f);vertex.TexCoords = glm::vec2(1.0f, 0.0f);// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f]; 由于有了这个有用的特性，我们能够直接传入一大列的Vertex结构体的指针作为缓冲的数据，它们将会完美地转换为glBufferData所能用的参数： 1glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); 自然sizeof运算也可以用在结构体上来计算它的字节大小。这个应该是32字节的（8个float * 每个4字节）。 结构体的另外一个很好的用途是它的预处理指令offsetof(s, m)，它的第一个参数是一个结构体，第二个参数是这个结构体中变量的名字。这个宏会返回那个变量距结构体头部的字节偏移量(Byte Offset)。这正好可以用在定义glVertexAttribPointer函数中的偏移参数： 1glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); 偏移量现在是使用offsetof来定义了，在这里它会将法向量的字节偏移量设置为结构体中法向量的偏移量，也就是3个float，即12字节。注意，我们同样将步长参数设置为了Vertex结构体的大小。 使用这样的一个结构体不仅能够提供可读性更高的代码，也允许我们很容易地拓展这个结构。如果我们希望添加另一个顶点属性，我们只需要将它添加到结构体中就可以了。由于它的灵活性，渲染的代码不会被破坏。 渲染我们需要为Mesh类定义最后一个函数，它的Draw函数。在真正渲染这个网格之前，我们需要在调用glDrawElements函数之前先绑定相应的纹理。然而，这实际上有些困难，我们一开始并不知道这个网格（如果有的话）有多少纹理、纹理是什么类型的。所以我们该如何在着色器中设置纹理单元和采样器呢？ 为了解决这个问题，我们需要设定一个命名标准：每个漫反射纹理被命名为texture_diffuseN，每个镜面光纹理应该被命名为texture_specularN，其中N的范围是1到纹理采样器最大允许的数字。比如说我们对某一个网格有3个漫反射纹理，2个镜面光纹理，它们的纹理采样器应该之后会被调用： 12345uniform sampler2D texture_diffuse1;uniform sampler2D texture_diffuse2;uniform sampler2D texture_diffuse3;uniform sampler2D texture_specular1;uniform sampler2D texture_specular2; 根据这个标准，我们可以在着色器中定义任意需要数量的纹理采样器，如果一个网格真的包含了（这么多）纹理，我们也能知道它们的名字是什么。根据这个标准，我们也能在一个网格中处理任意数量的纹理，开发者也可以自由选择需要使用的数量，他只需要定义正确的采样器就可以了（虽然定义少的话会有点浪费绑定和uniform调用）。 像这样的问题有很多种不同的解决方案。如果你不喜欢这个解决方案，你可以自己想一个你自己的解决办法。 最终的渲染代码是这样的： 12345678910111213141516171819202122232425void Draw(Shader shader) &#123; unsigned int diffuseNr = 1; unsigned int specularNr = 1; for(unsigned int i = 0; i &lt; textures.size(); i++) &#123; glActiveTexture(GL_TEXTURE0 + i); // 在绑定之前激活相应的纹理单元 // 获取纹理序号（diffuse_textureN 中的 N） string number; string name = textures[i].type; if(name == \"texture_diffuse\") number = std::to_string(diffuseNr++); else if(name == \"texture_specular\") number = std::to_string(specularNr++); shader.setFloat((\"material.\" + name + number).c_str(), i); glBindTexture(GL_TEXTURE_2D, textures[i].id); &#125; glActiveTexture(GL_TEXTURE0); // 绘制网格 glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0);&#125; 我们首先计算了每个纹理类型的N-分量，并将其拼接到纹理类型字符串上，来获取对应的uniform名称。接下来我们查找对应的采样器，将它的位置值设置为当前激活的纹理单元，并绑定纹理。这也是我们在Draw函数中需要着色器的原因。我们也将”material.”添加到了最终的uniform名称中，因为我们希望将纹理储存在一个材质结构体中（这在每个实现中可能都不同）。 注意我们在将漫反射计数器和镜面光计数器插入stringstream时，对它们进行了递增。在C++中，这个递增操作：variable++将会返回变量本身，之后再递增，而++variable则是先递增，再返回值。在我们的例子中是首先将原本的计数器值插入stringstream，之后再递增它，供下一次循环使用。 源码mesh.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#ifndef MESH_H#define MESH_H#include &lt;glad/glad.h&gt; // holds all OpenGL type declarations#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include \"shader.h\"#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Vertex &#123; // 顶点 glm::vec3 Position; // 法线 glm::vec3 Normal; // 纹理坐标 glm::vec2 TexCoords; // 切线 glm::vec3 Tangent; // 双切线 glm::vec3 Bitangent;&#125;;struct Texture &#123; unsigned int id; string type; string path;&#125;;class Mesh &#123;public: // 网格数据 vector&lt;Vertex&gt; vertices; vector&lt;unsigned int&gt; indices; vector&lt;Texture&gt; textures; unsigned int VAO; // constructor Mesh(vector&lt;Vertex&gt; vertices, vector&lt;unsigned int&gt; indices, vector&lt;Texture&gt; textures) &#123; this-&gt;vertices = vertices; this-&gt;indices = indices; this-&gt;textures = textures; // 现在我们已经有了所有需要的数据，设置顶点缓冲区和它的顶点属性指针。 setupMesh(); &#125; // 渲染网格 void Draw(Shader &amp;shader) &#123; // 绑定对应的纹理 unsigned int diffuseNr = 1; unsigned int specularNr = 1; unsigned int normalNr = 1; unsigned int heightNr = 1; for (unsigned int i = 0; i &lt; textures.size(); i++) &#123; glActiveTexture(GL_TEXTURE0 + i); // active proper texture unit before binding // retrieve texture number (the N in diffuse_textureN) string number; string name = textures[i].type; if (name == \"texture_diffuse\") number = std::to_string(diffuseNr++); else if (name == \"texture_specular\") number = std::to_string(specularNr++); // transfer unsigned int to stream else if (name == \"texture_normal\") number = std::to_string(normalNr++); // transfer unsigned int to stream else if (name == \"texture_height\") number = std::to_string(heightNr++); // transfer unsigned int to stream // now set the sampler to the correct texture unit glUniform1i(glGetUniformLocation(shader.ID, (name + number).c_str()), i); // and finally bind the texture glBindTexture(GL_TEXTURE_2D, textures[i].id); &#125; // 画网格 glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0); // 一旦配置好，就将所有内容设置回默认值总是好的做法。 glActiveTexture(GL_TEXTURE0); &#125;private: // render data unsigned int VBO, EBO; // initializes all the buffer objects/arrays void setupMesh() &#123; // create buffers/arrays glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); // load data into vertex buffers glBindBuffer(GL_ARRAY_BUFFER, VBO); // A great thing about structs is that their memory layout is sequential for all its items. // The effect is that we can simply pass a pointer to the struct and it translates perfectly to a glm::vec3/2 array which // again translates to 3/2 floats which translates to a byte array. glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;vertices[0], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;indices[0], GL_STATIC_DRAW); // set the vertex attribute pointers // vertex Positions glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); // vertex tangent glEnableVertexAttribArray(3); glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent)); // vertex bitangent glEnableVertexAttribArray(4); glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Bitangent)); glBindVertexArray(0); &#125;&#125;;#endif","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"42、OpenGL 之模型加载库Assimp","slug":"OpenGL/42、OpenGL 之模型加载库Assimp","date":"2020-06-11T05:00:00.000Z","updated":"2020-08-07T14:20:18.686Z","comments":true,"path":"2020/06/11/OpenGL/42、OpenGL 之模型加载库Assimp/","link":"","permalink":"https://www.zackaddy.xin/2020/06/11/OpenGL/42、OpenGL 之模型加载库Assimp/","excerpt":"","text":"OpenGL 之模型加载库Assimp简介一个非常流行的模型导入库是Assimp，它是Open Asset Import Library（开放的资产导入库）的缩写。 Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。 当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。 由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。 Assimp数据结构的（简化）模型如下： 和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。 场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。 一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。 一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。 最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。 构建http://assimp.org/index.php/downloads 下载","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"41、OpenGL 之多光源实例","slug":"OpenGL/41、OpenGL 之多光源实例","date":"2020-06-10T06:00:00.000Z","updated":"2020-08-07T14:20:18.681Z","comments":true,"path":"2020/06/10/OpenGL/41、OpenGL 之多光源实例/","link":"","permalink":"https://www.zackaddy.xin/2020/06/10/OpenGL/41、OpenGL 之多光源实例/","excerpt":"","text":"OpenGL 之多光源实例1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; 1.multiple_lights.vs 123456789101112131415161718192021#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; TexCoords = aTexCoords; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.multiple_lights.fs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct DirLight &#123; vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;struct PointLight &#123; vec3 position; float constant; float linear; float quadratic; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;struct SpotLight &#123; vec3 position; vec3 direction; float cutOff; float outerCutOff; float constant; float linear; float quadratic; vec3 ambient; vec3 diffuse; vec3 specular; &#125;;#define NR_POINT_LIGHTS 4in vec3 FragPos;in vec3 Normal;in vec2 TexCoords;uniform vec3 viewPos;uniform DirLight dirLight;uniform PointLight pointLights[NR_POINT_LIGHTS];uniform SpotLight spotLight;uniform Material material;// function prototypesvec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir);vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir);void main()&#123; // properties vec3 norm = normalize(Normal); vec3 viewDir = normalize(viewPos - FragPos); // == ===================================================== // Our lighting is set up in 3 phases: directional, point lights and an optional flashlight // For each phase, a calculate function is defined that calculates the corresponding color // per lamp. In the main() function we take all the calculated colors and sum them up for // this fragment's final color. // == ===================================================== // phase 1: directional lighting vec3 result = CalcDirLight(dirLight, norm, viewDir); // phase 2: point lights for(int i = 0; i &lt; NR_POINT_LIGHTS; i++) result += CalcPointLight(pointLights[i], norm, FragPos, viewDir); // phase 3: spot light result += CalcSpotLight(spotLight, norm, FragPos, viewDir); FragColor = vec4(result, 1.0);&#125;// calculates the color when using a directional light.vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)&#123; vec3 lightDir = normalize(-light.direction); // diffuse shading float diff = max(dot(normal, lightDir), 0.0); // specular shading vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); // combine results vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); return (ambient + diffuse + specular);&#125;// calculates the color when using a point light.vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)&#123; vec3 lightDir = normalize(light.position - fragPos); // diffuse shading float diff = max(dot(normal, lightDir), 0.0); // specular shading vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); // attenuation float distance = length(light.position - fragPos); float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); // combine results vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); ambient *= attenuation; diffuse *= attenuation; specular *= attenuation; return (ambient + diffuse + specular);&#125;// calculates the color when using a spot light.vec3 CalcSpotLight(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)&#123; vec3 lightDir = normalize(light.position - fragPos); // diffuse shading float diff = max(dot(normal, lightDir), 0.0); // specular shading vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); // attenuation float distance = length(light.position - fragPos); float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); // spotlight intensity float theta = dot(lightDir, normalize(-light.direction)); float epsilon = light.cutOff - light.outerCutOff; float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0); // combine results vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); ambient *= attenuation * intensity; diffuse *= attenuation * intensity; specular *= attenuation * intensity; return (ambient + diffuse + specular);&#125; multiple_lights.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.multiple_lights.vs\", \"1.multiple_lights.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // normals // texture coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f &#125;; // positions all containers glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; // positions of the point lights glm::vec3 pointLightPositions[] = &#123; glm::vec3(0.7f, 0.2f, 2.0f), glm::vec3(2.3f, -3.3f, -4.0f), glm::vec3(-4.0f, 2.0f, -12.0f), glm::vec3(0.0f, 0.0f, -3.0f) &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // load textures (we now use a utility function to keep the code more organized) // ----------------------------------------------------------------------------- unsigned int diffuseMap = loadTexture(\"container2.png\"); unsigned int specularMap = loadTexture(\"container2_specular.png\"); // shader configuration // -------------------- lightingShader.use(); lightingShader.setInt(\"material.diffuse\", 0); lightingShader.setInt(\"material.specular\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); lightingShader.setVec3(\"viewPos\", camera.Position); lightingShader.setFloat(\"material.shininess\", 32.0f); /* Here we set all the uniforms for the 5/6 types of lights we have. We have to set them manually and index the proper PointLight struct in the array to set each uniform variable. This can be done more code-friendly by defining light types as classes and set their values in there, or by using a more efficient uniform approach by using 'Uniform buffer objects', but that is something we'll discuss in the 'Advanced GLSL' tutorial. */ // directional light lightingShader.setVec3(\"dirLight.direction\", -0.2f, -1.0f, -0.3f); lightingShader.setVec3(\"dirLight.ambient\", 0.05f, 0.05f, 0.05f); lightingShader.setVec3(\"dirLight.diffuse\", 0.4f, 0.4f, 0.4f); lightingShader.setVec3(\"dirLight.specular\", 0.5f, 0.5f, 0.5f); // point light 1 lightingShader.setVec3(\"pointLights[0].position\", pointLightPositions[0]); lightingShader.setVec3(\"pointLights[0].ambient\", 0.05f, 0.05f, 0.05f); lightingShader.setVec3(\"pointLights[0].diffuse\", 0.8f, 0.8f, 0.8f); lightingShader.setVec3(\"pointLights[0].specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"pointLights[0].constant\", 1.0f); lightingShader.setFloat(\"pointLights[0].linear\", 0.09); lightingShader.setFloat(\"pointLights[0].quadratic\", 0.032); // point light 2 lightingShader.setVec3(\"pointLights[1].position\", pointLightPositions[1]); lightingShader.setVec3(\"pointLights[1].ambient\", 0.05f, 0.05f, 0.05f); lightingShader.setVec3(\"pointLights[1].diffuse\", 0.8f, 0.8f, 0.8f); lightingShader.setVec3(\"pointLights[1].specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"pointLights[1].constant\", 1.0f); lightingShader.setFloat(\"pointLights[1].linear\", 0.09); lightingShader.setFloat(\"pointLights[1].quadratic\", 0.032); // point light 3 lightingShader.setVec3(\"pointLights[2].position\", pointLightPositions[2]); lightingShader.setVec3(\"pointLights[2].ambient\", 0.05f, 0.05f, 0.05f); lightingShader.setVec3(\"pointLights[2].diffuse\", 0.8f, 0.8f, 0.8f); lightingShader.setVec3(\"pointLights[2].specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"pointLights[2].constant\", 1.0f); lightingShader.setFloat(\"pointLights[2].linear\", 0.09); lightingShader.setFloat(\"pointLights[2].quadratic\", 0.032); // point light 4 lightingShader.setVec3(\"pointLights[3].position\", pointLightPositions[3]); lightingShader.setVec3(\"pointLights[3].ambient\", 0.05f, 0.05f, 0.05f); lightingShader.setVec3(\"pointLights[3].diffuse\", 0.8f, 0.8f, 0.8f); lightingShader.setVec3(\"pointLights[3].specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"pointLights[3].constant\", 1.0f); lightingShader.setFloat(\"pointLights[3].linear\", 0.09); lightingShader.setFloat(\"pointLights[3].quadratic\", 0.032); // spotLight lightingShader.setVec3(\"spotLight.position\", camera.Position); lightingShader.setVec3(\"spotLight.direction\", camera.Front); lightingShader.setVec3(\"spotLight.ambient\", 0.0f, 0.0f, 0.0f); lightingShader.setVec3(\"spotLight.diffuse\", 1.0f, 1.0f, 1.0f); lightingShader.setVec3(\"spotLight.specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"spotLight.constant\", 1.0f); lightingShader.setFloat(\"spotLight.linear\", 0.09); lightingShader.setFloat(\"spotLight.quadratic\", 0.032); lightingShader.setFloat(\"spotLight.cutOff\", glm::cos(glm::radians(12.5f))); lightingShader.setFloat(\"spotLight.outerCutOff\", glm::cos(glm::radians(15.0f))); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // bind diffuse map glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, diffuseMap); // bind specular map glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap); // render containers glBindVertexArray(cubeVAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // also draw the lamp object(s) lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); // we now draw as many light bulbs as we have point lights. glBindVertexArray(lightCubeVAO); for (unsigned int i = 0; i &lt; 4; i++) &#123; model = glm::mat4(1.0f); model = glm::translate(model, pointLightPositions[i]); model = glm::scale(model, glm::vec3(0.2f)); // Make it a smaller cube lightCubeShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"40、OpenGL 之聚光与手电筒","slug":"OpenGL/40、OpenGL 之聚光与手电筒","date":"2020-06-10T05:00:00.000Z","updated":"2020-08-07T14:20:18.676Z","comments":true,"path":"2020/06/10/OpenGL/40、OpenGL 之聚光与手电筒/","link":"","permalink":"https://www.zackaddy.xin/2020/06/10/OpenGL/40、OpenGL 之聚光与手电筒/","excerpt":"","text":"OpenGL 之聚光与手电筒聚光聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。 这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。 对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。 LightDir：从片段指向光源的向量。 SpotDir：聚光所指向的方向。 Phiϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。 Thetaθ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θ值应该比ϕ值小。 所以我们要做的就是计算LightDir向量和SpotDir向量之间的点积（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与切光角ϕ值对比。 手电筒手电筒(Flashlight)是一个位于观察者位置的聚光，通常它都会瞄准玩家视角的正前方。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。 所以，在片段着色器中我们需要的值有聚光的位置向量（来计算光的方向向量）、聚光的方向向量和一个切光角。我们可以将它们储存在Light结构体中： 123456struct Light &#123; vec3 position; vec3 direction; float cutOff; ...&#125;; 接下来我们将合适的值传到着色器中： 123lightingShader.setVec3(\"light.position\", camera.Position);lightingShader.setVec3(\"light.direction\", camera.Front);lightingShader.setFloat(\"light.cutOff\", glm::cos(glm::radians(12.5f))); 你可以看到，我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中。 接下来就是计算θ值，并将它和切光角ϕ对比，来决定是否在聚光的内部： 12345678float theta = dot(lightDir, normalize(-light.direction));// lightDir与normalize(-light.direction)都是单位向量，所以点乘结果就是1 * 1 * cosθif(theta &gt; light.cutOff) &#123; // 执行光照计算&#125;else // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗 color = vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0); 运行程序，你将会看到一个聚光，它仅会照亮聚光圆锥内的片段。看起来像是这样的： 平滑/软化边缘为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个内圆锥(Inner Cone)和一个外圆锥(Outer Cone)。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界。 为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度值就是0.0。 我们可以用下面这个公式来计算这个值： 1I = \\dfrac&#123;θ - γ&#125;&#123;ϵ&#125; 这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的I值就是在当前片段聚光的强度。 很难去表现这个公式是怎么工作的，所以我们用一些实例值来看看： θ θ（角度） ϕ（内光切） ϕ（角度） γ（外光切） γ（角度） ϵ I 0.87 30 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.87 - 0.82 / 0.09 = 0.56 0.9 26 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.9 - 0.82 / 0.09 = 0.89 0.97 14 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.97 - 0.82 / 0.09 = 1.67 0.83 34 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.83 - 0.82 / 0.09 = 0.11 0.64 50 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.64 - 0.82 / 0.09 = -2.0 0.966 15 0.9978 12.5 0.953 17.5 0.966 - 0.953 = 0.0448 0.966 - 0.953 / 0.0448 = 0.29 12345678float theta = dot(lightDir, normalize(-light.direction));float epsilon = light.cutOff - light.outerCutOff;float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0); ...// 将不对环境光做出影响，让它总是能有一点光diffuse *= intensity;specular *= intensity;... 源码1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; 1.lighting_maps.vs 123456789101112131415161718192021#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; TexCoords = aTexCoords; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.lighting_maps.fs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct Light &#123; vec3 position; vec3 direction; float cutOff; float outerCutOff; vec3 ambient; vec3 diffuse; vec3 specular; float constant; float linear; float quadratic;&#125;;in vec3 FragPos; in vec3 Normal; in vec2 TexCoords; uniform vec3 viewPos;uniform Material material;uniform Light light;void main()&#123; // ambient vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(light.position - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb; // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb; // spotlight (soft edges) float theta = dot(lightDir, normalize(-light.direction)); float epsilon = (light.cutOff - light.outerCutOff); float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0); diffuse *= intensity; specular *= intensity; // attenuation float distance = length(light.position - FragPos); float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); ambient *= attenuation; diffuse *= attenuation; specular *= attenuation; vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; lighting_maps.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.lighting_maps.vs\", \"1.lighting_maps.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // normals // texture coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f &#125;; // positions all containers glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // load textures (we now use a utility function to keep the code more organized) // ----------------------------------------------------------------------------- unsigned int diffuseMap = loadTexture(\"container2.png\"); unsigned int specularMap = loadTexture(\"container2_specular.png\"); // shader configuration // -------------------- lightingShader.use(); lightingShader.setInt(\"material.diffuse\", 0); lightingShader.setInt(\"material.specular\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); //lightingShader.setVec3(\"light.position\", lightPos); lightingShader.setVec3(\"light.position\", camera.Position); lightingShader.setVec3(\"light.direction\", camera.Front); lightingShader.setFloat(\"light.cutOff\", glm::cos(glm::radians(12.5f))); lightingShader.setFloat(\"light.outerCutOff\", glm::cos(glm::radians(17.5f))); lightingShader.setVec3(\"viewPos\", camera.Position); // light properties lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f); lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"light.constant\", 1.0f); lightingShader.setFloat(\"light.linear\", 0.09f); lightingShader.setFloat(\"light.quadratic\", 0.032f); // material properties lightingShader.setFloat(\"material.shininess\", 64.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // bind diffuse map glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, diffuseMap); // bind specular map glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap); // render the cube //glBindVertexArray(cubeVAO); //glDrawArrays(GL_TRIANGLES, 0, 36); // render containers glBindVertexArray(cubeVAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"39、OpenGL 之点光源","slug":"OpenGL/39、OpenGL 之点光源","date":"2020-06-09T06:00:00.000Z","updated":"2020-08-07T14:20:18.671Z","comments":true,"path":"2020/06/09/OpenGL/39、OpenGL 之点光源/","link":"","permalink":"https://www.zackaddy.xin/2020/06/09/OpenGL/39、OpenGL 之点光源/","excerpt":"","text":"OpenGL 之点光源简介定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源(Point Light)。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。想象作为投光物的灯泡和火把，它们都是点光源。 我们在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。然而，我们定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强。在大部分的3D模拟中，我们都希望模拟的光源仅照亮光源附近的区域而不是整个场景。 我们希望在后排的箱子与前排的箱子相比仅仅是被轻微地照亮。 衰减随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。 随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。 在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。 幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量： 1F_&#123;att&#125; = \\dfrac&#123;1.0&#125;&#123;K_&#123;c&#125;+K_&#123;l&#125;*d + K_&#123;q&#125;*d^2&#125; 在这里d代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Kl和二次项Kq。 常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。 一次项会与距离值相乘，以线性的方式减少强度。 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。 下面这张图显示了在100的距离内衰减的效果： 选择正确的值正确地设定它们的值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。 距离 常数项 一次项 二次项 7 1.0 0.7 1.8 13 1.0 0.35 0.44 20 1.0 0.22 0.20 32 1.0 0.14 0.07 50 1.0 0.09 0.032 65 1.0 0.07 0.017 100 1.0 0.045 0.0075 160 1.0 0.027 0.0028 200 1.0 0.022 0.0019 325 1.0 0.014 0.0007 600 1.0 0.007 0.0002 3250 1.0 0.0014 0.000007 可以看到，常数项Kc在所有的情况下都是1.0。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小。 实现衰减在片段着色器中我们还需要三个额外的值：也就是公式中的常数项、一次项和二次项。它们最好储存在之前定义的Light结构体中。 1234567891011struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; float constant; float linear; float quadratic;&#125;; 我们会使用表格中对应的常数项、一次项和二次项： 123lightingShader.setFloat(\"light.constant\", 1.0f);lightingShader.setFloat(\"light.linear\", 0.09f);lightingShader.setFloat(\"light.quadratic\", 0.032f); 我们可以通过获取片段和光源之间的向量差，并获取结果向量的长度作为距离项。我们可以使用GLSL内建的length函数来完成这一点： 123float distance = length(light.position - FragPos);float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); 接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。 123ambient *= attenuation; diffuse *= attenuation;specular *= attenuation; 源码1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; 1.lighting_maps.vs 123456789101112131415161718192021#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; TexCoords = aTexCoords; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.lighting_maps.fs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct Light &#123; //vec3 position; vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular; float constant; float linear; float quadratic;&#125;;in vec3 FragPos; in vec3 Normal; in vec2 TexCoords; uniform vec3 viewPos;uniform Material material;uniform Light light;void main()&#123; // ambient vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb; // diffuse vec3 norm = normalize(Normal); // vec3 lightDir = normalize(light.position - FragPos); vec3 lightDir = normalize(light.direction - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb; // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb; // attenuation float distance = length(light.direction - FragPos); float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); ambient *= attenuation; diffuse *= attenuation; specular *= attenuation; vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; lighting_maps.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.lighting_maps.vs\", \"1.lighting_maps.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // normals // texture coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f &#125;; // positions all containers glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // load textures (we now use a utility function to keep the code more organized) // ----------------------------------------------------------------------------- unsigned int diffuseMap = loadTexture(\"container2.png\"); unsigned int specularMap = loadTexture(\"container2_specular.png\"); // shader configuration // -------------------- lightingShader.use(); lightingShader.setInt(\"material.diffuse\", 0); lightingShader.setInt(\"material.specular\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); //lightingShader.setVec3(\"light.position\", lightPos); lightingShader.setVec3(\"light.direction\", lightPos); lightingShader.setVec3(\"viewPos\", camera.Position); // light properties lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f); lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); lightingShader.setFloat(\"light.constant\", 1.0f); lightingShader.setFloat(\"light.linear\", 0.09f); lightingShader.setFloat(\"light.quadratic\", 0.032f); // material properties lightingShader.setFloat(\"material.shininess\", 64.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // bind diffuse map glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, diffuseMap); // bind specular map glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap); // render the cube //glBindVertexArray(cubeVAO); //glDrawArrays(GL_TRIANGLES, 0, 36); // render containers glBindVertexArray(cubeVAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"38、OpenGL 之平行光","slug":"OpenGL/38、OpenGL 之平行光","date":"2020-06-09T05:00:00.000Z","updated":"2020-08-07T14:20:18.666Z","comments":true,"path":"2020/06/09/OpenGL/38、OpenGL 之平行光/","link":"","permalink":"https://www.zackaddy.xin/2020/06/09/OpenGL/38、OpenGL 之平行光/","excerpt":"","text":"OpenGL 之平行光投光物将光投射(Cast)到物体的光源叫做投光物(Light Caster) 学会模拟不同种类的光源是又一个能够进一步丰富场景的工具。 定向光 当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。 定向光非常好的一个例子就是太阳。太阳距离我们并不是无限远，但它已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，我们可以在下图看到： 因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。 我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的direction向量而不是通过direction来计算lightDir向量。 1234567891011121314struct Light &#123; // vec3 position; // 使用定向光就不再需要了 vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;...void main()&#123; vec3 lightDir = normalize(-light.direction); ...&#125; 人们更习惯定义定向光为一个从光源出发的全局方向（以光所在坐标轴来指向物体所在的方向） 先定义了十个不同的箱子位置，并对每个箱子都生成了一个不同的模型矩阵，每个模型矩阵都包含了对应的局部-世界坐标变换： 12345678910for(unsigned int i = 0; i &lt; 10; i++)&#123; glm::mat4 model; model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36);&#125; 同时，不要忘记定义光源的方向（注意我们将方向定义为从光源出发的方向，你可以很容易看到光的方向朝下）。 1lightingShader.setVec3(\"light.direction\", -0.2f, -1.0f, -0.3f); 在场景中自由移动，你就可以看到好像有一个太阳一样的光源对所有的物体投光。 源码1.lighting_maps.vs 123456789101112131415161718192021#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; TexCoords = aTexCoords; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.lighting_maps.fs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct Light &#123; //vec3 position; vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;in vec3 FragPos; in vec3 Normal; in vec2 TexCoords; uniform vec3 viewPos;uniform Material material;uniform Light light;void main()&#123; // ambient vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb; // diffuse vec3 norm = normalize(Normal); // vec3 lightDir = normalize(light.position - FragPos); vec3 lightDir = normalize(-light.direction); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb; // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb; vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; 1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; lighting_maps.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.lighting_maps.vs\", \"1.lighting_maps.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // normals // texture coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f &#125;; // positions all containers glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // load textures (we now use a utility function to keep the code more organized) // ----------------------------------------------------------------------------- unsigned int diffuseMap = loadTexture(\"container2.png\"); unsigned int specularMap = loadTexture(\"container2_specular.png\"); // shader configuration // -------------------- lightingShader.use(); lightingShader.setInt(\"material.diffuse\", 0); lightingShader.setInt(\"material.specular\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); //lightingShader.setVec3(\"light.position\", lightPos); lightingShader.setVec3(\"light.direction\", -0.2f, -1.0f, -0.3f); lightingShader.setVec3(\"viewPos\", camera.Position); // light properties lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f); lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); // material properties lightingShader.setFloat(\"material.shininess\", 64.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // bind diffuse map glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, diffuseMap); // bind specular map glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap); // render the cube //glBindVertexArray(cubeVAO); //glDrawArrays(GL_TRIANGLES, 0, 36); // render containers glBindVertexArray(cubeVAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // also draw the lamp object //lightCubeShader.use(); //lightCubeShader.setMat4(\"projection\", projection); //lightCubeShader.setMat4(\"view\", view); //model = glm::mat4(1.0f); //model = glm::translate(model, lightPos); //model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube //lightCubeShader.setMat4(\"model\", model); //glBindVertexArray(lightCubeVAO); //glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"37、OpenGL 之光照贴图","slug":"OpenGL/37、OpenGL 之光照贴图","date":"2020-06-08T06:00:00.000Z","updated":"2020-08-07T14:20:18.662Z","comments":true,"path":"2020/06/08/OpenGL/37、OpenGL 之光照贴图/","link":"","permalink":"https://www.zackaddy.xin/2020/06/08/OpenGL/37、OpenGL 之光照贴图/","excerpt":"","text":"OpenGL 之光照贴图简介想想一辆汽车：它的外壳非常有光泽，车窗会部分反射周围的环境，轮胎不会那么有光泽，所以它没有镜面高光，轮毂非常闪亮（如果你洗车了的话）。 只有材质系统是肯定不够的，它只是一个最简单的模型，所以我们需要拓展之前的系统，引入漫反射和镜面光贴图(Map)。这允许我们对物体的漫反射分量（以及间接地对环境光分量，它们几乎总是一样的）和镜面光分量有着更精确的控制。 漫反射贴图我们希望通过某种方式对物体的每个片段单独设置漫反射颜色 一个纹理。 我们仅仅是对同样的原理使用了不同的名字：其实都是使用一张覆盖物体的图像，让我们能够逐片段索引其独立的颜色值。在光照场景中，它通常叫做一个漫反射贴图(Diffuse Map)（3D艺术家通常都这么叫它），它是一个表现了物体所有的漫反射颜色的纹理图像。 ==注意sampler2D是所谓的不透明类型(Opaque Type)，也就是说我们不能将它实例化，只能通过uniform来定义它。如果我们使用除uniform以外的方法（比如函数的参数）实例化这个结构体，GLSL会抛出一些奇怪的错误。这同样也适用于任何封装了不透明类型的结构体。== 在着色器中使用漫反射贴图的方法和纹理教程中是完全一样的。但这次我们会将纹理储存为Material结构体中的一个sampler2D。 我们也移除了环境光材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们不需要将它们分开储存： 1234567struct Material &#123; sampler2D diffuse; vec3 specular; float shininess;&#125;; ...in vec2 TexCoords; 注意我们将在片段着色器中再次需要纹理坐标，所以我们声明一个额外的输入变量。接下来我们只需要从纹理中采样片段的漫反射颜色值即可： 1vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); 不要忘记将环境光得材质颜色设置为漫反射材质颜色同样的值。 1vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); 顶点数据现在包含了顶点位置、法向量和立方体顶点处的纹理坐标。 123456789101112#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;...out vec2 TexCoords;void main()&#123; ... TexCoords = aTexCoords;&#125; 记得去更新两个VAO的顶点属性指针来匹配新的顶点数据，并加载箱子图像为一个纹理。在绘制箱子之前，我们希望将要用的纹理单元赋值到material.diffuse这个uniform采样器，并绑定箱子的纹理到这个纹理单元： 1234lightingShader.setInt(\"material.diffuse\", 0);...glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, diffuseMap); 使用了漫反射贴图之后，细节再一次得到惊人的提升，这次箱子有了光照开始闪闪发光（字面意思也是）了。你的箱子看起来可能像这样： 采样镜面光贴图镜面高光看起来有些奇怪，因为我们的物体大部分都是木头，我们知道木头不应该有这么强的镜面高光的。 镜面高光的强度可以通过图像每个像素的亮度来获取。 镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量vec3(0.0)，灰色代表颜色向量vec3(0.5)。 在片段着色器中，我们接下来会取样对应的颜色值并将它乘以光源的镜面强度。 一个像素越「白」，乘积就会越大，物体的镜面光分量就会越亮。 我们必须要对镜面光贴图使用一个不同的纹理单元（见纹理），所以我们在渲染之前先把它绑定到合适的纹理单元上： 1234lightingShader.setInt(\"material.specular\", 1);...glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, specularMap); 接下来更新片段着色器的材质属性，让其接受一个sampler2D而不是vec3作为镜面光分量： 12345struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; 最后我们希望采样镜面光贴图，来获取片段所对应的镜面光强度： 1通过使用镜面光贴图我们可以可以对物体设置大量的细节，比如物体的哪些部分需要有闪闪发光的属性，我们甚至可以设置它们对应的强度。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。 源码1.lighting_maps.vs 123456789101112131415161718192021#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;out vec3 FragPos;out vec3 Normal;out vec2 TexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; TexCoords = aTexCoords; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.lighting_maps.fs 123456789101112131415161718192021222324252627282930313233343536373839404142434445#version 330 coreout vec4 FragColor;struct Material &#123; sampler2D diffuse; sampler2D specular; float shininess;&#125;; struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;in vec3 FragPos; in vec3 Normal; in vec2 TexCoords; uniform vec3 viewPos;uniform Material material;uniform Light light;void main()&#123; // ambient vec3 ambient = light.ambient * texture(material.diffuse, TexCoords).rgb; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(light.position - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = light.diffuse * diff * texture(material.diffuse, TexCoords).rgb; // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = light.specular * spec * texture(material.specular, TexCoords).rgb; vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; 1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; lighting_maps.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);unsigned int loadTexture(const char *path);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.lighting_maps.vs\", \"1.lighting_maps.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // normals // texture coords -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // load textures (we now use a utility function to keep the code more organized) // ----------------------------------------------------------------------------- unsigned int diffuseMap = loadTexture(\"container2.png\"); unsigned int specularMap = loadTexture(\"container2_specular.png\"); // shader configuration // -------------------- lightingShader.use(); lightingShader.setInt(\"material.diffuse\", 0); lightingShader.setInt(\"material.specular\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); lightingShader.setVec3(\"light.position\", lightPos); lightingShader.setVec3(\"viewPos\", camera.Position); // light properties lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f); lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); // material properties lightingShader.setFloat(\"material.shininess\", 64.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // bind diffuse map glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, diffuseMap); // bind specular map glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, specularMap); // render the cube glBindVertexArray(cubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;// utility function for loading a 2D texture from file// ---------------------------------------------------unsigned int loadTexture(char const * path)&#123; unsigned int textureID; glGenTextures(1, &amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(path, &amp;width, &amp;height, &amp;nrComponents, 0); if (data) &#123; GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); &#125; else &#123; std::cout &lt;&lt; \"Texture failed to load at path: \" &lt;&lt; path &lt;&lt; std::endl; stbi_image_free(data); &#125; return textureID;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"36、OpenGL 之材质","slug":"OpenGL/36、OpenGL 之材质","date":"2020-06-08T05:00:00.000Z","updated":"2020-08-07T14:20:18.652Z","comments":true,"path":"2020/06/08/OpenGL/36、OpenGL 之材质/","link":"","permalink":"https://www.zackaddy.xin/2020/06/08/OpenGL/36、OpenGL 之材质/","excerpt":"","text":"OpenGL 之材质关于材质的理解： 材质就是对光的反射特性 比如说：在阳光下，树叶是绿色的，并不是树叶发出了绿色的光，而是树叶吸收了其他颜色的光，反射绿色的光。剥离掉树叶这种物质，提取出树叶对光“处理”的特性，这就叫树叶材质。 在现实世界里，每个物体会对光产生不同的反应。比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义一个材质(Material)属性。 我们可以用三个分量来定义一个材质颜色(Material Color)：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对物体的颜色输出有着精细的控制了。现在，我们再添加反光度(Shininess)这个分量到上述的三个颜色中，这就有我们需要的所有材质属性了： 123456789#version 330 corestruct Material &#123; vec3 ambient; vec3 diffuse; vec3 specular; float shininess;&#125;; uniform Material material; 我们为每个冯氏光照模型的分量都定义一个颜色向量。 ambient材质向量定义了在环境光照下这个物体反射得是什么颜色，通常这是和物体颜色相同的颜色。 diffuse材质向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要设置为我们需要的物体颜色。 specular材质向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。 shininess影响镜面高光的散射/半径。 正确地指定一个物体的材质属性，我们对这个物体的感知也就不同了。 设置材质修改上次的1.colors.fs 1234567891011121314151617181920void main()&#123; // 环境光 vec3 ambient = lightColor * material.ambient; // 漫反射 vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = lightColor * (diff * material.diffuse); // 镜面光 vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = lightColor * (spec * material.specular); vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; colors.cpp 1234lightingShader.setVec3(\"material.ambient\", 1.0f, 0.5f, 0.31f);lightingShader.setVec3(\"material.diffuse\", 1.0f, 0.5f, 0.31f);lightingShader.setVec3(\"material.specular\", 0.5f, 0.5f, 0.5f);lightingShader.setFloat(\"material.shininess\", 32.0f); 光的属性这个物体太亮了。物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射。光源对环境光、漫反射和镜面光分量也具有着不同的强度。前面的教程，我们通过使用一个强度值改变环境光和镜面光强度的方式解决了这个问题。我们想做一个类似的系统，但是这次是要为每个光照分量都指定一个强度向量。 像之前一样如果我们假设lightColor是vec3(1.0)，代码会看起来像这样： 123vec3 ambient = vec3(1.0) * material.ambient;vec3 diffuse = vec3(1.0) * (diff * material.diffuse);vec3 specular = vec3(1.0) * (spec * material.specular); 所以物体的每个材质属性对每一个光照分量都返回了最大的强度。对单个光源来说，这些vec3(1.0)值同样可以分别改变，而这通常就是我们想要的。现在，物体的环境光分量完全地影响了立方体的颜色，可是环境光分量实际上不应该对最终的颜色有这么大的影响，所以我们会将光源的环境光强度设置为一个小一点的值，从而限制环境光颜色： 1vec3 ambient = vec3(0.1) * material.ambient; 我们可以用同样的方式修改光源的漫反射和镜面光强度。这和我们在上一节中所做的极为相似，你可以说我们已经创建了一些光照属性来影响每个单独的光照分量。我们希望为光照属性创建一个与材质结构体类似的结构体： 123456789struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;uniform Light light; 一个光源对它的ambient、diffuse和specular光照有着不同的强度。环境光照通常会设置为一个比较低的强度，因为我们不希望环境光颜色太过显眼。光源的漫反射分量通常设置为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为vec3(1.0)，以最大强度发光。注意我们也将光源的位置添加到了结构体中。 和材质uniform一样，我们需要更新片段着色器： 123vec3 ambient = light.ambient * material.ambient;vec3 diffuse = light.diffuse * (diff * material.diffuse);vec3 specular = light.specular * (spec * material.specular); 我们接下来在程序中设置光照强度： 123lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f);lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); // 将光照调暗了一些以搭配场景lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); 现在我们调整了光照对物体材质的影响，我们应该能得到一个更类似于上一节的视觉效果。但这次我们有了对光照和物体材质的完全掌控：改变物体的视觉效果现在变得相对容易了。 不同的光源颜色12345678910glm::vec3 lightColor;lightColor.x = sin(glfwGetTime() * 2.0f);lightColor.y = sin(glfwGetTime() * 0.7f);lightColor.z = sin(glfwGetTime() * 1.3f);glm::vec3 diffuseColor = lightColor * glm::vec3(0.5f); // 降低影响glm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f); // 很低的影响lightingShader.setVec3(\"light.ambient\", ambientColor);lightingShader.setVec3(\"light.diffuse\", diffuseColor); 源码1.colors.vs 123456789101112131415161718#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out vec3 FragPos;out vec3 Normal;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.colors.fs 123456789101112131415161718192021222324252627282930313233343536373839404142434445#version 330 coreout vec4 FragColor;in vec3 Normal; in vec3 FragPos; struct Material &#123; vec3 ambient; vec3 diffuse; vec3 specular; float shininess;&#125;; struct Light &#123; vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;&#125;;uniform Material material;uniform Light light;uniform vec3 viewPos; void main()&#123; // ambient vec3 ambient = light.ambient * material.ambient; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(light.position - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = light.diffuse * (diff * material.diffuse); // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = light.specular * (spec * material.specular); vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);&#125; 1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; colors.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 0.5f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.colors.vs\", \"1.colors.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // normal attribute glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // change the light's position values over time (can be done anywhere in the render loop actually, but try to do it at least before using the light source positions) lightPos.x = 1.0f + sin((float)glfwGetTime()) * 2.0f; lightPos.y = sin((float)glfwGetTime() / 2.0f) * 1.0f; // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); lightingShader.setVec3(\"light.position\", lightPos); lightingShader.setVec3(\"viewPos\", camera.Position); // light properties glm::vec3 lightColor; lightColor.x = sin(glfwGetTime() * 2.0f); lightColor.y = sin(glfwGetTime() * 0.7f); lightColor.z = sin(glfwGetTime() * 1.3f); glm::vec3 diffuseColor = lightColor * glm::vec3(0.5f); // decrease the influence glm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f); // low influence lightingShader.setVec3(\"light.ambient\", ambientColor); lightingShader.setVec3(\"light.diffuse\", diffuseColor); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); lightingShader.setVec3(\"material.ambient\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"material.diffuse\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"material.specular\", 0.5f, 0.5f, 0.5f); lightingShader.setFloat(\"material.shininess\", 32.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // render the cube glBindVertexArray(cubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"35、OpenGL 之基础光照","slug":"OpenGL/35、OpenGL 之基础光照","date":"2020-06-07T06:00:00.000Z","updated":"2020-08-07T14:20:18.657Z","comments":true,"path":"2020/06/07/OpenGL/35、OpenGL 之基础光照/","link":"","permalink":"https://www.zackaddy.xin/2020/06/07/OpenGL/35、OpenGL 之基础光照/","excerpt":"","text":"OpenGL 之基础光照简介现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。 有一个模型被称为冯氏光照模型(Phong Lighting Model) 冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照。 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。 环境光照把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色： 12345678void main()&#123; float ambientStrength = 0.1; vec3 ambient = ambientStrength * lightColor; vec3 result = ambient * objectColor; FragColor = vec4(result, 1.0);&#125; 漫反射光照漫反射光照对物体产生显著的视觉影响。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。 灯光位置向量 - 立方体位置向量 = 上图黑线向量 上图黑线向量点乘黄色法线向量结果值再乘以光的颜色，得到漫反射分量。 有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色就可以看到漫反射光照 法向量：一个垂直于顶点表面的向量（我们先让它垂直立方体所有顶点）。 上图黑线向量与法向量两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于θ，θ越大，光对片段颜色的影响就应该越小。 镜面光照 我们把另一个uniform添加到片段着色器，把相应的摄像机位置坐标传给片段着色器： 1uniform vec3 viewPos; 1lightingShader.setVec3(\"viewPos\", camera.Position); 现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个镜面强度(Specular Intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。 1float specularStrength = 0.5; 下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量： 12vec3 viewDir = normalize(viewPos - FragPos);vec3 reflectDir = reflect(-lightDir, norm); 剩下要做的是计算镜面分量。下面的代码完成了这件事： 12float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);vec3 specular = specularStrength * spec * lightColor; 我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的32次幂。这个32是高光的反光度(Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响： 剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色： 12vec3 result = (ambient + diffuse + specular) * objectColor;FragColor = vec4(result, 1.0); 源码1.colors.vs 123456789101112131415161718#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out vec3 FragPos;out vec3 Normal;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; FragPos = vec3(model * vec4(aPos, 1.0)); Normal = mat3(transpose(inverse(model))) * aNormal; gl_Position = projection * view * vec4(FragPos, 1.0);&#125; 1.colors.fs 123456789101112131415161718192021222324252627282930313233#version 330 coreout vec4 FragColor;in vec3 Normal; in vec3 FragPos; uniform vec3 lightPos; uniform vec3 viewPos; uniform vec3 lightColor;uniform vec3 objectColor;void main()&#123; // ambient float ambientStrength = 0.1; vec3 ambient = ambientStrength * lightColor; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = diff * lightColor; // specular float specularStrength = 0.5; vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), 256); vec3 specular = specularStrength * spec * lightColor; vec3 result = (ambient + diffuse + specular) * objectColor; FragColor = vec4(result, 1.0);&#125; 1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; colors.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 0.5f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.colors.vs\", \"1.colors.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, 0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, 0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 1.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, -1.0f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, -1.0f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, -1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, -1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, -1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.0f &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // normal attribute glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); // note that we update the lamp's position attribute's stride to reflect the updated buffer data glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); lightingShader.setVec3(\"objectColor\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"lightColor\", 1.0f, 1.0f, 1.0f); lightingShader.setVec3(\"lightPos\", lightPos); lightingShader.setVec3(\"viewPos\", camera.Position); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // render the cube glBindVertexArray(cubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125; 让灯光围着箱子旋转123456789101112131415161718192021222324252627282930int main()&#123; [...] // render loop while(!glfwWindowShouldClose(window)) &#123; // per-frame time logic float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input processInput(window); // clear the colorbuffer glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // change the light's position values over time (can be done anywhere in the render loop actually, but try to do it at least before using the light source positions) lightPos.x = 1.0f + sin(glfwGetTime()) * 2.0f; lightPos.y = sin(glfwGetTime() / 2.0f) * 1.0f; // set uniforms, draw objects [...] // glfw: swap buffers and poll IO events glfwSwapBuffers(window); glfwPollEvents(); &#125;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"34、OpenGL 之创建一个光照场景","slug":"OpenGL/34、OpenGL 之创建一个光照场景","date":"2020-06-07T05:00:00.000Z","updated":"2020-08-07T14:20:18.648Z","comments":true,"path":"2020/06/07/OpenGL/34、OpenGL 之创建一个光照场景/","link":"","permalink":"https://www.zackaddy.xin/2020/06/07/OpenGL/34、OpenGL 之创建一个光照场景/","excerpt":"","text":"OpenGL 之创建一个光照场景在接下来的教程中，我们将会广泛地使用颜色来模拟现实世界中的光照效果，创造出一些有趣的视觉效果。由于我们现在将会使用光源了，我们希望将它们显示为可见的物体，并在场景中至少加入一个物体来测试模拟光照的效果。 首先我们需要一个物体来作为被投光(Cast the light)的对象，我们将使用前面教程中的那个著名的立方体箱子。我们还需要一个物体来代表光源在3D场景中的位置。 简单起见，我们依然使用一个立方体来代表光源。 源码1.colors.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.colors.fs 12345678910#version 330 coreout vec4 FragColor; uniform vec3 objectColor;uniform vec3 lightColor;void main()&#123; FragColor = vec4(lightColor * objectColor, 1.0);&#125; 1.light_cube.vs 1234567891011#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; gl_Position = projection * view * model * vec4(aPos, 1.0);&#125; 1.light_cube.fs 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0); // set alle 4 vector values to 1.0&#125; colors.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include \"camera.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));float lastX = SCR_WIDTH / 2.0f;float lastY = SCR_HEIGHT / 2.0f;bool firstMouse = true;// timingfloat deltaTime = 0.0f;float lastFrame = 0.0f;// lightingglm::vec3 lightPos(1.2f, 1.0f, 2.0f);int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader lightingShader(\"1.colors.vs\", \"1.colors.fs\"); Shader lightCubeShader(\"1.light_cube.vs\", \"1.light_cube.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, &#125;; // first, configure the cube's VAO (and VBO) unsigned int VBO, cubeVAO; glGenVertexArrays(1, &amp;cubeVAO); glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindVertexArray(cubeVAO); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // second, configure the light's VAO (VBO stays the same; the vertices are the same for the light object which is also a 3D cube) unsigned int lightCubeVAO; glGenVertexArrays(1, &amp;lightCubeVAO); glBindVertexArray(lightCubeVAO); // we only need to bind to the VBO (to link it with glVertexAttribPointer), no need to fill it; the VBO's data already contains all we need (it's already bound, but we do it again for educational purposes) glBindBuffer(GL_ARRAY_BUFFER, VBO); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // be sure to activate shader when setting uniforms/drawing objects lightingShader.use(); lightingShader.setVec3(\"objectColor\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"lightColor\", 1.0f, 1.0f, 1.0f); // view/projection transformations glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); glm::mat4 view = camera.GetViewMatrix(); lightingShader.setMat4(\"projection\", projection); lightingShader.setMat4(\"view\", view); // world transformation glm::mat4 model = glm::mat4(1.0f); lightingShader.setMat4(\"model\", model); // render the cube glBindVertexArray(cubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // also draw the lamp object lightCubeShader.use(); lightCubeShader.setMat4(\"projection\", projection); lightCubeShader.setMat4(\"view\", view); model = glm::mat4(1.0f); model = glm::translate(model, lightPos); model = glm::scale(model, glm::vec3(0.2f)); // a smaller cube lightCubeShader.setMat4(\"model\", model); glBindVertexArray(lightCubeVAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;cubeVAO); glDeleteVertexArrays(1, &amp;lightCubeVAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) camera.ProcessKeyboard(FORWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) camera.ProcessKeyboard(BACKWARD, deltaTime); if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) camera.ProcessKeyboard(LEFT, deltaTime); if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) camera.ProcessKeyboard(RIGHT, deltaTime);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; camera.ProcessMouseMovement(xoffset, yoffset);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; camera.ProcessMouseScroll(yoffset);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"80、LinearAlgebra 之奇异值的SVD分解","slug":"LinearAlgebra/80、LinearAlgebra 之奇异值的SVD分解","date":"2020-06-06T06:00:00.000Z","updated":"2020-08-07T14:10:11.840Z","comments":true,"path":"2020/06/06/LinearAlgebra/80、LinearAlgebra 之奇异值的SVD分解/","link":"","permalink":"https://www.zackaddy.xin/2020/06/06/LinearAlgebra/80、LinearAlgebra 之奇异值的SVD分解/","excerpt":"","text":"LinearAlgebra 之奇异值的SVD分解简介这是矩阵最重要的分解形式。SVD分解的全称为“Singular Value Decomposition”，即通过矩阵的奇异值进行分解。SVD分解的优势在于，该方法对矩阵没有任何限制，对于任意形状的矩阵都适用。 上图中奇异值从大到小排序，则V和U也需要按奇异值从大到小的顺序 应用SVD分解使用很广泛，几乎在使用线性代数的地方都脱离不开SVD分解。举例说明， 123456所以SVD可以对原始数据进行压缩、降维、去噪(奇异值很小的数据可以视为噪音)。上式表示将A这个m×n的数据，看做是一个r维的数据，其中(r&lt;=min(m,n))。SVD在图像领域的应用很广泛，利用SVD分解，减少了一定的数据量但是依旧可以很好的表达图像的语义。 定义伪逆 推荐系统 自然语言处理 搜索引擎","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"33、OpenGL 之创建摄像机类","slug":"OpenGL/33、OpenGL 之创建摄像机类","date":"2020-06-06T06:00:00.000Z","updated":"2020-08-07T14:20:18.643Z","comments":true,"path":"2020/06/06/OpenGL/33、OpenGL 之创建摄像机类/","link":"","permalink":"https://www.zackaddy.xin/2020/06/06/OpenGL/33、OpenGL 之创建摄像机类/","excerpt":"","text":"OpenGL 之创建摄像机类camera.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#ifndef CAMERA_H#define CAMERA_H#include &lt;glad/glad.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;vector&gt;// Defines several possible options for camera movement. Used as abstraction to stay away from window-system specific input methodsenum Camera_Movement &#123; FORWARD, BACKWARD, LEFT, RIGHT&#125;;// Default camera valuesconst float YAW = -90.0f;const float PITCH = 0.0f;const float SPEED = 2.5f;const float SENSITIVITY = 0.1f;const float ZOOM = 45.0f;// An abstract camera class that processes input and calculates the corresponding Euler Angles, Vectors and Matrices for use in OpenGLclass Camera&#123;public: // camera Attributes glm::vec3 Position; glm::vec3 Front; glm::vec3 Up; glm::vec3 Right; glm::vec3 WorldUp; // euler Angles float Yaw; float Pitch; // camera options float MovementSpeed; float MouseSensitivity; float Zoom; // constructor with vectors Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM) &#123; Position = position; WorldUp = up; Yaw = yaw; Pitch = pitch; updateCameraVectors(); &#125; // constructor with scalar values Camera(float posX, float posY, float posZ, float upX, float upY, float upZ, float yaw, float pitch) : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM) &#123; Position = glm::vec3(posX, posY, posZ); WorldUp = glm::vec3(upX, upY, upZ); Yaw = yaw; Pitch = pitch; updateCameraVectors(); &#125; // returns the view matrix calculated using Euler Angles and the LookAt Matrix glm::mat4 GetViewMatrix() &#123; return glm::lookAt(Position, Position + Front, Up); &#125; // processes input received from any keyboard-like input system. Accepts input parameter in the form of camera defined ENUM (to abstract it from windowing systems) void ProcessKeyboard(Camera_Movement direction, float deltaTime) &#123; float velocity = MovementSpeed * deltaTime; if (direction == FORWARD) Position += Front * velocity; if (direction == BACKWARD) Position -= Front * velocity; if (direction == LEFT) Position -= Right * velocity; if (direction == RIGHT) Position += Right * velocity; &#125; // processes input received from a mouse input system. Expects the offset value in both the x and y direction. void ProcessMouseMovement(float xoffset, float yoffset, GLboolean constrainPitch = true) &#123; xoffset *= MouseSensitivity; yoffset *= MouseSensitivity; Yaw += xoffset; Pitch += yoffset; // make sure that when pitch is out of bounds, screen doesn't get flipped if (constrainPitch) &#123; if (Pitch &gt; 89.0f) Pitch = 89.0f; if (Pitch &lt; -89.0f) Pitch = -89.0f; &#125; // update Front, Right and Up Vectors using the updated Euler angles updateCameraVectors(); &#125; // processes input received from a mouse scroll-wheel event. Only requires input on the vertical wheel-axis void ProcessMouseScroll(float yoffset) &#123; Zoom -= (float)yoffset; if (Zoom &lt; 1.0f) Zoom = 1.0f; if (Zoom &gt; 45.0f) Zoom = 45.0f; &#125;private: // calculates the front vector from the Camera's (updated) Euler Angles void updateCameraVectors() &#123; // calculate the new Front vector glm::vec3 front; front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch)); front.y = sin(glm::radians(Pitch)); front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch)); Front = glm::normalize(front); // also re-calculate the Right and Up vector Right = glm::normalize(glm::cross(Front, WorldUp)); // normalize the vectors, because their length gets closer to 0 the more you look up or down which results in slower movement. Up = glm::normalize(glm::cross(Right, Front)); &#125;&#125;;#endif","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"79、LinearAlgebra 之奇异值","slug":"LinearAlgebra/79、LinearAlgebra 之奇异值","date":"2020-06-06T05:00:00.000Z","updated":"2020-08-07T14:10:11.840Z","comments":true,"path":"2020/06/06/LinearAlgebra/79、LinearAlgebra 之奇异值/","link":"","permalink":"https://www.zackaddy.xin/2020/06/06/LinearAlgebra/79、LinearAlgebra 之奇异值/","excerpt":"","text":"LinearAlgebra 之奇异值","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"32、OpenGL 之视角移动（涉及欧拉角跳过）","slug":"OpenGL/32、OpenGL 之视角移动（涉及欧拉角跳过）","date":"2020-06-06T05:00:00.000Z","updated":"2020-08-07T14:20:18.638Z","comments":true,"path":"2020/06/06/OpenGL/32、OpenGL 之视角移动（涉及欧拉角跳过）/","link":"","permalink":"https://www.zackaddy.xin/2020/06/06/OpenGL/32、OpenGL 之视角移动（涉及欧拉角跳过）/","excerpt":"","text":"OpenGL 之视角移动（涉及欧拉角跳过）只用键盘移动不能转向，移动很受限制。是时候加入鼠标了！ 为了能够改变视角，我们需要根据鼠标的输入改变cameraFront向量。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void mouse_callback(GLFWwindow* window, double xpos, double ypos);void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraglm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);bool firstMouse = true;float yaw = -90.0f; // yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right so we initially rotate a bit to the left.float pitch = 0.0f;float lastX = 800.0f / 2.0;float lastY = 600.0 / 2.0;float fov = 45.0f;// timingfloat deltaTime = 0.0f; // time between current frame and last framefloat lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); glfwSetCursorPosCallback(window, mouse_callback); glfwSetScrollCallback(window, scroll_callback); // tell GLFW to capture our mouse glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"4.2.texture.vs\", \"4.2.texture.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; // world space positions of our cubes glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; unsigned int VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // texture coord attribute glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // load and create a texture // ------------------------- unsigned int texture1, texture2; // texture 1 // --------- glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char *data = stbi_load(\"container.jpg\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // texture 2 // --------- glGenTextures(1, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture2); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps data = stbi_load(\"awesomeface.png\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); ourShader.setInt(\"texture1\", 0); ourShader.setInt(\"texture2\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now! // bind textures on corresponding texture units glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); // activate shader ourShader.use(); // pass projection matrix to shader (note that in this case it could change every frame) glm::mat4 projection = glm::perspective(glm::radians(fov), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); ourShader.setMat4(\"projection\", projection); // camera/view transformation glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp); ourShader.setMat4(\"view\", view); // render boxes glBindVertexArray(VAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); float cameraSpeed = 2.5 * deltaTime; if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;// glfw: whenever the mouse moves, this callback is called// -------------------------------------------------------void mouse_callback(GLFWwindow* window, double xpos, double ypos)&#123; if (firstMouse) &#123; lastX = xpos; lastY = ypos; firstMouse = false; &#125; float xoffset = xpos - lastX; float yoffset = lastY - ypos; // reversed since y-coordinates go from bottom to top lastX = xpos; lastY = ypos; float sensitivity = 0.1f; // change this value to your liking xoffset *= sensitivity; yoffset *= sensitivity; yaw += xoffset; pitch += yoffset; // make sure that when pitch is out of bounds, screen doesn't get flipped if (pitch &gt; 89.0f) pitch = 89.0f; if (pitch &lt; -89.0f) pitch = -89.0f; glm::vec3 front; front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch)); front.y = sin(glm::radians(pitch)); front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch)); cameraFront = glm::normalize(front);&#125;// glfw: whenever the mouse scroll wheel scrolls, this callback is called// ----------------------------------------------------------------------void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)&#123; fov -= (float)yoffset; if (fov &lt; 1.0f) fov = 1.0f; if (fov &gt; 45.0f) fov = 45.0f;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"78、LinearAlgebra 之正交对角化","slug":"LinearAlgebra/78、LinearAlgebra 之正交对角化","date":"2020-06-05T06:00:00.000Z","updated":"2020-08-07T14:10:11.840Z","comments":true,"path":"2020/06/05/LinearAlgebra/78、LinearAlgebra 之正交对角化/","link":"","permalink":"https://www.zackaddy.xin/2020/06/05/LinearAlgebra/78、LinearAlgebra 之正交对角化/","excerpt":"","text":"LinearAlgebra 之正交对角化对称矩阵一定可以被正交对角化 正交对角化是对称矩阵另一个良好的性质，对称矩阵的所有的不同的特征值对应的特征向量相互垂直。 上图中A为对称矩阵","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"31、OpenGL 之自由移动与移动速度","slug":"OpenGL/31、OpenGL 之自由移动与移动速度","date":"2020-06-05T06:00:00.000Z","updated":"2020-08-07T14:20:18.633Z","comments":true,"path":"2020/06/05/OpenGL/31、OpenGL 之自由移动与移动速度/","link":"","permalink":"https://www.zackaddy.xin/2020/06/05/OpenGL/31、OpenGL 之自由移动与移动速度/","excerpt":"","text":"OpenGL 之自由移动与移动速度自由移动让摄像机绕着场景转的确很有趣，但是让我们自己移动摄像机会更有趣！首先我们必须设置一个摄像机系统，所以在我们的程序前面定义一些摄像机变量很有用： 123glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); LookAt函数现在成了： 1view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp); 我们首先将摄像机位置设置为之前定义的cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新cameraPos向量。 我们已经为GLFW的键盘输入定义过一个processInput函数了，我们来新添加几个需要检查的按键命令： 12345678910111213void processInput(GLFWwindow *window)&#123; ... float cameraSpeed = 0.05f; // adjust accordingly if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;&#125; 当我们按下WASD键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个右向量(Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的横移(Strafe)效果。 注意，我们对右向量进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据cameraFront变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。 移动速度图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。 我们跟踪两个全局变量来计算出deltaTime值： 12float deltaTime = 0.0f; // 当前帧与上一帧的时间差float lastFrame = 0.0f; // 上一帧的时间 在每一帧中我们计算出新的deltaTime以备后用。 123float currentFrame = glfwGetTime();deltaTime = currentFrame - lastFrame;lastFrame = currentFrame; 现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了： 12345void processInput(GLFWwindow *window)&#123; float cameraSpeed = 2.5f * deltaTime; ...&#125; 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;// cameraglm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);// timingfloat deltaTime = 0.0f; // time between current frame and last framefloat lastFrame = 0.0f;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"4.2.texture.vs\", \"4.2.texture.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; // world space positions of our cubes glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; unsigned int VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // texture coord attribute glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // load and create a texture // ------------------------- unsigned int texture1, texture2; // texture 1 // --------- glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char *data = stbi_load(\"container.jpg\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // texture 2 // --------- glGenTextures(1, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture2); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps data = stbi_load(\"awesomeface.png\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); ourShader.setInt(\"texture1\", 0); ourShader.setInt(\"texture2\", 1); // pass projection matrix to shader (as projection matrix rarely changes there's no need to do this per frame) // ----------------------------------------------------------------------------------------------------------- glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); ourShader.setMat4(\"projection\", projection); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // per-frame time logic // -------------------- float currentFrame = glfwGetTime(); deltaTime = currentFrame - lastFrame; lastFrame = currentFrame; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now! // bind textures on corresponding texture units glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); // activate shader ourShader.use(); // camera/view transformation glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp); ourShader.setMat4(\"view\", view); // render boxes glBindVertexArray(VAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); float cameraSpeed = 2.5 * deltaTime; if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"77、LinearAlgebra 之完美的对称矩阵","slug":"LinearAlgebra/77、LinearAlgebra 之完美的对称矩阵","date":"2020-06-05T05:00:00.000Z","updated":"2020-08-07T14:10:11.839Z","comments":true,"path":"2020/06/05/LinearAlgebra/77、LinearAlgebra 之完美的对称矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/06/05/LinearAlgebra/77、LinearAlgebra 之完美的对称矩阵/","excerpt":"","text":"LinearAlgebra 之完美的对称矩阵借助对称矩阵可以处理任何矩阵，将任何矩阵都分解成希望的形式。 123对称矩阵中所有元素沿主对角线对称，主对角线元素不要求实相同的。用数学语言表述为A=A^&#123;T&#125; 对称矩阵的特征值一定是实数 对称矩阵出现多重特征值时，其几何重数一定等于代数重数。也就意味着对称矩阵一定有n个线性无关的特征向量。 对称矩阵一定可以被对角化。这实际上与上一条性质等价。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"30、OpenGL 之Look At矩阵","slug":"OpenGL/30、OpenGL 之Look At矩阵","date":"2020-06-05T05:00:00.000Z","updated":"2020-08-07T14:20:18.628Z","comments":true,"path":"2020/06/05/OpenGL/30、OpenGL 之Look At矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/06/05/OpenGL/30、OpenGL 之Look At矩阵/","excerpt":"","text":"OpenGL 之Look At矩阵 如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵 你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间 1234567891011LookAt = \\begin&#123;pmatrix&#125; R_x &amp; R_y &amp; R_z &amp; 0 \\\\ U_x &amp; U_y &amp; U_z &amp; 0 \\\\ D_x &amp; D_y &amp; D_z &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; * \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; -P_x \\\\ 0 &amp; 1 &amp; 0 &amp; -P_y \\\\ 0 &amp; 0 &amp; 1 &amp; -P_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; 其中R是右向量，U是上向量，D是方向向量P是摄像机位置向量。 GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵： glm::LookAt函数需要一个位置、目标和上向量。 1234glm::mat4 view;view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); 在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。 我们需要用到一点三角学的知识来在每一帧创建一个x和z坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算x和y坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径radius，在每次渲染迭代中使用GLFW的glfwGetTime函数重新创建观察矩阵，来扩大这个圆。 12345float radius = 10.0f;float camX = sin(glfwGetTime()) * radius;float camZ = cos(glfwGetTime()) * radius;glm::mat4 view;view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0)); 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include &lt;iostream&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"4.2.texture.vs\", \"4.2.texture.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; // world space positions of our cubes glm::vec3 cubePositions[] = &#123; glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3(2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3(1.3f, -2.0f, -2.5f), glm::vec3(1.5f, 2.0f, -2.5f), glm::vec3(1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) &#125;; unsigned int VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // texture coord attribute glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // load and create a texture // ------------------------- unsigned int texture1, texture2; // texture 1 // --------- glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char *data = stbi_load(\"container.jpg\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // texture 2 // --------- glGenTextures(1, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture2); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps data = stbi_load(\"awesomeface.png\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); ourShader.setInt(\"texture1\", 0); ourShader.setInt(\"texture2\", 1); // pass projection matrix to shader (as projection matrix rarely changes there's no need to do this per frame) // ----------------------------------------------------------------------------------------------------------- glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); ourShader.setMat4(\"projection\", projection); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now! // bind textures on corresponding texture units glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); // activate shader ourShader.use(); // camera/view transformation glm::mat4 view = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first float radius = 10.0f; float camX = sin(glfwGetTime()) * radius; float camZ = cos(glfwGetTime()) * radius; view = glm::lookAt(glm::vec3(camX, 0.0f, camZ), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); ourShader.setMat4(\"view\", view); // render boxes glBindVertexArray(VAO); for (unsigned int i = 0; i &lt; 10; i++) &#123; // calculate the model matrix for each object and pass it to shader before drawing glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4(\"model\", model); glDrawArrays(GL_TRIANGLES, 0, 36); &#125; // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"76、LinearAlgebra 之矩阵对角化","slug":"LinearAlgebra/76、LinearAlgebra 之矩阵对角化","date":"2020-06-04T06:00:00.000Z","updated":"2020-08-07T14:10:11.839Z","comments":true,"path":"2020/06/04/LinearAlgebra/76、LinearAlgebra 之矩阵对角化/","link":"","permalink":"https://www.zackaddy.xin/2020/06/04/LinearAlgebra/76、LinearAlgebra 之矩阵对角化/","excerpt":"","text":"LinearAlgebra 之矩阵对角化 对于一个对角矩阵而言，其幂运算结果也是一个对角矩阵，且这个结论能够推广到n次幂上这使得计算不需要进行矩阵转换，计算消耗减少很多。 特征值反映的是系统各个部分分量在不同时刻空间的变换速率。而且对角化后的运算都会简便很多，日常采集的大部分数据也都是能够被对角化的。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"29、OpenGL 之摄像机与观察空间","slug":"OpenGL/29、OpenGL 之摄像机与观察空间","date":"2020-06-04T06:00:00.000Z","updated":"2020-08-07T14:20:18.623Z","comments":true,"path":"2020/06/04/OpenGL/29、OpenGL 之摄像机与观察空间/","link":"","permalink":"https://www.zackaddy.xin/2020/06/04/OpenGL/29、OpenGL 之摄像机与观察空间/","excerpt":"","text":"OpenGL 之摄像机与观察空间OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。 我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标： 观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。 要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。 摄像机位置获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。 1glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); 摄像机方向 我们需要一个向量是摄像机的方向，这里指的是摄像机指向哪个方向。 现在我们让摄像机指向场景原点：(0, 0, 0)。 用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。 摄像机指向自身z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机自身z轴正方向。 如果我们交换相减的顺序，我们就会获得一个指向摄像机自身正z轴方向的向量：12glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget); 方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。 右轴 我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。 为获取右向量我们需要先定义一个上向量(Up Vector)。 把上向量和第二步得到的方向向量进行叉乘。 两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量 如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量12glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection)); 上轴 已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了： 我们把右向量和方向向量进行叉乘：1glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight); ==使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。==","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"75、LinearAlgebra 之矩阵相似和背后的重要含义","slug":"LinearAlgebra/75、LinearAlgebra 之矩阵相似和背后的重要含义","date":"2020-06-04T05:00:00.000Z","updated":"2020-08-07T14:10:11.838Z","comments":true,"path":"2020/06/04/LinearAlgebra/75、LinearAlgebra 之矩阵相似和背后的重要含义/","link":"","permalink":"https://www.zackaddy.xin/2020/06/04/LinearAlgebra/75、LinearAlgebra 之矩阵相似和背后的重要含义/","excerpt":"","text":"LinearAlgebra 之矩阵相似和背后的重要含义这一节是在为之后理解特征值和特征向量的具体用途进行铺垫。同时也是理解特征值和特征向量中“特征”一词在矩阵中具体的指代。 A和B本质是一个变换，只是观察的坐标系不同！ A和B的特征方程相同！特征值相同！ 1234A=P^&#123;-1&#125;BP在最后，说明第一步的转换将P坐标系转换为标准坐标系，否则P这一步没有几何意义，之后的B转换是在标准坐标系中发生的。B=PAP^&#123;-1&#125;在最后，说明第一步转换是在P坐标系中进行的，否则P^&#123;-1&#125;转换没有几何意义，之后的A转换是在P坐标系中发生的。 A和B是相似矩阵，则两个矩阵具有相同的特征方程，相应的它们的特征值是相同的。这也就是特征值的本意，无论是在哪个坐标系下观察，A和B在不同的坐标系中的值并不相同，但是其特征方程和特征值是不变的。对上面的结论进行证明 特征方程和特征值相同表达的是当把矩阵看做是变换时，这个变换无论从哪个坐标系看，这些变换都有相同的特征，这些特征通过特征值表征出来。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"28、OpenGL 之坐标系统实例","slug":"OpenGL/28、OpenGL 之坐标系统实例","date":"2020-06-04T05:00:00.000Z","updated":"2020-08-07T14:20:18.618Z","comments":true,"path":"2020/06/04/OpenGL/28、OpenGL 之坐标系统实例/","link":"","permalink":"https://www.zackaddy.xin/2020/06/04/OpenGL/28、OpenGL 之坐标系统实例/","excerpt":"","text":"OpenGL 之坐标系统实例在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。让我们变换一下我们的平面，将其绕着x轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的： 12glm::mat4 model;model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f)); 通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。 接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子： 将摄像机向后移动，和将整个场景向前移动是一样的。 这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且OpenGL是一个右手坐标系(Right-handed System)，所以我们需要沿着z轴的正方向移动。我们会通过将场景沿着z轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。 右手坐标系右手坐标系(Right-handed System) 按照惯例，OpenGL是一个右手坐标系。简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下： 为了理解为什么被称为右手坐标系，按如下的步骤做： 沿着正y轴方向伸出你的右臂，手指着上方。 大拇指指向右方。 食指指向上方。 中指向下弯曲90度。 如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。如果你用左臂来做这些动作，你会发现z轴的方向是相反的。这个叫做左手坐标系，它被DirectX广泛地使用。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。 就目前来说，观察矩阵是这样的： 123glm::mat4 view;// 注意，我们将矩阵向我们要进行移动场景的反方向移动。view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); 最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵： 12glm::mat4 projection;projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f); 既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标： 12345678910111213#version 330 corelayout (location = 0) in vec3 aPos;...uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main()&#123; // 注意乘法要从右向左读 gl_Position = projection * view * model * vec4(aPos, 1.0); ...&#125; 我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）： 123int modelLoc = glGetUniformLocation(ourShader.ID, \"model\"));glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));... // 观察矩阵和投影矩阵与之类似 我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会： 稍微向后倾斜至地板方向。 离我们有一些距离。 有透视效果（顶点越远，变得越小）。 让我们检查一下结果是否满足这些要求： 它看起来就像是一个3D的平面，静止在一个虚构的地板上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;stb_image.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;learnopengl/shader_m.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"6.1.coordinate_systems.vs\", \"6.1.coordinate_systems.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // texture coords 0.5f, 0.5f, 0.0f, 1.0f, 1.0f, // top right 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f, 0.0f, 1.0f // top left &#125;; unsigned int indices[] = &#123; 0, 1, 3, // first triangle 1, 2, 3 // second triangle &#125;; unsigned int VBO, VAO, EBO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // texture coord attribute glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // load and create a texture // ------------------------- unsigned int texture1, texture2; // texture 1 // --------- glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char *data = stbi_load(FileSystem::getPath(\"resources/textures/container.jpg\").c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // texture 2 // --------- glGenTextures(1, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture2); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps data = stbi_load(FileSystem::getPath(\"resources/textures/awesomeface.png\").c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); ourShader.setInt(\"texture1\", 0); ourShader.setInt(\"texture2\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // bind textures on corresponding texture units glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); // activate shader ourShader.use(); // create transformations glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first glm::mat4 view = glm::mat4(1.0f); glm::mat4 projection = glm::mat4(1.0f); model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f)); view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); // retrieve the matrix uniform locations unsigned int modelLoc = glGetUniformLocation(ourShader.ID, \"model\"); unsigned int viewLoc = glGetUniformLocation(ourShader.ID, \"view\"); // pass them to the shaders (3 different ways) glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model)); glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &amp;view[0][0]); // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it's often best practice to set it outside the main loop only once. ourShader.setMat4(\"projection\", projection); // render container glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteBuffers(1, &amp;EBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125; 为了有趣一点，我们将让立方体随着时间旋转： 1model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f)); 然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点。 1glDrawArrays(GL_TRIANGLES, 0, 36); OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。 OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。 然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。我们可以通过glEnable函数来开启深度测试。glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启GL_DEPTH_TEST： 1glEnable(GL_DEPTH_TEST); 因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;stb_image.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;learnopengl/shader_m.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // configure global opengl state // ----------------------------- glEnable(GL_DEPTH_TEST); // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"6.2.coordinate_systems.vs\", \"6.2.coordinate_systems.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f &#125;; unsigned int VBO, VAO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // texture coord attribute glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // load and create a texture // ------------------------- unsigned int texture1, texture2; // texture 1 // --------- glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. unsigned char *data = stbi_load(FileSystem::getPath(\"resources/textures/container.jpg\").c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // texture 2 // --------- glGenTextures(1, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture2); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps data = stbi_load(FileSystem::getPath(\"resources/textures/awesomeface.png\").c_str(), &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; // note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); ourShader.setInt(\"texture1\", 0); ourShader.setInt(\"texture2\", 1); // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // also clear the depth buffer now! // bind textures on corresponding texture units glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); // activate shader ourShader.use(); // create transformations glm::mat4 model = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix first glm::mat4 view = glm::mat4(1.0f); glm::mat4 projection = glm::mat4(1.0f); model = glm::rotate(model, (float)glfwGetTime(), glm::vec3(0.5f, 1.0f, 0.0f)); view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); projection = glm::perspective(glm::radians(45.0f), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f); // retrieve the matrix uniform locations unsigned int modelLoc = glGetUniformLocation(ourShader.ID, \"model\"); unsigned int viewLoc = glGetUniformLocation(ourShader.ID, \"view\"); // pass them to the shaders (3 different ways) glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model)); glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &amp;view[0][0]); // note: currently we set the projection matrix each frame, but since the projection matrix rarely changes it's often best practice to set it outside the main loop only once. ourShader.setMat4(\"projection\", projection); // render box glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 36); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"74、LinearAlgebra 之直观理解特征值与特征向量","slug":"LinearAlgebra/74、LinearAlgebra 之直观理解特征值与特征向量","date":"2020-06-03T06:00:00.000Z","updated":"2020-08-07T14:10:11.838Z","comments":true,"path":"2020/06/03/LinearAlgebra/74、LinearAlgebra 之直观理解特征值与特征向量/","link":"","permalink":"https://www.zackaddy.xin/2020/06/03/LinearAlgebra/74、LinearAlgebra 之直观理解特征值与特征向量/","excerpt":"","text":"LinearAlgebra 之直观理解特征值与特征向量","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"27、OpenGL 之裁剪空间","slug":"OpenGL/27、OpenGL 之裁剪空间","date":"2020-06-03T06:00:00.000Z","updated":"2020-08-07T14:20:18.614Z","comments":true,"path":"2020/06/03/OpenGL/27、OpenGL 之裁剪空间/","link":"","permalink":"https://www.zackaddy.xin/2020/06/03/OpenGL/27、OpenGL 之裁剪空间/","excerpt":"","text":"OpenGL 之裁剪空间在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。 投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。 所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。 在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。 ==如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。== 由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum) 每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。 将特定范围内的坐标转化到标准化设备坐标系的过程被称之为投影(Projection) 使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。 一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量； 透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。 在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。 将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。 正射投影正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器： 上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。 要创建一个正射投影矩阵，我们可以使用GLM的内置函数glm::ortho： 1glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f); 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。 正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。 透视投影如果你曾经体验过实际生活给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视(Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样： 正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上： 12345out = \\begin&#123;pmatrix&#125; x / w \\\\ y / w \\\\ z / w\\end&#123;pmatrix&#125; 顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。 在GLM中可以这样创建一个透视投影矩阵： 1glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); 同样，glm::perspective所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片： 它的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。 当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。 当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比： 你可以看到，使用透视投影的话，远处的顶点看起来比较小，而在正射投影中每个顶点距离观察者的距离都是一样的。 我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标： 1V_&#123;clip&#125; = M_&#123;projection&#125; \\cdot M_&#123;view&#125; \\cdot V_&#123;model&#125; \\cdot V_&#123;local&#125; 注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。 然后呢？ 顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为视口变换。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"73、LinearAlgebra 之特征值与特征向量的性质","slug":"LinearAlgebra/73、LinearAlgebra 之特征值与特征向量的性质","date":"2020-06-03T05:00:00.000Z","updated":"2020-08-07T14:10:11.838Z","comments":true,"path":"2020/06/03/LinearAlgebra/73、LinearAlgebra 之特征值与特征向量的性质/","link":"","permalink":"https://www.zackaddy.xin/2020/06/03/LinearAlgebra/73、LinearAlgebra 之特征值与特征向量的性质/","excerpt":"","text":"LinearAlgebra 之特征值与特征向量的性质 123456789101112A\\overrightharpoon&#123;u&#125; = \\lambda\\overrightharpoon&#123;u&#125;当\\lambda = 0 时，A\\overrightharpoon&#123;u&#125; = 0由于特征向量不考虑零向量只有A不可逆这样才能有非零解所以 \\lambda = 0 是A的特征值，则A不可逆！所以 \\lambda = 0 不是A的特征值，则A可逆！ 下三角矩阵的特征值也是其对角线上的元素 当m为负数时上面的证明不成立","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"26、OpenGL 之局部世界观察空间","slug":"OpenGL/26、OpenGL 之局部世界观察空间","date":"2020-06-03T05:00:00.000Z","updated":"2020-08-07T14:20:18.611Z","comments":true,"path":"2020/06/03/OpenGL/26、OpenGL 之局部世界观察空间/","link":"","permalink":"https://www.zackaddy.xin/2020/06/03/OpenGL/26、OpenGL 之局部世界观察空间/","excerpt":"","text":"OpenGL 之局部世界观察空间局部空间局部空间是相对于物体自身的坐标空间，即对象最开始所在的地方。 世界空间世界空间是物体相对于世界坐标空间所在位置。 观察空间观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。 观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。 因此观察空间就是从摄像机的视角所观察到的空间。 这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。 这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"72、LinearAlgebra 之特征值和特征向量的相关概念","slug":"LinearAlgebra/72、LinearAlgebra 之特征值和特征向量的相关概念","date":"2020-06-02T06:00:00.000Z","updated":"2020-08-07T14:10:11.817Z","comments":true,"path":"2020/06/02/LinearAlgebra/72、LinearAlgebra 之特征值和特征向量的相关概念/","link":"","permalink":"https://www.zackaddy.xin/2020/06/02/LinearAlgebra/72、LinearAlgebra 之特征值和特征向量的相关概念/","excerpt":"","text":"LinearAlgebra 之特征值和特征向量的相关概念","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"25、OpenGL 之坐标系统","slug":"OpenGL/25、OpenGL 之坐标系统","date":"2020-06-02T06:00:00.000Z","updated":"2020-08-07T14:20:18.606Z","comments":true,"path":"2020/06/02/OpenGL/25、OpenGL 之坐标系统/","link":"","permalink":"https://www.zackaddy.xin/2020/06/02/OpenGL/25、OpenGL 之坐标系统/","excerpt":"","text":"OpenGL 之坐标系统 OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。 我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。 将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子 在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System) 将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易 比较重要的总共有5个不同的坐标系统 局部空间(Local Space，或者称为物体空间(Object Space)) 世界空间(World Space) 观察空间(View Space，或者称为视觉空间(Eye Space)) 裁剪空间(Clip Space) 屏幕空间(Screen Space) 为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)(包含位移、旋转)、投影(Projection)三个矩阵 我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。 接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。 我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。 例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通； 如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。 如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。 假设物体A的局部空间坐标为(0,0,0), 世界坐标为(1,1,1) 假设摄像机的局部空间坐标为(0,0,0), 世界坐标为(2,2,2) 上方物体A相对于摄像机的坐标为(-1,-1,-1)","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"71、LinearAlgebra 之什么是特征值和特征向量","slug":"LinearAlgebra/71、LinearAlgebra 之什么是特征值和特征向量","date":"2020-06-02T05:00:00.000Z","updated":"2020-08-07T14:10:11.816Z","comments":true,"path":"2020/06/02/LinearAlgebra/71、LinearAlgebra 之什么是特征值和特征向量/","link":"","permalink":"https://www.zackaddy.xin/2020/06/02/LinearAlgebra/71、LinearAlgebra 之什么是特征值和特征向量/","excerpt":"","text":"LinearAlgebra 之什么是特征值和特征向量 特征值和特征向量是线性代数中十分关键的一部分内容。 特征值和特征向量都是方阵的属性。 描述的是方阵的特征，同时特征值和特征向量表征是当方阵做变换时候的一个特征。 具体举例如下， 12345\\lambda 称为A的特征值（eigenvalue）\\overrightharpoon&#123;u&#125; 称为A对于\\lambda 的特征向量（eigenvector）λ（lambda）为常数 上图s是一个自由向量","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"24、OpenGL 之glm数学库实践","slug":"OpenGL/24、OpenGL 之glm数学库实践","date":"2020-06-02T05:00:00.000Z","updated":"2020-08-07T14:20:18.602Z","comments":true,"path":"2020/06/02/OpenGL/24、OpenGL 之glm数学库实践/","link":"","permalink":"https://www.zackaddy.xin/2020/06/02/OpenGL/24、OpenGL 之glm数学库实践/","excerpt":"","text":"OpenGL 之glm数学库实践OpenGL没有自带任何的矩阵和向量知识 有个易于使用，专门为OpenGL量身定做的数学库，那就是GLM。 位移12345678910111213141516\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; T_x \\\\ 0 &amp; 1 &amp; 0 &amp; T_y \\\\ 0 &amp; 0 &amp; 1 &amp; T_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; x + T_x \\\\ y + T_y \\\\ z + T_z \\\\ 1\\end&#123;pmatrix&#125; 下方代码把一个向量(1, 0, 0)位移(1, 1, 0)个单位 123456789101112131415161718#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;#include &lt;iostream&gt;int main()&#123; glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); // 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本 // 下面这行代码就需要改为: // glm::mat4 trans = glm::mat4(1.0f); // 之后将不再进行提示 glm::mat4 trans; // trans为单位矩阵 trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f)); // 在trans单位矩阵上的Tx Ty Tz 位置添加位移值 vec = trans * vec; std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl; // 2 1 0&#125; 旋转与缩放123glm::mat4 trans;trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0)); // z轴旋转90°trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5)); // 每个轴都缩放到0.5倍 让之前的箱子随时间旋转1234glm::mat4 transform = glm::mat4(1.0f); // make sure to initialize matrix to identity matrix firsttransform = glm::rotate(transform, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));ourShader.use();ourShader.setMat4(\"transform\", transform);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"70、LinearAlgebra 之华而不实的行列式的代数表达","slug":"LinearAlgebra/70、LinearAlgebra 之华而不实的行列式的代数表达","date":"2020-06-01T06:00:00.000Z","updated":"2020-08-07T14:10:11.816Z","comments":true,"path":"2020/06/01/LinearAlgebra/70、LinearAlgebra 之华而不实的行列式的代数表达/","link":"","permalink":"https://www.zackaddy.xin/2020/06/01/LinearAlgebra/70、LinearAlgebra 之华而不实的行列式的代数表达/","excerpt":"","text":"LinearAlgebra 之华而不实的行列式的代数表达 余子式为上图红色十字线标记的行列去掉后，剩余项组成的矩阵","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"23.1、OpenGL 之齐次坐标","slug":"OpenGL/23.1、OpenGL 之齐次坐标","date":"2020-06-01T06:00:00.000Z","updated":"2020-08-07T14:20:18.597Z","comments":true,"path":"2020/06/01/OpenGL/23.1、OpenGL 之齐次坐标/","link":"","permalink":"https://www.zackaddy.xin/2020/06/01/OpenGL/23.1、OpenGL 之齐次坐标/","excerpt":"","text":"OpenGL 之齐次坐标在欧几里得几何空间里，两条平行线永远都不会相交。但是在投影空间中，如右图中的两条铁轨在地平线处却是会相交的，因为在无限远处它们看起来相交于一点。 在欧几里得（或称笛卡尔）空间里描述2D/3D 几何物体是很理想的，但在投影空间里面却并不见得。 我们用 表示笛卡尔空间中的一个 2D 点，而处于无限远处的点 (∞,∞) 在笛卡尔空间里是没有意义的。投影空间里的两条平行线会在无限远处相交于一点，但笛卡尔空间里面无法搞定这个问题（因为无限远处的点在笛卡尔空间里是没有意义的），因此数学家想出齐次坐标这个点子来了。 解决办法: 其次坐标由 August Ferdinand Möbius 提出的齐次坐标（Homogeneous coordinates）让我们能够在投影空间里进行图像和几何处理，齐次坐标用 N + 1个分量来描述 N 维坐标。比如，2D 齐次坐标是在笛卡尔坐标(X, Y)的基础上增加一个新分量 w，变成(x, y, w)，其中笛卡尔坐标系中的大X，Y 与齐次坐标中的小x，y有如下对应关系： 12X = x/wY = y/w 笛卡尔坐标中的点 (1, 2) 在齐次坐标中就是 (1, 2, 1) 。如果这点移动到无限远(∞,∞)处，在齐次坐标中就是 (1, 2, 0) ，这样我们就避免了用没意义的”∞” 来描述无限远处的点。 为什么叫齐次坐标？前面提到，我们分别用齐次坐标中的 x 和 y 除以 w 就得到笛卡尔坐标中的 x 和 y，如图所示： 123(x,y,z) = \\begin&#123;pmatrix&#125; \\dfrac&#123;x&#125;&#123;w&#125;, \\dfrac&#123;y&#125;&#123;w&#125;\\end&#123;pmatrix&#125; 仔细观察下面的转换例子，可以发现些有趣的东西： 12345678910111213141516171819(1,2,3) = \\begin&#123;pmatrix&#125; \\dfrac&#123;1&#125;&#123;3&#125;, \\dfrac&#123;2&#125;&#123;3&#125;\\end&#123;pmatrix&#125;(2,4,6) = \\begin&#123;pmatrix&#125; \\dfrac&#123;1&#125;&#123;3&#125;, \\dfrac&#123;2&#125;&#123;3&#125;\\end&#123;pmatrix&#125;(4,8,12) = \\begin&#123;pmatrix&#125; \\dfrac&#123;1&#125;&#123;3&#125;, \\dfrac&#123;2&#125;&#123;3&#125;\\end&#123;pmatrix&#125;...(1a,2a,3a) = \\begin&#123;pmatrix&#125; \\dfrac&#123;1a&#125;&#123;3a&#125;, \\dfrac&#123;2a&#125;&#123;3a&#125;\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\dfrac&#123;1&#125;&#123;3&#125;, \\dfrac&#123;2&#125;&#123;3&#125;\\end&#123;pmatrix&#125; 上图中，点 (1, 2, 3), (2, 4, 6) 和 (4, 8, 12) 对应笛卡尔坐标中的同一点 (1/3, 2/3)。 任意数量积的(1a, 2a, 3a) 始终对应于笛卡尔坐标中的同一点 (1/3, 2/3)。因此这些点是“齐次”的，因为他们始终对应于笛卡尔坐标中的同一点。换句话说，齐次坐标描述缩放不变性 证明: 两平行线可以相交笛卡尔坐标系中，对于如下两个直线方程： 1234\\begin&#123;cases&#125; Ax + By + C = 0 \\\\ Ax + By + D = 0\\end&#123;cases&#125; 如果 C ≠ D，以上方程组无解；如果 C = D，那这两条线就是同一条线了。 下面我们用 x/w, y/w 代替 x, y 放到投影空间里来求解： 123456789\\begin&#123;cases&#125; A\\dfrac&#123;x&#125;&#123;w&#125; + B\\dfrac&#123;y&#125;&#123;w&#125; + C = 0 \\\\ \\\\ A\\dfrac&#123;y&#125;&#123;w&#125; + B\\dfrac&#123;y&#125;&#123;w&#125; + D = 0\\end&#123;cases&#125; \\to \\begin&#123;cases&#125; Ax + By + Cw = 0 \\\\ Ax + By + Dw = 0\\end&#123;cases&#125; 现在我们就可以在 C ≠ D 的情况得到一组解 (x, y, 0)，代入得 (C - D)w = 0，因为 C ≠ D，所以 w = 0。因而，两条平行线相交于投影空间中无限远处的一点(x, y, 0)。 齐次坐标在计算机图形学中是有用的，将 3D 场景投影到 2D 平面的过程中就用到它了。 引入齐次坐标的意义https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/95230246 前面我们提到了图像的缩放变换和旋转变换，可以用矩阵乘法的形式来表达变换后的像素位置映射关系。 那么，对于平移变换呢？平移变换表示的是位置变化的概念。如下图所示，一个图像矩形从中心点[x1,y1]平移到了中心点[x2,y2] 处，整体大小和角度都没有变化。在x方向和y方向上分别平移了tx和ty大小。 显然： 这对于图像中的每一个点都是成立的。写成矩阵的形式就是： 我们再把前面的缩放变换和旋转变换的矩阵形式写出来：缩放变换： 旋转变换： 我们注意到，缩放变换和旋转变换都可以表示成矩阵乘法的形式。实际上，图像的几何变换通常不是单一的，也就是说经常性的缩放、旋转、平移一起变换。例如先放大2倍，然后旋转45度，然后再缩小0.5倍。那么就可以表示成矩阵乘法串接的形式： 这样，不管有多少次变换，都可以用矩阵乘法来实现。但是平移变换呢？从前面看到，平移变换并不是矩阵乘法的形式，而是矩阵加法的形式！ 那能不能把缩放变换、旋转变换、平移变换统一成矩阵乘法的形式呢，这样不管进行多少次变换，都可以表示成矩阵连乘的形式，将极大的方便计算和降低运算量。 这种方法就是“升维”，引入“齐次坐标”，将图像从平面2D坐标变成3D坐标。我们看看平移变换的矩阵形式： 将其升维，变成3维，上式就可以表示成： 这是个非常优美的地方，学习过矩阵乘法的同学可以算一下右边的式子，是否最终结果与前面是一样的。 这样，平移变换通过升维后的齐次坐标，也变成了矩阵乘法的形式。当然缩放变换和旋转变换的矩阵形式也得改一改，统一变成3维的形式。缩放变换： 旋转变换： 终于统一了。以后所有的变换，不管怎样变换，变换多少次，都可以表示成一连串的矩阵相乘了，这是多么的方便。 这就是引入齐次坐标的作用，把各种变换都统一了起来，即 把缩放，旋转，平移等变换都统一起来，都表示成一连串的矩阵相乘的形式。保证了形式上的线性一致性。 简短的解释： 齐次坐标就是将一个原本是n维的向量用一个n+1维向量来表示。 许多图形应用涉及到几何变换，主要包括平移、旋转、缩放。以矩阵表达式来计算这些变换时，平移是矩阵相加，旋转和缩放则是矩阵相乘，综合起来可以表示为 x=R∗X+t（注：因为习惯的原因，实际使用时一般使用变化矩阵左乘向量）(R 旋转缩放矩阵，t 为平移矩阵，X为原向量，x 为变换后的向量)。引入齐次坐标的目的主要是合并矩阵运算中的乘法和加法，表示为x=P∗X的形式。即它提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"69、LinearAlgebra 之行式就是列式","slug":"LinearAlgebra/69、LinearAlgebra 之行式就是列式","date":"2020-06-01T05:00:00.000Z","updated":"2020-08-07T14:10:11.816Z","comments":true,"path":"2020/06/01/LinearAlgebra/69、LinearAlgebra 之行式就是列式/","link":"","permalink":"https://www.zackaddy.xin/2020/06/01/LinearAlgebra/69、LinearAlgebra 之行式就是列式/","excerpt":"","text":"LinearAlgebra 之行式就是列式在之前，行列式的理解都是以行为单位的。但是实际上，对于行列式而言“行式就是列式”，即 1det(A)=det(A^T) 如果行列式的两列相同，则行列式的值为0 如果行列式的一列是另一列的k倍，则行列式的值为0 如果行列式的一列是其他列的组合，则行列式的值为0 如果一个方阵加（减）另一列的k倍，行列式的值不变 正是因为这个定理，使得行列式从行角度和列角度看都是相同的。这也为之后的特征值、奇异值打下了良好的基础。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"23.0、OpenGL 之矩阵的缩放位移与组合","slug":"OpenGL/23.0、OpenGL 之矩阵的缩放位移与组合","date":"2020-06-01T05:00:00.000Z","updated":"2020-08-07T14:20:18.593Z","comments":true,"path":"2020/06/01/OpenGL/23.0、OpenGL 之矩阵的缩放位移与组合/","link":"","permalink":"https://www.zackaddy.xin/2020/06/01/OpenGL/23.0、OpenGL 之矩阵的缩放位移与组合/","excerpt":"","text":"OpenGL 之矩阵的缩放位移与组合缩放对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。 12345678910111213141516\\begin&#123;pmatrix&#125; S_1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; S_2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; S_3 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; S_1 \\cdot x \\\\ S_2 \\cdot y \\\\ S_3 \\cdot z \\\\ 1\\end&#123;pmatrix&#125; 齐次坐标(Homogeneous Coordinates)向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。 如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。 位移123456789101112131415161718192021222324位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。我们已经讨论了向量加法，所以这应该不会太陌生。和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; T_x \\\\ 0 &amp; 1 &amp; 0 &amp; T_y \\\\ 0 &amp; 0 &amp; 1 &amp; T_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; x + T_x \\\\ y + T_y \\\\ z + T_z \\\\ 1\\end&#123;pmatrix&#125; 旋转沿x轴旋转： 12345678910111213141516\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\ 0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; x \\\\ \\cos\\theta \\cdot y - \\sin\\theta \\cdot z \\\\ \\sin\\theta \\cdot y + \\cos\\theta \\cdot z \\\\ 1\\end&#123;pmatrix&#125; 沿y轴旋转： 12345678910111213141516\\begin&#123;pmatrix&#125; \\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\\\ -\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta \\cdot x - \\sin\\theta \\cdot z \\\\ y \\\\ -\\sin\\theta \\cdot x + \\cos\\theta \\cdot z \\\\ 1\\end&#123;pmatrix&#125; 沿z轴旋转： 12345678910111213141516\\begin&#123;pmatrix&#125; \\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0 \\\\ \\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta \\cdot x - \\sin\\theta \\cdot y \\\\ \\sin\\theta \\cdot x + \\cos\\theta \\cdot y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; 矩阵的组合使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样： 12345678910111213141516Trans.Scale = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; 2 \\\\ 0 &amp; 0 &amp; 1 &amp; 3 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; 2 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 2 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 2 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 2 \\\\ 0 &amp; 0 &amp; 2 &amp; 3 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; 注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！ 用最终的变换矩阵左乘我们的向量会得到以下结果： 12345678910111213141516\\begin&#123;pmatrix&#125; 2 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 2 &amp; 0 &amp; 2 \\\\ 0 &amp; 0 &amp; 2 &amp; 3 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z \\\\ 1\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 2x + 1 \\\\ 2y + 2 \\\\ 2z + 3 \\\\ 1\\end&#123;pmatrix&#125; 不错！向量先缩放2倍，然后位移了(1, 2, 3)个单位。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"68、LinearAlgebra 之初等矩阵与行列式","slug":"LinearAlgebra/68、LinearAlgebra 之初等矩阵与行列式","date":"2020-05-31T06:00:00.000Z","updated":"2020-08-07T14:10:11.815Z","comments":true,"path":"2020/05/31/LinearAlgebra/68、LinearAlgebra 之初等矩阵与行列式/","link":"","permalink":"https://www.zackaddy.xin/2020/05/31/LinearAlgebra/68、LinearAlgebra 之初等矩阵与行列式/","excerpt":"","text":"LinearAlgebra 之初等矩阵与行列式","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"22、OpenGL 之矩阵相乘与单位矩阵","slug":"OpenGL/22、OpenGL 之矩阵相乘与单位矩阵","date":"2020-05-31T06:00:00.000Z","updated":"2020-08-07T14:20:18.589Z","comments":true,"path":"2020/05/31/OpenGL/22、OpenGL 之矩阵相乘与单位矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/31/OpenGL/22、OpenGL 之矩阵相乘与单位矩阵/","excerpt":"","text":"OpenGL 之矩阵相乘与单位矩阵矩阵相乘 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A 单位矩阵单位矩阵是一个除了对角线以外都是0的N×N矩阵 在下式中可以看到，这种变换矩阵使一个向量完全不变： 123456789101112131415161718192021\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; 1 \\\\ 2 \\\\ 3 \\\\ 4\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 \\cdot 1 \\\\ 1 \\cdot 2 \\\\ 1 \\cdot 3 \\\\ 1 \\cdot 4\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 \\\\ 2 \\\\ 3 \\\\ 4\\end&#123;pmatrix&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"67、LinearAlgebra 之计算行列式的算法","slug":"LinearAlgebra/67、LinearAlgebra 之计算行列式的算法","date":"2020-05-31T05:00:00.000Z","updated":"2020-08-07T14:10:11.814Z","comments":true,"path":"2020/05/31/LinearAlgebra/67、LinearAlgebra 之计算行列式的算法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/31/LinearAlgebra/67、LinearAlgebra 之计算行列式的算法/","excerpt":"","text":"LinearAlgebra 之计算行列式的算法 如果Gauss-Jordan消元的结果存在零行，则行列式的值为0。 故总结行列式计算步骤， 对方阵进行Gauss消元(即没有Gauss-Jordan消元法后向过程) 不进行归一化处理 如果消元结果中存在零行，则行列式的值为0 如果不存在零行，则行列式的值为主对角线全部元素乘积 这也是大多数线性代数计算库计算行列式值的算法过程，这个过程本身的运算效率是较高的。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"21、OpenGL 之矩阵的加减与数乘","slug":"OpenGL/21、OpenGL 之矩阵的加减与数乘","date":"2020-05-31T05:00:00.000Z","updated":"2020-08-07T14:20:18.585Z","comments":true,"path":"2020/05/31/OpenGL/21、OpenGL 之矩阵的加减与数乘/","link":"","permalink":"https://www.zackaddy.xin/2020/05/31/OpenGL/21、OpenGL 之矩阵的加减与数乘/","excerpt":"","text":"OpenGL 之矩阵的加减与数乘矩阵的加减矩阵与标量之间的加减定义如下 12345678910\\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; + 3 = \\begin&#123;pmatrix&#125; 1 + 3 &amp; 2 + 3 \\\\ 3 + 3 &amp; 4 + 3\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 4 &amp; 5 \\\\ 6 &amp; 7\\end&#123;pmatrix&#125; ==注意，数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持== 矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法只对同维度的矩阵才是有定义的。一个3×2矩阵和一个2×3矩阵（或一个3×3矩阵与4×4矩阵）是不能进行加减的。我们看看两个2×2矩阵是怎样相加的： 12345678910111213\\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; + \\begin&#123;pmatrix&#125; 5 &amp; 6 \\\\ 7 &amp; 8\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 + 5 &amp; 2 + 6 \\\\ 3 + 7 &amp; 4 + 8\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 6 &amp; 8 \\\\ 10 &amp; 12\\end&#123;pmatrix&#125; 矩阵的数乘和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量 123456789102 \\cdot \\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 2 \\cdot 1 &amp; 2 \\cdot 2 \\\\ 2 \\cdot 3 &amp; 2 \\cdot 4\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 2 &amp; 4 \\\\ 6 &amp; 8\\end&#123;pmatrix&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"66、LinearAlgebra 之行列式与矩阵的逆","slug":"LinearAlgebra/66、LinearAlgebra 之行列式与矩阵的逆","date":"2020-05-30T06:00:00.000Z","updated":"2020-08-07T14:10:11.814Z","comments":true,"path":"2020/05/30/LinearAlgebra/66、LinearAlgebra 之行列式与矩阵的逆/","link":"","permalink":"https://www.zackaddy.xin/2020/05/30/LinearAlgebra/66、LinearAlgebra 之行列式与矩阵的逆/","excerpt":"","text":"LinearAlgebra 之行列式与矩阵的逆四大基本性质 如果行列式有一行为0，则行列式的值为0 如果行列式的两行相同，则行列式的值为0 如果行列式的一行是另一行的k倍，则行列式的值为0 如果行列式的一行是其他行的线性组合，则行列式的值为0","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"20、OpenGL 之矩阵","slug":"OpenGL/20、OpenGL 之矩阵","date":"2020-05-30T06:00:00.000Z","updated":"2020-08-07T14:20:18.581Z","comments":true,"path":"2020/05/30/OpenGL/20、OpenGL 之矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/30/OpenGL/20、OpenGL 之矩阵/","excerpt":"","text":"OpenGL 之矩阵简单来说矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素(Element)。下面是一个2×3矩阵的例子： 1234\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6\\end&#123;pmatrix&#125; 矩阵可以通过(i, j)进行索引，i是行，j是列，这就是上面的矩阵叫做2×3矩阵的原因（3列2行，也叫做矩阵的维度(Dimension)）。这与你在索引2D图像时的(x, y)相反，获取4的索引是(2, 1)（第二行，第一列） 矩阵基本也就是这些了，它就是一个矩形的数学表达式阵列。和向量一样，矩阵也有非常漂亮的数学属性。矩阵有几个运算，分别是：矩阵加法、减法和乘法。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"65、LinearAlgebra 之行列式的四大基本性质","slug":"LinearAlgebra/65、LinearAlgebra 之行列式的四大基本性质","date":"2020-05-30T05:00:00.000Z","updated":"2020-08-07T14:10:11.814Z","comments":true,"path":"2020/05/30/LinearAlgebra/65、LinearAlgebra 之行列式的四大基本性质/","link":"","permalink":"https://www.zackaddy.xin/2020/05/30/LinearAlgebra/65、LinearAlgebra 之行列式的四大基本性质/","excerpt":"","text":"LinearAlgebra 之行列式的四大基本性质 标准单位向量的行列式值为1。 交换行列式的两行，则行列式的值取反。以二维空间为例，行列式可以理解为两个二维向量围成的有向面积。如果将向量取反，则相当于把围成的面积翻面，方向与原先相反，故行列式的值也是相反的。 方阵的某一行乘以一个数k，则其对应的行列式也缩放了k倍","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"19、OpenGL 之向量相乘","slug":"OpenGL/19、OpenGL 之向量相乘","date":"2020-05-30T05:00:00.000Z","updated":"2020-08-07T14:20:18.577Z","comments":true,"path":"2020/05/30/OpenGL/19、OpenGL 之向量相乘/","link":"","permalink":"https://www.zackaddy.xin/2020/05/30/OpenGL/19、OpenGL 之向量相乘/","excerpt":"","text":"OpenGL 之向量相乘两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是点乘(Dot Product)，记作 1\\overrightharpoon&#123;v&#125; \\cdot \\overrightharpoon&#123;k&#125; ，另一个是叉乘(Cross Product)，记作 1\\overrightharpoon&#123;v&#125; \\times \\overrightharpoon&#123;k&#125; 点乘现在点积只定义了两个向量的夹角。你也许记得90度的余弦值是0，0度的余弦值是1。使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角） 1\\overrightharpoon&#123;v&#125; \\cdot \\overrightharpoon&#123;k&#125; = ||\\overrightharpoon&#123;v&#125;|| \\cdot ||\\overrightharpoon&#123;k&#125;|| \\cdot \\cos\\theta 如果两个向量的长度都为1 1\\overrightharpoon&#123;v&#125; \\cdot \\overrightharpoon&#123;k&#125; = 1 \\cdot 1 \\cdot \\cos\\theta 点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。 123456789\\begin&#123;pmatrix&#125; 0.6 \\\\ -0.8 \\\\ 0\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; 0 \\\\ 1 \\\\ 0\\end&#123;pmatrix&#125; = (0.6*0) + (-0.8*1) + (0*0) = -0.8 叉乘叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量 只记住公式就没问题啦 12345678910111213\\begin&#123;pmatrix&#125; A_x \\\\ A_y \\\\ A_z\\end&#123;pmatrix&#125; \\times \\begin&#123;pmatrix&#125; B_x \\\\ B_y \\\\ B_z\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; A_y \\cdot B_z - A_z \\cdot B_y \\\\ A_z \\cdot B_x - A_x \\cdot B_z\\\\ A_x \\cdot B_y - A_y \\cdot B_x\\end&#123;pmatrix&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"64、LinearAlgebra 之什么是行列式","slug":"LinearAlgebra/64、LinearAlgebra 之什么是行列式","date":"2020-05-29T06:00:00.000Z","updated":"2020-08-07T14:10:11.814Z","comments":true,"path":"2020/05/29/LinearAlgebra/64、LinearAlgebra 之什么是行列式/","link":"","permalink":"https://www.zackaddy.xin/2020/05/29/LinearAlgebra/64、LinearAlgebra 之什么是行列式/","excerpt":"","text":"LinearAlgebra 之什么是行列式 行列式和矩阵以及空间的基等概念有密切的联系 关注行列式的性质，为后续学习打基础 行列式是方阵的一个属性，只有方阵才有行列式 行列式是方阵的一个属性，在之前对矩阵的理解是“矩阵是一组向量”每一列对应着一个向量，而方阵表示的是nnn个nnn维向量。 行列式是一个数字，以二维空间为例，下面的三组基向量都是构成二维空间的向量 构成这三个二维坐标系的向量围成的面积就是行列式。继续深入到三维、四维至n维空间，行列式可以理解为构成这些空间所用的基向量围成的体积。与矩阵不一样的是，行列式中每一行是一个向量。与一般的面积和体积不一样的是，行列式的值可以是负数，理解为一个有向的面积或体积。 即主对角线元素乘积减去副对角线元素乘积(仅限二维，高维度矩阵计算更复杂)。 三阶及以上行列式行列式表示向量组在空间中形成的有向体积。 更高维度的行列式是不容易使用上面的过程推导的，三阶行列式对应的六面体需要空间几何的运算，更高维度的体积无法可视化，推导的难度更大。 行列式表示向量组在空间中形成的有向体积，在行列式中，每一行都是向量，且向量排列的顺序是有意义的，交换两行，则行列式的值取反。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"18、OpenGL 之长度","slug":"OpenGL/18、OpenGL 之长度","date":"2020-05-29T06:00:00.000Z","updated":"2020-08-07T14:20:18.573Z","comments":true,"path":"2020/05/29/OpenGL/18、OpenGL 之长度/","link":"","permalink":"https://www.zackaddy.xin/2020/05/29/OpenGL/18、OpenGL 之长度/","excerpt":"","text":"OpenGL 之长度 我们使用勾股定理(Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。 如果你把向量的x与y分量画出来，该向量会和x与y分量为边形成一个三角形: 因为两条边（x和y）是已知的，如果希望知道斜边向量v的长度，我们可以直接通过勾股定理来计算： 123456789101112131415161718||\\overrightharpoon&#123;v&#125;|| = \\sqrt&#123;x^2 + y^2&#125;||\\overrightharpoon&#123;v&#125;||表示向量\\overrightharpoon&#123;v&#125;的长度，我们也可以加上z^2把这个公式拓展到三维空间。例子中向量(4, 2)的长度等于：||\\overrightharpoon&#123;v&#125;||=\\sqrt&#123;4^2 + 2^2&#125; = 4.47有一个特殊类型的向量叫做单位向量(Unit Vector)。单位向量有一个特别的性质——它的长度是1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量\\hat&#123;n&#125;\\hat&#123;n&#125; = \\dfrac&#123;\\overrightharpoon&#123;v&#125;&#125;&#123;||\\overrightharpoon&#123;v&#125;||&#125;我们把这种方法叫做一个向量的标准化(Normalizing)。单位向量头上有一个\\hat&#123;&#125;样子的记号。通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"63、LinearAlgebra 之线性变换","slug":"LinearAlgebra/63、LinearAlgebra 之线性变换","date":"2020-05-29T05:00:00.000Z","updated":"2020-08-07T14:10:11.813Z","comments":true,"path":"2020/05/29/LinearAlgebra/63、LinearAlgebra 之线性变换/","link":"","permalink":"https://www.zackaddy.xin/2020/05/29/LinearAlgebra/63、LinearAlgebra 之线性变换/","excerpt":"","text":"LinearAlgebra 之线性变换 所有的矩阵都可以用来表示一个线性变换 用矩阵表示空间的视角和用矩阵表示变换的视角是等价","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"17、OpenGL 之向量加减与取反","slug":"OpenGL/17、OpenGL 之向量加减与取反","date":"2020-05-29T05:00:00.000Z","updated":"2020-08-07T14:20:18.569Z","comments":true,"path":"2020/05/29/OpenGL/17、OpenGL 之向量加减与取反/","link":"","permalink":"https://www.zackaddy.xin/2020/05/29/OpenGL/17、OpenGL 之向量加减与取反/","excerpt":"","text":"OpenGL 之向量加减与取反向量取反对一个向量取反(Negate)会将其方向逆转。一个指向东北的向量取反后就指向西南方向了。我们在一个向量的每个分量前加负号就可以实现取反了（或者说用-1数乘该向量）: 123456789-\\overrightharpoon&#123;v&#125; = -\\begin&#123;pmatrix&#125; v_x \\\\ v_y \\\\ v_z\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; -v_x \\\\ -v_y \\\\ -v_z\\end&#123;pmatrix&#125; 向量加减向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量： 1234567891011121314151617\\overrightharpoon&#123;v&#125; = \\begin&#123;pmatrix&#125; 1 \\\\ 2 \\\\ 3\\end&#123;pmatrix&#125;，\\overrightharpoon&#123;k&#125; = \\begin&#123;pmatrix&#125; 4 \\\\ 5 \\\\ 6\\end&#123;pmatrix&#125; \\to \\overrightharpoon&#123;v&#125; + \\overrightharpoon&#123;k&#125; = \\begin&#123;pmatrix&#125; 1+4 \\\\ 2+5 \\\\ 3+6\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 5 \\\\ 7 \\\\ 9\\end&#123;pmatrix&#125; 向量v = (4, 2)和k = (1, 2)可以直观地表示为： 两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"62、LinearAlgebra 之任意坐标系转换","slug":"LinearAlgebra/62、LinearAlgebra 之任意坐标系转换","date":"2020-05-28T06:00:00.000Z","updated":"2020-08-07T14:10:11.813Z","comments":true,"path":"2020/05/28/LinearAlgebra/62、LinearAlgebra 之任意坐标系转换/","link":"","permalink":"https://www.zackaddy.xin/2020/05/28/LinearAlgebra/62、LinearAlgebra 之任意坐标系转换/","excerpt":"","text":"LinearAlgebra 之任意坐标系转换","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"16、OpenGL 之向量与标量运算","slug":"OpenGL/16、OpenGL 之向量与标量运算","date":"2020-05-28T06:00:00.000Z","updated":"2020-08-07T14:20:18.565Z","comments":true,"path":"2020/05/28/OpenGL/16、OpenGL 之向量与标量运算/","link":"","permalink":"https://www.zackaddy.xin/2020/05/28/OpenGL/16、OpenGL 之向量与标量运算/","excerpt":"","text":"OpenGL 之向量与标量运算标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加/减/乘/除一个标量，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样: 123456789\\begin&#123;pmatrix&#125; 1 \\\\ 2 \\\\ 3\\end&#123;pmatrix&#125; + x = \\begin&#123;pmatrix&#125; 1 + x \\\\ 2 + x \\\\ 3 + x\\end&#123;pmatrix&#125; 其中的+可以是+，-，·或÷，其中·是乘号。注意－和÷运算时不能颠倒（标量-/÷向量），因为颠倒的运算是没有定义的。 ==注意，数学上是没有向量与标量相加这个运算的，但是很多线性代数的库都对它有支持（比如说我们用的GLM和python中的numpy）。==","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"61、LinearAlgebra 之其他坐标系与标准坐标系的转换","slug":"LinearAlgebra/61、LinearAlgebra 之其他坐标系与标准坐标系的转换","date":"2020-05-28T05:00:00.000Z","updated":"2020-08-07T14:10:11.813Z","comments":true,"path":"2020/05/28/LinearAlgebra/61、LinearAlgebra 之其他坐标系与标准坐标系的转换/","link":"","permalink":"https://www.zackaddy.xin/2020/05/28/LinearAlgebra/61、LinearAlgebra 之其他坐标系与标准坐标系的转换/","excerpt":"","text":"LinearAlgebra 之其他坐标系与标准坐标系的转换","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"15、OpenGL 之向量","slug":"OpenGL/15、OpenGL 之向量","date":"2020-05-28T05:00:00.000Z","updated":"2020-08-07T14:20:18.561Z","comments":true,"path":"2020/05/28/OpenGL/15、OpenGL 之向量/","link":"","permalink":"https://www.zackaddy.xin/2020/05/28/OpenGL/15、OpenGL 之向量/","excerpt":"","text":"OpenGL 之向量 向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。 你可以把向量想像成一个藏宝图上的指示：“向左走10步，向北走3步，然后向右走5步”；“左”就是方向，“10步”就是向量的长度。那么这个藏宝图的指示一共有3个向量。 向量可以在任意维度(Dimension)上，但是我们通常只使用2至4维。 如果一个向量有2个维度，它表示一个平面的方向(想象一下2D的图像)，当它有3个维度的时候它可以表达一个3D世界的方向。 由于向量表示的是方向，起始于何处并不会改变它的值。下图我们可以看到向量v和w是相等的，尽管他们的起始点不同 数学家喜欢在字母上面加一横表示向量 12345\\overrightharpoon&#123;v&#125; = \\begin&#123;pmatrix&#125; x \\\\ y \\\\ z\\end&#123;pmatrix&#125; 由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来 为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。 比如说位置向量(3, 5)在图像中的起点会是(0, 0)，并会指向(3, 5)。我们可以使用向量在2D或3D空间中表示方向与位置. 和普通数字一样，我们也可以用向量进行多种运算","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"60、LinearAlgebra 之空间的基和坐标系","slug":"LinearAlgebra/60、LinearAlgebra 之空间的基和坐标系","date":"2020-05-27T06:00:00.000Z","updated":"2020-08-07T14:10:11.813Z","comments":true,"path":"2020/05/27/LinearAlgebra/60、LinearAlgebra 之空间的基和坐标系/","link":"","permalink":"https://www.zackaddy.xin/2020/05/27/LinearAlgebra/60、LinearAlgebra 之空间的基和坐标系/","excerpt":"","text":"LinearAlgebra 之空间的基和坐标系","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"14、OpenGL 之应用纹理","slug":"OpenGL/14、OpenGL 之应用纹理","date":"2020-05-27T06:00:00.000Z","updated":"2020-08-07T14:20:18.555Z","comments":true,"path":"2020/05/27/OpenGL/14、OpenGL 之应用纹理/","link":"","permalink":"https://www.zackaddy.xin/2020/05/27/OpenGL/14、OpenGL 之应用纹理/","excerpt":"","text":"OpenGL 之应用纹理 stb_image.h https://github.com/nothings/stb/blob/master/stb_image.h 箱子图片 https://learnopengl-cn.github.io/img/01/06/container.jpg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define STB_IMAGE_IMPLEMENTATION#include \"stb_image.h\"#include \"shader.h\"#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // build and compile our shader zprogram // ------------------------------------ Shader ourShader(\"4.2.texture.vs\", \"4.2.texture.fs\"); // set up vertex data (and buffer(s)) and configure vertex attributes // ------------------------------------------------------------------ float vertices[] = &#123; // positions // colors // texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // top left &#125;; unsigned int indices[] = &#123; 0, 1, 3, // first triangle 1, 2, 3 // second triangle &#125;; unsigned int VBO, VAO, EBO; glGenVertexArrays(1, &amp;VAO); glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // position attribute glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // color attribute glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); glEnableVertexAttribArray(1); // texture coord attribute glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); // load and create a texture // ------------------------- unsigned int texture1; // texture 1 // --------- glGenTextures(1, &amp;texture1); glActiveTexture(GL_TEXTURE2); // // 在绑定纹理之前先激活纹理单元 glBindTexture(GL_TEXTURE_2D, texture1); // set the texture wrapping parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); // set texture wrapping to GL_REPEAT (default wrapping method) glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); // set texture filtering parameters glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // load image, create texture and generate mipmaps int width, height, nrChannels; stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture's on the y-axis. // The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path. unsigned char *data = stbi_load(\"container.jpg\", &amp;width, &amp;height, &amp;nrChannels, 0); if (data) &#123; glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); &#125; else &#123; std::cout &lt;&lt; \"Failed to load texture\" &lt;&lt; std::endl; &#125; stbi_image_free(data); // tell opengl for each sampler to which texture unit it belongs to (only has to be done once) // ------------------------------------------------------------------------------------------- ourShader.use(); // 设置uniforms前需调用 ourShader.setInt(\"texture3\", 2); // 这里的2需要与GL_TEXTURE2对应 // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // render // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // bind textures on corresponding texture units // render container //ourShader.use(); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // optional: de-allocate all resources once they've outlived their purpose: // ------------------------------------------------------------------------ glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteBuffers(1, &amp;EBO); // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"59、LinearAlgebra 之更多与投影相关的话题","slug":"LinearAlgebra/59、LinearAlgebra 之更多与投影相关的话题","date":"2020-05-27T05:00:00.000Z","updated":"2020-08-07T14:10:11.812Z","comments":true,"path":"2020/05/27/LinearAlgebra/59、LinearAlgebra 之更多与投影相关的话题/","link":"","permalink":"https://www.zackaddy.xin/2020/05/27/LinearAlgebra/59、LinearAlgebra 之更多与投影相关的话题/","excerpt":"","text":"LinearAlgebra 之更多与投影相关的话题 正交基 标准正交基 正交非零向量组一定线性无关 n个非零正交向量一定是n维空间的基 Ax = b 如果A的行数大于列数，大概率无解，下方解决如何有解 方程数大于未知数个数 找到A的列空间中离b最近的b’ （求出A空间的一组正交基，求出b到正交基中各个分量的投影,把各个投影分量加载一块就是b’） Ax = b’ b’就是A的列空间的投影！","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"13、OpenGL 之Shader类封装","slug":"OpenGL/13、OpenGL 之Shader类封装","date":"2020-05-27T05:00:00.000Z","updated":"2020-08-07T14:20:18.550Z","comments":true,"path":"2020/05/27/OpenGL/13、OpenGL 之Shader类封装/","link":"","permalink":"https://www.zackaddy.xin/2020/05/27/OpenGL/13、OpenGL 之Shader类封装/","excerpt":"","text":"OpenGL 之Shader类封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#ifndef SHADER_H#define SHADER_H#include &lt;glad/glad.h&gt;#include &lt;glm/glm.hpp&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader&#123;public: unsigned int ID; // constructor generates the shader on the fly // ------------------------------------------------------------------------ Shader(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr) &#123; // 1. retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::string geometryCode; std::ifstream vShaderFile; std::ifstream fShaderFile; std::ifstream gShaderFile; // ensure ifstream objects can throw exceptions: vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); try &#123; // open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // read file's buffer contents into streams vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // close file handlers vShaderFile.close(); fShaderFile.close(); // convert stream into string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); // if geometry shader path is present, also load a geometry shader if (geometryPath != nullptr) &#123; gShaderFile.open(geometryPath); std::stringstream gShaderStream; gShaderStream &lt;&lt; gShaderFile.rdbuf(); gShaderFile.close(); geometryCode = gShaderStream.str(); &#125; &#125; catch (std::ifstream::failure&amp; e) &#123; std::cout &lt;&lt; \"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\" &lt;&lt; std::endl; &#125; const char* vShaderCode = vertexCode.c_str(); const char * fShaderCode = fragmentCode.c_str(); // 2. compile shaders unsigned int vertex, fragment; // vertex shader vertex = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertex, 1, &amp;vShaderCode, NULL); glCompileShader(vertex); checkCompileErrors(vertex, \"VERTEX\"); // fragment Shader fragment = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragment, 1, &amp;fShaderCode, NULL); glCompileShader(fragment); checkCompileErrors(fragment, \"FRAGMENT\"); // if geometry shader is given, compile geometry shader unsigned int geometry; if (geometryPath != nullptr) &#123; const char * gShaderCode = geometryCode.c_str(); geometry = glCreateShader(GL_GEOMETRY_SHADER); glShaderSource(geometry, 1, &amp;gShaderCode, NULL); glCompileShader(geometry); checkCompileErrors(geometry, \"GEOMETRY\"); &#125; // shader Program ID = glCreateProgram(); glAttachShader(ID, vertex); glAttachShader(ID, fragment); if (geometryPath != nullptr) glAttachShader(ID, geometry); glLinkProgram(ID); checkCompileErrors(ID, \"PROGRAM\"); // delete the shaders as they're linked into our program now and no longer necessery glDeleteShader(vertex); glDeleteShader(fragment); if (geometryPath != nullptr) glDeleteShader(geometry); &#125; // activate the shader // ------------------------------------------------------------------------ void use() &#123; glUseProgram(ID); &#125; // utility uniform functions // ------------------------------------------------------------------------ void setBool(const std::string &amp;name, bool value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value); &#125; // ------------------------------------------------------------------------ void setInt(const std::string &amp;name, int value) const &#123; glUniform1i(glGetUniformLocation(ID, name.c_str()), value); &#125; // ------------------------------------------------------------------------ void setFloat(const std::string &amp;name, float value) const &#123; glUniform1f(glGetUniformLocation(ID, name.c_str()), value); &#125; // ------------------------------------------------------------------------ void setVec2(const std::string &amp;name, const glm::vec2 &amp;value) const &#123; glUniform2fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec2(const std::string &amp;name, float x, float y) const &#123; glUniform2f(glGetUniformLocation(ID, name.c_str()), x, y); &#125; // ------------------------------------------------------------------------ void setVec3(const std::string &amp;name, const glm::vec3 &amp;value) const &#123; glUniform3fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec3(const std::string &amp;name, float x, float y, float z) const &#123; glUniform3f(glGetUniformLocation(ID, name.c_str()), x, y, z); &#125; // ------------------------------------------------------------------------ void setVec4(const std::string &amp;name, const glm::vec4 &amp;value) const &#123; glUniform4fv(glGetUniformLocation(ID, name.c_str()), 1, &amp;value[0]); &#125; void setVec4(const std::string &amp;name, float x, float y, float z, float w) &#123; glUniform4f(glGetUniformLocation(ID, name.c_str()), x, y, z, w); &#125; // ------------------------------------------------------------------------ void setMat2(const std::string &amp;name, const glm::mat2 &amp;mat) const &#123; glUniformMatrix2fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125; // ------------------------------------------------------------------------ void setMat3(const std::string &amp;name, const glm::mat3 &amp;mat) const &#123; glUniformMatrix3fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125; // ------------------------------------------------------------------------ void setMat4(const std::string &amp;name, const glm::mat4 &amp;mat) const &#123; glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); &#125;private: // utility function for checking shader compilation/linking errors. // ------------------------------------------------------------------------ void checkCompileErrors(GLuint shader, std::string type) &#123; GLint success; GLchar infoLog[1024]; if (type != \"PROGRAM\") &#123; glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER_COMPILATION_ERROR of type: \" &lt;&lt; type &lt;&lt; \"\\n\" &lt;&lt; infoLog &lt;&lt; \"\\n -- --------------------------------------------------- -- \" &lt;&lt; std::endl; &#125; &#125; else &#123; glGetProgramiv(shader, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shader, 1024, NULL, infoLog); std::cout &lt;&lt; \"ERROR::PROGRAM_LINKING_ERROR of type: \" &lt;&lt; type &lt;&lt; \"\\n\" &lt;&lt; infoLog &lt;&lt; \"\\n -- --------------------------------------------------- -- \" &lt;&lt; std::endl; &#125; &#125; &#125;&#125;;#endif","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"58、LinearAlgebra 之实现矩阵的QR分解","slug":"LinearAlgebra/58、LinearAlgebra 之实现矩阵的QR分解","date":"2020-05-26T06:00:00.000Z","updated":"2020-08-07T14:10:11.812Z","comments":true,"path":"2020/05/26/LinearAlgebra/58、LinearAlgebra 之实现矩阵的QR分解/","link":"","permalink":"https://www.zackaddy.xin/2020/05/26/LinearAlgebra/58、LinearAlgebra 之实现矩阵的QR分解/","excerpt":"","text":"LinearAlgebra 之实现矩阵的QR分解 12345A = QRR = Q^&#123;-1&#125;AR = Q^&#123;T&#125;A 代码实现1234567891011121314151617181920212223function qr(A) &#123; console.log(A.rowNum() === A.colNum(), 'A must be square'); let basis = []; for (let i = 0;i &lt; A.colNum();i++) &#123; basis.push(A.colVector(i)); &#125; let P = gramSchmidtProcess(basis); let q = []; for (let p of P) &#123; q.push(p.div(p.norm())); &#125; let Q = (new Matrix(q)).T(); let R = Q.T().dot(A); return [Q, R];&#125;console.log(qr(new Matrix([ [1,1,2], [1,1,0], [1,0,0]])))","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"12、OpenGL 之多级渐远纹理","slug":"OpenGL/12、OpenGL 之多级渐远纹理","date":"2020-05-26T06:00:00.000Z","updated":"2020-08-07T14:20:18.546Z","comments":true,"path":"2020/05/26/OpenGL/12、OpenGL 之多级渐远纹理/","link":"","permalink":"https://www.zackaddy.xin/2020/05/26/OpenGL/12、OpenGL 之多级渐远纹理/","excerpt":"","text":"OpenGL 之多级渐远纹理在一个场景中，远处的物体和近处的物体有相同高的分辨率，由于远处的物体只能产生很少的片段（这个很好理解吧，透视投影中，近大远小，非常远的物体看起来就像一个点），OpenGL使用高分辨率纹理为这些片段取正确的颜色值是很困难的，它需要对一个跨过纹理很大部分的片段只拾取一个颜色，这一句话可能不太好理解，举个例子，场景中有两个大小相同的正方体A,B，A距离相机比较近，B距离相机比较远，那么A占有的片段就比较多，要知道一个片段是只能取一个颜色的（想一想片段处理器逐片段处理的时候每次返回一个颜色值），B占有的片段就比较少，我们讨论一下极限值，B假如就占有一个片段，那这个片段就只能有一个颜色值，此时B占有的片段是对应着整个纹理的，那它如何来拾取纹理颜色呢，而与B相比，A在进行纹理采样时就比较好采集。所以，对B来说它应该选用一个低分辨率的图片，假设它只有一个片段，而B的纹理是一个只有一个像素的图片，那么颜色不就正好对应上了吗，而且低分辨率的图片还大大节省了内存资源。 OpenGL使用多级渐远纹理(Mipmap)来解决这个问题，它就是一系列的纹理图像，后一个纹理是前一个纹理的1/2，依次类推。 它的原理就是把摄像机到物体的距离与阙值作比较，在不同的距离空间内选用不同的纹理图像。即最适合物体的距离的那个。 OpenGL有一个生成Mipmap的函数，glGenerateMipmap(); 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界，生硬边界到底什么意思呢：这个通常在阙值处出现，比如纹理级别2和3在它对应的阙值距离处就会因为两张纹理不同的分辨率产生生硬边界，切换多级渐远纹理级别时，我们也可以在两个纹理级别之间进行NEAREST和LINEAR过滤。 过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"57、LinearAlgebra 之标准正交基的性质","slug":"LinearAlgebra/57、LinearAlgebra 之标准正交基的性质","date":"2020-05-26T05:00:00.000Z","updated":"2020-08-07T14:10:11.811Z","comments":true,"path":"2020/05/26/LinearAlgebra/57、LinearAlgebra 之标准正交基的性质/","link":"","permalink":"https://www.zackaddy.xin/2020/05/26/LinearAlgebra/57、LinearAlgebra 之标准正交基的性质/","excerpt":"","text":"LinearAlgebra 之标准正交基的性质12345一组n维标准正交基\\overrightharpoon&#123;v_1&#125;,\\overrightharpoon&#123;v_2&#125;,\\overrightharpoon&#123;v_3&#125;,...,\\overrightharpoon&#123;v_n&#125;按照列的方式排成一个n阶方阵Q，称Q为标准正交矩阵标准正交矩阵的重要性质：Q^&#123;T&#125; \\cdot Q = I 除了主对角线的元素，其余都是相互正交的两个向量的点乘，结果为0。主对角线实际上是标准正交向量的模，为1。 1 00 4 5 67 8 5 60 0 0 028 32","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"11、OpenGL 之纹理过滤","slug":"OpenGL/11、OpenGL 之纹理过滤","date":"2020-05-26T05:00:00.000Z","updated":"2020-08-07T14:20:18.542Z","comments":true,"path":"2020/05/26/OpenGL/11、OpenGL 之纹理过滤/","link":"","permalink":"https://www.zackaddy.xin/2020/05/26/OpenGL/11、OpenGL 之纹理过滤/","excerpt":"","text":"OpenGL 之纹理过滤纹理像素Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素； 注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEARESTGL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。 当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEARGL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。 一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： 效果对比 GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。 我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"56、LinearAlgebra 之高维投影和Gram-Schmidt实现过程","slug":"LinearAlgebra/56、LinearAlgebra 之高维投影和Gram-Schmidt实现过程","date":"2020-05-25T06:00:00.000Z","updated":"2020-08-07T14:10:11.811Z","comments":true,"path":"2020/05/25/LinearAlgebra/56、LinearAlgebra 之高维投影和Gram-Schmidt实现过程/","link":"","permalink":"https://www.zackaddy.xin/2020/05/25/LinearAlgebra/56、LinearAlgebra 之高维投影和Gram-Schmidt实现过程/","excerpt":"","text":"LinearAlgebra 之高维投影和Gram-Schmidt（格拉姆·斯密特）实现过程简介通过任意维度的一组基构造空间的正交基的算法。 三维空间1234567891011以三维向量为例，假设存在一组三维向量需要求出这三个向量所在空间的正交基其中两个已经处理得到相互正交的向量\\overrightharpoon&#123;p_1&#125;和\\overrightharpoon&#123;p_2&#125;做\\overrightharpoon&#123;w&#125;投影\\overrightharpoon&#123;p&#125;做\\overrightharpoon&#123;w&#125;在\\overrightharpoon&#123;p_1&#125;上的投影\\overrightharpoon&#123;a&#125;做\\overrightharpoon&#123;w&#125;在\\overrightharpoon&#123;p_2&#125;上的投影\\overrightharpoon&#123;b&#125; 四维及以上空间四维以上的空间是无法可视化的，但是与三维空间相似，可以先求取低维度空间的正交基，在其基础上进行高一维度正交基的求取。 给出任何一组n维空间的基，正交基的过程都可以通过逐一维度的计算得到。任何一个维度的向量都减去它在低维度空间中已经正交的向量的投影，这一过程就是Gram-Schmidt过程。 1234567891011121314151617function gramSchmidtProcess(basis) &#123; let matrix = new Matrix(basis); console.assert(rank(matrix) === basis.length); let res = [basis[0]]; for (let i = 1;i &lt; basis.length;i++) &#123; let p = basis[i]; for (let r of res) &#123; p = p.sub(r.mul(basis[i].dot(r) / r.dot(r))) &#125; res.push(p); &#125; return res;&#125;let basis1 = [new Vector([2,1]), new Vector([1,1])]console.log(gramSchmidtProcess(basis1));","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"10、OpenGL 之纹理环绕方式","slug":"OpenGL/10、OpenGL 之纹理环绕方式","date":"2020-05-25T06:00:00.000Z","updated":"2020-08-07T14:20:18.534Z","comments":true,"path":"2020/05/25/OpenGL/10、OpenGL 之纹理环绕方式/","link":"","permalink":"https://www.zackaddy.xin/2020/05/25/OpenGL/10、OpenGL 之纹理环绕方式/","excerpt":"","text":"OpenGL 之纹理环绕方式纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像 OpenGL提供了更多的选择：环绕方式| 描述–|–GL_REPEAT| 对纹理的默认行为。重复纹理图像。GL_MIRRORED_REPEAT| 和GL_REPEAT一样，但每次重复图片是镜像放置的。GL_CLAMP_TO_EDGE| 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。GL_CLAMP_TO_BORDER| 超出的坐标为用户指定的边缘颜色。 每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D 第二个参数需要我们指定设置的选项与应用的纹理轴 最后一个参数需要我们传递一个环绕方式(Wrapping) 如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值： 12float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"55、LinearAlgebra 之一维投影","slug":"LinearAlgebra/55、LinearAlgebra 之一维投影","date":"2020-05-25T05:00:00.000Z","updated":"2020-08-07T14:10:11.811Z","comments":true,"path":"2020/05/25/LinearAlgebra/55、LinearAlgebra 之一维投影/","link":"","permalink":"https://www.zackaddy.xin/2020/05/25/LinearAlgebra/55、LinearAlgebra 之一维投影/","excerpt":"","text":"LinearAlgebra 之一维投影比如列空间、行空间等得到的一组基不能保证是正交的，我们如何保证一组基的正交？如何求出一组基的正交？ 一维投影相当于把一个向量投影到另一个向量，可以进一步求取正交基","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"9、OpenGL 之纹理概述","slug":"OpenGL/9、OpenGL 之纹理概述","date":"2020-05-25T05:00:00.000Z","updated":"2020-08-07T14:20:18.537Z","comments":true,"path":"2020/05/25/OpenGL/9、OpenGL 之纹理概述/","link":"","permalink":"https://www.zackaddy.xin/2020/05/25/OpenGL/9、OpenGL 之纹理概述/","excerpt":"","text":"OpenGL 之纹理概述简介我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。 纹理坐标纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。 我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。 纹理坐标看起来就像这样： 12345float texCoords[] = &#123; 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中&#125;;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"54、LinearAlgebra 之正交基与标准正交基","slug":"LinearAlgebra/54、LinearAlgebra 之正交基与标准正交基","date":"2020-05-24T06:00:00.000Z","updated":"2020-08-07T14:10:11.811Z","comments":true,"path":"2020/05/24/LinearAlgebra/54、LinearAlgebra 之正交基与标准正交基/","link":"","permalink":"https://www.zackaddy.xin/2020/05/24/LinearAlgebra/54、LinearAlgebra 之正交基与标准正交基/","excerpt":"","text":"LinearAlgebra 之正交基与标准正交基12345678910111213一个n维空间中任何一组线性无关的向量，都是这个n维空间的一组基。当这组基的向量两两垂直，则称为正交基。而标准正交基只是将正交基又添加了一个条件，模长为1。一个空间可以有无数组基向量，正交基和标准正交基也同样是有无数组的。正交基的好处在于可以很方便地表示空间中的点，用数学语言表示为，两个向量u和v的乘积，\\overrightharpoon&#123;u&#125; \\cdot \\overrightharpoon&#123;\\nu&#125; = u_&#123;1&#125; \\cdot v_&#123;1&#125; + u_&#123;2&#125; \\cdot v_&#123;2&#125; + ... + u_&#123;n&#125; \\cdot v_&#123;n&#125; = ||\\overrightharpoon&#123;u&#125;|| \\cdot ||\\overrightharpoon&#123;\\nu&#125;|| \\cdot \\cos\\theta当θ=90°时，cosθ=0，相应的 \\overrightharpoon&#123;u&#125; \\cdot \\overrightharpoon&#123;\\nu&#125; = 0，称这两个向量相互垂直或相互正交。 正交向量组则是一组向量，任意两个向量都满足正交的关系，则称为正交向量组。正交向量组的一个很好的性质是，正交非零向量组一定线性无关。这一性质的证明并不复杂，","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"8、OpenGL 之着色器","slug":"OpenGL/8、OpenGL 之着色器","date":"2020-05-24T06:00:00.000Z","updated":"2020-08-07T14:20:18.530Z","comments":true,"path":"2020/05/24/OpenGL/8、OpenGL 之着色器/","link":"","permalink":"https://www.zackaddy.xin/2020/05/24/OpenGL/8、OpenGL 之着色器/","excerpt":"","text":"OpenGL 之着色器简介 着色器只是一种把输入转化为输出的程序 着色器也是一种非常独立的程序，因为它们之间不能相互通信； 它们之间唯一的沟通只有通过输入和输出。 GLSL 着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。 一个典型的着色器有下面的结构：123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main()&#123; // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;&#125; 每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限： 123int nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);std::cout &lt;&lt; \"Maximum nr of vertex attributes supported: \" &lt;&lt; nrAttributes &lt;&lt; std::endl; 数据类型 GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。 GLSL也有两种容器类型，分别是向量(Vector)和矩阵(Matrix) 类型| 含义 vecn | 包含n个float分量的默认向量bvecn | 包含n个bool分量的向量ivecn | 包含n个int分量的向量uvecn | 包含n个unsigned int分量的向量dvecn | 包含n个double分量的向量 向量重组一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。 向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法： 1234vec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy; 可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可； 不允许在一个vec2向量中去获取.z元素 向量构造传参也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量： 123vec2 vect = vec2(0.5, 0.7);vec4 result = vec4(vect, 0.0, 0.0);vec4 otherResult = vec4(result.xyz, 1.0); 输入与输出 着色器是各自独立的小程序，它们都是一个整体的一部分 每个着色器都有输入和输出进行数据交流和传递，GLSL定义了in和out 顶点着色器的输入特殊在，它从顶点数据中直接接收输入 顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。 示例 顶点着色器 12345678910#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main()&#123; gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色&#125; 片段着色器 123456789#version 330 coreout vec4 FragColor;in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main()&#123; FragColor = vertexColor;&#125; Uniform Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式 uniform和顶点属性有些不同 uniform是全局的(Global)。在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问 把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 让三角形颜色随时间变化123456789#version 330 coreout vec4 FragColor;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main()&#123; FragColor = ourColor;&#125; 12345float timeValue = glfwGetTime();float greenValue = (sin(timeValue) / 2.0f) + 0.5f;int vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你必须先调用glUseProgram，因为它是在当前激活的着色器程序中设置uniform的。 glUniform后缀 后缀 含义 f 函数需要一个float作为它的值 i 函数需要一个int作为它的值 ui 函数需要一个unsigned int作为它的值 3f 函数需要3个float作为它的值 fv 函数需要一个float向量/数组作为它的值 存在位置和颜色的顶点数据123456float vertices[] = &#123; // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部&#125;; 1234567891011#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0 layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1out vec3 ourColor; // 向片段着色器输出一个颜色void main()&#123; gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色&#125; 12345678#version 330 coreout vec4 FragColor; in vec3 ourColor;void main()&#123; FragColor = vec4(ourColor, 1.0);&#125; 123456// 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));glEnableVertexAttribArray(1);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"53、LinearAlgebra 之左零空间，四大子空间和研究子空间的原因","slug":"LinearAlgebra/53、LinearAlgebra 之左零空间，四大子空间和研究子空间的原因","date":"2020-05-24T05:00:00.000Z","updated":"2020-08-07T14:10:11.810Z","comments":true,"path":"2020/05/24/LinearAlgebra/53、LinearAlgebra 之左零空间，四大子空间和研究子空间的原因/","link":"","permalink":"https://www.zackaddy.xin/2020/05/24/LinearAlgebra/53、LinearAlgebra 之左零空间，四大子空间和研究子空间的原因/","excerpt":"","text":"LinearAlgebra 之左零空间，四大子空间和研究子空间的原因矩阵的列空间与之对应的是矩阵的零空间。理论上也会存在一个与矩阵的行空间对应的空间，可以使用 Null(A^T) )进行表示，称为左零空间。 研究子空间的意义子空间的维度比原空间的维度低，尤其是面对维度很高的数据时，不仅难分析而且计算量极大。如果可以降维，可以简化问题的研究。 在实际的研究中，很多情况下都会遇到 Ax=b，这样的线性系统，若A的行数大于列数（可以理解为样本数目大于特征数目），即方程数大于未知数个数。此时线性系统是无解的，因此很难学习到有用的知识。在A的列空间中寻找一个离b最近的b′。转而求解 Ax=b′","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"7、OpenGL 之索引缓冲对象","slug":"OpenGL/7、OpenGL 之索引缓冲对象","date":"2020-05-24T05:00:00.000Z","updated":"2020-08-07T14:20:18.525Z","comments":true,"path":"2020/05/24/OpenGL/7、OpenGL 之索引缓冲对象/","link":"","permalink":"https://www.zackaddy.xin/2020/05/24/OpenGL/7、OpenGL 之索引缓冲对象/","excerpt":"","text":"OpenGL 之索引缓冲对象绘制一个矩形我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形） 这会生成下面的顶点的集合 12345678910float vertices[] = &#123; // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;; 可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了 索引缓冲对象只要储存4个顶点和两个三角形的索引就能绘制矩形了 和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引： 1234567891011float vertices[] = &#123; 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角&#125;;unsigned int indices[] = &#123; // 注意索引从0开始! 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形&#125;; 当时用索引的时候，我们只定义了4个顶点，而不是6个。 初始化代码如下 1234567891011121314151617181920// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);[...]// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0); 第一个参数指定了我们绘制的模式 第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。 第三个参数是索引的类型，这里是GL_UNSIGNED_INT。 最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。1glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"52、LinearAlgebra 之零空间 与 秩-零化度定理","slug":"LinearAlgebra/52、LinearAlgebra 之零空间 与 秩-零化度定理","date":"2020-05-23T06:00:00.000Z","updated":"2020-08-07T14:10:11.810Z","comments":true,"path":"2020/05/23/LinearAlgebra/52、LinearAlgebra 之零空间 与 秩-零化度定理/","link":"","permalink":"https://www.zackaddy.xin/2020/05/23/LinearAlgebra/52、LinearAlgebra 之零空间 与 秩-零化度定理/","excerpt":"","text":"LinearAlgebra 之零空间 与 秩-零化度定理 主元列有2个 自由列有4个 零空间的维度为4 零空间的基为下图4个向量 秩（rank）+ 零化度（Nullity）= n 列空间与零空间对比对于一个m×n的矩阵， 列空间 零空间 Ax=v(v任取) Ax=0 列空间是m维空间的子空间 零空间是n维空间的子空间 列空间的维度是行最简形式中主元列的数目 零空间的维度是行最简形式中自由列的数目 主元列对应原矩阵的列，是列空间的一组基 求取零空间的基需要求解齐次线性系统 当行最简形式不存在自由列时，零空间的维度为0。此时矩阵是满秩的。因为矩阵满秩的等价命题是矩阵存在逆矩阵，所以在矩阵可逆的命题中又多了一条等价命题。 A的零空间就是Ax=0中，所有x组成的空间 零空间是一个集合，这个集合中的所有向量与A的行向量的点乘结果为0 这个集合中所有的向量与A的行空间中所有的向量垂直(正交)","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"6.2、OpenGL 之glEnableVertexAttribArray函数","slug":"OpenGL/6.2、OpenGL 之glEnableVertexAttribArray函数","date":"2020-05-23T06:00:00.000Z","updated":"2020-08-07T14:20:18.521Z","comments":true,"path":"2020/05/23/OpenGL/6.2、OpenGL 之glEnableVertexAttribArray函数/","link":"","permalink":"https://www.zackaddy.xin/2020/05/23/OpenGL/6.2、OpenGL 之glEnableVertexAttribArray函数/","excerpt":"","text":"OpenGL 之glEnableVertexAttribArray函数简介使vbo的内存变为可用状态。 glEnableVertexAttribArray的作用及调用位置对于OpenGL ES 3.0，可使用至少16个顶点属性，可查询具体实现的支持数量。 12GLint maxVertexAttribs;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;maxVertexAttribs); 函数glEnableVertexAttribArray功能默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的，意味着数据在着色器端是不可见的，哪怕数据已经上传到GPU，由glEnableVertexAttribArray启用指定属性，才可在顶点着色器中访问逐顶点的属性数据。 glVertexAttribPointer或VBO只是建立CPU和GPU之间的逻辑连接，从而实现了CPU数据上传至GPU。 但是，数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。 什么时候调用glEnableVertexAttribArray那么，glEnableVertexAttribArray应该在glVertexAttribPointer之前还是之后调用？ 答案是都可以，只要在绘图调用（glDraw*系列函数）前调用即可。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"51、LinearAlgebra 之零空间与看待零空间的三个视角","slug":"LinearAlgebra/51、LinearAlgebra 之零空间与看待零空间的三个视角","date":"2020-05-23T05:00:00.000Z","updated":"2020-08-07T14:10:11.810Z","comments":true,"path":"2020/05/23/LinearAlgebra/51、LinearAlgebra 之零空间与看待零空间的三个视角/","link":"","permalink":"https://www.zackaddy.xin/2020/05/23/LinearAlgebra/51、LinearAlgebra 之零空间与看待零空间的三个视角/","excerpt":"","text":"LinearAlgebra 之零空间与看待零空间的三个视角 上图u v是Ax = 0的解 一个齐次线性方程组的所有解，形成一个向量空间。称这个空间，为零空间（Null Space） A的零空间，就是Ax=0中，所有x组成的空间 零空间是一个集合，这个集合中的所有的向量，和A的行向量点乘结果为0！ 矩阵A的零空间 把A看作系统：A的零空间，就是Ax=0中，所有x（解）组成的空间。 把A看作函数（变换）：A的零空间，所有被A变化为0的向量所组成的空间 把A看作空间：A的零空间，是和A的行空间正交的向量空间","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"6.1、OpenGL 之相同三角形与不同VAO和VBO代码练习","slug":"OpenGL/6.1、OpenGL 之相同三角形与不同VAO和VBO代码练习","date":"2020-05-23T05:00:00.000Z","updated":"2020-08-07T14:20:18.517Z","comments":true,"path":"2020/05/23/OpenGL/6.1、OpenGL 之相同三角形与不同VAO和VBO代码练习/","link":"","permalink":"https://www.zackaddy.xin/2020/05/23/OpenGL/6.1、OpenGL 之相同三角形与不同VAO和VBO代码练习/","excerpt":"","text":"OpenGL 之相同三角形与不同VAO和VBO代码练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;using namespace std;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);const unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;const char *vertexShaderSource = \"#version 430 core\\n\"\"layout (location = 0) in vec3 aPos;\\n\"\"void main()\\n\"\"&#123;\\n\"\" gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"\"&#125;\\0\";const char *fragmentShaderSource = \"#version 430 core\\n\"\"out vec4 FragColor;\\n\"\"void main()\\n\"\"&#123;\\n\"\" FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"\"&#125;\\n\\0\";int main()&#123; // GLFW: 初始化和配置 // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X#endif // GLFW 创建窗口 // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: 加载所有OpenGL函数指针 // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl; return -1; &#125; // 构建和编译着色器程序 // ------------------------------------ // 顶点着色器 int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); // 检查着色器是否编译错误 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // 片段着色器 int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); // 检查着色器是否编译错误 glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; // 链接所有着色器 int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // 检查链接错误 glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; glDeleteShader(vertexShader); glDeleteShader(fragmentShader); // 设置顶点数据(和缓冲区)并配置顶点属性 // ------------------------------------------------------------------ float firstTriangle[] = &#123; -0.9f, -0.5f, 0.0f, // left -0.0f, -0.5f, 0.0f, // right -0.45f, 0.5f, 0.0f, // top &#125;; float secondTriangle[] = &#123; 0.0f, -0.5f, 0.0f, // left 0.9f, -0.5f, 0.0f, // right 0.45f, 0.5f, 0.0f // top &#125;; unsigned int VBOs[2], VAOs[2]; glGenVertexArrays(2, VAOs); // 我们还可以同时生成多个VAOs或缓冲区 glGenBuffers(2, VBOs); // 第一个三角形的设置 // -------------------- glBindVertexArray(VAOs[0]); glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]); glBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // glBindVertexArray(0); // 不需要取消绑定，因为我们在接下来几行直接绑定一个不同的VAO // 第二个三角形的设置 // --------------------- glBindVertexArray(VAOs[1]); // 注意，我们现在绑定到一个不同的VAO glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]); // 和一个不同的VBO glBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0); glEnableVertexAttribArray(0); // glBindVertexArray(0); // 这里也不是必须的，但是要注意glBindVertexArray在绑定时可能影响VAOs的调用(比如绑定元素缓冲对象glBindBuffer，或者启用/禁用顶点属性glEnableVertexAttribArray) // 取消注释则开启绘制线框模式 //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // 循环渲染 // ----------- while (!glfwWindowShouldClose(window)) &#123; // 输入 // ----- processInput(window); // 渲染 // ------ glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(shaderProgram); // 使用第一个VAO绘制第一个三角形 glBindVertexArray(VAOs[0]); glDrawArrays(GL_TRIANGLES, 0, 3); // 然后我们使用第二个VAO绘制第二个三角形 glBindVertexArray(VAOs[1]); glDrawArrays(GL_TRIANGLES, 0, 3); // GLFW: 交换缓冲区和轮询IO事件(按键按下/释放，鼠标移动等) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // 可选择: 一旦它们失去了意义，释放所有资源 // ------------------------------------------------------------------------ glDeleteVertexArrays(2, VAOs); glDeleteBuffers(2, VBOs); // GLFW: 终止, 清除所有已经分配的GLFW资源。 // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// 处理所有输入:查询此函数中的相关键是否按下/释放并做出相应的反应// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// GLFW: 每当窗口大小改变(通过操作系统或用户调整大小)，这个回调函数就会执行// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // 确保viewport与新的窗口尺寸匹配 glViewport(0, 0, width, height);&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"50、LinearAlgebra 之实现矩阵的秩","slug":"LinearAlgebra/50、LinearAlgebra 之实现矩阵的秩","date":"2020-05-22T06:00:00.000Z","updated":"2020-08-07T14:10:11.810Z","comments":true,"path":"2020/05/22/LinearAlgebra/50、LinearAlgebra 之实现矩阵的秩/","link":"","permalink":"https://www.zackaddy.xin/2020/05/22/LinearAlgebra/50、LinearAlgebra 之实现矩阵的秩/","excerpt":"","text":"LinearAlgebra 之实现矩阵的秩123456789101112131415// 维度function rank(A) &#123; let ls = new LinearSystem(A); ls.gaussJordanElimination(); console.log(ls) let zero = Vector.zero(A.colNum()); let count = 0; for (let i = 0;i &lt; ls.Ab.length;i++) &#123; let row = ls.Ab[i]; if (!row.equal(zero)) &#123; count++; &#125; &#125; return count;&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"6.0、OpenGL 之VBO与VAO","slug":"OpenGL/6.0、OpenGL 之VBO与VAO","date":"2020-05-22T06:00:00.000Z","updated":"2020-08-07T14:20:18.513Z","comments":true,"path":"2020/05/22/OpenGL/6.0、OpenGL 之VBO与VAO/","link":"","permalink":"https://www.zackaddy.xin/2020/05/22/OpenGL/6.0、OpenGL 之VBO与VAO/","excerpt":"","text":"OpenGL 之VBO与VAOOpenGL渲染时涉及到的数据传输 准备好需要绘制的顶点数据。（自己定义的或者是从某些模型文件中读取出来的） 在GPU中开辟一块内存。 将顶点数据传到上一步开辟的GPU的内存中。 将着色器代码转化为着色器程序，并链接到当前的执行程序中。 GPU根据着色器的逻辑将这块内存的数据进行计算。（指定该如何将数据发送给显卡） 将这块已经计算完的数据一并发送给显卡进行渲染绘制。 GPU的内存通过顶点缓冲对象(Vertex Buffer Objects)，也就是VBO来管理这个内存，它会在GPU内存(通常被称为显存)中储存大量顶点。 使用这VBO的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。 glGenBuffers 生成顶点缓冲对象VBO这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer 为顶点缓冲对象绑定类型OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上： 1glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData 顶点数据复制到VBO管理的GPU开辟的一块内存中glBufferData是一个专门用来把顶点数据复制到由VBO管理的GPU开辟的一块内存中： 1glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 位置数据不会改变，每次渲染调用时都保持原样，使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。 指定OpenGL该如何解释VBO中的顶点数据12345float vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f&#125;; 顶点数据传入GPU之后，还需要通知OpenGL如何解释这些顶点数据，这个工作由函数glVertexAttribPointer完成 1glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); //设置顶点属性（索引为0的属性,与shader中的 layout (location = 0) 内容有交互 ） 指定顶点数据的哪一个部分对应顶点着色器的哪一个顶点属性，也就是在渲染前指定OpenGL该如何解释VBO中的顶点数据。glVertexAttribPointer中的参数的意义分别是： 第一个参数为顶点着色器中layout (location=0) in vec3 position;中的location的值。 第二个参数为第二个参数指定顶点属性的维数，如果是vec3，它由3个值组成，所以大小是3。 第三个参数为数据的类型。 第四个参数为是否希望数据被标准化，如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。设置为0的意思是让OpenGL自己去识别步长。 最后一个参数表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。 使VBO管理的顶点数据在着色器中可见1glEnableVertexAttribArray(0); //设置开启顶点属性（索引为0的属性,与shader中的 layout (location = 0) 内容有交互 ） VAO（Vertex Arrary Object，VAO）VBO保存了一个模型的顶点属性信息，每次绘制模型之前需要绑定顶点的所有信息，当数据量很大时，重复这样的动作变得非常麻烦。VAO可以把这些所有的配置都存储在一个对象中，每次绘制模型时，只需要绑定这个VAO对象就可以了。 VAO是一个保存了所有顶点数据属性的状态结合，它存储了顶点数据的格式以及顶点数据所需的VBO对象的引用。 VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理。 VAO对象中存储的内容包括： VAO开启或者关闭的状态（glEnableVertexAttribArray和glDisableVertexAttribArray) 使用glVertexAttribPointer对顶点属性进行的设置 存储顶点数据的VBO对象 设置当前VAO，之后所有操作存储在该VAO中（注意：这些操作必须是上文VAO中包含的内容所注明的调用，其他非VAO中存储的内容即使调用了也不会影响VAO） 创建VAO使用 glGenVertexArrays的参数与glGenBuffers类似 1void glGenVertexArrays(GLsizei n, GLuint *arrays); 在创建VAO之后，需要使用glBindVertexArray设置它为当前操作的VAO，之后我们所有关于顶点数据的设置（包括数据使用的VBO对象，顶点的属性设置的信息都会被存储在VAO之中），在设置完成之后一般会解绑VAO，然后在需要绘制的时候启用相应的VAO对象。 12345678910//创建VAOGLuint VAO;glGenVertexArrays(1, &amp;VAO);//设置当前VAO，之后所有操作(注意：这些操作必须是上文VAO中包含的内容所注明的调用，其他非VAO中存储的内容即使调用了也不会影响VAO）存储在该VAO中glBindVertexArray(VAO);glBindBuffer(GL_ARRAY_BUFFER, VBO); //设置了VBOglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);//设置VBO中的数据glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); //设置顶点属性（索引为0的属性，与shader中的内容有交互）glEnableVertexAttribArray(0); //设置开启顶点属性（索引为0的属性,与shader中的内容有交互）glBindVertexArray(0); //解绑VAO（解绑主要是为了不影响后续VAO的设置，有点类似于C++中指针delete后置空，是个好习惯） 循环操作如下 1234glUseProgram(shaderProgram);glBindVertexArray(VAO); // 如果我们只有一个VAO，就没有必要每次都绑定它，这样做是为了让事情更有条理一些glDrawArrays(GL_TRIANGLES, 0, 3);glBindVertexArray(0);","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"49、LinearAlgebra 之矩阵的秩和矩阵的逆","slug":"LinearAlgebra/49、LinearAlgebra 之矩阵的秩和矩阵的逆","date":"2020-05-22T05:00:00.000Z","updated":"2020-08-07T14:10:11.809Z","comments":true,"path":"2020/05/22/LinearAlgebra/49、LinearAlgebra 之矩阵的秩和矩阵的逆/","link":"","permalink":"https://www.zackaddy.xin/2020/05/22/LinearAlgebra/49、LinearAlgebra 之矩阵的秩和矩阵的逆/","excerpt":"","text":"LinearAlgebra 之矩阵的秩和矩阵的逆 123456789101112\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; ... &amp; 0 &amp; f_&#123;00&#125; &amp; ... &amp; f_&#123;0j&#125; \\\\ 0 &amp; 1 &amp; ... &amp; 0 &amp; f_&#123;10&#125; &amp; ... &amp; f_&#123;1j&#125; \\\\ ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\ 0 &amp; 0 &amp; ... &amp; 1 &amp; f_&#123;r0&#125; &amp; ... &amp; f_&#123;rj&#125; \\\\ 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 &amp; ... &amp; 0 \\\\ ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\\\ 0 &amp; 0 &amp; ... &amp; 0 &amp; 0 &amp; ... &amp; 0 \\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; I &amp; F \\\\ O &amp; O\\end&#123;pmatrix&#125; 矩阵的秩（Rank）行秩：行最简形式非零行数 列秩：行最简形式主元列数 一个矩阵的行空间和列空间维度相等！ 满秩对于一个n阶矩阵 矩阵的秩r=n，满秩（Full Rank） 行最简形式的非零行个数为n 行最简形式的主元列个数为n 行最简形式为I","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"5、OpenGL 之使用着色器","slug":"OpenGL/5、OpenGL 之使用着色器","date":"2020-05-22T05:00:00.000Z","updated":"2020-08-07T14:20:18.508Z","comments":true,"path":"2020/05/22/OpenGL/5、OpenGL 之使用着色器/","link":"","permalink":"https://www.zackaddy.xin/2020/05/22/OpenGL/5、OpenGL 之使用着色器/","excerpt":"","text":"OpenGL 之使用着色器顶点着色器顶点着色器(Vertex Shader)是几个可编程着色器中的一个。 它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。 编写GLSL顶点着色器完整代码如下 1234567#version 330 corelayout (location = 0) in vec3 aPos;void main()&#123; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);&#125; 下方代码声明OpenGL版本号和模式，下方为OpenGL 3.3以及和更高版本中，明确表示我们会使用核心模式。 1#version 330 core 通过layout (location = 0)设定了输入变量的位置值(Location) 1layout (location = 0) in vec3 aPos; 将gl_Position设置的值会成为该顶点着色器的输出 1gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); 编译顶点着色器12345678910111213141516171819202122232425262728293031const char *vertexShaderSource = \"#version 330 core\\n\" \"layout (location = 0) in vec3 aPos;\\n\" \"void main()\\n\" \"&#123;\\n\" \" gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\" \"&#125;\\0\";int vertexShader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader);// check for shader compile errorsint success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);if (!success)&#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl;&#125;// link shadersint shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glLinkProgram(shaderProgram);// check for linking errorsglGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl;&#125;glDeleteShader(vertexShader); 编写GLSL片段着色器完整代码如下 1234567#version 330 coreout vec4 FragColor;void main()&#123; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);&#125; 下方代码声明OpenGL版本号和模式，下方为OpenGL 3.3以及和更高版本中，明确表示我们会使用核心模式。 1#version 330 core 用out关键字声明输出变量 1out vec4 FragColor; 将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。 1FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f); 编译顶点着色器与编译顶点着色器相同","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"48、LinearAlgebra 之列空间","slug":"LinearAlgebra/48、LinearAlgebra 之列空间","date":"2020-05-21T06:00:00.000Z","updated":"2020-08-07T14:10:11.809Z","comments":true,"path":"2020/05/21/LinearAlgebra/48、LinearAlgebra 之列空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/21/LinearAlgebra/48、LinearAlgebra 之列空间/","excerpt":"","text":"LinearAlgebra 之列空间 主元列的个数为维度！ 主元列的个数，为列秩。（Column Rank） 对于一个矩阵。列向量生成的空间，称为空间（Column Space） m行n列，列空间是m维空间的子空间 一个矩阵的行最简形式的主元列数量称为矩阵的列秩 列空间的维度，为矩阵的列秩 行最简形式主元列对应原矩阵的列，是列空间的一组基 对于一个m行n列矩阵行空间 | 列空间 行空间是n为空间的子空间 | 列空间是m维空间的子空间行最简形式的非零行个数为矩阵的行秩 | 行最简形式的主元列个数为矩阵的列秩行空间的维度，为矩阵的行秩 | 列空间的维度为矩阵的列秩行最简形式的非零行是行空间的一组基 | 主元列对应原矩阵的列是列空间的一组基","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"4、OpenGL 之图形渲染管线概述","slug":"OpenGL/4、OpenGL 之图形渲染管线概述","date":"2020-05-21T06:00:00.000Z","updated":"2020-08-07T14:20:18.503Z","comments":true,"path":"2020/05/21/OpenGL/4、OpenGL 之图形渲染管线概述/","link":"","permalink":"https://www.zackaddy.xin/2020/05/21/OpenGL/4、OpenGL 之图形渲染管线概述/","excerpt":"","text":"OpenGL 之图形渲染管线概述眼熟几个术语 顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO 在OpenGL 之VBO与VAO中会详细说明 图形渲染管线（GraphicsPipeline） 大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程） 图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。 图形渲染管线可以被划分为两个主要部分 第一部分把你的3D坐标转换为2D坐标 第二部分是把2D坐标转变为实际的有颜色的像素 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。 所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。 正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为渲染管线每一个阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。 有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的 下面为图形渲染管线的每个阶段的抽象展示，蓝色部分代表的是我们可以注入自定义的着色器的部分。 首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。 而顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据。 (但是简单起见，我们还是假定每个顶点只有一个3D位置和一些颜色值组成的。) 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。 我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？ 做出的这些提示叫做图元(Primitive) 任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 顶点着色器(Vertex Shader)它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。 图元装配(Primitive Assembly)将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状 几何着色器(Geometry Shader)几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。上图中，它生成了另一个三角形。 光栅化阶段(Rasterization Stage)把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。片段：OpenGL渲染一个像素所需的所有数据。 片段着色器(Fragment Shader) 主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。 通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段 Alpha测试和混合(Blending)阶段 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。 这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend) 所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"47、LinearAlgebra 之行空间和矩阵的行秩","slug":"LinearAlgebra/47、LinearAlgebra 之行空间和矩阵的行秩","date":"2020-05-21T05:00:00.000Z","updated":"2020-08-07T14:10:11.809Z","comments":true,"path":"2020/05/21/LinearAlgebra/47、LinearAlgebra 之行空间和矩阵的行秩/","link":"","permalink":"https://www.zackaddy.xin/2020/05/21/LinearAlgebra/47、LinearAlgebra 之行空间和矩阵的行秩/","excerpt":"","text":"LinearAlgebra 之行空间和矩阵的行秩 123456789101112131415对于一个矩阵 行向量生成的空间，称为行空间（Row Space）列向量生成的空间，称为列空间（Column Space）3行4列 \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\\\ 9 &amp; 10 &amp; 11 &amp; 12\\end&#123;pmatrix&#125; 行空间是4维空间的子集列空间是3维空间的子集m行n列，行空间是n维向量的子集m行n列，列空间是m维向量的子集 对于一个矩阵，行向量生成的空间，称为行空间（Row Space） m行n列，行空间是n维空间的子集 行空间的维度&lt;=n 求法如下！ 上方非0行为生成空间的维度 一个矩阵的行最简形式的非零行数量称为矩阵的行秩（Row Rank） 行空间的维度，为矩阵的秩 一个矩阵行最简形式的非零行向量，是A的行空间的基","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"3、OpenGL 之顶点输入","slug":"OpenGL/3、OpenGL 之顶点输入","date":"2020-05-21T05:00:00.000Z","updated":"2020-08-07T14:20:18.494Z","comments":true,"path":"2020/05/21/OpenGL/3、OpenGL 之顶点输入/","link":"","permalink":"https://www.zackaddy.xin/2020/05/21/OpenGL/3、OpenGL 之顶点输入/","excerpt":"","text":"OpenGL 之顶点输入简介 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。 OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。 OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素； OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。 所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。 渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。 12345float vertices[] = &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f&#125;; 由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth)都是一样的，从而使它看上去像是2D的。 定义这样的顶点数据以后（float vertices[]），我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。 顶点着色器会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。 glGenBuffers 生成顶点缓冲对象VBO这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); glBindBuffer 为顶点缓冲对象绑定类型OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上： 1glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData 顶点数据复制到缓冲的内存中glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它会把之前定义的顶点数据复制到缓冲的内存中： 1glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"46、LinearAlgebra 之维度","slug":"LinearAlgebra/46、LinearAlgebra 之维度","date":"2020-05-20T06:00:00.000Z","updated":"2020-08-07T14:10:11.808Z","comments":true,"path":"2020/05/20/LinearAlgebra/46、LinearAlgebra 之维度/","link":"","permalink":"https://www.zackaddy.xin/2020/05/20/LinearAlgebra/46、LinearAlgebra 之维度/","excerpt":"","text":"LinearAlgebra 之维度 一个（欧几里得）空间的任何一组基，其中的向量个数是相同的。 一个欧几里得空间的维度是固定的 一个欧几里得空间中的每一个有序实数元组包含n个元素，这个空间的维度为n？（在子空间的概念下此条是错误的） 123一组向量 \\overrightharpoon&#123;\\nu&#125;_1,\\overrightharpoon&#123;\\nu&#125;_2,\\overrightharpoon&#123;\\nu&#125;_3,...,\\overrightharpoon&#123;\\nu&#125;_p属于空间V，则它们生成的空间是V的子空间一组n维向量 \\overrightharpoon&#123;\\nu&#125;_1,\\overrightharpoon&#123;\\nu&#125;_2,\\overrightharpoon&#123;\\nu&#125;_3,...,\\overrightharpoon&#123;\\nu&#125;_p的生成空间，是n维空间的子空间。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"2、OpenGL 之GLFW和GLAD简介与VS2017环境搭建","slug":"OpenGL/2、OpenGL 之GLFW和GLAD简介与VS2017环境搭建","date":"2020-05-20T06:00:00.000Z","updated":"2020-08-07T14:20:18.499Z","comments":true,"path":"2020/05/20/OpenGL/2、OpenGL 之GLFW和GLAD简介与VS2017环境搭建/","link":"","permalink":"https://www.zackaddy.xin/2020/05/20/OpenGL/2、OpenGL 之GLFW和GLAD简介与VS2017环境搭建/","excerpt":"","text":"OpenGL 之GLFW和GLAD简介与VS2017环境搭建GLFW简介GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入 节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染 GLAD简介因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异 1234567// 定义函数原型typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);// 找到正确的函数并赋值给函数指针GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)wglGetProcAddress(\"glGenBuffers\");// 现在函数可以被正常调用了GLuint buffer;glGenBuffers(1, &amp;buffer); 我们需要对每个可能使用的函数都要重复这个过程，GLAD能简化此过程。 opengl环境搭建参考地址https://blog.csdn.net/sigmarising/article/details/80470054","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"45、LinearAlgebra 之直观理解欧几里得空间的子空间","slug":"LinearAlgebra/45、LinearAlgebra 之直观理解欧几里得空间的子空间","date":"2020-05-20T05:00:00.000Z","updated":"2020-08-07T14:10:11.808Z","comments":true,"path":"2020/05/20/LinearAlgebra/45、LinearAlgebra 之直观理解欧几里得空间的子空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/20/LinearAlgebra/45、LinearAlgebra 之直观理解欧几里得空间的子空间/","excerpt":"","text":"LinearAlgebra 之直观理解欧几里得空间的子空间并不是二维欧几里得空间中所有的直线都是子空间 不经过原点的直线 经过原点的射线 原点也可以看做是二维欧几里得空间的子空间。 对于三维空间来说： 过原点的一个平面，是三维空间的一个子空间 过原点的一个直线，是三维空间的一个子空间 原点本身，是三维空间的一个子空间！ 对于n维空间来说：： 过原点的一个m维空间（m &lt; n），是n维空间的一个子空间","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"1、OpenGL 之基本术语","slug":"OpenGL/1、OpenGL 之基本术语","date":"2020-05-20T05:00:00.000Z","updated":"2020-08-07T14:20:18.490Z","comments":true,"path":"2020/05/20/OpenGL/1、OpenGL 之基本术语/","link":"","permalink":"https://www.zackaddy.xin/2020/05/20/OpenGL/1、OpenGL 之基本术语/","excerpt":"","text":"OpenGL 之基本术语标准化设备坐标(Normalized Device Coordinates, NDC) 一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。 任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。 下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)： 与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。 你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是通过glViewport函数进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。 深度通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。 片段OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。 向量(Vector)在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过vec.x、vec.y、vec.z和vec.w来获取。注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。 顶点数据顶点数据是一系列顶点的集合。 一个顶点(Vertex)是一个3d坐标的数据的集合。 而顶点的数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据。 (但是简单起见，我们还是假定每个顶点只有一个3D位置和一些颜色值组成的。) 图元为了让openGL知道我们的坐标和颜色值构成的到底是什么，openGL需要你去指定这些数据所表示的渲染类型。 我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出这些提示的叫做图元(Primitive) 任何一个绘制指令的调用都将把图元传递给openGL。这是其中的几个： GL_POINTS 、GL_TRIANGLES、 GL_LINE_STRIP。 颜色向量(Color Vector)一个通过红绿蓝(RGB)分量的组合描绘大部分真实颜色的向量。一个物体的颜色实际上是该物体所不能吸收的反射颜色分量。 冯氏光照模型(Phong Lighting Model)：一个通过计算环境光，漫反射，和镜面光分量的值来估计真实光照的模型。 环境光照(Ambient Lighting)：通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。 漫反射着色(Diffuse Shading)：一个顶点/片段与光线方向越接近，光照会越强。使用了法向量来计算角度。 法向量(Normal Vector)：一个垂直于平面的单位向量。 法线矩阵(Normal Matrix)：一个3x3矩阵，或者说是没有平移的模型（或者模型-观察）矩阵。它也被以某种方式修改（逆转置），从而在应用非统一缩放时，保持法向量朝向正确的方向。否则法向量会在使用非统一缩放时被扭曲。 镜面光照(Specular Lighting)：当观察者视线靠近光源在表面的反射线时会显示的镜面高光。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。 冯氏着色(Phong Shading)：冯氏光照模型应用在片段着色器。 Gouraud着色(Gouraud shading)：冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。 GLSL结构体(GLSL struct)：一个类似于C的结构体，用作着色器变量的容器。大部分时间用来管理输入/输出/uniform。 材质(Material)：一个物体反射的环境光，漫反射，镜面光颜色。这些东西设定了物体所拥有的颜色。 光照属性(Light(properties))：一个光的环境光，漫反射，镜面光的强度。可以使用任何颜色值，对每一个冯氏分量(Phong Component)定义光源发出的颜色/强度。 漫反射贴图(Diffuse Map)：一个设定了每个片段中漫反射颜色的纹理图片。 镜面光贴图(Specular Map)：一个设定了每一个片段的镜面光强度/颜色的纹理贴图。仅在物体的特定区域显示镜面高光。 定向光(Directional Light)：只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。 点光源(Point Light)：一个在场景中有位置的，光线逐渐衰减的光源。 衰减(Attenuation)：光随着距离减少强度的过程，通常使用在点光源和聚光下。 聚光(Spotlight)：一个被定义为在某一个方向上的锥形的光源。 手电筒(Flashlight)：一个摆放在观察者视角的聚光。 GLSL uniform数组(GLSL Uniform Array)：一个uniform值数组。它的工作原理和C语言数组大致一样，只是不能动态分配内存。 网格当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型/形状组合而成。组合模型的每个单独的形状就叫做一个网格(Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://www.zackaddy.xin/categories/OpenGL/"}]},{"title":"44、LinearAlgebra 之子空间","slug":"LinearAlgebra/44、LinearAlgebra 之子空间","date":"2020-05-19T06:00:00.000Z","updated":"2020-08-07T14:10:11.808Z","comments":true,"path":"2020/05/19/LinearAlgebra/44、LinearAlgebra 之子空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/19/LinearAlgebra/44、LinearAlgebra 之子空间/","excerpt":"","text":"LinearAlgebra 之子空间假设V是一个向量空间，如果S是V的一个子集，且S还是一个向量空间，则称S是V的一个子空间。 如何判断S是否是一个向量空间？ 遵循上面提及的十条性质的一定是向量空间，但是实际上只需要判断集合中的向量是否符合前两条性质即可，因为后面的都是前两条性质衍生出的性质。即 假设V是一个向量空间，如果S是V的一个子集，且S对加法和数量乘法封闭，则称S是V的一个子空间。 假设V是一个向量空间，如果S是V的一个子集，且S还是一个向量空间，则称S是V的一个子空间。 假设V是一个向量空间，如果S是V的一个子集，且S对加法和数量乘法封闭（满足十大性质），则称S是V的一个子空间。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"43、LinearAlgebra 之广义向量空间","slug":"LinearAlgebra/43、LinearAlgebra 之广义向量空间","date":"2020-05-19T05:00:00.000Z","updated":"2020-08-07T14:10:11.808Z","comments":true,"path":"2020/05/19/LinearAlgebra/43、LinearAlgebra 之广义向量空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/19/LinearAlgebra/43、LinearAlgebra 之广义向量空间/","excerpt":"","text":"LinearAlgebra 之广义向量空间 区别于欧几里得空间，通常把非欧几里得空间的向量空间称为广义向量空间。如，所有 m×n的矩阵构成的空间就是一个广义线性空间 不仅仅是矩阵，所有的多项式也同样是广义的向量空间。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"42、LinearAlgebra 之空间，向量空间和欧几里得空间","slug":"LinearAlgebra/42、LinearAlgebra 之空间，向量空间和欧几里得空间","date":"2020-05-18T06:00:00.000Z","updated":"2020-08-07T14:10:11.807Z","comments":true,"path":"2020/05/18/LinearAlgebra/42、LinearAlgebra 之空间，向量空间和欧几里得空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/18/LinearAlgebra/42、LinearAlgebra 之空间，向量空间和欧几里得空间/","excerpt":"","text":"LinearAlgebra 之空间，向量空间和欧几里得空间","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"41、LinearAlgebra 之空间的基的更多性质","slug":"LinearAlgebra/41、LinearAlgebra 之空间的基的更多性质","date":"2020-05-18T05:00:00.000Z","updated":"2020-08-07T14:10:11.807Z","comments":true,"path":"2020/05/18/LinearAlgebra/41、LinearAlgebra 之空间的基的更多性质/","link":"","permalink":"https://www.zackaddy.xin/2020/05/18/LinearAlgebra/41、LinearAlgebra 之空间的基的更多性质/","excerpt":"","text":"LinearAlgebra 之空间的基的更多性质 n维空间中，任意n个线性无关的向量，一定是这个n维空间的基n维空间中，如果n个向量可以生成整个空间，则这n个向量，是这n维空间的基","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"40、LinearAlgebra 之空间的基","slug":"LinearAlgebra/40、LinearAlgebra 之空间的基","date":"2020-05-17T06:00:00.000Z","updated":"2020-08-07T14:10:11.807Z","comments":true,"path":"2020/05/17/LinearAlgebra/40、LinearAlgebra 之空间的基/","link":"","permalink":"https://www.zackaddy.xin/2020/05/17/LinearAlgebra/40、LinearAlgebra 之空间的基/","excerpt":"","text":"LinearAlgebra 之空间的基 上图换为单位向量后，为标准正交基 在n维空间，如果给定一组基。 任何一个向量（或者是点）都可以表示成这组基的线性组合！且表示方法唯一。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"39、LinearAlgebra 之生成空间","slug":"LinearAlgebra/39、LinearAlgebra 之生成空间","date":"2020-05-17T05:00:00.000Z","updated":"2020-08-07T14:10:11.806Z","comments":true,"path":"2020/05/17/LinearAlgebra/39、LinearAlgebra 之生成空间/","link":"","permalink":"https://www.zackaddy.xin/2020/05/17/LinearAlgebra/39、LinearAlgebra 之生成空间/","excerpt":"","text":"LinearAlgebra 之生成空间 n个向量不一定可以生成n维空间","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"38、LinearAlgebra 之直观理解线性相关、线性无关","slug":"LinearAlgebra/38、LinearAlgebra 之直观理解线性相关、线性无关","date":"2020-05-16T06:00:00.000Z","updated":"2020-08-07T14:10:11.806Z","comments":true,"path":"2020/05/16/LinearAlgebra/38、LinearAlgebra 之直观理解线性相关、线性无关/","link":"","permalink":"https://www.zackaddy.xin/2020/05/16/LinearAlgebra/38、LinearAlgebra 之直观理解线性相关、线性无关/","excerpt":"","text":"LinearAlgebra 之直观理解线性相关、线性无关","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"37、LinearAlgebra 之线性相关、线性无关","slug":"LinearAlgebra/37、LinearAlgebra 之线性相关、线性无关","date":"2020-05-16T05:00:00.000Z","updated":"2020-08-07T14:10:11.806Z","comments":true,"path":"2020/05/16/LinearAlgebra/37、LinearAlgebra 之线性相关、线性无关/","link":"","permalink":"https://www.zackaddy.xin/2020/05/16/LinearAlgebra/37、LinearAlgebra 之线性相关、线性无关/","excerpt":"","text":"LinearAlgebra 之线性相关、线性无关线性组合回忆向量的两个最基本的运算：向量加法和标量乘法 1\\overrightharpoon&#123;u&#125; + \\overrightharpoon&#123;w&#125; \\quad k\\overrightharpoon&#123;u&#125; 向量的两个最基本的运算构建了线性代数中最重要的一个概念：线性组合 对于若干个n为向量 123\\overrightharpoon&#123;\\nu&#125;_1,\\overrightharpoon&#123;\\nu&#125;_2,\\overrightharpoon&#123;\\nu&#125;_3,...,\\overrightharpoon&#123;\\nu&#125;_pk_1 \\cdot \\overrightharpoon&#123;\\nu&#125;_1 + k_2 \\cdot \\overrightharpoon&#123;\\nu&#125;_2 + k_3 \\cdot \\overrightharpoon&#123;\\nu&#125;_3 + ... + k_p \\cdot \\overrightharpoon&#123;\\nu&#125;_p 称为这些向量的一个线性组合 三维空间中的任何一个向量 都是其三个标准单位向量的一个线性组合 1\\overrightharpoon&#123;\\nu&#125; = (x,y,z) = x \\cdot (1,0,0)^&#123;T&#125; + y \\cdot (0,1,0)^&#123;T&#125; + z \\cdot (0,0,1)^&#123;T&#125; = x \\cdot \\overrightharpoon&#123;e&#125;_1 + y \\cdot \\overrightharpoon&#123;e&#125;_2 + z \\cdot \\overrightharpoon&#123;e&#125;_3 如下图 Gauss-Jordan消元法结果的每一行，是原来矩阵各行的一个线性组合 线性相关 线性无关 线性相关重要性质","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"36、LinearAlgebra 之矩阵的PLUP'分解和再看矩阵的乘法","slug":"LinearAlgebra/36、LinearAlgebra 之矩阵的PLUP'分解和再看矩阵的乘法","date":"2020-05-15T06:00:00.000Z","updated":"2020-08-07T14:10:11.806Z","comments":true,"path":"2020/05/15/LinearAlgebra/36、LinearAlgebra 之矩阵的PLUP'分解和再看矩阵的乘法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/15/LinearAlgebra/36、LinearAlgebra 之矩阵的PLUP'分解和再看矩阵的乘法/","excerpt":"","text":"LinearAlgebra 之矩阵的PLUP’分解和再看矩阵的乘法","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"35、LinearAlgebra 之非方阵的LU分解，矩阵的LDU分解和PLU分解","slug":"LinearAlgebra/35、LinearAlgebra 之非方阵的LU分解，矩阵的LDU分解和PLU分解","date":"2020-05-15T05:00:00.000Z","updated":"2020-08-07T14:10:11.805Z","comments":true,"path":"2020/05/15/LinearAlgebra/35、LinearAlgebra 之非方阵的LU分解，矩阵的LDU分解和PLU分解/","link":"","permalink":"https://www.zackaddy.xin/2020/05/15/LinearAlgebra/35、LinearAlgebra 之非方阵的LU分解，矩阵的LDU分解和PLU分解/","excerpt":"","text":"LinearAlgebra 之非方阵的LU分解，矩阵的LDU分解和PLU分解矩阵LU分解不仅仅能使用在下面的方阵 123456789101112A = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ * &amp; 1 &amp; 0 &amp; 0 \\\\ * &amp; * &amp; 1 &amp; 0 \\\\ * &amp; * &amp; * &amp; 1\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; * &amp; * &amp; * &amp; * \\\\ 0 &amp; * &amp; * &amp; * \\\\ 0 &amp; 0 &amp; * &amp; * \\\\ 0 &amp; 0 &amp; 0 &amp; *\\end&#123;pmatrix&#125; LU分解可以用于非方阵 123456789101112131415161718192021222324252627A = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ * &amp; 1 &amp; 0 &amp; 0 \\\\ * &amp; * &amp; 1 &amp; 0 \\\\ * &amp; * &amp; * &amp; 1\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; * &amp; * &amp; * &amp; * &amp; * &amp; * \\\\ 0 &amp; * &amp; * &amp; * &amp; * &amp; * \\\\ 0 &amp; 0 &amp; * &amp; * &amp; * &amp; * \\\\ 0 &amp; 0 &amp; 0 &amp; * &amp; * &amp; *\\end&#123;pmatrix&#125;A = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ * &amp; 1 &amp; 0 &amp; 0 \\\\ * &amp; * &amp; 1 &amp; 0 \\\\ * &amp; * &amp; * &amp; 1 \\\\ * &amp; * &amp; * &amp; * \\\\ * &amp; * &amp; * &amp; *\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; * &amp; * &amp; * &amp; * \\\\ 0 &amp; * &amp; * &amp; * \\\\ 0 &amp; 0 &amp; * &amp; * \\\\ 0 &amp; 0 &amp; 0 &amp; *\\end&#123;pmatrix&#125; LDU分解 PLU分解","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"34、LinearAlgebra 之实现矩阵的LU分解","slug":"LinearAlgebra/34、LinearAlgebra 之实现矩阵的LU分解","date":"2020-05-14T06:00:00.000Z","updated":"2020-08-07T14:10:11.805Z","comments":true,"path":"2020/05/14/LinearAlgebra/34、LinearAlgebra 之实现矩阵的LU分解/","link":"","permalink":"https://www.zackaddy.xin/2020/05/14/LinearAlgebra/34、LinearAlgebra 之实现矩阵的LU分解/","excerpt":"","text":"LinearAlgebra 之实现矩阵的LU分解1234567891011121314151617181920212223242526272829303132333435363738394041function lu(matrix) &#123; console.assert(matrix.rowNum() === matrix.colNum(), 'matrix must be a square matrix') let n = matrix.rowNum(); let A = []; for (let i = 0;i &lt; n;i++) &#123; A.push(matrix.rowVector(i)); &#125; let L = []; for (let i = 0;i &lt; n;i++) &#123; L[i] = []; for (let j = 0;j &lt; n;j++) &#123; if (i === j) &#123; L[i].push(1); &#125; else &#123; L[i].push(0); &#125; &#125; &#125; for (let i = 0;i &lt; n;i++) &#123; if (isZero(A[i][i])) &#123; return null; &#125; else &#123; for (let j = i + 1;j &lt; n;j++) &#123; let p = A[j].getItem(i) / A[i].getItem(i); A[j] = A[j].sub(A[i].mul(p)); L[j][i] = p; &#125; &#125; &#125; let U = []; for (let i = 0;i &lt; n;i++) &#123; U.push(A[i].getValues()); &#125; return [new Matrix(L), new Matrix(U)]&#125;console.log(lu(new Matrix([[1,2,3], [4,5,6], [3,-3,-5]])))","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"33、LinearAlgebra 之矩阵的LU分解","slug":"LinearAlgebra/33、LinearAlgebra 之矩阵的LU分解","date":"2020-05-14T05:00:00.000Z","updated":"2020-08-07T14:10:11.804Z","comments":true,"path":"2020/05/14/LinearAlgebra/33、LinearAlgebra 之矩阵的LU分解/","link":"","permalink":"https://www.zackaddy.xin/2020/05/14/LinearAlgebra/33、LinearAlgebra 之矩阵的LU分解/","excerpt":"","text":"LinearAlgebra 之矩阵的LU分解简介数的分解：66 = 2 * 3 * 11 质因数分解 一个矩阵也可以分解成为几个矩阵乘积形式 矩阵分解有不同的目的 矩阵的LU分解，提高计算效率为目的 矩阵的LU分解将矩阵分解为 A = L * U L：Lower Triangle Matrix 下三角矩阵 123456\\begin&#123;pmatrix&#125; * &amp; 0 &amp; 0 &amp; 0 \\\\ * &amp; * &amp; 0 &amp; 0 \\\\ * &amp; * &amp; * &amp; 0 \\\\ * &amp; * &amp; * &amp; *\\end&#123;pmatrix&#125; 单位下三角矩阵 123456\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ * &amp; 1 &amp; 0 &amp; 0 \\\\ * &amp; * &amp; 1 &amp; 0 \\\\ * &amp; * &amp; * &amp; 1\\end&#123;pmatrix&#125; U：Upper Triangle Matrix 上三角矩阵 123456\\begin&#123;pmatrix&#125; * &amp; * &amp; * &amp; * \\\\ 0 &amp; * &amp; * &amp; * \\\\ 0 &amp; 0 &amp; * &amp; * \\\\ 0 &amp; 0 &amp; 0 &amp; *\\end&#123;pmatrix&#125; 单位上三角矩阵 123456\\begin&#123;pmatrix&#125; 1 &amp; * &amp; * &amp; * \\\\ 0 &amp; 1 &amp; * &amp; * \\\\ 0 &amp; 0 &amp; 1 &amp; * \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263将矩阵A分解为 A = L * U 以方阵为例E_&#123;p&#125; \\cdot ... \\cdot E_&#123;3&#125; \\cdot E_&#123;2&#125; \\cdot E_&#123;1&#125; \\cdot A = UL = E_&#123;1&#125;^&#123;-1&#125; \\cdot E_&#123;1&#125;^&#123;-1&#125; \\cdot E_&#123;2&#125;^&#123;-1&#125; \\cdot E_&#123;3&#125;^&#123;-1&#125; \\cdot ... \\cdot E_&#123;p&#125;^&#123;-1&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 3 &amp; -3 &amp; -5\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 0 &amp; -3 &amp; -6 \\\\ 3 &amp; -3 &amp; -5\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 0 &amp; -3 &amp; -6 \\\\ 0 &amp; -9 &amp; -4\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 0 &amp; -3 &amp; -6 \\\\ 0 &amp; 0 &amp; 14\\end&#123;pmatrix&#125;第一次变换矩阵的逆矩阵：\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 4 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125;第二次变换矩阵的逆矩阵：\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 3 &amp; 0 &amp; 1\\end&#123;pmatrix&#125;第三次变换矩阵的逆矩阵：\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 3 &amp; 1\\end&#123;pmatrix&#125;三次变换矩阵的逆矩阵相乘结果为：\\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 4 &amp; 1 &amp; 0 \\\\ 3 &amp; 3 &amp; 1\\end&#123;pmatrix&#125;A = \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 3 &amp; -3 &amp; -5\\end&#123;pmatrix&#125; \\quad L = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 4 &amp; 1 &amp; 0 \\\\ 3 &amp; 3 &amp; 1\\end&#123;pmatrix&#125; \\quad U = \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 0 &amp; -3 &amp; -6 \\\\ 0 &amp; 0 &amp; 14\\end&#123;pmatrix&#125;矩阵可以进行LU分解的条件：对A进行高斯消元的过程不需要交换两行位置 为什么进行矩阵的LU分解提高计算效率 12345678910111213141516171819202122232425262728293031323334353637L = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 4 &amp; 1 &amp; 0 \\\\ 3 &amp; 3 &amp; 1\\end&#123;pmatrix&#125; \\quad U = \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 0 &amp; -3 &amp; -6 \\\\ 0 &amp; 0 &amp; 14\\end&#123;pmatrix&#125;L对角线下方大概有：0.5n^&#123;2&#125;U在高斯消元过程中需要把下方元素消为0，大概是n个操作在解Ax=b的过程中 LU分解：O(0.5n^&#123;3&#125;)L \\cdot U \\cdot x = b设Ux = y，L \\cdot y = b 大概O(n^&#123;2&#125;)求出yU \\cdot x = y O(n^2)求出x在解Ax=b的过程中 LU分解：O(0.5n^&#123;3&#125;) + 2*O(n^&#123;2&#125;)对比求解矩阵的逆：求逆：O(2*n^3) + O(n^2)\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 &amp; 0 \\\\ 3 &amp; 4 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; x_&#123;11&#125; &amp; x_&#123;12&#125; \\\\ 0 &amp; 1 &amp; x_&#123;21&#125; &amp; x_&#123;22&#125;\\end&#123;pmatrix&#125; 2n \\quad | \\quad n^2x = A^&#123;-1&#125; \\cdot b","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"32、LinearAlgebra 之为什么矩阵的逆这么重要","slug":"LinearAlgebra/32、LinearAlgebra 之为什么矩阵的逆这么重要","date":"2020-05-13T06:00:00.000Z","updated":"2020-08-07T14:10:11.804Z","comments":true,"path":"2020/05/13/LinearAlgebra/32、LinearAlgebra 之为什么矩阵的逆这么重要/","link":"","permalink":"https://www.zackaddy.xin/2020/05/13/LinearAlgebra/32、LinearAlgebra 之为什么矩阵的逆这么重要/","excerpt":"","text":"LinearAlgebra 之为什么矩阵的逆这么重要1234567对于线性系统：Ax = bA^&#123;-1&#125; \\cdot A \\cdot x = A^&#123;-1&#125; \\cdot bx = A^&#123;-1&#125; \\cdot b如果在A不变，b会变化的条件下，大大加快计算速度","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"31、LinearAlgebra 之初等矩阵","slug":"LinearAlgebra/31、LinearAlgebra 之初等矩阵","date":"2020-05-13T05:00:00.000Z","updated":"2020-08-07T14:10:11.804Z","comments":true,"path":"2020/05/13/LinearAlgebra/31、LinearAlgebra 之初等矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/13/LinearAlgebra/31、LinearAlgebra 之初等矩阵/","excerpt":"","text":"LinearAlgebra 之初等矩阵 初等矩阵：对单位矩阵进行一次初等变换得到的结果矩阵，通常记为E。 回忆使用Gauss-Jordan消元法把矩阵化为行最简形式（rref）的过程：寻找一系列初等矩阵E，使得： 1E_&#123;p&#125; \\cdot ... \\cdot E_&#123;3&#125; \\cdot E_&#123;2&#125; \\cdot E_&#123;1&#125; \\cdot A = rref(A) 初等矩阵是对单位矩阵进行一次初等变换得到的 因为初等变换是可逆的，所以初等矩阵是可逆的 如果A可逆，存在一系列E，使得： 1234567891011E_&#123;p&#125; \\cdot ... \\cdot E_&#123;3&#125; \\cdot E_&#123;2&#125; \\cdot E_&#123;1&#125; \\cdot A = IE_&#123;p&#125; \\cdot ... \\cdot E_&#123;3&#125; \\cdot E_&#123;2&#125; \\cdot E_&#123;1&#125; \\cdot A \\cdot A^&#123;-1&#125; = I \\cdot A^&#123;-1&#125;E_&#123;p&#125; \\cdot ... \\cdot E_&#123;3&#125; \\cdot E_&#123;2&#125; \\cdot E_&#123;1&#125; \\cdot I = A^&#123;-1&#125;\\begin&#123;pmatrix&#125; A &amp; I\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; I &amp; A^&#123;-1&#125;\\end&#123;pmatrix&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"30、Linearalgebra 之实现求解矩阵的逆","slug":"LinearAlgebra/30、Linearalgebra 之实现求解矩阵的逆","date":"2020-05-12T06:00:00.000Z","updated":"2020-08-07T14:10:11.804Z","comments":true,"path":"2020/05/12/LinearAlgebra/30、Linearalgebra 之实现求解矩阵的逆/","link":"","permalink":"https://www.zackaddy.xin/2020/05/12/LinearAlgebra/30、Linearalgebra 之实现求解矩阵的逆/","excerpt":"","text":"Linearalgebra 之实现求解矩阵的逆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function LinearSystem(A, b) &#123; console.assert(A.rowNum() === b.len(), 'Row number of A must be equal to the length of b'); this._m = A.rowNum(); this._n = A.colNum(); this.Ab = []; // 增广矩阵 if (b instanceof Vector) &#123; for (let i = 0;i &lt; this._m;i++) &#123; this.Ab.push(new Vector(A.rowVector(i).getValues().concat([b.getItem(i)]))); &#125; &#125; if (b instanceof Matrix) &#123; for (let i = 0;i &lt; this._m;i++) &#123; this.Ab.push(new Vector(A.rowVector(i).getValues().concat(b.rowVector(i).getValues()))); &#125; &#125; this.pivots = [];&#125;// 求解矩阵的逆LinearSystem.inv = function(A) &#123; if (A.rowNum() !== A.colNum()) &#123; return null; &#125; let n = A.rowNum(); let ls = new LinearSystem(A, Matrix.identity(n)); if (!ls.gaussJordanElimination()) &#123; return null; &#125; const result = []; for (let item of ls.Ab) &#123; result.push(item.getValues().slice(n)); &#125; return new Matrix(result);&#125;;LinearSystem.prototype._maxRow = function(index_i, index_j, n) &#123; let best = this.Ab[index_i].getItem(index_j); let ret = index_i; for (let i = index_i + 1;i &lt; n;i++) &#123; if (this.Ab[i].getItem(index_j) &gt; best) &#123; best = this.Ab[i].getItem(index_j); ret = i; &#125; &#125; return ret;&#125;;LinearSystem.prototype._forward = function() &#123; let i = 0,k = 0; while (i &lt; this._m &amp;&amp; k &lt; this._n) &#123; const maxRow = this._maxRow(i, k, this._m); const swap = this.Ab[i]; this.Ab[i] = this.Ab[maxRow]; this.Ab[maxRow] = swap; if (isZero(this.Ab[i].getItem(k))) &#123; k += 1; &#125; else &#123; this.Ab[i] = this.Ab[i].div(this.Ab[i].getItem(k)); for (let j = i + 1;j &lt; this._m;j++) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(k))) &#125; this.pivots.push(k); i += 1; &#125; &#125;&#125;;LinearSystem.prototype._backWard = function() &#123; const n = this.pivots.length; for (let i = n - 1;i &gt;= 0;i--) &#123; let k = this.pivots[i]; for (let j = i - 1;j &gt;= 0;j--) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(k))) &#125; &#125;&#125;;LinearSystem.prototype.gaussJordanElimination = function() &#123; this._forward(); this._backWard(); for (let i = this.pivots.length;i &lt; this._m;i++) &#123; if (!isZero(this.Ab[i].getItem(this.Ab[i].len() - 1))) &#123; return false; &#125; &#125; return true;&#125;;LinearSystem.prototype.format = function() &#123; let str = ''; for (let item of this.Ab) &#123; str = str.concat([JSON.stringify(item.getValues()), '\\n']) &#125; console.log(str) console.log(this)&#125;;let m = new Matrix([[1,2],[3,4]]);let A = LinearSystem.inv(m);console.log(A, m.dot(A))","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"29、LinearAlgebra 之线性系统与矩阵的逆","slug":"LinearAlgebra/29、LinearAlgebra 之线性系统与矩阵的逆","date":"2020-05-12T05:00:00.000Z","updated":"2020-08-07T14:10:11.803Z","comments":true,"path":"2020/05/12/LinearAlgebra/29、LinearAlgebra 之线性系统与矩阵的逆/","link":"","permalink":"https://www.zackaddy.xin/2020/05/12/LinearAlgebra/29、LinearAlgebra 之线性系统与矩阵的逆/","excerpt":"","text":"LinearAlgebra 之线性系统与矩阵的逆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113矩阵中 AB = BA = I，则称A是可逆矩阵，B是A的逆矩阵，记住：B=A^&#123;-1&#125;只有方阵才有逆矩阵。假设矩阵A有逆矩阵，如何求解？A = \\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; \\\\ A \\cdot A^&#123;-1&#125; = I = \\begin&#123;pmatrix&#125; 1 &amp; 0 \\\\ 0 &amp; 1\\end&#123;pmatrix&#125;A^&#123;-1&#125; = \\begin&#123;pmatrix&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; \\\\ x_&#123;21&#125; &amp; x_&#123;22&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x_&#123;11&#125; &amp; x_&#123;12&#125; \\\\ x_&#123;21&#125; &amp; x_&#123;22&#125;\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 &amp; 0 \\\\ 0 &amp; 1\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x_&#123;11&#125; \\\\ x_&#123;21&#125;\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 \\\\ 0\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x_&#123;12&#125; \\\\ x_&#123;22&#125;\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 0 \\\\ 1\\end&#123;pmatrix&#125;\\begin&#123;cases&#125; x_&#123;11&#125; + 2x_&#123;21&#125; = 1 \\\\ 3x_&#123;11&#125; + 4x_&#123;21&#125; = 0\\end&#123;cases&#125;\\begin&#123;cases&#125; x_&#123;12&#125; + 2x_&#123;22&#125; = 0 \\\\ 3x_&#123;12&#125; + 4x_&#123;22&#125; = 1\\end&#123;cases&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 \\\\ 3 &amp; 4 &amp; 0\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; * \\\\ 0 &amp; 1 &amp; *\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; x_&#123;11&#125; \\\\ 0 &amp; 1 &amp; x_&#123;21&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 0 \\\\ 3 &amp; 4 &amp; 1\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; * \\\\ 0 &amp; 1 &amp; *\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; x_&#123;12&#125; \\\\ 0 &amp; 1 &amp; x_&#123;22&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 &amp; 0 \\\\ 3 &amp; 4 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; x_&#123;11&#125; &amp; x_&#123;12&#125; \\\\ 0 &amp; 1 &amp; x_&#123;21&#125; &amp; x_&#123;22&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; A &amp; I\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; I &amp; A^&#123;-1&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 &amp; 0 \\\\ 3 &amp; 4 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 &amp; 0 \\\\ 0 &amp; -2 &amp; -3 &amp; 1\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1.5 &amp; -0.5\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; -2 &amp; 1 \\\\ 0 &amp; 1 &amp; 1.5 &amp; -0.5\\end&#123;pmatrix&#125; 1234567891011\\begin&#123;pmatrix&#125; a &amp; b &amp; 1 &amp; 0 \\\\ c &amp; d &amp; 0 &amp; 1\\end&#123;pmatrix&#125; 不可能有无数解可能无解，此时矩阵A没有逆矩阵何时无解？系数矩阵化为行最简形式时有0行！","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"28、LinearAlgebra 之齐次线性方程组","slug":"LinearAlgebra/28、LinearAlgebra 之齐次线性方程组","date":"2020-05-11T06:00:00.000Z","updated":"2020-08-07T14:10:11.803Z","comments":true,"path":"2020/05/11/LinearAlgebra/28、LinearAlgebra 之齐次线性方程组/","link":"","permalink":"https://www.zackaddy.xin/2020/05/11/LinearAlgebra/28、LinearAlgebra 之齐次线性方程组/","excerpt":"","text":"LinearAlgebra 之齐次线性方程组定义：常数项都为零的线性方程组 123456789101112131415\\begin&#123;cases&#125; -x + 2y + 3z = 0 \\\\ x - 4y - 13z = 0 \\\\ -3x + 5y + 4z = 0\\end&#123;cases&#125; \\to \\begin&#123;pmatrix&#125; -1 &amp; 2 &amp; 3 \\\\ 1 &amp; -4 &amp; -13 \\\\ -3 &amp; 5 &amp; 4\\end&#123;pmatrix&#125; \\to \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 7 \\\\ 0 &amp; 1 &amp; 5 \\\\ 0 &amp; 0 &amp; 0\\end&#123;pmatrix&#125; 称为齐次线性方程组。 常数项不全为零的线性方程组，称为非齐次线性方程组。 肯定有解 最后一列肯定永远为零 解的过程可以只对系数矩阵做操作 齐次线性方程组一定有解，因为 1x_&#123;1&#125; = x_&#123;2&#125; = x_&#123;3&#125; = x_&#123;n&#125; = 0 是它的一个解，称为零解，零解以外的解称为非零解。 关于齐次线性方程组，我们关心的是它是否有非零解。 1234567\\begin&#123;cases&#125; -x + 2y + 3z = 1 \\\\ x - 4y - 13z = 2 \\\\ -3x + 5y + 4z = 3\\end&#123;cases&#125; \\\\非齐次线性方程组","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"27、LinearAlgebra 之实现更一般化的高斯·元旦消元法","slug":"LinearAlgebra/27、LinearAlgebra 之实现更一般化的高斯·元旦消元法","date":"2020-05-11T05:00:00.000Z","updated":"2020-08-07T14:10:11.803Z","comments":true,"path":"2020/05/11/LinearAlgebra/27、LinearAlgebra 之实现更一般化的高斯·元旦消元法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/11/LinearAlgebra/27、LinearAlgebra 之实现更一般化的高斯·元旦消元法/","excerpt":"","text":"LinearAlgebra 之实现更一般化的高斯·元旦消元法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function LinearSystem(A, b) &#123; console.assert(A.rowNum() === b.len(), 'Row number of A must be equal to the length of b'); this._m = A.rowNum(); this._n = A.colNum(); this.Ab = []; // 增广矩阵 for (let i = 0;i &lt; this._m;i++) &#123; this.Ab.push(new Vector(A.rowVector(i).getValues().concat([b.getItem(i)]))); &#125; this.pivots = [];&#125;LinearSystem.prototype._maxRow = function(index_i, index_j, n) &#123; let best = this.Ab[index_i].getItem(index_j); let ret = index_i; for (let i = index_i + 1;i &lt; n;i++) &#123; if (this.Ab[i].getItem(index_j) &gt; best) &#123; best = this.Ab[i].getItem(index_j); ret = i; &#125; &#125; return ret;&#125;;LinearSystem.prototype._forward = function() &#123; let i = 0,k = 0; while (i &lt; this._m &amp;&amp; k &lt; this._n) &#123; const maxRow = this._maxRow(i, k, this._m); const swap = this.Ab[i]; this.Ab[i] = this.Ab[maxRow]; this.Ab[maxRow] = swap; if (isZero(this.Ab[i].getItem(k))) &#123; k += 1; &#125; else &#123; this.Ab[i] = this.Ab[i].div(this.Ab[i].getItem(k)); for (let j = i + 1;j &lt; this._m;j++) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(k))) &#125; this.pivots.push(k); i += 1; &#125; &#125;&#125;;LinearSystem.prototype._backWard = function() &#123; const n = this.pivots.length; for (let i = n - 1;i &gt;= 0;i--) &#123; let k = this.pivots[i]; for (let j = i - 1;j &gt;= 0;j--) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(k))) &#125; &#125;&#125;;LinearSystem.prototype.gaussJordanElimination = function() &#123; this._forward(); this._backWard(); for (let i = this.pivots.length;i &lt; this._m;i++) &#123; if (!isZero(this.Ab[i].getItem(this.Ab[i].len() - 1))) &#123; return false; &#125; &#125; return true;&#125;;LinearSystem.prototype.format = function() &#123; let str = ''; for (let item of this.Ab) &#123; str = str.concat([JSON.stringify(item.getValues()), '\\n']) &#125; console.log(str)&#125;;const linear = new LinearSystem(new Matrix([[3,8],[2,5]]), new Vector([33, 20]));linear.gaussJordanElimination();linear.format();","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"26、LinearAlgebra 之线性方程组解的结构","slug":"LinearAlgebra/26、LinearAlgebra 之线性方程组解的结构","date":"2020-05-10T06:00:00.000Z","updated":"2020-08-07T14:10:11.802Z","comments":true,"path":"2020/05/10/LinearAlgebra/26、LinearAlgebra 之线性方程组解的结构/","link":"","permalink":"https://www.zackaddy.xin/2020/05/10/LinearAlgebra/26、LinearAlgebra 之线性方程组解的结构/","excerpt":"","text":"LinearAlgebra 之线性方程组解的结构 方程的个数 n个未知数有n个方程，才可能有唯一解。 两个三元方程联立，方程组个数小于未知数个数，一定没有唯一解，可能无解 行最简形式A中主元所在列为主元列 行最简形式A中非主元列为自由列 无解 | 无解 | 无解 | 唯一解 | 唯一解无数解 | 无数解 | 无数解 行最简形式A非零行 &lt; 未知数 行最简形式A非零行 = 未知数 无解 无解 - 唯一解 无数解 无数解 行最简形式A非零行 &lt; 行最简形式Ab非零行：无解行最简形式A非零行 &lt; 未知数 | 行最简形式A非零行 = 未知数—|—无数解 | 唯一解","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"25、LinearAlgebra 之实现高斯·元旦消元法","slug":"LinearAlgebra/25、LinearAlgebra 之实现高斯·元旦消元法","date":"2020-05-10T05:00:00.000Z","updated":"2020-08-07T14:10:11.802Z","comments":true,"path":"2020/05/10/LinearAlgebra/25、LinearAlgebra 之实现高斯·元旦消元法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/10/LinearAlgebra/25、LinearAlgebra 之实现高斯·元旦消元法/","excerpt":"","text":"LinearAlgebra 之实现高斯·元旦消元法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function LinearSystem(A, b) &#123; console.assert(A.rowNum() === b.len(), 'Row number of A must be equal to the length of b'); this._m = A.rowNum(); this._n = A.colNum(); this.Ab = []; // 增广矩阵 for (let i = 0;i &lt; this._m;i++) &#123; this.Ab.push(new Vector(A.rowVector(i).getValues().concat([b.getItem(i)]))); &#125;&#125;LinearSystem.prototype._maxRow = function(index, n) &#123; let best = this.Ab[index].getItem(index); let ret = index; for (let i = index + 1;i &lt; n;i++) &#123; if (this.Ab[index].getItem(index) &gt; best) &#123; best = this.Ab[index].getItem(index); ret = i; &#125; &#125; return ret;&#125;;LinearSystem.prototype._forward = function() &#123; for (let i = 0;i &lt; this._m;i++) &#123; const maxRow = this._maxRow(i, this._m); const swap = this.Ab[i]; this.Ab[i] = this.Ab[maxRow]; this.Ab[maxRow] = swap; this.Ab[i] = this.Ab[i].div(this.Ab[i].getItem(i)); for (let j = i + 1;j &lt; this._m;j++) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(i))) &#125; &#125;&#125;;LinearSystem.prototype._backWard = function() &#123; for (let i = this._m - 1;i &gt;= 0;i--) &#123; for (let j = i - 1;j &gt;= 0;j--) &#123; this.Ab[j] = this.Ab[j].sub(this.Ab[i].mul(this.Ab[j].getItem(i))) &#125; &#125;&#125;;LinearSystem.prototype.gaussJordanElimination = function() &#123; this._forward(); this._backWard(); console.log(this)&#125;;new LinearSystem(new Matrix([[1,2,4], [3,7,2], [2,3,3]]), new Vector([7,-11,1])).gaussJordanElimination()","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"24、LinearAlgebra 之高斯·约旦消元法","slug":"LinearAlgebra/24、LinearAlgebra 之高斯·约旦消元法","date":"2020-05-09T06:00:00.000Z","updated":"2020-08-07T14:10:11.802Z","comments":true,"path":"2020/05/09/LinearAlgebra/24、LinearAlgebra 之高斯·约旦消元法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/09/LinearAlgebra/24、LinearAlgebra 之高斯·约旦消元法/","excerpt":"","text":"LinearAlgebra 之高斯·约旦消元法 将线性方程表示为增广矩阵进行消元 矩阵的某一行乘以一个常数 矩阵的一行加（减）另一行 交换矩阵的两行 从第一行消元后，再从最后一行消元","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"23、LinearAlgebra 之线性系统与消元法","slug":"LinearAlgebra/23、LinearAlgebra 之线性系统与消元法","date":"2020-05-09T05:00:00.000Z","updated":"2020-08-07T14:10:11.801Z","comments":true,"path":"2020/05/09/LinearAlgebra/23、LinearAlgebra 之线性系统与消元法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/09/LinearAlgebra/23、LinearAlgebra 之线性系统与消元法/","excerpt":"","text":"LinearAlgebra 之线性系统与消元法1234567\\begin&#123;cases&#125; x + 2y = 5 \\\\ 3x + 4y = 6\\end&#123;cases&#125; \\\\什么是线性？\\\\未知数只能是一次方项","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"22、LinearAlgebra 之看待矩阵的空间视角","slug":"LinearAlgebra/22、LinearAlgebra 之看待矩阵的空间视角","date":"2020-05-08T06:00:00.000Z","updated":"2020-08-07T14:10:11.801Z","comments":true,"path":"2020/05/08/LinearAlgebra/22、LinearAlgebra 之看待矩阵的空间视角/","link":"","permalink":"https://www.zackaddy.xin/2020/05/08/LinearAlgebra/22、LinearAlgebra 之看待矩阵的空间视角/","excerpt":"","text":"LinearAlgebra 之看待矩阵的空间视角使用列视角 向量表示空间","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"21、LinearAlgebra 之用Javascript实现向量与矩阵","slug":"LinearAlgebra/21、LinearAlgebra 之用Javascript实现向量与矩阵","date":"2020-05-08T05:00:00.000Z","updated":"2020-08-07T14:10:11.801Z","comments":true,"path":"2020/05/08/LinearAlgebra/21、LinearAlgebra 之用Javascript实现向量与矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/08/LinearAlgebra/21、LinearAlgebra 之用Javascript实现向量与矩阵/","excerpt":"","text":"LinearAlgebra 之用Javascript实现向量与矩阵实现工具函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const EPSILON = 1e-8;function filter(array, predicate) &#123; let index = -1 let resIndex = 0 const length = array == null ? 0 : array.length const result = [] while (++index &lt; length) &#123; const value = array[index] if (predicate(value, index, array)) &#123; result[resIndex++] = value &#125; &#125; return result&#125;function map(array, iteratee) &#123; let index = -1 const length = array == null ? 0 : array.length const result = new Array(length) while (++index &lt; length) &#123; result[index] = iteratee(array[index], index, array) &#125; return result&#125;const MAX_SAFE_INTEGER = 9007199254740991function isLength(value) &#123; return typeof value === 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER&#125;function isArrayLike(value) &#123; return value != null &amp;&amp; typeof value !== 'function' &amp;&amp; isLength(value.length)&#125;function isObjectLike(value) &#123; return typeof value === 'object' &amp;&amp; value !== null&#125;function isArrayLikeObject(value) &#123; return isObjectLike(value) &amp;&amp; isArrayLike(value)&#125;function baseProperty(key) &#123; return (object) =&gt; object == null ? undefined : object[key]&#125;function unzip(array) &#123; if (!(array != null &amp;&amp; array.length)) &#123; return [] &#125; let length = 0; array = filter(array, (group) =&gt; &#123; if (isArrayLikeObject(group)) &#123; length = Math.max(group.length, length); return true &#125; &#125;); let index = -1; const result = new Array(length); while (++index &lt; length) &#123; result[index] = map(array, baseProperty(index)) &#125; return result;&#125;function zip(...arrays) &#123; return unzip(arrays)&#125; 实现向量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function Vector(list) &#123; this._values = list.concat();&#125;// 生成n维零向量Vector.zero = function(dim) &#123; return new Vector(new Array(dim).fill(0));&#125;;Vector.prototype.toString = function() &#123; return `Vector([$&#123;this._values&#125;])`;&#125;;/** * 返回向量的模 * @return &#123;number&#125; */Vector.prototype.norm = function() &#123; let result = 0; for (let num of this._values) &#123; result = math.chain(result).add(math.square(num)).value; &#125; return math.sqrt(result);&#125;;/** * 返回向量的单位向量 * @return &#123;Vector&#125; */Vector.prototype.normalize = function() &#123; const normValue = this.norm(); console.assert(normValue &gt; EPSILON, 'Error in normalize. Result of this.norm() cannot be zero'); return (new Vector(this._values)).div(normValue);&#125;;/** * 点乘 * @param another * @return &#123;number|*&#125; */Vector.prototype.dot = function(another) &#123; console.assert(this.len() === another.len(), 'Error in adding. Length of vectors must be same.') let result = 0; for (let array of zip(this._values, another._values)) &#123; result = math.chain(array[0]).multiply(array[1]).add(result).value; &#125; return result;&#125;;Vector.prototype.len = function() &#123; return this._values.length;&#125;;Vector.prototype.getItem = function(index) &#123; return this._values[index];&#125;;Vector.prototype.add = function(another) &#123; console.assert(this.len() === another.len(), 'Error in adding. Length of vectors must be same.') const result = []; for (let array of zip(this._values, another._values)) &#123; result.push(math.chain(array[0]).add(array[1]).value); &#125; return new Vector(result);&#125;;Vector.prototype.sub = function(another) &#123; console.assert(this.len() === another.len(), 'Error in subtracting. Length of vectors must be same.') const result = []; for (let array of zip(this._values, another._values)) &#123; result.push(math.chain(array[0]).subtract(array[1]).value); &#125; return new Vector(result);&#125;;Vector.prototype.mul = function(k) &#123; const result = []; for (let num of this._values) &#123; result.push(math.chain(num).multiply(k).value); &#125; return new Vector(result);&#125;;Vector.prototype.div = function(k) &#123; const result = []; for (let num of this._values) &#123; result.push(math.chain(num).divide(k).value); &#125; return new Vector(result);&#125;;Vector.prototype.pos = function() &#123; return this.mul(1);&#125;;Vector.prototype.neg = function() &#123; return this.mul(-1);&#125;;Vector.prototype.getValues = function () &#123; return this._values;&#125;; 实现矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138function Matrix(list2d) &#123; const result = []; for (let list of list2d) &#123; result.push(list); &#125; this._values = result;&#125;Matrix.zero = function(r, c) &#123; const result = []; for (let i = 0;i &lt; r;i++) &#123; result.push(new Array(c).fill(0)); &#125; return new Matrix(result);&#125;;Matrix.prototype.toString = function() &#123; return `Matrix($&#123;JSON.stringify(this._values)&#125;)`;&#125;;Matrix.prototype.len = function() &#123; return this._values.length;&#125;;/** * 几行几列 * @return &#123;*[]&#125; */Matrix.prototype.shape = function() &#123; return [this.len(), this._values[0].length];&#125;;Matrix.prototype.rowNum = function() &#123; return this.shape()[0];&#125;;Matrix.prototype.colNum = function() &#123; return this.shape()[1];&#125;;Matrix.prototype.size = function() &#123; return this.rowNum() * this.colNum();&#125;;Matrix.prototype.getItem = function(row, col) &#123; return this._values[row][col];&#125;;Matrix.prototype.rowVector = function(index) &#123; return new Vector(this._values[index]);&#125;;Matrix.prototype.colVector = function(index) &#123; const result = []; for (let row of this._values) &#123; result.push(row[index]); &#125; return new Vector(result);&#125;;Matrix.prototype.add = function(another) &#123; console.assert(this.toString() === another.toString(), 'Error in adding. Shape of matrix must be same.'); const result = []; for (let rowIndex = 0;rowIndex &lt; this.rowNum();rowIndex++) &#123; result[rowIndex] = []; for (let colIndex = 0;colIndex &lt; this.colNum();colIndex++) &#123; result[rowIndex].push(math.chain(this.getItem(rowIndex, colIndex)).add(another.getItem(rowIndex, colIndex)).value); &#125; &#125; return new Matrix(result)&#125;;Matrix.prototype.sub = function(another) &#123; console.assert(this.toString() === another.toString(), 'Error in adding. Shape of matrix must be same.'); const result = []; for (let rowIndex = 0;rowIndex &lt; this.rowNum();rowIndex++) &#123; result[rowIndex] = []; for (let colIndex = 0;colIndex &lt; this.colNum();colIndex++) &#123; result[rowIndex].push(math.chain(this.getItem(rowIndex, colIndex)).subtract(another.getItem(rowIndex, colIndex)).value); &#125; &#125; return new Matrix(result)&#125;;Matrix.prototype.dot = function(another) &#123; if (another instanceof Vector) &#123; console.assert(this.colNum() === another.len(), 'Error in Matrix-Vector Multiplication'); const result = []; for (let i = 0;i &lt; this.rowNum();i++) &#123; result.push(this.rowVector(i).dot(another)); &#125; return new Vector(result); &#125; if (another instanceof Matrix) &#123; console.assert(this.colNum() === another.rowNum(), 'Error in Matrix-Matrix Multiplication'); const result = new Array(this.rowNum()).fill(0).map(function()&#123; return []; &#125;); for (let j = 0;j &lt; another.colNum();j++) &#123; for (let i = 0;i &lt; this.rowNum();i++) &#123; result[i][j] = this.rowVector(i).dot(another.colVector(j)); &#125; &#125; return new Matrix(result); &#125;&#125;;Matrix.prototype.mul = function(k) &#123; const result = []; for (let rowIndex = 0;rowIndex &lt; this.rowNum();rowIndex++) &#123; result[rowIndex] = []; for (let colIndex = 0;colIndex &lt; this.colNum();colIndex++) &#123; result[rowIndex].push(math.chain(this.getItem(rowIndex, colIndex)).multiply(k).value); &#125; &#125; return new Matrix(result)&#125;;Matrix.prototype.div = function(k) &#123; return this.mul(math.chain(1).divide(k).value);&#125;;Matrix.prototype.pos = function() &#123; return this.mul(1);&#125;;Matrix.prototype.neg = function() &#123; return this.mul(-1);&#125;;Matrix.prototype.T = function() &#123; const result = []; for (let i = 0;i &lt; this.colNum();i++) &#123; result.push(this.colVector(i).getValues()) &#125; return new Matrix(result);&#125;;console.log(new Matrix([[1,0], [0,1]]).dot(new Matrix([[2,1,3,4,5,6],[3,5,6,1,2,9]])))","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"20、LinearAlgebra 之矩阵的逆","slug":"LinearAlgebra/20、LinearAlgebra 之矩阵的逆","date":"2020-05-07T06:00:00.000Z","updated":"2020-08-07T14:10:11.801Z","comments":true,"path":"2020/05/07/LinearAlgebra/20、LinearAlgebra 之矩阵的逆/","link":"","permalink":"https://www.zackaddy.xin/2020/05/07/LinearAlgebra/20、LinearAlgebra 之矩阵的逆/","excerpt":"","text":"LinearAlgebra 之矩阵的逆什么是矩阵的逆1234567891011121314151617181920212223242526272829303132333435数字系统中：x \\cdot (x^&#123;-1&#125;)=1 \\\\矩阵中：AB = BA = I,则称B是A的逆矩阵，记作：B = A^&#123;-1&#125; \\\\A称为可逆矩阵，或者叫非奇异矩阵（non-singular）\\\\有些矩阵是不可逆的！称为不可逆矩阵，或者奇异矩阵（singular）\\\\如果BA=I，则称B是A的左逆矩阵 \\\\如果AC=I，则称C是A的右逆矩阵。\\\\如果一个矩阵A既存在左逆矩阵B，又存在右逆矩阵C，则B=C \\\\BA=I \\quad AC=I \\\\B(AC)=BI \\\\(BA)C = B \\\\IC = B \\\\C = B \\\\对于矩阵A，存在矩阵B，满足BA=AB=I，矩阵A可逆 \\\\可逆矩阵一定为方阵！ \\\\非方阵一定不可逆！ \\\\A^&#123;0&#125; = I \\\\A^&#123;-2&#125;=(A^&#123;-1&#125;)^2 \\\\对于矩阵A，如果存在逆矩阵B，则B唯一。 矩阵逆的性质12345证明：(A^&#123;-1&#125;)^&#123;-1&#125; = A \\quad (X)^&#123;-1&#125; = A \\\\只需要证明：X \\cdot A = I \\quad A \\cdot X = I \\\\A^&#123;-1&#125; \\cdot A = I \\quad A \\cdot A^&#123;-1&#125; = I 123456789101112131415161718192021证明：(A \\cdot B)^&#123;-1&#125; = B^&#123;-1&#125;A^&#123;-1&#125; \\\\只需要证明：(AB)\\cdot(B^&#123;-1&#125;A^&#123;-1&#125;) = I \\quad (B^&#123;-1&#125;A^&#123;-1&#125;)\\cdot(AB) = I \\\\= A(B \\cdot B^&#123;-1&#125;)A^&#123;-1&#125; \\quad = B^&#123;-1&#125;(A^&#123;-1&#125;\\cdot A)B \\\\= A \\cdot I \\cdot A^&#123;-1&#125; \\quad = B^&#123;-1&#125; \\cdot I \\cdot B \\\\= A \\cdot A^&#123;-1&#125; = I \\quad = B^&#123;-1&#125; \\cdot B = I \\\\(A \\cdot B)^&#123;-1&#125; = B^&#123;-1&#125;A^&#123;-1&#125; \\\\(A \\cdot B)^&#123;T&#125; = B^&#123;T&#125;A^&#123;T&#125; \\\\证明：(A^T)^&#123;-1&#125; = (A^&#123;-1&#125;)^T \\\\只需要证明：A^T \\cdot (A^&#123;-1&#125;)^T = I \\quad (A^&#123;-1&#125;)^T \\cdot A^T = I \\\\= (A^&#123;-1&#125; \\cdot A)^T \\quad = (A \\cdot A^&#123;-1&#125;)^T \\\\= I^T = I \\quad = I^T = I","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"19、LinearAlgebra 之单位矩阵","slug":"LinearAlgebra/19、LinearAlgebra 之单位矩阵","date":"2020-05-07T05:00:00.000Z","updated":"2020-08-07T14:10:11.800Z","comments":true,"path":"2020/05/07/LinearAlgebra/19、LinearAlgebra 之单位矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/07/LinearAlgebra/19、LinearAlgebra 之单位矩阵/","excerpt":"","text":"LinearAlgebra 之单位矩阵12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273让每个点的横坐标扩大1倍，纵坐标扩大1倍 \\\\T = \\begin&#123;pmatrix&#125; 1 &amp; 0 \\\\ 0 &amp; 1\\end&#123;pmatrix&#125; \\quad T \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 1 &amp; 0 \\\\ 0 &amp; 1\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; \\\\经过矩阵变换后结果未改变。 \\\\我们称这样的矩阵为单位矩阵：\\\\ I_2 = \\begin&#123;pmatrix&#125; 1 &amp; 0 \\\\ 0 &amp; 1\\end&#123;pmatrix&#125; \\\\I_3 = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125; \\\\I_n = \\begin&#123;pmatrix&#125; 1 &amp; 0 &amp; ... &amp; 0 \\\\ 0 &amp; 1 &amp; ... &amp; 0 \\\\ ... &amp; ... &amp; ... &amp; ... \\\\ 0 &amp; 0 &amp; ... &amp; 1\\end&#123;pmatrix&#125; \\\\I_n = (i_&#123;kj&#125;) = \\begin&#123;cases&#125; 1 &amp;\\text&#123;if &#125; k=j \\\\ 0 &amp;\\text&#123;if &#125; k\\space&#123;=&#125;\\mathllap&#123;/\\,&#125;\\space j\\end&#123;cases&#125; \\\\单位矩阵一定是方阵 \\\\I \\cdot A = A \\\\\\begin&#123;pmatrix&#125; --\\overrightharpoon&#123;r_1&#125;-- \\\\ --\\overrightharpoon&#123;r_2&#125;-- \\\\ ... \\\\ --\\overrightharpoon&#123;r_m&#125;-- \\end&#123;pmatrix&#125;\\space \\cdot \\begin&#123;pmatrix&#125; | &amp; | &amp; &amp; | \\\\ \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;c_n&#125; \\\\ | &amp; | &amp; &amp; | \\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_n&#125; \\\\ \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_n&#125; \\\\ ... &amp; ... &amp; &amp; ... \\\\ \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_n&#125;\\end&#123;pmatrix&#125; \\\\I \\cdot A = A \\quad A \\cdot I = A \\quad I \\cdot A = A \\cdot I = A\\\\","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"18、LinearAlgebra 之矩阵旋转变换","slug":"LinearAlgebra/18、LinearAlgebra 之矩阵旋转变换","date":"2020-05-06T06:00:00.000Z","updated":"2020-08-07T14:10:11.800Z","comments":true,"path":"2020/05/06/LinearAlgebra/18、LinearAlgebra 之矩阵旋转变换/","link":"","permalink":"https://www.zackaddy.xin/2020/05/06/LinearAlgebra/18、LinearAlgebra 之矩阵旋转变换/","excerpt":"","text":"LinearAlgebra 之矩阵旋转变换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354旋转：T \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; ? \\\\ ?\\end&#123;pmatrix&#125;\\cos\\alpha \\cdot d = x \\quad d = \\frac&#123;x&#125;&#123;\\cos\\alpha&#125; \\quad d = \\frac&#123;x&apos;&#125;&#123;\\cos(\\alpha - \\theta)&#125;\\\\\\sin\\alpha \\cdot d = y \\quad d = \\frac&#123;y&#125;&#123;\\sin\\alpha&#125; \\quad d = \\frac&#123;y&apos;&#125;&#123;\\sin(\\alpha - \\theta)&#125;\\\\x&apos; = \\frac&#123;\\cos(\\alpha - \\theta)&#125;&#123;\\cos\\alpha&#125;x \\quad y&apos; = \\frac&#123;\\sin(\\alpha - \\theta)&#125;&#123;\\sin\\alpha&#125;y \\\\x&apos; = \\cos\\theta \\cdot x + \\sin\\theta\\frac&#123;\\sin\\alpha&#125;&#123;\\cos\\alpha&#125;x = \\cos\\theta \\cdot x + \\sin\\theta \\cdot y \\\\T \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta \\cdot x + \\sin\\theta \\cdot y \\\\ ?\\end&#123;pmatrix&#125; \\\\y&apos; = \\frac&#123;\\sin\\alpha\\cos\\theta - \\cos\\alpha\\sin\\theta&#125;&#123;\\sin\\alpha&#125;y \\\\y&apos; = \\cos\\theta \\cdot y - \\sin\\theta\\frac&#123;\\cos\\alpha&#125;&#123;\\sin\\alpha&#125;y = \\cos\\theta \\cdot y - \\sin\\theta \\cdot x \\\\T \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta \\cdot x + \\sin\\theta \\cdot y \\\\ - \\sin\\theta \\cdot x + \\cos\\theta \\cdot y\\end&#123;pmatrix&#125; \\\\T = \\begin&#123;pmatrix&#125; \\cos\\theta &amp; \\sin\\theta \\\\ -\\sin\\theta &amp; \\cos\\theta\\end&#123;pmatrix&#125; \\\\T \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta &amp; \\sin\\theta \\\\ -\\sin\\theta &amp; \\cos\\theta\\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; x \\\\ y\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\cos\\theta \\cdot x + \\sin\\theta \\cdot y \\\\ - \\sin\\theta \\cdot x + \\cos\\theta \\cdot y\\end&#123;pmatrix&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"17、LinearAlgebra 之更多变换矩阵","slug":"LinearAlgebra/17、LinearAlgebra 之更多变换矩阵","date":"2020-05-06T05:00:00.000Z","updated":"2020-08-07T14:10:11.800Z","comments":true,"path":"2020/05/06/LinearAlgebra/17、LinearAlgebra 之更多变换矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/06/LinearAlgebra/17、LinearAlgebra 之更多变换矩阵/","excerpt":"","text":"LinearAlgebra 之更多变换矩阵","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"16、LinearAlgebra 之矩阵转置","slug":"LinearAlgebra/16、LinearAlgebra 之矩阵转置","date":"2020-05-05T06:00:00.000Z","updated":"2020-08-07T14:10:11.800Z","comments":true,"path":"2020/05/05/LinearAlgebra/16、LinearAlgebra 之矩阵转置/","link":"","permalink":"https://www.zackaddy.xin/2020/05/05/LinearAlgebra/16、LinearAlgebra 之矩阵转置/","excerpt":"","text":"LinearAlgebra 之矩阵转置12345678910111213141516171819202122232425262728293031323334T = \\begin&#123;pmatrix&#125; 1.5 &amp; 0 \\\\ 0 &amp; 2\\end&#123;pmatrix&#125; \\\\P = \\begin&#123;pmatrix&#125; 0 &amp; 0 \\\\ 4 &amp; 3 \\\\ 5 &amp; 3\\end&#123;pmatrix&#125; \\\\T 和 P不能直接相乘,T的列数与P的行数不相同\\\\需要对P进行转置才能与T相乘 \\\\ P^T = \\begin&#123;pmatrix&#125; 0 &amp; 4 &amp; 5 \\\\ 0 &amp; 3 &amp; 3\\end&#123;pmatrix&#125; \\\\P^T上的T为transposition的缩写 \\\\矩阵的转置：行变成列；列变成行 \\\\A = (a_&#123;ij&#125;) \\\\A^T = (a_&#123;ji&#125;) \\\\回忆：行向量与列向量 (3,4) \\begin&#123;pmatrix&#125; 3 \\\\ 4\\end&#123;pmatrix&#125; \\\\由于横板印刷问题，使用符号：(3,4)^T 矩阵转置的性质1234567(A^T)^T = A \\\\(A+B)^T = A^T + B^T \\\\(k \\cdot A)^T = k \\cdot A^T \\\\(A \\cdot B)^T = B^T \\cdot A^T 下方证明不完全正确，但可以帮助理解 123456789证明思路： (A \\cdot B)^T = B^T \\cdot A^T \\\\A是m*k矩阵，B是k*n的矩阵AB是m*n的矩阵，AB的转置是n*m的矩阵A的转置是k*m的矩阵，B的转置是n*k的矩阵(B的转置)(A的转置)是n*m的矩阵","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"15、LinearAlgebra 之矩阵乘法的性质和矩阵的幂","slug":"LinearAlgebra/15、LinearAlgebra 之矩阵乘法的性质和矩阵的幂","date":"2020-05-05T05:00:00.000Z","updated":"2020-08-07T14:10:11.799Z","comments":true,"path":"2020/05/05/LinearAlgebra/15、LinearAlgebra 之矩阵乘法的性质和矩阵的幂/","link":"","permalink":"https://www.zackaddy.xin/2020/05/05/LinearAlgebra/15、LinearAlgebra 之矩阵乘法的性质和矩阵的幂/","excerpt":"","text":"LinearAlgebra 之矩阵乘法的性质和矩阵的幂矩阵乘法的性123456789101112131415161718矩阵乘法不遵守交换律： A \\cdot B \\mathrlap&#123;\\,/&#125;&#123;=&#125; B \\cdot A \\\\ 矩阵乘法遵守：(A \\cdot B) \\cdot C = A \\cdot (B \\cdot C) \\\\A \\cdot (B + C) = A \\cdot B + A \\cdot C \\\\(B + C) \\cdot A = B \\cdot A + C \\cdot A \\\\对任意r*c的矩阵A，存在c*x的矩阵O，满足：A \\cdot O_&#123;cx&#125; = O_&#123;rx&#125; \\\\对任意r*c的矩阵A，存在x*r的矩阵O，满足：O_&#123;xr&#125; \\cdot A = O_&#123;xc&#125; \\\\(A+B)^2 \\mathrlap&#123;\\,/&#125;&#123;=&#125; A^2 + 2AB + B^2 \\\\(A+B)^2 = (A+B) \\cdot (A+B) \\\\= A \\cdot(A+B)+B \\cdot(A+B) \\\\= A \\cdot A + A \\cdot B + B \\cdot A + B \\cdot B \\\\= A^2 + A \\cdot B + B \\cdot A + B^2 矩阵的幂只有方阵才可以进行矩阵的幂运算！ 1A^k = \\underbrace&#123;A \\cdot A \\cdot ... \\cdot A&#125;_&#123;\\text&#123;k&#125;&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"14、LinearAlgebra 之矩阵和矩阵的乘法","slug":"LinearAlgebra/14、LinearAlgebra 之矩阵和矩阵的乘法","date":"2020-05-04T06:00:00.000Z","updated":"2020-08-07T14:10:11.799Z","comments":true,"path":"2020/05/04/LinearAlgebra/14、LinearAlgebra 之矩阵和矩阵的乘法/","link":"","permalink":"https://www.zackaddy.xin/2020/05/04/LinearAlgebra/14、LinearAlgebra 之矩阵和矩阵的乘法/","excerpt":"","text":"LinearAlgebra 之矩阵和矩阵的乘法矩阵在图形变换中的应用 上面T我们可以使用任意点坐标与之相乘就可以将横坐标放大1.5倍，纵坐标放大2倍 下面我们将多个坐标与T相乘使之批量放大，而不用一个一个点与T相乘 矩阵与矩阵乘法 矩阵A的列数必须和矩阵B的行数相等 矩阵A的行数与结果行数相等 矩阵B的列数与结果列数相等 A是mk矩阵；B是kn矩阵，则结果为mn的矩阵![image](http://m.qpic.cn/psc?/V11lfhu01dRHln/AhdOM4QqaJmhyYpLm8c4zvVo2PpACwoiHinPHAnYGhOicWLpwSCpmwsi5d7w0Ue02nZLrCDO.MOQxY9BBf1wg!!/b&amp;bo=owNOAQAAAAARB98!&amp;rf=viewer_4) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748A \\cdot B = A \\cdot \\begin&#123;pmatrix&#125; | &amp; | &amp; &amp; | \\\\ \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;c_n&#125; \\\\ | &amp; | &amp; &amp; | \\end&#123;pmatrix&#125;\\space = \\begin&#123;pmatrix&#125; | &amp; | &amp; &amp; | \\\\ A \\cdot \\overrightharpoon&#123;c_1&#125; &amp; A \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; A \\cdot \\overrightharpoon&#123;c_n&#125; \\\\ | &amp; | &amp; &amp; | \\end&#123;pmatrix&#125;\\\\\\begin&#123;pmatrix&#125; --\\overrightharpoon&#123;r_1&#125;-- \\\\ --\\overrightharpoon&#123;r_2&#125;-- \\\\ ... \\\\ --\\overrightharpoon&#123;r_m&#125;-- \\end&#123;pmatrix&#125;\\space \\cdot \\begin&#123;pmatrix&#125; | &amp; | &amp; &amp; | \\\\ \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;c_n&#125; \\\\ | &amp; | &amp; &amp; | \\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;c_n&#125; \\\\ \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;c_n&#125; \\\\ ... &amp; ... &amp; &amp; ... \\\\ \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;c_n&#125;\\end&#123;pmatrix&#125;\\begin&#123;pmatrix&#125; | &amp; | &amp; &amp; | \\\\ \\overrightharpoon&#123;c_1&#125; &amp; \\overrightharpoon&#123;c_2&#125; &amp; ... &amp; \\overrightharpoon&#123;c_n&#125; \\\\ | &amp; | &amp; &amp; | \\end&#123;pmatrix&#125; \\cdot \\begin&#123;pmatrix&#125; --\\overrightharpoon&#123;r_1&#125;-- \\\\ --\\overrightharpoon&#123;r_2&#125;-- \\\\ ... \\\\ --\\overrightharpoon&#123;r_n&#125;-- \\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;c_1&#125; \\cdot \\overrightharpoon&#123;r_1&#125;\\end&#123;pmatrix&#125; + \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;c_2&#125; \\cdot \\overrightharpoon&#123;r_2&#125;\\end&#123;pmatrix&#125; + ... + \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;c_n&#125; \\cdot \\overrightharpoon&#123;r_n&#125;\\end&#123;pmatrix&#125; 12345矩阵乘法不遵守交换律！A \\cdot B &#123;=&#125;\\mathllap&#123;/\\,&#125; B \\cdot A\\\\很有可能根本不能相乘！即时可以相乘，结果也不一样","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"13、LinearAlgebra 之矩阵和向量的乘法与把矩阵看作向量的函数","slug":"LinearAlgebra/13、LinearAlgebra 之矩阵和向量的乘法与把矩阵看作向量的函数","date":"2020-05-04T05:00:00.000Z","updated":"2020-08-07T14:10:11.799Z","comments":true,"path":"2020/05/04/LinearAlgebra/13、LinearAlgebra 之矩阵和向量的乘法与把矩阵看作向量的函数/","link":"","permalink":"https://www.zackaddy.xin/2020/05/04/LinearAlgebra/13、LinearAlgebra 之矩阵和向量的乘法与把矩阵看作向量的函数/","excerpt":"","text":"LinearAlgebra 之矩阵和向量的乘法与把矩阵看作向量的函数12345678910111213141516171819202122232425262728293031323334353637383940\\begin&#123;cases&#125; x_&#123;it&#125; - 0.2x_e + 0.1x_m + 0.5x_h = 100 \\\\ -0.5x_&#123;it&#125; - x_e + 0.2x_m + 0.1x_h = 50 \\\\ -0.4x_e - x_m + 0.3x_h = 20 \\\\ -0.2x_&#123;it&#125; + x_h = 666\\end&#123;cases&#125;\\\\\\begin&#123;pmatrix&#125; 1 &amp; -0.2 &amp; 0.1 &amp; 0.5 \\\\ -0.5 &amp; -1 &amp; 0.2 &amp; 0.1 \\\\ 0 &amp; -0.4 &amp; -1 &amp; 0.3 \\\\ -0.2 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125;\\space \\begin&#123;pmatrix&#125; x_&#123;it&#125; \\\\ x_e \\\\ x_m \\\\ x_h\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; 100 \\\\ 50 \\\\ 20 \\\\ 666\\end&#123;pmatrix&#125;\\\\\\begin&#123;pmatrix&#125; 1 &amp; -0.2 &amp; 0.1 &amp; 0.5 \\\\ -0.5 &amp; -1 &amp; 0.2 &amp; 0.1 \\\\ 0 &amp; -0.4 &amp; -1 &amp; 0.3 \\\\ -0.2 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125;\\space \\begin&#123;pmatrix&#125; x_&#123;it&#125; \\\\ x_e \\\\ x_m \\\\ x_h\\end&#123;pmatrix&#125; = \\begin&#123;pmatrix&#125; x_&#123;it&#125; - 0.2x_e + 0.1x_m + 0.5x_h \\\\ -0.5x_&#123;it&#125; - x_e + 0.2x_m + 0.1x_h \\\\ -0.4x_e - x_m + 0.3x_h \\\\ -0.2x_&#123;it&#125; + x_h\\end&#123;pmatrix&#125; 矩阵A的列数必须和向量u的元素个数一致！ 矩阵A的行数没有限制 1T \\cdot \\overrightharpoon&#123;a&#125; = \\overrightharpoon&#123;b&#125; 矩阵T实际上将向量a转换成了向量b 可以把矩阵理解成向量的函数 1234567891011\\begin&#123;pmatrix&#125; --\\overrightharpoon&#123;r_1&#125;-- \\\\ --\\overrightharpoon&#123;r_2&#125;-- \\\\ ... \\\\ --\\overrightharpoon&#123;r_m&#125;-- \\end&#123;pmatrix&#125;\\space \\cdot \\overrightharpoon&#123;u&#125; = \\begin&#123;pmatrix&#125; \\overrightharpoon&#123;r_1&#125; \\cdot \\overrightharpoon&#123;u&#125; \\\\ \\overrightharpoon&#123;r_2&#125; \\cdot \\overrightharpoon&#123;u&#125; \\\\ ... \\\\ \\overrightharpoon&#123;r_m&#125; \\cdot \\overrightharpoon&#123;u&#125;\\end&#123;pmatrix&#125; 再看向量的点乘","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"12、LinearAlgebra 之把矩阵看作是对系统的描述","slug":"LinearAlgebra/12、LinearAlgebra 之把矩阵看作是对系统的描述","date":"2020-05-03T06:00:00.000Z","updated":"2020-08-07T14:10:11.799Z","comments":true,"path":"2020/05/03/LinearAlgebra/12、LinearAlgebra 之把矩阵看作是对系统的描述/","link":"","permalink":"https://www.zackaddy.xin/2020/05/03/LinearAlgebra/12、LinearAlgebra 之把矩阵看作是对系统的描述/","excerpt":"","text":"LinearAlgebra 之把矩阵看作是对系统的描述 线性方程组在各个领域，有着重要的应用 在线性代数中，称为线性系统 123456789101112131415161718\\begin&#123;cases&#125; x_&#123;it&#125; - 0.2x_e + 0.1x_m + 0.5x_h = 100 \\\\ -0.5x_&#123;it&#125; - x_e + 0.2x_m + 0.1x_h = 50 \\\\ -0.4x_e - x_m + 0.3x_h = 20 \\\\ -0.2x_&#123;it&#125; + x_h = 666\\end&#123;cases&#125;\\\\左侧 = \\begin&#123;pmatrix&#125; 1 &amp; -0.2 &amp; 0.1 &amp; 0.5 \\\\ -0.5 &amp; -1 &amp; 0.2 &amp; 0.1 \\\\ 0 &amp; -0.4 &amp; -1 &amp; 0.3 \\\\ -0.2 &amp; 0 &amp; 0 &amp; 1\\end&#123;pmatrix&#125;\\space 右侧 = \\begin&#123;pmatrix&#125; 100 \\\\ 50 \\\\ 20 \\\\ 666\\end&#123;pmatrix&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"11、LinearAlgebra 之矩阵的基本运算和基本性质","slug":"LinearAlgebra/11、LinearAlgebra 之矩阵的基本运算和基本性质","date":"2020-05-03T05:00:00.000Z","updated":"2020-08-07T14:10:11.798Z","comments":true,"path":"2020/05/03/LinearAlgebra/11、LinearAlgebra 之矩阵的基本运算和基本性质/","link":"","permalink":"https://www.zackaddy.xin/2020/05/03/LinearAlgebra/11、LinearAlgebra 之矩阵的基本运算和基本性质/","excerpt":"","text":"LinearAlgebra 之矩阵的基本运算和基本性质矩阵加法 1234567891011121314151617181920A = \\begin&#123;pmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; ... &amp; a_&#123;1c&#125; \\\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; ... &amp; a_&#123;2c&#125; \\\\ ... &amp; ... &amp; ... &amp; ... \\\\ a_&#123;r1&#125; &amp; a_&#123;r2&#125; &amp; ... &amp; a_&#123;rc&#125; \\\\\\end&#123;pmatrix&#125;\\\\B = \\begin&#123;pmatrix&#125; b_&#123;11&#125; &amp; b_&#123;12&#125; &amp; ... &amp; b_&#123;1c&#125; \\\\ b_&#123;21&#125; &amp; b_&#123;22&#125; &amp; ... &amp; b_&#123;2c&#125; \\\\ ... &amp; ... &amp; ... &amp; ... \\\\ b_&#123;r1&#125; &amp; b_&#123;r2&#125; &amp; ... &amp; b_&#123;rc&#125; \\\\\\end&#123;pmatrix&#125;A + B = \\begin&#123;pmatrix&#125; a_&#123;11&#125; + b_&#123;11&#125; &amp; a_&#123;12&#125; + b_&#123;12&#125; &amp; ... &amp; a_&#123;1c&#125; + b_&#123;1c&#125; \\\\ a_&#123;21&#125; + b_&#123;21&#125; &amp; a_&#123;22&#125; + b_&#123;22&#125; &amp; ... &amp; a_&#123;2c&#125; + b_&#123;2c&#125; \\\\ ... &amp; ... &amp; ... &amp; ... \\\\ a_&#123;r1&#125; + b_&#123;r1&#125; &amp; a_&#123;r2&#125; + b_&#123;r2&#125; &amp; ... &amp; a_&#123;rc&#125; + b_&#123;rc&#125; \\\\\\end&#123;pmatrix&#125; 矩阵的数量乘法","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"10、LinearAlgebra 之什么是矩阵","slug":"LinearAlgebra/10、LinearAlgebra 之什么是矩阵","date":"2020-05-02T06:00:00.000Z","updated":"2020-08-07T14:10:11.798Z","comments":true,"path":"2020/05/02/LinearAlgebra/10、LinearAlgebra 之什么是矩阵/","link":"","permalink":"https://www.zackaddy.xin/2020/05/02/LinearAlgebra/10、LinearAlgebra 之什么是矩阵/","excerpt":"","text":"LinearAlgebra 之什么是矩阵 向量是对数的扩展，一个向量表示一组数 矩阵是对向量的扩展，一个矩阵表示一组向量 123456\\begin&#123;pmatrix&#125; 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\\\ 9 &amp; 10 &amp; 11 &amp; 12 \\\\ 13 &amp; 14 &amp; 15 &amp; 16 \\\\\\end&#123;pmatrix&#125; 行视角：每一行表示一个向量 列视角：每一列表示一个向量 每个视角都有4个向量 行数与列数相等则称为方阵 方阵有很多特殊的性质 有很多特殊的矩阵是方阵 我们通常用大写字母代表一个矩阵，对应的小写字母代表元素，其中数字代表对应的行列下标 12345A = \\begin&#123;pmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; &amp; a_&#123;14&#125; \\\\ a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; &amp; a_&#123;24&#125; \\\\ a_&#123;31&#125; &amp; a_&#123;32&#125; &amp; a_&#123;33&#125; &amp; a_&#123;34&#125; \\\\\\end&#123;pmatrix&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"9、LinearAlgebra 之向量点乘的应用","slug":"LinearAlgebra/9、LinearAlgebra 之向量点乘的应用","date":"2020-05-02T05:00:00.000Z","updated":"2020-08-07T14:10:11.841Z","comments":true,"path":"2020/05/02/LinearAlgebra/9、LinearAlgebra 之向量点乘的应用/","link":"","permalink":"https://www.zackaddy.xin/2020/05/02/LinearAlgebra/9、LinearAlgebra 之向量点乘的应用/","excerpt":"","text":"LinearAlgebra 之向量点乘的应用","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"8、LinearAlgebra 之向量的点乘与几何意义","slug":"LinearAlgebra/8、LinearAlgebra 之向量的点乘与几何意义","date":"2020-05-01T06:00:00.000Z","updated":"2020-08-07T14:10:11.841Z","comments":true,"path":"2020/05/01/LinearAlgebra/8、LinearAlgebra 之向量的点乘与几何意义/","link":"","permalink":"https://www.zackaddy.xin/2020/05/01/LinearAlgebra/8、LinearAlgebra 之向量的点乘与几何意义/","excerpt":"","text":"LinearAlgebra 之向量的点乘与几何意义两个向量相乘 1上图表达：||\\overrightharpoon&#123;u&#125;||到\\overrightharpoon&#123;\\nu&#125;向量上的投影再与||\\overrightharpoon&#123;\\nu&#125;||相乘","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"7、LinearAlgebra 之规范化和单位向量","slug":"LinearAlgebra/7、LinearAlgebra 之规范化和单位向量","date":"2020-05-01T05:00:00.000Z","updated":"2020-08-07T14:10:11.840Z","comments":true,"path":"2020/05/01/LinearAlgebra/7、LinearAlgebra 之规范化和单位向量/","link":"","permalink":"https://www.zackaddy.xin/2020/05/01/LinearAlgebra/7、LinearAlgebra 之规范化和单位向量/","excerpt":"","text":"LinearAlgebra 之规范化和单位向量 123\\overrightharpoon&#123;u&#125;的大小可以说成\\overrightharpoon&#123;u&#125;的欧拉长度，也可以说成\\overrightharpoon&#123;u&#125;的模\\\\由于||与绝对值符号重合所以向量的模改用||||双竖线表示，有的课本可能用的还是单竖线 向量的模 我们可以从上面得知向量模的计算方法 单位向量 标准单位向量 n维空间中，有n个标准单位向量 123\\overrightharpoon&#123;e_1&#125; = (1,0,...,0)\\\\\\overrightharpoon&#123;e_2&#125; = (0,1,...,0)\\\\\\overrightharpoon&#123;e_n&#125; = (0,0,...,1)","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"6、LinearAlgebra 之零向量","slug":"LinearAlgebra/6、LinearAlgebra 之零向量","date":"2020-04-30T06:00:00.000Z","updated":"2020-08-07T14:10:11.816Z","comments":true,"path":"2020/04/30/LinearAlgebra/6、LinearAlgebra 之零向量/","link":"","permalink":"https://www.zackaddy.xin/2020/04/30/LinearAlgebra/6、LinearAlgebra 之零向量/","excerpt":"","text":"LinearAlgebra 之零向量我们不定义什么是零向量，我们从推导出一个性质出发 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556对于任意一个向量\\space\\overrightharpoon&#123;u&#125;\\space都有一个向量O，满足：\\overrightharpoon&#123;u&#125;+O=\\overrightharpoon&#123;u&#125;\\\\\\overrightharpoon&#123;u&#125; = \\begin&#123;pmatrix&#125; u_1 \\\\ u_2 \\\\ ... \\\\ u_n \\end&#123;pmatrix&#125;\\spaceO = \\begin&#123;pmatrix&#125; o_1 \\\\ o_2 \\\\ ... \\\\ o_n \\end&#123;pmatrix&#125;\\space\\overrightharpoon&#123;u&#125; + O = \\begin&#123;pmatrix&#125; u_1 \\\\ u_2 \\\\ ... \\\\ u_n \\end&#123;pmatrix&#125; + \\begin&#123;pmatrix&#125; o_1 \\\\ o_2 \\\\ ... \\\\ o_n \\end&#123;pmatrix&#125;\\space= \\begin&#123;pmatrix&#125; u_1+o_1 \\\\ u_2+o_2 \\\\ ... \\\\ u_n+o_n \\end&#123;pmatrix&#125;\\space=\\begin&#123;pmatrix&#125; u_1 \\\\ u_2 \\\\ ... \\\\ u_n \\end&#123;pmatrix&#125;\\\\\\begin&#123;cases&#125; u_1 + o_1 = u_1 \\\\ u_2 + o_2 = u_2 \\\\ ... \\\\ u_n + o_n = u_n \\\\\\end&#123;cases&#125;\\implies\\begin&#123;cases&#125; o_1 = 0 \\\\ o_2 = 0 \\\\ ... \\\\ o_n = 0 \\\\\\end&#123;cases&#125;\\implies O = \\begin&#123;cases&#125; 0 \\\\ 0 \\\\ ... \\\\ 0 \\\\\\end&#123;cases&#125; 我们证明了O这个向量的存在性，我们称这个向量，为零向量 123456O = \\begin&#123;cases&#125; 0 \\\\ 0 \\\\ ... \\\\ 0 \\\\\\end&#123;cases&#125; 注意：这个零向量O没有箭头，它没有方向，它就是一个点，在坐标原点 123456789101112131415对于任意一个向量\\space\\overrightharpoon&#123;u&#125;\\space都有一个向量\\overrightharpoon&#123;-u&#125;，满足：\\overrightharpoon&#123;u&#125;+\\overrightharpoon&#123;-u&#125;=O\\\\上述\\overrightharpoon&#123;-u&#125;唯一。\\\\证明：假设存在另外一个向量\\overrightharpoon&#123;\\nu&#125;，也满足\\overrightharpoon&#123;u&#125;+\\overrightharpoon&#123;\\nu&#125;=O\\\\\\overrightharpoon&#123;-u&#125; + (\\overrightharpoon&#123;u&#125;+\\overrightharpoon&#123;\\nu&#125;) = \\overrightharpoon&#123;-u&#125; + O\\\\(\\overrightharpoon&#123;-u&#125;+\\overrightharpoon&#123;u&#125;)+\\overrightharpoon&#123;\\nu&#125; = \\overrightharpoon&#123;-u&#125;\\\\O + \\overrightharpoon&#123;\\nu&#125; = \\overrightharpoon&#123;-u&#125;\\\\\\overrightharpoon&#123;\\nu&#125; = \\overrightharpoon&#123;-u&#125;\\\\上述\\overrightharpoon&#123;-u&#125;唯一。\\\\ 1\\overrightharpoon&#123;-u&#125; = -1 \\cdot \\overrightharpoon&#123;u&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"5、LinearAlgebra 之向量运算的基本性质","slug":"LinearAlgebra/5、LinearAlgebra 之向量运算的基本性质","date":"2020-04-30T05:00:00.000Z","updated":"2020-08-07T14:10:11.812Z","comments":true,"path":"2020/04/30/LinearAlgebra/5、LinearAlgebra 之向量运算的基本性质/","link":"","permalink":"https://www.zackaddy.xin/2020/04/30/LinearAlgebra/5、LinearAlgebra 之向量运算的基本性质/","excerpt":"","text":"LinearAlgebra 之向量运算的基本性质回忆小学时学习的数的运算 我们也要先有数的运算的相关性质，之后才敢进行更加复杂的运算 比如：加法交换律，乘法交换律，加法结合律，乘法结合律，等等 对于向量运算，我们也要这么做！ 123456\\overrightharpoon&#123;u&#125; + \\overrightharpoon&#123;\\nu&#125; = \\overrightharpoon&#123;\\nu&#125; + \\overrightharpoon&#123;u&#125; \\\\(\\overrightharpoon&#123;u&#125; + \\overrightharpoon&#123;\\nu&#125;)\\space+\\space \\overrightharpoon&#123;w&#125; = \\overrightharpoon&#123;u&#125; + (\\overrightharpoon&#123;\\nu&#125; + \\overrightharpoon&#123;w&#125;) \\\\k(\\overrightharpoon&#123;u&#125; + \\overrightharpoon&#123;\\nu&#125;) = k\\overrightharpoon&#123;u&#125; + k\\overrightharpoon&#123;\\nu&#125; \\\\(k+c)\\overrightharpoon&#123;u&#125; = k\\overrightharpoon&#123;u&#125; + c\\overrightharpoon&#123;u&#125; \\\\(kc)\\overrightharpoon&#123;u&#125; = k(c\\overrightharpoon&#123;u&#125;) \\\\1\\overrightharpoon&#123;u&#125; = \\overrightharpoon&#123;u&#125; \\\\ 证明举例 上面的6条向量运算都可以根据上图方式证明出来","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"4、LinearAlgebra 之向量的基本运算","slug":"LinearAlgebra/4、LinearAlgebra 之向量的基本运算","date":"2020-04-29T06:00:00.000Z","updated":"2020-08-07T14:10:11.809Z","comments":true,"path":"2020/04/29/LinearAlgebra/4、LinearAlgebra 之向量的基本运算/","link":"","permalink":"https://www.zackaddy.xin/2020/04/29/LinearAlgebra/4、LinearAlgebra 之向量的基本运算/","excerpt":"","text":"LinearAlgebra 之向量的基本运算向量加法 向量加法运算 两个向量相加为平行四边形对角线1(5,2)^T + (2,5)^T = (7,7)^T 以上是二维向量加法，三维向量加法同理 1234567891011121314151617\\begin&#123;pmatrix&#125; a \\\\ b \\\\ c \\end&#123;pmatrix&#125;+ \\begin&#123;pmatrix&#125; d \\\\ e \\\\ f \\end&#123;pmatrix&#125;=\\begin&#123;pmatrix&#125; a + d \\\\ b + e \\\\ c + f \\end&#123;pmatrix&#125; 我们继续推导至n维向量 1234567891011121314151617181920\\begin&#123;pmatrix&#125; v_1 \\\\ v_2 \\\\ ... \\\\ v_n\\end&#123;pmatrix&#125;+ \\begin&#123;pmatrix&#125; u_1 \\\\ u_2 \\\\ ... \\\\ u_n\\end&#123;pmatrix&#125;=\\begin&#123;pmatrix&#125; v_1 + u_1 \\\\ v_2 + u_2 \\\\ ... \\\\ v_n + u_n\\end&#123;pmatrix&#125; 向量乘法 数量乘法12 \\times (5,2)^T = (10,4)^T 继续延申 1k \\times (a,b)^T = (ka,kb)^T n维向量同理 123456789101112131415k\\times\\begin&#123;pmatrix&#125; v_1 \\\\ v_2 \\\\ ... \\\\ v_n\\end&#123;pmatrix&#125;=\\begin&#123;pmatrix&#125; k \\cdot v_1 \\\\ k \\cdot v_2 \\\\ ... \\\\ k \\cdot v_n\\end&#123;pmatrix&#125;","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"3、LinearAlgebra 之向量的更多术语与表示法","slug":"LinearAlgebra/3、LinearAlgebra 之向量的更多术语与表示法","date":"2020-04-29T05:00:00.000Z","updated":"2020-08-07T14:10:11.807Z","comments":true,"path":"2020/04/29/LinearAlgebra/3、LinearAlgebra 之向量的更多术语与表示法/","link":"","permalink":"https://www.zackaddy.xin/2020/04/29/LinearAlgebra/3、LinearAlgebra 之向量的更多术语与表示法/","excerpt":"","text":"LinearAlgebra 之向量的更多术语与表示法 和向量相对应，一个数字，称为标量 代数，用符号代表数。和标量相区别，向量的符号画箭头。 1\\overrightharpoon&#123;\\nu&#125; 个别情况下，尤其是几何学中，我们会考虑向量的起始点 在几何学中上图的两个向量是不相等的，在线性代数中大部分情况下这两个向量是相等的是不考虑起始点的。 向量分为列向量和行向量 行向量就是就是写成一行（3，4） 列向量就是如下写成一列 1234\\begin&#123;pmatrix&#125; 3 \\\\ 4\\end&#123;pmatrix&#125; 通常教材、论文提到的向量，都是指列向量 由于书籍横板印刷问题，使用符号： 1(3,4)^T 表示列向量","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"2、LinearAlgebra 之什么是向量","slug":"LinearAlgebra/2、LinearAlgebra 之什么是向量","date":"2020-04-28T06:00:00.000Z","updated":"2020-08-07T14:10:11.803Z","comments":true,"path":"2020/04/28/LinearAlgebra/2、LinearAlgebra 之什么是向量/","link":"","permalink":"https://www.zackaddy.xin/2020/04/28/LinearAlgebra/2、LinearAlgebra 之什么是向量/","excerpt":"","text":"LinearAlgebra 之什么是向量 为什么线性代数这么重要？从研究一个数扩展到一组数 一组数的基本表示方法————向量（Vector） 向量（Vector）是线性代数研究的基本元素 一个数 666 一组数 （6，66，666） 从物理专业的角度看，向量是空间中的箭头，决定一个向量的是它的长度和所指方向。只要这两个特征相同，就可以自由移动一个向量而保持它不变。 一组数有什么用最基本的出发点：表示方向 如上图第一个和第二个图的箭头长度都为5，虽然都为5但是它们表示的方向却不同。 向量的起始点 向量（Vector）是线性代数研究的基本元素 向量只考虑从一个点到另外一个点的过程，不考虑从哪个起始点出发的 为了研究的方便，我们定义的向量都是从原点起始的 顺序是重要的，（3，4）和（4，3）是截然不同的从坐标（-1，-1）到（3，2）和从（0，0）到（4，3）是一样的，坐标系不同 空间中的一个点，可以看做从原点指向这个点的一个方向 如果只是表示方向，最多三维就够了 更加抽象：n维向量","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"1、LinearAlgebra 之为什么学习线性代数","slug":"LinearAlgebra/1、LinearAlgebra 之为什么学习线性代数","date":"2020-04-28T05:00:00.000Z","updated":"2020-08-07T14:10:11.800Z","comments":true,"path":"2020/04/28/LinearAlgebra/1、LinearAlgebra 之为什么学习线性代数/","link":"","permalink":"https://www.zackaddy.xin/2020/04/28/LinearAlgebra/1、LinearAlgebra 之为什么学习线性代数/","excerpt":"","text":"LinearAlgebra 之为什么学习线性代数初等教育中的代数更多是在研究一个数 自然数N 有理数Q 实数R 1f(x) 将一个数传入一个规则中得到另外一个结果 线性代数在研究“一组数”，即向量。 1234567N^n \\space Q^n \\space R^n \\\\\\space\\\\\\spaceT(\\overrightharpoon&#123;\\nu&#125;)\\\\\\space\\\\\\space\\overrightharpoon&#123;x&#125;=(x_1 \\space x_2 \\space ... \\space x_n) 真实世界是多维度的 单变量不足以描述真实世界 用单变量描述真实世界是不方便的 线性代数是相对容易的，因为在低维空间很容易“看”到线性代数结论的直观几何意义。","categories":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}],"tags":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/tags/LinearAlgebra/"}],"keywords":[{"name":"LinearAlgebra","slug":"LinearAlgebra","permalink":"https://www.zackaddy.xin/categories/LinearAlgebra/"}]},{"title":"48、cocos creator 之战争迷雾效果","slug":"Cocos Creator/48、cocos creator 之战争迷雾效果","date":"2019-01-12T08:00:00.000Z","updated":"2020-08-07T14:10:11.686Z","comments":true,"path":"2019/01/12/Cocos Creator/48、cocos creator 之战争迷雾效果/","link":"","permalink":"https://www.zackaddy.xin/2019/01/12/Cocos Creator/48、cocos creator 之战争迷雾效果/","excerpt":"","text":"cocos creator 之战争迷雾效果 在Tiled地图制作工具中添加一层smog层将地图上的内容全部遮盖 分组管理添加smog分组将smog-hero关联 在hero节点上添加Circle碰撞组件 给迷雾动态添加碰撞组件 123456789101112131415let tileSize = this.tiledMap.getTileSize();let layer = this.tiledMap.getLayer('smog');let layerSize = layer.getLayerSize();for (let i = 0; i &lt; layerSize.width; i++) &#123; for (let j = 0; j &lt; layerSize.height; j++) &#123; let tile = layer.getTiledTileAt(i, j, true); if (tile.gid != 0) &#123; tile.node.group = 'smog'; let collider = tile.node.addComponent(cc.BoxCollider); collider.offset = cc.v2(tileSize.width / 2, tileSize.height / 2); collider.size = tileSize; &#125; &#125;&#125; 在hero节点脚本中添加如下代码 123456onCollisionEnter(other, self) &#123; if (other.node.group == 'smog') &#123; other.node.active = false; other.node.getComponent(cc.TiledTile).gid = 0; &#125;&#125;","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"47、cocos creator 之摄像机跟随效果","slug":"Cocos Creator/47、cocos creator 之摄像机跟随效果","date":"2019-01-12T07:00:00.000Z","updated":"2020-08-07T14:10:11.686Z","comments":true,"path":"2019/01/12/Cocos Creator/47、cocos creator 之摄像机跟随效果/","link":"","permalink":"https://www.zackaddy.xin/2019/01/12/Cocos Creator/47、cocos creator 之摄像机跟随效果/","excerpt":"","text":"cocos creator 之摄像机跟随效果 新建Camera.js 将Camera.js挂载到Main Carame节点上 输入以下代码到Camera.js内12345678910111213141516cc.Class(&#123; extends: cc.Component, properties: &#123; playerNode: cc.Node // 摄像机需要跟随的节点（英雄） &#125;, update(dt) &#123; if (!this.playerNode) &#123; return &#125; let wPos = this.playerNode.convertToWorldSpaceAR(cc.v2(0, 0)) let nPos = this.node.parent.convertToNodeSpaceAR(wPos) this.node.position = nPos &#125;&#125;)","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"46、cocos creator 之物理与碰撞系统","slug":"Cocos Creator/46、cocos creator 之物理与碰撞系统","date":"2019-01-12T06:00:00.000Z","updated":"2020-08-07T14:10:11.686Z","comments":true,"path":"2019/01/12/Cocos Creator/46、cocos creator 之物理与碰撞系统/","link":"","permalink":"https://www.zackaddy.xin/2019/01/12/Cocos Creator/46、cocos creator 之物理与碰撞系统/","excerpt":"","text":"cocos creator 之物理与碰撞系统简介目前 Cocos Creator 内置了一个简单易用的碰撞检测系统，支持 圆形，矩形 以及 多边形 相互间的碰撞检测。 碰撞分组配对 这张表里面的行与列分别列出了 分组列表 里面的项 分组列表 里的修改将会实时映射到这张表里。 你可以在这张表里面配置哪一个分组可以对其他的分组进行碰撞检测，假设 a 行 b 列 被勾选上，那么表示 a 行 上的分组将会与 b 列 上的分组进行碰撞检测。 例如Platform和Bullet被勾选上则Platform - Platform会产生碰撞 根据上面的规则，在这张表里产生的碰撞对有： Platform - Bullet Collider - Collider Actor - Wall Actor - Platform 碰撞示例 给要绑定的目标节点添加碰撞器 选定目标节点配置分组 在添加组件处选择添加碰撞组件 Box Collider表示方形碰撞器 Circle Collider 表示圆形碰撞器 Polygon Collider 表示自定义图形的碰撞器 选择好形状后，钩选中Editing处进行大小的编辑，注意：多边形在做碰撞检测的时候性能会差，所以能用圆形或者方形的，一般用圆形或者方形 在代码中开启碰撞检测系统（默认的碰撞检测是关闭的），开启和关闭碰撞检测的调试 碰撞检测系统的配置，建立一个script文件，绑定到canvas根目录下来配置碰撞检测的参数设置123456789101112131415161718cc.Class(&#123; extends: cc.Component, properties: &#123; is_enable: true, //是否开启碰撞检测系统 is_debug: false //是否显示碰撞检测区域 &#125;, onLoad() &#123; if (this.is_enable) &#123; let manager = cc.director.getCollisionManager(); manager.enabled = true; //开启碰撞检测 if (this.is_debug) &#123; manager.enabledDebugDraw = true; //显示碰撞检测区域 &#125; &#125; &#125;&#125;); 碰撞检测系统的API接口 12345onCollisionEnter:function(other,self)&#123;&#125; =&gt; 当两物体刚发生碰撞时被触发onCollisionStay:function(other,self)&#123;&#125; =&gt; 当两物体发生碰撞后，并且有交集的时候被触发onCollisionExit:function(other,self)&#123;&#125; =&gt; 当两物体发生碰撞后，并且在离开的那一刻被触发 在添加碰撞器节点上绑定脚本文件如下 12345678910111213141516cc.Class(&#123; extends: cc.Component, properties: &#123;&#125;, start() &#123; &#125;, onCollisionEnter(other, self) &#123; console.log(other, self); &#125;, onCollisionStay(other, self) &#123; console.log('现在正在有交集'); &#125;, onCollisionExit(other, self) &#123; console.log('现在刚离开') &#125;&#125;); 场景编辑器中复制一个碰撞节点并将两个节点部分重叠，在浏览器控制台可以看到一直在输出“现在正在有交集” 物理组件为上篇文章地图上的墙壁wall层级动态附加物理碰撞组件123456789101112131415161718192021222324252627282930313233343536373839404142434445cc.Class(&#123; extends: cc.Component, properties: &#123; tiledMap: &#123; type: cc.TiledMap, default: null &#125; &#125;, onLoad() &#123; var manager = cc.director.getCollisionManager(); // 获取碰撞检测类 manager.enabled = true //开启碰撞检测 manager.enabledDebugDraw = true //显示碰撞检测区域 var phyManager = cc.director.getPhysicsManager(); phyManager.enabled = true; phyManager.debugDrawFlags = true; phyManager.gravity = cc.v2(0, 0); &#125;, start() &#123; if (!this.tiledMap) &#123; return; &#125; let tileSize = this.tiledMap.getTileSize(); let layer = this.tiledMap.getLayer('wall'); let layerSize = layer.getLayerSize(); for (let i = 0; i &lt; layerSize.width; i++) &#123; for (let j = 0; j &lt; layerSize.height; j++) &#123; let tile = layer.getTiledTileAt(i, j, true); if (tile.gid != 0) &#123; tile.node.group = 'wall'; let body = tile.node.addComponent(cc.RigidBody); body.type = cc.RigidBodyType.Static; let collider = tile.node.addComponent(cc.PhysicsBoxCollider); collider.offset = cc.v2(tileSize.width / 2, tileSize.height / 2); collider.size = tileSize; collider.apply(); &#125; &#125; &#125; &#125;,&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"45、cocos creator 之Tiledmap绘制地图","slug":"Cocos Creator/45、cocos creator 之Tiledmap绘制地图","date":"2019-01-12T05:00:00.000Z","updated":"2020-08-07T14:10:11.685Z","comments":true,"path":"2019/01/12/Cocos Creator/45、cocos creator 之Tiledmap绘制地图/","link":"","permalink":"https://www.zackaddy.xin/2019/01/12/Cocos Creator/45、cocos creator 之Tiledmap绘制地图/","excerpt":"","text":"cocos creator 之Tiledmap绘制地图简介我们会遇到超过屏幕大小的地图，例如即时战略游戏，使得玩家可以在地图中滚动游戏画面。 这类游戏通常会有丰富的背景元素，如果直接使用背景图切换的方式，需要为每个不同的场景准备一张背景图，而且每个背景图都不小，这样会造成资源浪费。瓦片地图就是为了解决这问题而产生的。 一张大的世界地图或者背景图可以由几种地形来表示，每种地形对应一张小的图片，我们称这些小的地形图片为瓦片。把这些瓦片拼接在一起，一个完整的地图就组合出来了，这就是瓦片地图的原理。 制作迷宫地图 准备上方选中素材（点我下载） 打开Tiled 文件-新建-创建新地图 选择宽度高度2424，块大小1616 点击新图块集导入（如上图） 右侧图层内新建图块层分别为flag、wall、road、background 鼠标点击background层并从Dungeon_Tileset铺满背景 鼠标点击road层并从Dungeon_Tileset铺满路 鼠标点击wall层并从Dungeon_Tileset铺满墙壁 点击新图块集导入flag图片并点击如上图的编辑按钮 点击第一个图片并点击上方摄像机的图标制作动画 回到上图这个位置鼠标点击第一个图片然后点击flag图块层并在地图上任意位置点击就可以看到红旗飘动的动画了 使用地图 打开cocos creator将Tiled生成的文件和素材文件都拖入到资源管理器中 将tmx文件拖入到层级管理器中就可以看到制作好的地图了","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"44、cocos creator 之粒子系统","slug":"Cocos Creator/44、cocos creator 之粒子系统","date":"2019-01-11T08:00:00.000Z","updated":"2020-08-07T14:10:11.685Z","comments":true,"path":"2019/01/11/Cocos Creator/44、cocos creator 之粒子系统/","link":"","permalink":"https://www.zackaddy.xin/2019/01/11/Cocos Creator/44、cocos creator 之粒子系统/","excerpt":"","text":"cocos creator 之粒子系统简介游戏里面实现大量的特效，比如一些爆炸效果，子弹射击，以及天气效果，这个时候就可以用到粒子系统。粒子系统是模拟自然界的而一些粒子的物理运动效果，单个粒子是无法体现粒子 的效果的，需要大量的粒子配合，粒子不断的消失，不断的生成，就会出现相应的效果。 常用API12particle.stopSystem();particle.resetSystem(); 创建方式 通过添加组件 点击 属性检查器 下方的 添加组件 按钮，然后从 渲染组件 中选择 ParticleSystem，即可添加 ParticleSystem 组件到节点上。 通过脚本创建1234567// 创建一个节点var node = new cc.Node();// 将节点添加到场景中cc.director.getScene().addChild(node);// 添加粒子组件到 Node 上var particleSystem = node.addComponent(cc.ParticleSystem);// 接下去就可以对 particleSystem 这个对象进行一系列操作了 制作粒子特效 推荐免费在线工具Particle2dx 通过Particle Designer软件进行制作 实现点击粒子效果 将资源管理器中的粒子拉入层级管理器 将层级管理器中的粒子节点勾选（Auto Remove On Finish）并拉回资源管理器中生成预制资源 删除层级管理器中的预制节点 接下来在点击界面的时候动态生成粒子 创建ParticleClick.js并拉入场景最顶层节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// ParticleClick.jscc.Class(&#123; extends: cc.Component, properties: &#123; &#125;, start() &#123; this._initNodeTouchEvent(); &#125;, _initNodeTouchEvent() &#123; //监听事件 this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegin, this); this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this); this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this); &#125;, _destroyTouchEvent() &#123; //销毁事件 this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegin, this); this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this); this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnd, this); this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this); cc.log(\"销毁事件...\"); &#125;, _onTouchBegin: function (event) &#123; //获取当前点击的全局坐标 let temp = event.getLocation(); //获取当前点击的局部坐标 let tempClick = this.node.convertToNodeSpaceAR(temp) this.newClickNode(tempClick, function (node) &#123; if (!node) return //杀死所有存在的粒子，然后重新启动粒子发射器。 node.getComponent(cc.ParticleSystem).resetSystem(); cc.log(\"子节点数:\" + this.node.children.length); this.node.children.forEach(element =&gt; &#123; if (element.name === 'clickNode') &#123; //获取粒子系统组件 let particle = element.getComponent(cc.ParticleSystem); //指示粒子播放是否完毕 if (particle.stopped) &#123; //特效播放完毕的节点放入对象池 this._clickPool.put(element); cc.log(\"顺利回收...\"); &#125; &#125; &#125;); &#125;.bind(this)); &#125;, _onTouchMoved: function (event) &#123; cc.log('_onTouchMoved'); &#125;, _onTouchEnd: function (event) &#123; cc.log('_onTouchEnd'); &#125;, _onTouchCancel: function (event) &#123; cc.log('_onTouchCancel'); &#125;, onDestroy() &#123; //销毁事件 this._destroyTouchEvent(); &#125;, newClickNode(position, callBack) &#123; let newNode = null; if (!this._clickPool) &#123; //初始化对象池 this._clickPool = new cc.NodePool(); &#125; if (this._clickPool.size() &gt; 0) &#123; //从对象池请求对象 newNode = this._clickPool.get(); cc.log('回收的元素：', newNode); this.setClickNode(newNode, position, callBack); &#125; else &#123; // 如果没有空闲对象，我们就用 cc.instantiate 重新创建 cc.loader.loadRes(\"prefab/smoke\", cc.Prefab, function (err, prefab) &#123; if (err) &#123; return; &#125; newNode = cc.instantiate(prefab); this.setClickNode(newNode, position, callBack); &#125;.bind(this)); &#125; &#125;, setClickNode(newNode, position, callBack) &#123; newNode.name = \"clickNode\"; //设置节点名称 newNode.setPosition(position); //设置节点位置 this.node.addChild(newNode); //将新的节点添加到当前组件所有节点上 if (callBack) &#123; callBack(newNode); //回调节点 &#125; &#125;,&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"43、cocos creator 之压缩纹理","slug":"Cocos Creator/43、cocos creator 之压缩纹理","date":"2019-01-11T07:00:00.000Z","updated":"2020-08-07T14:10:11.685Z","comments":true,"path":"2019/01/11/Cocos Creator/43、cocos creator 之压缩纹理/","link":"","permalink":"https://www.zackaddy.xin/2019/01/11/Cocos Creator/43、cocos creator 之压缩纹理/","excerpt":"","text":"cocos creator 之压缩纹理简介Cocos Creator 可以直接在编辑器中设置纹理需要的压缩方式，然后在项目发布时自动对纹理进行压缩。针对 Web 平台，支持同时导出多种图片格式，引擎将根据不同的浏览器自动下载合适的格式。 详解 资源管理器中选中一张图片 右侧属性检查器中有一项Select A Format To Add，点击它 出现下拉框选择一项压缩方式 Cocos Creator 在构建图片的时候，会查找当前图片是否进行了压缩纹理的配置，如果没有，则继续查找是否做了默认（Default）的配置，如果没有，则最后按原图输出。 如果查找到了压缩纹理的配置，那么会按照找到的配置对图片进行纹理压缩。在一个平台中可以指定多种纹理格式，每种纹理格式在构建时都会根据原图压缩生成一张指定格式的图片。 这些生成的图片不会都被加载到引擎中，引擎会根据 cc.macro.SUPPORT_TEXTURE_FORMATS 中的配置来选择加载合适格式的图片。cc.macro.SUPPORT_TEXTURE_FORMATS 列举了当前平台支持的所有图片格式，引擎加载图片时会从生成的图片中找到在这个列表中 优先级靠前（即排列靠前）的格式来加载。 用户可以通过修改 cc.macro.SUPPORT_TEXTURE_FORMATS 来自定义平台的图片资源支持情况以及加载顺序的优先级。 注意：模拟器可能不支持压缩纹理，请以真机为准。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"42、cocos creator 之自动图集资源","slug":"Cocos Creator/42、cocos creator 之自动图集资源","date":"2019-01-11T06:00:00.000Z","updated":"2020-08-07T14:10:11.685Z","comments":true,"path":"2019/01/11/Cocos Creator/42、cocos creator 之自动图集资源/","link":"","permalink":"https://www.zackaddy.xin/2019/01/11/Cocos Creator/42、cocos creator 之自动图集资源/","excerpt":"","text":"cocos creator 之自动图集资源简介自动图集资源 作为 Cocos Creator 自带的合图功能，可以将指定的一系列碎图打包成一张大图，具体作用和 Texture Packer 的功能很相近。 自动图集资源 将会以当前文件夹下的所有 SpriteFrame 作为碎图资源，以后会增加其他的选择碎图资源的方式。 如果碎图资源 SpriteFrame 有进行配置过，在打包后重新生成的 SpriteFrame 将会保留这些配置。 配置自动图集资源 在 资源管理器 中右键，可以在如下菜单中找到 新建 -&gt; 自动图集配置 的子菜单 在资源管理器中选中自动图集资源 后，属性检查器 面板将会显示 自动图集资源 的所有可配置项。 属性 功能说明 最大宽度 单张图集最大宽度 最大高度 单张图集最大高度 间距 图集中碎图之间的间距 允许旋转 是否允许旋转碎图 输出大小为正方形 是否强制将图集长宽大小设置成正方形 输出大小为二次幂 是否将图集长宽大小设置为二次方倍数 算法 图集打包策略，可选的策略有 [BestShortSideFit、BestLongSideFit、BestAreaFit、BottomLeftRule、ContactPointRule] 扩边 在碎图的边框外扩展出一像素外框，并复制相邻碎图像素到外框中。该功能也称作 “Extrude”。 不包含未被引用资源 在预览中，此选项不会生效，构建后此选项才会生效 配置完成后，如需预览，请点击 预览 按钮来预览打包的结果，结果将会展示在 属性检查器 下面的区域。 结果分为： Packed Textures：显示打包后的图集图片以及图片相关的信息，如果会生成的图片有多张，则会往下在 属性检查器 中列出来。 Unpacked Textures：显示不能打包进图集的碎图资源，造成的原因有可能是这些碎图资源的大小比图集资源的大小还大导致的，这时候可能需要调整下图集的配置或者碎图的大小了。 生成图集预览项目或者在 Cocos Creator 中使用碎图的时候都是直接使用的碎图资源，在 构建项目 这一步才会真正生成图集到项目中。 注意：如果碎图开启了 Alpha 预乘，那么在生成图集时会失效。若需要使用预乘功能，可在图集上勾选 Premultiply Alpha。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"41、cocos creator 之图集资源","slug":"Cocos Creator/41、cocos creator 之图集资源","date":"2019-01-11T05:00:00.000Z","updated":"2020-08-07T14:10:11.685Z","comments":true,"path":"2019/01/11/Cocos Creator/41、cocos creator 之图集资源/","link":"","permalink":"https://www.zackaddy.xin/2019/01/11/Cocos Creator/41、cocos creator 之图集资源/","excerpt":"","text":"cocos creator 之图集资源简介图像资源又经常被称作贴图、图片，是游戏中绝大部分图像渲染的数据源。 目前包括 JPG 和 PNG 两种。 Texture 属性图片拖入资源管理局并点击图片后在右侧属性检查器中有如下属性 属性 功能说明 Type 包括 Raw 和 Sprite 两种模式。Raw 模式表示只会生成贴图资源，Sprite 模式表示还会生成 SpriteFrame 子资源。 Premultiply Alpha 是否开启 Alpha 预乘，勾选之后会将 RGB 通道预先乘以 Alpha 通道。 Wrap Mode 寻址模式，包括 Clamp（钳位）、Repeat（重复） 两种寻址模式 Filter Mode 过滤方式，包括 Point（邻近点采样）、Bilinear（双线性过滤）、Trilinear（三线性过滤） 三种过滤方式。 genMipmaps 是否开启自动生成 mipmap packable 是否允许贴图参与合图 Texture 和 SpriteFrame 资源类型 在 资源管理器 中，图像资源的左边会显示一个和文件夹类似的三角图标，点击就可以展开看到它的子资源（sub asset），每个图像资源导入后编辑器会自动在它下面创建同名的 SpriteFrame 资源。 SpriteFrame 是核心渲染组件 Sprite 所使用的资源，设置或替换 Sprite 组件中的 spriteFrame 属性，就可以切换显示的图像。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"40、cocos creator 之音乐与音效","slug":"Cocos Creator/40、cocos creator 之音乐与音效","date":"2019-01-10T08:00:00.000Z","updated":"2020-08-07T14:10:11.684Z","comments":true,"path":"2019/01/10/Cocos Creator/40、cocos creator 之音乐与音效/","link":"","permalink":"https://www.zackaddy.xin/2019/01/10/Cocos Creator/40、cocos creator 之音乐与音效/","excerpt":"","text":"cocos creator 之音乐与音效使用 AudioEngine API 播放1cc.audioEngine.play(audio, loop, volume); 12345678910111213141516171819// AudioEngine.jscc.Class(&#123; extends: cc.Component, properties: &#123; audio: &#123; default: null, type: cc.AudioClip &#125; &#125;, onLoad: function () &#123; this.current = cc.audioEngine.play(this.audio, false, 1); &#125;, onDestroy: function () &#123; cc.audioEngine.stop(this.current); &#125;&#125;); AudioSource 组件参考 属性 说明 Clip 用来播放的音频资源对象 Volume 音量大小，范围在 0~1 之间 Mute 是否静音 Loop 是否循环播放 Play on load 是否在组件激活后自动播放音频 preload 是否在未播放的时候预先加载 具体API查看参考手册 AudioSource audioEngine 区别AudioSource 是作为组件挂载在场景的各种节点上的，所以它可能同时会有多个。而背景音乐的底层播放接口不支持多音轨，同一时刻只能播放一个。所以背景音乐需要用 cc.audioEngine.playMusic 来切换，而 AudioSource 应该用来播放短音效 AudioSource 最终调用了还是 audioEngine 的代码.","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"39、cocos creator 之动画系统","slug":"Cocos Creator/39、cocos creator 之动画系统","date":"2019-01-10T07:00:00.000Z","updated":"2020-08-07T14:10:11.684Z","comments":true,"path":"2019/01/10/Cocos Creator/39、cocos creator 之动画系统/","link":"","permalink":"https://www.zackaddy.xin/2019/01/10/Cocos Creator/39、cocos creator 之动画系统/","excerpt":"","text":"cocos creator 之动画系统Cocos Creator的动画系统除了基础的平移动画、旋转动画、缩放动画和逐帧动画(又名序列帧动画)以外,还支持在动画过程修改任意节点组件的组件属性值,以及任意编辑时间曲线和移动轨迹编辑等,实现无代码化高效、细腻的动画创作与修改。 动画系统与动作系统区别 动作系统针对游戏运行时才能确定 动画系统针对固定动画，比如游戏开始一个小方块移动到屏幕中间 动画编辑器 动画组件: Animation组件,动画同样也是组件,需要被添加到需要动画控制的节点上 动画剪辑: Clip文件,动画的保存文件。动画组件播放的内容保存至动画剪辑。 动画编辑器: 动画编辑器是动画剪辑属性检查器的延伸,是用来编辑动画剪辑的唯一手段。 动画组件控制节点的子节点时,子节点不可以重名,否则将只能控制同名子节点中第一个 动画编辑器界面 按钮控制区: 动画编辑器常用功能按钮,从左至右依次是“开始编辑按钮″”返回第一帧按钮″”上一帧按钮″‘播放、暂停按钮下一帧按钮″“新建动画剪辑按钮”和“插入动画事件按钮”。 时间轴与自定义事件: 显示时间,时间表示格式为“秒:帧”,比如时间显示“1:05″代表1秒零5帧,具体时间与帧速率有关。右侧部分可用鼠标滚轮缩放时间比例。自定义事件也显示在此 节点区: 动画剪辑需要控制的节点。这里是以动画组件所依附的节点为根节点。选中节点,下方属性区会显示该节点对应需要控制的属性。 属性区: 动画控制属性。动画控制其实际控制的内容是节点属性或节点上组件属性,如位置、旋转或缩放等。在节点区选中节点后,在属性区添加或修改相应属性。 帧预览区: 展示每个节点在各个时间段是否有关键帧。光标移至帧预览区,可按住“空格”键,按住鼠标左键拖曳可左右移动帧预览区。 关键帧区: 展示每个属性的关键帧,通过点击选中的关键帧进行修改。光标移至关键帧区,可按住“空格″键,按住鼠标左键拖曳可左右移动关键帧区 动画剪辑属性: 动画剪辑的基本属性,包括 Sample(帧速率)即每秒动画帧数,默认为60帧秒,可以和游戏帧速率不一致;Speed(播放速度),正常速度的倍数,默认是1; Duration(持续时间),当前动画剪辑在速度为1时持续时间; Real Time(真实时间),动画剪辑从开始播放到结束真正结束时间,播放速度会计算在内; Wrap Mode(循环模式),不循环、不断循环、来回往复等方式 编辑动画 在任何一个组件上添加Animation组件 点击动画编辑器 点击新建 Clip 文件 点击左上角打开编辑模式 点击属性列表 Add Property 选择y 拖动预览时间轴到0 在属性列表区点击y属性右侧菜单按钮选择插入关键帧 拖动预览时间轴到1:00 属性检查器区域修改节点y属性值 你会看到帧预览区0为一个蓝色⚪点，1:00为蓝色⚪，0到1:00之间则有一条蓝色柱线连接(补间连线) 拖动预览时间轴从0到1:00，你会看到动画效果 编辑逐帧动画在cc.Sprite.spriteFrame属性轨道的合适时间位置添加关键帧。逐帧动画的关键帧间隔通常—致,并且间隔最短不低于1帧所用时间,最长不超过1/12秒(5帧)(人眼视觉残像保留时间)。 必备资源 点我下载图集下面实现官方小山羊奔跑的逐帧动画 新建Sprite精灵组件并在上面添加Animation组件 点击动画编辑器 点击新建 Clip 文件 点击左上角打开编辑模式 点击属性列表 Add Property 选择cc.Sprite.spriteFrame 拖动预览时间轴到0 在属性列表区点击cc.Sprite.spriteFrame属性右侧菜单按钮选择插入关键帧 将图集中的sheep_run_0移入到Sprite组件上的Sprite Frame属性上 拖动预览时间轴到0:10 将图集中的sheep_run_1移入到Sprite组件上的Sprite Frame属性上 拖动预览时间轴到0:20 将图集中的sheep_run_2移入到Sprite组件上的Sprite Frame属性上 拖动预览时间轴到0:30 将图集中的sheep_run_3移入到Sprite组件上的Sprite Frame属性上 拖动预览时间轴到0:40 将图集中的sheep_run_3移入到Sprite组件上的Sprite Frame属性上 勾选WrapMode为Loop 将Clip 文件移动到Animation组件上的Default Clip属性上 勾选Animation组件上的Play On Load 查看效果 非均速动画双击补间连线可以看到编辑窗口，可以选择许多的预设曲线或自定义，这里没什么好说的了 动画事件 拖动预览时间轴到你想触发事件的位置 点击左上角按钮区插入帧事件 帧预览区上方出现白色小矩形 双击白色小矩形并添加触发事件的名称，支持传入参数。 当事件触发时，会遍历此节点所有组件的所有方法以匹配。 动态注册动画事件目前支持的回调事件有： play : 开始播放时 stop : 停止播放时 pause : 暂停播放时 resume : 恢复播放时 lastframe : 假如动画循环次数大于 1，当动画播放到最后一帧时 finished : 动画播放完成时 123456789101112131415161718192021var animation = this.node.getComponent(cc.Animation);// 注册animation.on('play', this.onPlay, this);animation.on('stop', this.onStop, this);animation.on('lastframe', this.onLastFrame, this);animation.on('finished', this.onFinished, this);animation.on('pause', this.onPause, this);animation.on('resume', this.onResume, this);// 取消注册animation.off('play', this.onPlay, this);animation.off('stop', this.onStop, this);animation.off('lastframe', this.onLastFrame, this);animation.off('finished', this.onFinished, this);animation.off('pause', this.onPause, this);animation.off('resume', this.onResume, this);// 对单个 cc.AnimationState 注册回调var anim1 = animation.getAnimationState('anim1');anim1.on('lastframe', this.onLastFrame, this); 播放 暂停 恢复 停止12345678910111213141516171819202122232425262728293031323334353637var anim = this.getComponent(cc.Animation);// 如果没有指定播放哪个动画，并且有设置 defaultClip 的话，则会播放 defaultClip 动画anim.play();// 指定播放 test 动画anim.play('test');// 指定从 1s 开始播放 test 动画anim.play('test', 1);// 使用 play 接口播放一个动画时，如果还有其他的动画正在播放，则会先停止其他动画anim.play('test2');// 指定暂停 test 动画anim.pause('test');// 暂停所有动画// anim.pause();// 指定恢复 test 动画anim.resume('test');// 恢复所有动画// anim.resume();// 指定停止 test 动画anim.stop('test');// 停止所有动画// anim.stop();// 设置 test 动画的当前播放时间为 1sanim.setCurrentTime(1, 'test');// 设置所有动画的当前播放时间为 1s// anim.setCurrentTime(1); 同时播放多个动画Animation 是支持同时播放多个动画的，播放不同的动画并不会影响其他的动画的播放状态，这对于做一些复合动画比较有帮助。 12345678var anim = this.getComponent(cc.Animation);// 播放第一个动画anim.playAdditive('position-anim');// 播放第二个动画// 使用 playAdditive 播放动画时，不会停止其他动画的播放。如果还有其他动画正在播放，则同时会有多个动画进行播放anim.playAdditive('rotation-anim'); AnimationState AnimationClip 作为动画数据的承载 AnimationState 则是 AnimationClip 在运行时的实例，它将动画数据解析为方便程序中做计算的数值。123456var anim = this.getComponent(cc.Animation);// play 会返回关联的 AnimationStatevar animState = anim.play('test');// 或是直接获取var animState = anim.getAnimationState('test'); 1234567891011121314151617181920212223242526272829303132var anim = this.getComponent(cc.Animation);var animState = anim.play('test');// 获取动画关联的clipvar clip = animState.clip;// 获取动画的名字var name = animState.name;// 获取动画的播放速度var speed = animState.speed;// 获取动画的播放总时长var duration = animState.duration;// 获取动画的播放时间var time = animState.time;// 获取动画的重复次数var repeatCount = animState.repeatCount;// 获取动画的循环模式var wrapMode = animState.wrapMode// 获取动画是否正在播放var playing = animState.isPlaying;// 获取动画是否已经暂停var paused = animState.isPaused;// 获取动画的帧率var frameRate = animState.frameRate; 1234567891011121314var anim = this.getComponent(cc.Animation);var animState = anim.play('test');// 设置循环模式为 NormalanimState.wrapMode = cc.WrapMode.Normal;// 设置循环模式为 LoopanimState.wrapMode = cc.WrapMode.Loop;// 设置动画循环次数为2次animState.repeatCount = 2;// 设置动画循环次数为无限次animState.repeatCount = Infinity; 动态创建 Animation Clip123456789101112131415var animation = this.node.getComponent(cc.Animation);// frames 这是一个 SpriteFrame 的数组.var clip = cc.AnimationClip.createWithSpriteFrames(frames, 17);clip.name = \"anim_run\";clip.wrapMode = cc.WrapMode.Loop;// 添加帧事件clip.events.push(&#123; frame: 1, // 准确的时间，以秒为单位。这里表示将在动画播放到 1s 时触发事件 func: \"frameEvent\", // 回调函数名称 params: [1, \"hello\"] // 回调参数&#125;);animation.addClip(clip);animation.play('anim_run');","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"38、cocos creator 之计时器","slug":"Cocos Creator/38、cocos creator 之计时器","date":"2019-01-10T06:00:00.000Z","updated":"2020-08-07T14:10:11.684Z","comments":true,"path":"2019/01/10/Cocos Creator/38、cocos creator 之计时器/","link":"","permalink":"https://www.zackaddy.xin/2019/01/10/Cocos Creator/38、cocos creator 之计时器/","excerpt":"","text":"cocos creator 之计时器简介可以使用setTimeout 和 setInterval 更推荐使用计时器，因为它更加强大灵活，和组件也结合得更好！ Component 中包含以下计时器函数 schedule：开始一个计时器 scheduleOnce：开始一个只执行一次的计时器 unschedule：取消一个计时器 unscheduleAllCallbacks：取消这个组件的所有计时器 schedule参数如下 Function 自定义回调方法,此方法要求无返回值,可以有参数 Number 间隔时间,单位秒,等于0的时候每帧都会调用,和 update.效果 Number 重复次数,会掉回被调用参数3+1次,可以填入kCCRepeatForever代表永久重复。此参数为选填参数 Number 第一次计时延迟时间,单位是秒,等于0的时候会在下一帧调用。此参数为选填参数1234component.schedule(function() &#123; // 这里的 this 指向 component this.doSomething();&#125;, interval, repeat, delay); 注意：cc.Node 不包含计时器相关 API 示例 开始一个计时器 1234component.schedule(function() &#123; // 这里的 this 指向 component this.doSomething();&#125;, 5); 取消计时器 12345678910this.count = 0;this.callback = function () &#123; if (this.count === 5) &#123; // 在第六次执行回调时取消这个计时器 this.unschedule(this.callback); &#125; this.doSomething(); this.count++;&#125;component.schedule(this.callback, 1);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"37、cocos creator 之缓动系统cc.tween","slug":"Cocos Creator/37、cocos creator 之缓动系统cc.tween","date":"2019-01-10T05:00:00.000Z","updated":"2020-08-07T14:10:11.683Z","comments":true,"path":"2019/01/10/Cocos Creator/37、cocos creator 之缓动系统cc.tween/","link":"","permalink":"https://www.zackaddy.xin/2019/01/10/Cocos Creator/37、cocos creator 之缓动系统cc.tween/","excerpt":"","text":"cocos creator 之缓动系统cc.tween简介 功能类似于 cc.Action（动作系统） cc.tween 提供了链式创建的方法 可以对任何对象进行操作 可以对对象的任意属性进行缓动 1234cc.tween(this.node) .to(1, &#123; position: cc.v2(100, 100), rotation: 360 &#125;) .to(1, &#123; scale: 2 &#125;) .start() 示例 to 添加一个对属性进行绝对值计算的 action 第一个参数为持续时间 第二个参数为变化属性 第三个参数为配置项，包括progress、easing 12345678cc.tween(this.node) // 0s 时，node 的 scale 还是 1 .to(1, &#123; scale: 2 &#125;) // 1s 时，执行完第一个 action，scale 为 2 .to(1, &#123; scale: 3 &#125;) // 2s 时，执行完第二个 action，scale 为 3 .start() // 调用 start 开始执行 cc.tween by 添加一个对属性进行相对值计算的 action 第一个参数为持续时间 第二个参数为变化属性 第三个参数为配置项，包括progress、easing 123456cc.tween(node) .to(1, &#123;scale: 2&#125;) // node.scale === 2 .by(1, &#123;scale: 2&#125;) // node.scale === 4 (2+2) .by(1, &#123;scale: 1&#125;) // node.scale === 5 .to(1, &#123;scale: 2&#125;) // node.scale === 2 .start() 缓动任意对象的任意属性 1234let obj = &#123; a: 0 &#125;cc.tween(obj) .to(1, &#123; a: 100 &#125;) .start() clone 克隆当前 tween 12345// 先创建一个缓动作为模板let tween = cc.tween().to(4, &#123; scale: 2 &#125;)// 复制 tween，并使用节点 Canvas/cocos 作为 targettween.clone(cc.find('Canvas/cocos')).start() then 插入其他的缓动到队列中 12345678let scale = cc.tween().to(1, &#123; scale: 2 &#125;)let rotate = cc.tween().to(1, &#123; rotation: 90&#125;)let move = cc.tween().to(1, &#123; position: cc.v3(100, 100, 100)&#125;)// 先缩放再旋转cc.tween(this.node).then(scale).then(rotate)// 先缩放再移动cc.tween(this.node).then(scale).then(move) call 回调 123456cc.tween(this.node) .to(2, &#123; rotation: 90&#125;) .to(1, &#123; scale: 2&#125;) // 当前面的动作都执行完毕后才会调用这个回调函数 .call(() =&gt; &#123; cc.log('This is a callback') &#125;) .start() parallel 并行执行缓动 1234567891011let t = cc.tween;t(this.node) // 同时执行两个 cc.tween .parallel( t().to(1, &#123; scale: 2 &#125;), t().to(2, &#123; position: cc.v2(100, 100) &#125;) ) .call(() =&gt; &#123; console.log('All tweens finished.') &#125;) .start() repeat 重复执行 12345678910111213141516171819cc.tween(this.node) .by(1, &#123; scale: 1 &#125;) // 对前一个 by 重复执行 10次 .repeat(10) // 最后 node.scale === 11 .start()// 也可以这样用cc.tween(this.node) .repeat(10, cc.tween().by(1, &#123; scale: 1 &#125;) ) .start()// 一直重复执行下去cc.tween(this.node) .by(1, &#123; scale: 1 &#125;) .repeatForever() .start() delay 延迟执行 12345678cc.tween(this.node) // 延迟 1s .delay(1) .to(1, &#123; scale: 2 &#125;) // 再延迟 1s .delay(1) .to(1, &#123; scale: 3 &#125;) .start()","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"36、cocos creator 之动作回调","slug":"Cocos Creator/36、cocos creator 之动作回调","date":"2019-01-09T08:00:00.000Z","updated":"2020-08-07T14:10:11.683Z","comments":true,"path":"2019/01/09/Cocos Creator/36、cocos creator 之动作回调/","link":"","permalink":"https://www.zackaddy.xin/2019/01/09/Cocos Creator/36、cocos creator 之动作回调/","excerpt":"","text":"cocos creator 之动作回调简介动作完成时调用指定函数 示例 第一个参数是处理回调的方法 第二个参数指定了处理回调方法的 context（也就是绑定 this） 第三个参数是向处理回调方法的传参12345var finished = cc.callFunc(function(target, score) &#123; this.score += score;&#125;, this, 100);//动作完成后会给玩家加100分var myAction = cc.sequence(cc.moveBy(1, cc.v2(0, 100)), cc.fadeOut(1), finished);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"35、cocos creator 之动作系统","slug":"Cocos Creator/35、cocos creator 之动作系统","date":"2019-01-09T07:00:00.000Z","updated":"2020-08-07T14:10:11.683Z","comments":true,"path":"2019/01/09/Cocos Creator/35、cocos creator 之动作系统/","link":"","permalink":"https://www.zackaddy.xin/2019/01/09/Cocos Creator/35、cocos creator 之动作系统/","excerpt":"","text":"cocos creator 之动作系统简介动作系统可以在一定时间内对节点完成位移，缩放，旋转等各种动作。 动作系统与动画系统的区别 动作系统比较适合来制作简单的形变和位移动画， 动画系统则强大许多，美术可以用编辑器制作支持各种属性，包含运动轨迹和缓动的复杂动画 基本使用 移动动作 以下3个参数代表2秒内移动到(100,100)位置,返回创建好的动作。 123var action = cc.moveTop(2, 100, 100);node.runAction(action); // 执行动作node.stopAction(action); // 停止动作 getActionByTag会返回指定了标签并开始执行的动作 1234567// 给 action 设置 tagvar ACTION_TAG = 1;action.setTag(ACTION_TAG);// 通过 tag 获取 actionvar action1 = node.getActionByTag(ACTION_TAG);// 通过 tag 停止一个动作node.stopActionByTag(ACTION_TAG); 动作有很多，具体见API列表。 下面只介绍其中几种 即时动作 显示 1var showAction = cc.show(); 隐藏 1var hideAction = cc.hide(); 显示/隐藏切换动作 1var toggleVisibilityAction = cc.toggleVisibility(); 从父节点移除自身 1var removeSelfAction = cc.removeSelf(); X/Y轴翻转 12var flipXAction = cc.flipX(true);var flipYAction = cc.flipY(true); 容器动作 将创建的多个动作将按顺序依次执行。 12var seq = cc.sequence(act1, act2);node.runAction(seq); 同步执行多个动作 1var action = cc.spawn(cc.jumpBy(2, cc.v2(300, 0), 50, 4), cc.rotateBy(2, 720)); 按一定次数重复一个动 1var rep = cc.repeat(cc.sequence(jump2, jump1), 5); 永远重复一个动作 1var repeat = cc.repeatForever(cc.rotateBy(1.0, 360)); 修改原本动作速率 12var action = cc.scaleTo(0.2, 1, 0.6);var newAction = cc.speed(action, 0.5); 缓动动作 设置动作由慢到快插值器1action.easing(cc.easeIn(3.0)); 等等 其它插值器查询API文档 时间间隔动作 移动到目标位置 1var actionBy = cc.moveTo(2, cc.v2(80, 80)); 跳跃方式到指定位置 参数分别为时间、x、y、每次跳跃高度、跳跃次数 1var actionTo = cc.jumpTo(2, 300, 300, 50, 4); 等等 其它间隔动作查询API文档 弹跳动作12345678setJumpAction: function () &#123; // 跳跃上升 var jumpUp = cc.moveBy(this.jumpDuration, cc.v2(0, this.jumpHeight)).easing(cc.easeCubicActionOut()); // 下落 var jumpDown = cc.moveBy(this.jumpDuration, cc.v2(0, -this.jumpHeight)).easing(cc.easeCubicActionIn()); // 不断重复 return cc.repeatForever(cc.sequence(jumpUp, jumpDown));&#125;,","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"34、cocos creator 之防止事件穿透BlockInputEvents组件","slug":"Cocos Creator/34、cocos creator 之防止事件穿透BlockInputEvents组件","date":"2019-01-09T06:00:00.000Z","updated":"2020-08-07T14:10:11.683Z","comments":true,"path":"2019/01/09/Cocos Creator/34、cocos creator 之防止事件穿透BlockInputEvents组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/09/Cocos Creator/34、cocos creator 之防止事件穿透BlockInputEvents组件/","excerpt":"","text":"cocos creator 之防止事件穿透BlockInputEvents组件简介BlockInputEvents 组件将拦截所属节点 bounding box 内的所有输入事件（鼠标和触摸），防止输入穿透到下层节点，一般用于上层 UI 的背景。 当我们制作一个弹出式的 UI 对话框时，对话框的背景默认不会截获事件。也就是说虽然它的背景挡住了游戏场景，但是在背景上点击或触摸时，下面被遮住的游戏元素仍然会响应点击事件。这时我们只要在背景所在的节点上添加这个组件，就能避免这种情况。 该组件没有任何 API 接口，直接添加到场景即可生效。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"33、cocos creator 之页面视图PageView组件","slug":"Cocos Creator/33、cocos creator 之页面视图PageView组件","date":"2019-01-09T05:00:00.000Z","updated":"2020-08-07T14:10:11.682Z","comments":true,"path":"2019/01/09/Cocos Creator/33、cocos creator 之页面视图PageView组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/09/Cocos Creator/33、cocos creator 之页面视图PageView组件/","excerpt":"","text":"cocos creator 之页面视图PageView组件简介PageView 是一种页面视图容器. 创建层级管理器-&gt;右键-&gt;创建节点-&gt;创建UI节点-&gt;PageView 12345678|---New PageView |---background |---view |---content |---page_1 |---page_2 |---page_3 |---indicator 属性 属性 功能说明 Content 它是一个节点引用，用来创建 PageView 的可滚动内容 Size Mode 页面视图中每个页面大小类型，目前有 Unified 和 Free 类型。详情可参考 SizeMove API Direction 页面视图滚动方向 Scroll Threshold 滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原 Auto Page Turning Threshold 快速滑动翻页临界值，当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值，该值与此临界值相比较，如果大于临界值，则进行自动翻页 Inertia 否开启滚动惯性 Brake 开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止 Elastic 布尔值，是否回弹 Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10 Indicator 页面视图指示器组件，详情可参考下方的 CCPageViewIndicator 设置。 Page Turning Speed 每个页面翻页时所需时间，单位：秒。Page Turning Event Timing 设置 PageView、PageTurning 事件的发送时机 Page Events 数组，滚动视图的事件回调函数 Cancel Inner Events 布尔值，是否在滚动行为时取消子节点上注册的触摸事件 回调123456789101112131415161718192021222324var pageViewEventHandler = new cc.Component.EventHandler();pageViewEventHandler.target = this.node; // 这个是你的事件处理代码组件所属的节点pageViewEventHandler.component = \"cc.MyComponent\"pageViewEventHandler.handler = \"callback\";pageViewEventHandler.customEventData = \"foobar\";pageView.pageEvents.push(pageViewEventHandler);// here is your component filecc.Class(&#123; name: 'cc.MyComponent' extends: cc.Component, properties: &#123; &#125;, // 注意参数的顺序和类型是固定的 callback: function(pageView, eventType, customEventData) &#123; // 这里 pageView 是一个 PageView 组件对象实例 // 这里的 eventType === cc.PageView.EventType.PAGE_TURNING // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;&#125;); 123456789101112131415161718// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; pageView: cc.PageView &#125;, onLoad: function () &#123; this.pageView.node.on('page-turning', this.callback, this); &#125;, callback: function (pageView) &#123; // 回调的参数是 pageView 组件 // 另外，注意这种方式注册的事件，也无法传递 customEventData &#125;&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"32、cocos creator 之滑动器Slider组件","slug":"Cocos Creator/32、cocos creator 之滑动器Slider组件","date":"2019-01-08T08:00:00.000Z","updated":"2020-08-07T14:10:11.682Z","comments":true,"path":"2019/01/08/Cocos Creator/32、cocos creator 之滑动器Slider组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/08/Cocos Creator/32、cocos creator 之滑动器Slider组件/","excerpt":"","text":"cocos creator 之滑动器Slider组件简介Slider 是一个滑动器组件。 属性 属性 功能说明 handle 滑块按钮部件，可以通过该按钮进行滑动调节 Slider 数值大小 direction 滑动器的方向，分为横向和竖向 progress 当前进度值，该数值的区间是 0-1 之间 slideEvents 滑动器组件事件回调函数 回调123456789101112131415161718192021var sliderEventHandler = new cc.Component.EventHandler();sliderEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点sliderEventHandler.component = \"cc.MyComponent\"sliderEventHandler.handler = \"callback\";sliderEventHandler.customEventData = \"foobar\";slider.slideEvents.push(sliderEventHandler);// here is your component filecc.Class(&#123; name: 'cc.MyComponent' extends: cc.Component, properties: &#123; &#125;, callback: function(slider, customEventData) &#123; // 这里 slider 是一个 cc.Slider 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;&#125;); 12345678910111213141516171819// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; slider: cc.Slider &#125;, onLoad: function () &#123; this.slider.node.on('slide', this.callback, this); &#125;, callback: function (slider) &#123; // 回调的参数是 slider // do whatever you want with the slider &#125;&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"31、cocos creator 之单选框ToggleContainer组件","slug":"Cocos Creator/31、cocos creator 之单选框ToggleContainer组件","date":"2019-01-08T07:00:00.000Z","updated":"2020-08-07T14:10:11.682Z","comments":true,"path":"2019/01/08/Cocos Creator/31、cocos creator 之单选框ToggleContainer组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/08/Cocos Creator/31、cocos creator 之单选框ToggleContainer组件/","excerpt":"","text":"cocos creator 之单选框ToggleContainer组件简介ToggleContainer 一般不会单独使用，它需要与 Toggle 配合使用来实现 RadioButton 的单选效果。 ToggleGroup/ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。当一组 Toggle 属于同一个 ToggleGroup/ToggleContainer 的时候，就只能有一个 Toggle 处于选中状态。 注意：ToggleGroup 与 ToggleContainer 不同之处在于，使用 ToggleContainer 所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中，而 ToggleGroup 需要手动进行 Toggle 组件的绑定。 创建层级管理器-&gt;右键-&gt;创建节点-&gt;创建UI节点-&gt;ToggleContainer 12345678910|---New ToggleContainer |---toggle1 |---Background |---checkmark |---toggle2 |---Background |---checkmark |---toggle3 |---Background |---checkmark 属性 属性 功能说明 Allow Switch Off 如果这个设置为 true，那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。 Check Events Toggle 按钮的点击事件列表。默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 ToggleContainer 事件 部分","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"30、cocos creator 之复选框Toggle组件","slug":"Cocos Creator/30、cocos creator 之复选框Toggle组件","date":"2019-01-08T06:00:00.000Z","updated":"2020-08-07T14:10:11.681Z","comments":true,"path":"2019/01/08/Cocos Creator/30、cocos creator 之复选框Toggle组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/08/Cocos Creator/30、cocos creator 之复选框Toggle组件/","excerpt":"","text":"cocos creator 之复选框Toggle组件简介Toggle 是一个 CheckBox 属性 属性 功能说明 isChecked 布尔类型，如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。 checkMark cc.Sprite 类型，Toggle 处于选中状态时显示的图片 toggleGroup cc.ToggleGroup 类型， Toggle 所属的 ToggleGroup，这个属性是可选的。如果这个属性为 null，则 Toggle 是一个 CheckBox，否则，Toggle 是一个 RadioButton。 Check Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Toggle 事件 部分。 回调123456789101112131415161718192021var checkEventHandler = new cc.Component.EventHandler();checkEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点checkEventHandler.component = \"cc.MyComponent\"checkEventHandler.handler = \"callback\";checkEventHandler.customEventData = \"foobar\";toggle.checkEvents.push(checkEventHandler);// here is your component filecc.Class(&#123; name: 'cc.MyComponent' extends: cc.Component, properties: &#123; &#125;, callback: function(toggle, customEventData) &#123; // 这里的 toggle 是事件发出的 Toggle 组件 // 这里的 customEventData 参数就等于之前设置的 \"foobar\" &#125;&#125;); 123456789101112131415161718// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; toggle: cc.Toggle &#125;, onLoad: function () &#123; this.toggle.node.on('toggle', this.callback, this); &#125;, callback: function (toggle) &#123; // 回调的参数是 toggle 组件 // do whatever you want with toggle &#125;&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"29、cocos creator 之进度条ProgressBar组件","slug":"Cocos Creator/29、cocos creator 之进度条ProgressBar组件","date":"2019-01-08T05:00:00.000Z","updated":"2020-08-07T14:10:11.681Z","comments":true,"path":"2019/01/08/Cocos Creator/29、cocos creator 之进度条ProgressBar组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/08/Cocos Creator/29、cocos creator 之进度条ProgressBar组件/","excerpt":"","text":"cocos creator 之进度条ProgressBar组件简介ProgressBar（进度条）经常被用于在游戏中显示某个操作的进度，在节点上添加 ProgressBar 组件，然后给该组件关联一个 Bar Sprite 就可以在场景中控制 Bar Sprite 来显示进度了。 创建层级管理器-&gt;右键-&gt;创建节点-&gt;创建UI节点-&gt;ProgressBar 12|---New ProgressBar |---bar 属性 属性 功能说明 Bar Sprite 进度条渲染所需要的 Sprite 组件，可以通过拖拽一个带有 Sprite 组件的节点到该属性上来建立关联。 Mode 支持 HORIZONTAL（水平）、VERTICAL（垂直）和 FILLED（填充）三种模式，可以通过配合 reverse 属性来改变起始方向。 Total Length 当进度条为 100% 时 Bar Sprite 的总长度/总宽度。在 FILLED 模式下 Total Length 表示取 Bar Sprite 总显示范围的百分比，取值范围从 0 ~ 1。 Progress 浮点，取值范围是 0~1，不允许输入该范围之外的数值。 Reverse 布尔值，默认的填充方向是从左至右/从下到上，开启后变成从右到左/从上到下。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"28、cocos creator 之滚动条ScrollBar组件","slug":"Cocos Creator/28、cocos creator 之滚动条ScrollBar组件","date":"2019-01-07T08:00:00.000Z","updated":"2020-08-07T14:10:11.681Z","comments":true,"path":"2019/01/07/Cocos Creator/28、cocos creator 之滚动条ScrollBar组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/07/Cocos Creator/28、cocos creator 之滚动条ScrollBar组件/","excerpt":"","text":"cocos creator之滚动条ScrollBar组件简介ScrollBar 一般不会单独使用，它需要与 ScrollView 配合使用，另外 ScrollBar 需要指定一个 Sprite 组件，即属性面板里面的 Handle。 通常我们还会给 ScrollBar 指定一张背景图片，用来指示整个 ScrollBar 的长度或者宽度。 属性 属性 功能说明 Handle ScrollBar 前景图片，它的长度/宽度会根据 ScrollView 的 content 的大小和实际显示区域的大小来计算。 Direction 滚动方向，目前包含水平和垂直两个方向。 Enable Auto Hide 是否开启自动隐藏，如果开启了，那么在 ScrollBar 显示后的 Auto Hide Time 时间内会自动消失。 Auto Hide Time 自动隐藏时间，需要配合设置 Enable Auto Hide","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"27、cocos creator 之滚动视图容器ScrollView","slug":"Cocos Creator/27、cocos creator 之滚动视图容器ScrollView","date":"2019-01-07T07:00:00.000Z","updated":"2020-08-07T14:10:11.680Z","comments":true,"path":"2019/01/07/Cocos Creator/27、cocos creator 之滚动视图容器ScrollView/","link":"","permalink":"https://www.zackaddy.xin/2019/01/07/Cocos Creator/27、cocos creator 之滚动视图容器ScrollView/","excerpt":"","text":"cocos creator 之滚动视图容器ScrollView简介ScrollView 是一种带滚动功能的容器，它提供一种方式可以在有限的显示区域内浏览更多的内容。通常 ScrollView 会与Mask组件配合使用，同时也可以添加ScrollBar组件来显示浏览内容的位置。 创建层级管理器-&gt;右键-&gt;创建节点-&gt;创建UI节点-&gt;ScrollView 123456|---NewScrollView |---scrollBar |---bar |---view |---content |---item ScrollView组件中由2个子节点组成scrollBar和view scrollBar是一个滚动条的模板 view是一个遮罩，用于把多出来的内容隐藏 属性 属性 功能说明 content 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。 Horizontal 布尔值，是否允许横向滚动。 Vertical 布尔值，是否允许纵向滚动。 Inertia 滚动的时候是否有加速度。 Brake 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。Elastic 布尔值，是否回弹。 Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10。 Horizontal ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。 Vertical ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置 Scroll Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Scrollview 事件。 CancelInnerEvents 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。 事件1234567891011121314151617181920212223// here is your component file, file name = MyComponent.jscc.Class(&#123; extends: cc.Component, properties: &#123;&#125;, onLoad: function () &#123; var scrollViewEventHandler = new cc.Component.EventHandler(); scrollViewEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 scrollViewEventHandler.component = \"MyComponent\";// 这个是代码文件名 scrollViewEventHandler.handler = \"callback\"; scrollViewEventHandler.customEventData = \"foobar\"; var scrollview = node.getComponent(cc.ScrollView); scrollview.scrollEvents.push(scrollViewEventHandler); &#125;, // 注意参数的顺序和类型是固定的 callback: function (scrollview, eventType, customEventData) &#123; // 这里 scrollview 是一个 Scrollview 组件对象实例 // 这里的 eventType === cc.ScrollView.EventType enum 里面的值 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;&#125;); 123456789101112131415161718// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; scrollview: cc.ScrollView &#125;, onLoad: function () &#123; this.scrollview.node.on('scroll-to-top', this.callback, this); &#125;, callback: function (scrollView) &#123; // 回调的参数是 ScrollView 组件 // do whatever you want with scrollview &#125;&#125;); 可以注册 scrolling, touch-up, scroll-began 等事件，这些事件的回调函数的参数与 scroll-to-top 的参数一致。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"26、cocos creator 之遮罩Mask组件","slug":"Cocos Creator/26、cocos creator 之遮罩Mask组件","date":"2019-01-07T06:00:00.000Z","updated":"2020-08-07T14:10:11.680Z","comments":true,"path":"2019/01/07/Cocos Creator/26、cocos creator 之遮罩Mask组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/07/Cocos Creator/26、cocos creator 之遮罩Mask组件/","excerpt":"","text":"cocos creator 之遮罩Mask组件简介Mask 用于规定子节点可渲染的范围，带有 Mask 组件的节点会使用该节点属性检查器中 Node 组件的 Size 规定的范围创建一个渲染遮罩，该节点的所有子节点都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。 不能添加到有其他渲染组件（如 Sprite、Label 等） 属性 属性 功能说明 Type 遮罩类型。包括 RECT、ELLIPSE、IMAGE_STENCIL 三种类型，详情可查看 Type API Inverted 布尔值，反向遮罩 Alpha Threshold Alpha 阈值，该属性为浮点类型，仅在 Type 设为 IMAGE_STENCIL 时才生效。只有当模板像素的 alpha值大于该值时，才会绘制内容。该属性的取值范围是 0 ~ 1，1 表示完全禁用。 Sprite Frame 遮罩所需要的贴图，只在遮罩类型设为 IMAGE_STENCIL 时生效 Segements 椭圆遮罩的曲线细分数，只在遮罩类型设为 ELLIPSE 时生效 节点添加了Mask组件之后，所有在该节点下的子节点，在渲染的时候都会受 Mask 影响。 使用mask组件制作的圆形头像会有锯齿，可使用圆形外边遮盖这个头像的锯齿，也可以使用shader","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"25、cocos creator 之自动布局容器Layout组件","slug":"Cocos Creator/25、cocos creator 之自动布局容器Layout组件","date":"2019-01-07T05:00:00.000Z","updated":"2020-08-07T14:10:11.680Z","comments":true,"path":"2019/01/07/Cocos Creator/25、cocos creator 之自动布局容器Layout组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/07/Cocos Creator/25、cocos creator 之自动布局容器Layout组件/","excerpt":"","text":"cocos creator 之自动布局容器Layout组件简介Layout(布局)是一种容器组件,容器拥有自动布局功能,自动按照规范排列所有子物体,并修改自己的尺寸。它非常适合做各种动态生成列表,特别是和滚动视图之类组件配合制作数量动态变化的列 根据Type属性,Layout分为水平布局容器、垂直布局容器和网格容器 水平布局容器:子节点水平方向排布 垂直布局容器:子节点垂直方向排布 网格布局容器:子节点网格方式排布 属性 属性 功能说明 Type 布局类型，支持 NONE, HORIZONTAL，VERTICAL 和 GRID。 Resize Mode 缩放模式，支持 NONE，CHILDREN 和 CONTAINER。 Padding Left 排版时，子物体相对于容器左边框的距离。 Padding Right 排版时，子物体相对于容器右边框的距离。 Padding Top 排版时，子物体相对于容器上边框的距离。 Padding Bottom 排版时，子物体相对于容器下边框的距离。 Spacing X 水平排版时，子物体与子物体在水平方向上的间距。NONE 模式无此属性。 Spacing Y 垂直排版时，子物体与子物体在垂直方向上的间距。NONE 模式无此属性。 Horizontal Direction 指定水平排版时，第一个子节点从容器的左边还是右边开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始水平排列方向。 Vertical Direction 指定垂直排版时，第一个子节点从容器的上面还是下面开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始垂直排列方向。 Cell Size 此属性只在 Grid 布局、Children 缩放模式时存在，指定网格容器里面排版元素的大小。 Start Axis 此属性只在 Grid 布局时存在，指定网格容器里面元素排版指定的起始方向轴。 Affected By Scale 子节点的缩放是否影响布局。 默认的布局类型是“NONE”,它表示容器不会修改子物体的大小和位置,当用户手动摆放子物体时,容器会以能够容纳所有子物体的最小矩形区域作为自身的大小。“NONE”容器只支持“NONE”和“CONTAINER”两种”ResizeMode”。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"24、cocos creator 之输入框EditBox组件","slug":"Cocos Creator/24、cocos creator 之输入框EditBox组件","date":"2019-01-06T08:00:00.000Z","updated":"2020-08-07T14:10:11.679Z","comments":true,"path":"2019/01/06/Cocos Creator/24、cocos creator 之输入框EditBox组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/06/Cocos Creator/24、cocos creator 之输入框EditBox组件/","excerpt":"","text":"cocos creator 之输入框EditBox组件简介EditBox(输入框)是一种文本输入组件,是 Cocos Creator目前提供的唯一用户输入文字的组件。 属性 属性 功能说明 String 输入框的初始输入内容，如果为空则会显示占位符的文本 Placeholder 输入框占位符的文本内容 Background 输入框背景节点上挂载的 Sprite 组件对象 Text Label 输入框输入文本节点上挂载的 Label 组件对象 Placeholder Label 输入框占位符节点上挂载的 Label 组件对象 KeyboardReturnType 指定移动设备上面回车按钮的样式 Input Flag 指定输入标识：可以指定输入方式为密码或者单词首字母大写（仅支持 Android 平台） Input Mode 指定输入模式: ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。 Max Length 输入框最大允许输入的字符个数 Tab Index 修改 DOM 输入元素的 tabIndex，这个属性只有在 Web 上面修改有意义。 Editing Did Began 开始编辑文本输入框触发的事件回调，详情请参考下方的 Editing Did Began 事件。 Text Changed 编辑文本输入框时触发的事件回调，详情请参考下方的 Text Changed 事件。 Editing Did Ended 结束编辑文本输入框时触发的事件回调，详情请参考下方的 Editing Did Ended 事件。 Editing Return 当用户按下回车按键时的事件回调，目前不支持 windows 平台，详情请参考下方的 Editing Return 事件。 事件 Editing Did Began 事件在用户开始输入时触发。 Text Changed 事件。该事件在用户每一次输入的文字变化时被触发 Editing Did Ended 事件。该事件在用户输入结束的时候被触发。在单行模式下面,通常是在用户按下回车或者点击屏幕输入框以外的地方触发该事件,如果是多行输入,通常是在用户点击屏幕输入框以外的地方触发该事件 Editing Returη 事件。该事件在用户按下回车键的时候被触发,如果是单行输入框,按回车键还会使输入框失去焦点 通过脚本代码添加回调方法一 123456789101112131415161718192021222324252627282930313233343536373839404142var editboxEventHandler = new cc.Component.EventHandler();editboxEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点editboxEventHandler.component = \"cc.MyComponent\"editboxEventHandler.handler = \"onEditDidBegan\";editboxEventHandler.customEventData = \"foobar\";editbox.editingDidBegan.push(editboxEventHandler);// 你也可以通过类似的方式来注册其它回调函数// editbox.editingDidEnded.push(editboxEventHandler);// editbox.textChanged.push(editboxEventHandler);// editbox.editingReturn.push(editboxEventHandler);// here is your component filecc.Class(&#123; name: 'cc.MyComponent' extends: cc.Component, properties: &#123; &#125;, onEditDidBegan: function(editbox, customEventData) &#123; // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;, // 假设这个回调是给 editingDidEnded 事件的 onEditDidEnded: function(editbox, customEventData) &#123; // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125; // 假设这个回调是给 textChanged 事件的 onTextChanged: function(text, editbox, customEventData) &#123; // 这里的 text 表示 修改完后的 EditBox 的文本内容 // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125; // 假设这个回调是给 editingReturn 事件的 onEditingReturn: function(editbox, customEventData) &#123; // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;&#125;); 方法二 123456789101112131415161718// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; editbox: cc.EditBox &#125;, onLoad: function () &#123; this.editbox.node.on('editing-did-began', this.callback, this); &#125;, callback: function (editbox) &#123; // 回调的参数是 editbox 组件 // do whatever you want with the editbox &#125;&#125;); editing-did-ended, text-changed 和 editing-return 事件，这些事件的回调函数的参数与 editing-did-began 的参数一致。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"23、cocos creator 之按钮Button组件","slug":"Cocos Creator/23、cocos creator 之按钮Button组件","date":"2019-01-06T07:00:00.000Z","updated":"2020-08-07T14:10:11.679Z","comments":true,"path":"2019/01/06/Cocos Creator/23、cocos creator 之按钮Button组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/06/Cocos Creator/23、cocos creator 之按钮Button组件/","excerpt":"","text":"cocos creator 之按钮Button组件简介Button(按钮)组件是用户界面中最常用的用户输入组件之当鼠标指针或手指点击、抬起或经过Button时,Button自身会有状态变化,可以呈现不同表现形式。 Button可以在用户在完成点击操作后回调一个自定义的行为 属性 属性 功能说明 Target Node 类型，当 Button 发生 Transition 的时候，会相应地修改 Target 节点的 SpriteFrame，颜色或者 Scale。 interactable 布尔类型，设为 false 时，则 Button 组件进入禁用状态。 Enable Auto Gray Effect 布尔类型，当设置为 true 的时候，如果 button 的 interactable 属性为 false，则 button 的 sprite Target 会变为灰度。 Transition 枚举类型，包括 NONE、COLOR、SPRITE 和 SCALE。每种类型对应不同的 Transition 设置。详情见下方的 Button Transition 部分。 Click Event 列表类型，默认为空，用户添加的每一个事件由节点引用、组件名称和一个响应函数组成。详情见下方的 Button 事件 部分。 注意：当 Transition 为 SPRITE 且 disabledSprite 属性有关联一个 spriteFrame 的时候，此时将忽略 Enable Auto Gray Effect 属性 通过脚本添加回调通过脚本添加回调有以下两种方式： 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过 Button 组件实现。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 1234567891011121314151617181920212223// here is your component file, file name = MyComponent.js cc.Class(&#123; extends: cc.Component, properties: &#123;&#125;, onLoad: function () &#123; var clickEventHandler = new cc.Component.EventHandler(); clickEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 clickEventHandler.component = \"MyComponent\";// 这个是代码文件名 clickEventHandler.handler = \"callback\"; clickEventHandler.customEventData = \"foobar\"; var button = this.node.getComponent(cc.Button); button.clickEvents.push(clickEventHandler); &#125;, callback: function (event, customEventData) &#123; // 这里 event 是一个 Event 对象，你可以通过 event.target 取到事件的发送节点 var node = event.target; var button = node.getComponent(cc.Button); // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" &#125;&#125;); 通过 button.node.on(‘click’, …) 的方式来添加，这是一种非常简便的方式，但是该方式有一定的局限性，在事件回调里面无法 获得当前点击按钮的屏幕坐标点。 123456789101112131415161718// 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理:cc.Class(&#123; extends: cc.Component, properties: &#123; button: cc.Button &#125;, onLoad: function () &#123; this.button.node.on('click', this.callback, this); &#125;, callback: function (button) &#123; // do whatever you want with button // 另外，注意这种方式注册的事件，也无法传递 customEventData &#125;&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"22、cocos creator 之制作九宫格图片","slug":"Cocos Creator/22、cocos creator 之制作九宫格图片","date":"2019-01-06T06:00:00.000Z","updated":"2020-08-07T14:10:11.679Z","comments":true,"path":"2019/01/06/Cocos Creator/22、cocos creator 之制作九宫格图片/","link":"","permalink":"https://www.zackaddy.xin/2019/01/06/Cocos Creator/22、cocos creator 之制作九宫格图片/","excerpt":"","text":"cocos creator 之制作九宫格图片简介制作可任意拉伸的 UI 图像，一方面节约游戏包体空间，另一方面能够灵活适配不同的排版需要。 创建要使用可以无限放大的九宫格图像效果，我们需要先对图像资源进行九宫格切分。 有两种方式可以打开 Sprite 编辑器来编辑图像资源： 在 资源管理器 中选中图像资源，然后点击 属性检查器 最下面的编辑按钮。如果您的窗口高度不够，可能需要向下滚动 属性检查器 才能看到下面的按钮。 在 场景编辑器 中选中想要九宫格化的图像节点，然后在 属性检查器 的 Sprite 组件里，找到并按下 Sprite Frame 属性右侧的 编辑 按钮。 使用 首先选中场景中的 Sprite 节点，将 Sprite 的 Type 属性设为 Sliced。 然后通过 矩形变换工具拖拽控制点使节点的 size 属性变大。您也可以直接在 属性检查器 中输入数值来修改 size属性。如果图像资源是用九宫格的形式生产的，那么不管 Sprite如何放大，都不会产生模糊或变形","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"21、cocos creator 之自动对齐Widget组件","slug":"Cocos Creator/21、cocos creator 之自动对齐Widget组件","date":"2019-01-06T05:00:00.000Z","updated":"2020-08-07T14:10:11.678Z","comments":true,"path":"2019/01/06/Cocos Creator/21、cocos creator 之自动对齐Widget组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/06/Cocos Creator/21、cocos creator 之自动对齐Widget组件/","excerpt":"","text":"cocos creator 之自动对齐Widget组件简介实现完美的多分辨率适配效果,特别是无黑边模式或类似画布內有部分内容会超出屏幕范围时,用户界面元素按照设计分辨率中规定的位置呈现是不够的,当屏幕宽度和高度发生变化时,用户界面元素要能够智能感知屏幕边界的位置,才能保证岀现在屏幕可见范围内,并且分布在合适的位置。 Cocos Creator提供 Widget(对齐挂件)来实现这种效果。 选项 | 说明 | 备注 Top| 对齐上边界| 选中后，将在旁边显示一个输入框，用于设定当前节点的上边界和父物体的上边界之间的距离。Bottom| 对齐下边界| 选中后，将在旁边显示一个输入框，用于设定当前节点的下边界和父物体的下边界之间的距离。Left| 对齐左边界| 选中后，将在旁边显示一个输入框，用于设定当前节点的左边界和父物体的左边界之间的距离。Right| 对齐右边界| 选中后，将在旁边显示一个输入框，用于设定当前节点的右边界和父物体的右边界之间的距离。HorizontalCenter| 水平方向居中|VerticalCenter| 竖直方向居中 |Target| 对齐目标| 指定对齐参照的节点，当这里未指定目标时会使用直接父级节点作为对齐目标Align Mode| 指定 widget 的对齐方式，用于决定运行时 widget 应何时更新| 通常设置为 ON_WINDOWS_RESIZE，仅在初始化和每当窗口大小改变时重新对齐。设置为 ONCE 时，仅在组件初始化时进行一次对齐。设置为 ALWAYS 时，每帧都会对当前 Widget 组件执行对齐逻辑。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"20、cocos creator 之设计分辨率和屏幕分辨率","slug":"Cocos Creator/20、cocos creator 之设计分辨率和屏幕分辨率","date":"2019-01-05T08:00:00.000Z","updated":"2020-08-07T14:10:11.678Z","comments":true,"path":"2019/01/05/Cocos Creator/20、cocos creator 之设计分辨率和屏幕分辨率/","link":"","permalink":"https://www.zackaddy.xin/2019/01/05/Cocos Creator/20、cocos creator 之设计分辨率和屏幕分辨率/","excerpt":"","text":"cocos creator 之设计分辨率和屏幕分辨率简介 设计分辨率:是内容生产者在制作场景时使用的分辨率蓝本,在Cocos creato场景编辑器中看到的各种尺寸和效果都是根据设计分辨率来锚定的。 屏幕分辨率:是游戏在设备上运行时的实际屏幕显示分辨率一般和设备硬件本身或运行设备设置分辨率有关。如果是网页平台则和硬件分辨率与浏览器窗口大小有关。 通常情况下设计分辨率会采用市场目标群体中使用率最高的设备的屏幕分辨率,比如目前Android设备中1920像素x1080像素和1280像素x720像素两种屏幕分辨率,或ios设备中1920像素×1080像素(iPhone6plus)和1134像素×750像素(iPhone6)两种屏幕分辨率;另外,智能手表一般分辨率为312像素×390像素。 这样当美术人员或策划人员使用设计分辨率设置好场景后,就可以无缩放高保真地展示给主要目标人群,并自动适配其他分辨率用户 设计分辨率与屏幕分辨率宽高比相同那么当设计分辨率和屏幕分辨率出现差异,并且设计分辨率和屏幕分辨率宽高比相同时, Cocos Creator会按照等比缩放方式进行适配 假设设计分辨率为800像素x480像素,美术人员制作了一个同样分辨率大小的背景图像。 如果屏幕分辨率为1600像素x960像素,即宽高比和设计分辨率致:1600/1960=800/480像素。画布会将画布和画布内所有子节点放大两倍(长和宽都是两倍),并保障画布在屏幕正中心。所有适配方式效果一致。 设计分辨率与屏幕分辨率宽高比不同如果屏幕分辨率是1024像素ⅹ768像素,设计分辨率宽高比800/480。如果对画面进行宽高不等比缩放会导致画面比例失调,效果较差。 为了保障画布内所有节点宽高比不变,需要按照宽或者高的比例进行整体缩放。 宽度匹配模式:勾选 Fit width选项时为宽度匹配模式,即按照屏幕宽度适配,那么缩放比例为1024/800=128。即画布放大1.28倍,则高度将被放大至480×1.28≈614像素,小于实际设备分辨率的768像素。效果将会是屏幕上下两边会有黑边。 高度匹配模式:勾选 Fit Height选项时为高度匹配模式,即按照屏幕宽度适配,那么缩放比例为768/480=1.6。即画布放大1.6倍则宽度将被放大至800×1.6=1280像素,大于实际设备的分辨率1024像素。效果将会是屏幕左右两边超出会有部分内容显示不齐。虽然屏幕两边会裁剪掉一部分背景图,但能够保证屏幕可见区域内不出现任何穿帮或黑边。之后可以通过wget(对齐挂件)调整用户界面元素的位置,来保证用户界面元素出现在屏幕可见区域里。 同时勾选Fit Height和Fit Width当 Fit Height与 Fit width两个选项都被勾选时,适配将变为Resolution Policy. SHOW ALL”模式,同时适配宽和高，一个应该有黑边。效果不佳, Cocos creator不推荐如此做。 同时取消勾选Fit Height和Fit Width当 Fit Height与 Fit Width两个选项不被勾选时适配将变为Resolution Policy. NO_ BORDER”模式,一定没黑边，有可能背景会被盖住一部分","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"19、cocos creator 之画布组件","slug":"Cocos Creator/19、cocos creator 之画布组件","date":"2019-01-05T07:00:00.000Z","updated":"2020-08-07T14:10:11.678Z","comments":true,"path":"2019/01/05/Cocos Creator/19、cocos creator 之画布组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/05/Cocos Creator/19、cocos creator 之画布组件/","excerpt":"","text":"cocos creator 之画布组件 画布( Canvas)是 Cocos creator新建空场景中自带的一个节点组件,并且该节点被命名为“ Canvas”。 该组件能够获得设备屏幕或浏览器有效区域的分辨率,并对场景中所有渲染元素进行适当的缩放。 场景中拥有的画布组件同时只能有一个，建议所有用户界面和渲染元素都设置为画布节点的子节点 选项 说明 Design Resolution 设计分辨率，内容产生者在制作场景时使用的分辨率蓝本 Fit Height 适配高度，设计分辨率的高度自动撑满屏幕高度 Fit Width 适配宽度，设计分辨率的宽度自动撑满屏幕宽度 其中设计分辨率为开发时画布实际分辨率,当运行设备和设计分辨率不一致时,画布会根据适配方式(适配高度或者适配宽度)进行缩放 因为画布会自动缩放,所以在画布节点的节点属性中位置、锚点和尺寸是不能修改的,只能通过修改画布组件的设计分辨率属性来改变画布大小。 位置必须在屏幕正中心,并且锚点也必须是(0.5,05),否则适配不同屏幕时坐标会有偏差 由于锚点属性的默认值会设置为(0.5,05),画布会保持在屏幕中心位置,并且画布的子节点会以屏幕中心作为坐标系原点","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"18、cocos creator 之全局系统事件","slug":"Cocos Creator/18、cocos creator 之全局系统事件","date":"2019-01-05T06:00:00.000Z","updated":"2020-08-07T14:10:11.677Z","comments":true,"path":"2019/01/05/Cocos Creator/18、cocos creator 之全局系统事件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/05/Cocos Creator/18、cocos creator 之全局系统事件/","excerpt":"","text":"cocos creator 之全局系统事件简介全局系统事件是指与节点树不相关的各种全局事件，由 cc.systemEvent 来统一派发，目前支持了以下几种事件： 键盘事件 设备重力传感事件 如何定义输入事件通过函数 cc.systemEvent.on(type, callback, target) 注册。 可选的 type 类型有: cc.SystemEvent.EventType.KEY_DOWN (键盘按下) cc.SystemEvent.EventType.KEY_UP (键盘释放) cc.SystemEvent.EventType.DEVICEMOTION (设备重力传感) 1234567891011121314151617181920212223242526272829cc.Class(&#123; extends: cc.Component, onLoad: function () &#123; // add key down and key up event cc.systemEvent.on(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this); cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this); &#125;, onDestroy () &#123; cc.systemEvent.off(cc.SystemEvent.EventType.KEY_DOWN, this.onKeyDown, this); cc.systemEvent.off(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this); &#125;, onKeyDown: function (event) &#123; switch(event.keyCode) &#123; case cc.macro.KEY.a: console.log('Press a key'); break; &#125; &#125;, onKeyUp: function (event) &#123; switch(event.keyCode) &#123; case cc.macro.KEY.a: console.log('release a key'); break; &#125; &#125;&#125;); 设备重力传感事件12345678910111213141516cc.Class(&#123; extends: cc.Component, onLoad () &#123; // open Accelerometer cc.systemEvent.setAccelerometerEnabled(true); cc.systemEvent.on(cc.SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this); &#125;, onDestroy () &#123; cc.systemEvent.off(cc.SystemEvent.EventType.DEVICEMOTION, this.onDeviceMotionEvent, this); &#125;, onDeviceMotionEvent (event) &#123; cc.log(event.acc.x + \" \" + event.acc.y); &#125;,&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"17、cocos creator 之节点系统事件","slug":"Cocos Creator/17、cocos creator 之节点系统事件","date":"2019-01-05T05:00:00.000Z","updated":"2020-08-07T14:10:11.677Z","comments":true,"path":"2019/01/05/Cocos Creator/17、cocos creator 之节点系统事件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/05/Cocos Creator/17、cocos creator 之节点系统事件/","excerpt":"","text":"cocos creator 之节点系统事件简介鼠标和触摸事件称为节点系统事件 123456789// 使用枚举类型来注册node.on(cc.Node.EventType.MOUSE_DOWN, function (event) &#123; console.log('Mouse down');&#125;, this);// 使用事件名来注册node.on('mousedown', function (event) &#123; console.log('Mouse down');&#125;, this); 暂停或恢复节点系统事件暂停节点系统事件 1234// 暂停当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。// 如果传递参数 true，那么这个 API 将暂停本节点和它的所有子节点上的节点系统事件。// examplethis.node.pauseSystemEvents(); 恢复节点系统事件 1234// 恢复当前节点上注册的所有节点系统事件，节点系统事件包含触摸和鼠标事件。// 如果传递参数 true，那么这个 API 将恢复本节点和它的所有子节点上的节点系统事件。// examplethis.node.resumeSystemEvents(); 多点触摸事件引擎在 v2.3 版本中新增了多点触摸事件的屏蔽开关，多点触摸事件默认为开启状态。对于有些类型的项目为了防止多点误触，需要屏蔽多点触摸事件，可以通过以下代码进行关闭： 1cc.macro.ENABLE_MULTI_TOUCH = false; 鼠标事件类型和事件对象鼠标事件在桌面平台才会触发，系统提供的事件类型如下：枚举对象定义 | 对应的事件名 | 事件触发的时机–|–|–cc.Node.EventType.MOUSE_DOWN| mousedown| 当鼠标在目标节点区域按下时触发一次cc.Node.EventType.MOUSE_ENTER| mouseenter| 当鼠标移入目标节点区域时，不论是否按下cc.Node.EventType.MOUSE_MOVE| mousemove| 当鼠标在目标节点区域中移动时，不论是否按下cc.Node.EventType.MOUSE_LEAVE| mouseleave| 当鼠标移出目标节点区域时，不论是否按下cc.Node.EventType.MOUSE_UP| mouseup| 当鼠标从按下状态松开时触发一次cc.Node.EventType.MOUSE_WHEEL| mousewheel| 当鼠标滚轮滚动时 函数名 返回值类型 意义 getScrollY Number 获取滚轮滚动的 Y 轴距离，只有滚动时才有效 getLocation Object 获取鼠标位置对象，对象包含 x 和 y 属性 getLocationX Number 获取鼠标的 X 轴位置 getLocationY Number 获取鼠标的 Y 轴位置 getPreviousLocation Object 获取鼠标事件上次触发时的位置对象，对象包含 x 和 y 属性 getDelta Object 获取鼠标距离上一次事件移动的距离对象，对象包含 x 和 y 属性 getButton Number cc.Event.EventMouse.BUTTON_LEFT 或 cc.Event.EventMouse.BUTTON_RIGHT 或 cc.Event.EventMouse.BUTTON_MIDDLE 触摸事件类型和事件对象 同时响应移动平台的触摸事件和桌面端的鼠标事件 需要注意的是，触摸事件支持多点触摸，每个触点都会发送一次事件给事件监听器。 枚举对象定义 对应的事件名 事件触发的时机 cc.Node.EventType.TOUCH_START touchstart 当手指触点落在目标节点区域内时 cc.Node.EventType.TOUCH_MOVE touchmove 当手指在屏幕上移动时 cc.Node.EventType.TOUCH_END touchend 当手指在目标节点区域内离开屏幕时 cc.Node.EventType.TOUCH_CANCEL touchcancel 当手指在目标节点区域外离开屏幕时 API 名 类型 意义 touch cc.Touch 与当前事件关联的触点对象 getID Number 获取触点的 ID，用于多点触摸的逻辑判断 getLocation Object 获取触点位置对象，对象包含 x 和 y 属性 getLocationX Number 获取触点的 X 轴位置 getLocationY Number 获取触点的 Y 轴位置 getPreviousLocation Object 获取触点上一次触发事件时的位置对象，对象包含 x 和 y 属性 getStartLocation Object 获取触点初始时的位置对象，对象包含 x 和 y 属性 getDelta Object 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"16、cocos creator 之发射和监听事件","slug":"Cocos Creator/16、cocos creator 之发射和监听事件","date":"2019-01-04T08:00:00.000Z","updated":"2020-08-07T14:10:11.677Z","comments":true,"path":"2019/01/04/Cocos Creator/16、cocos creator 之发射和监听事件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/04/Cocos Creator/16、cocos creator 之发射和监听事件/","excerpt":"","text":"cocos creator 之发射和监听事件监听事件以下两种调用方式， 效果上是相同的： 123456789// 使用函数绑定this.node.on('mousedown', function ( event ) &#123; this.enabled = false;&#125;.bind(this));// 使用第三个参数this.node.on('mousedown', function (event) &#123; this.enabled = false;&#125;, this); 发射事件我们可以通过两种方式发射事件：emit 和 dispatchEvent。两者的区别在于，后者可以做事件传递。 我们先通过一个简单的例子来了解 emit 事件： 123456789101112131415cc.Class(&#123; extends: cc.Component, onLoad () &#123; // args are optional param. this.node.on('say-hello', function (msg) &#123; console.log(msg); &#125;); &#125;, start () &#123; // At most 5 args could be emit. this.node.emit('say-hello', 'Hello, this is Cocos Creator'); &#125;,&#125;); 除了使用 on 监听，我们还可以使用 once 方法。once 监听在监听函数响应后就会关闭监听事件。 关闭监听123456789101112131415cc.Class(&#123; extends: cc.Component, _sayHello: function () &#123; console.log('Hello World'); &#125;, onEnable: function () &#123; this.node.on('foobar', this._sayHello, this); &#125;, onDisable: function () &#123; this.node.off('foobar', this._sayHello, this); &#125;,&#125;); 发射事件我们可以通过两种方式发射事件：emit 和 dispatchEvent。两者的区别在于，后者可以做事件传递。 我们先通过一个简单的例子来了解 emit 事件： 123456789101112131415cc.Class(&#123; extends: cc.Component, onLoad () &#123; // args are optional param. this.node.on('say-hello', function (msg) &#123; console.log(msg); &#125;); &#125;, start () &#123; // At most 5 args could be emit. this.node.emit('say-hello', 'Hello, this is Cocos Creator'); &#125;,&#125;); 派送事件冒泡派送会将事件从事件发起节点，不断地向上传递给他的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.stopPropagation()。 爷爷a，爸爸b，儿子c节点 12// 节点 c 的组件脚本中this.node.dispatchEvent( new cc.Event.EventCustom('foobar', true) ); 1234// 节点 b 的组件脚本中this.node.on('foobar', function (event) &#123; event.stopPropagation();&#125;); c节点触发事件冒泡 b节点收到事件后调用event.stopPropagation();停止冒泡 a收不到派发的foobar事件。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"15、cocos creator 之动态加载资源","slug":"Cocos Creator/15、cocos creator 之动态加载资源","date":"2019-01-04T07:00:00.000Z","updated":"2020-08-07T14:10:11.676Z","comments":true,"path":"2019/01/04/Cocos Creator/15、cocos creator 之动态加载资源/","link":"","permalink":"https://www.zackaddy.xin/2019/01/04/Cocos Creator/15、cocos creator 之动态加载资源/","excerpt":"","text":"cocos creator 之动态加载资源注意resources 文件夹中的资源，可以引用文件夹外部的其它资源，同样也可以被外部场景或资源引用到。项目构建时，除了已在 构建发布 面板勾选的场景外，resources 文件夹中的所有资源，连同它们关联依赖的 resources 文件夹外部的资源，都会被导出。 如果一份资源仅仅是被 resources 中的其它资源所依赖，而不需要直接被 cc.loader.loadRes 调用，那么 请不要 放在 resources 文件夹里。否则会增大包体和 settings.js 的大小，并且项目中无用的资源，将无法在构建的过程中自动剔除。同时在构建过程中，JSON 的自动合并策略也将受到影响，无法尽可能将零碎的 JSON 合并起来。 加载预制资源 Creator 提供了 cc.loader.loadRes 这个 API 来专门加载那些位于 resources 目录下的 Asset。 loadRes 一次只能加载单个 Asset 只要传入相对 resources 的路径即可，并且路径的结尾处 不能 包含文件扩展名。12345// 加载 Prefabcc.loader.loadRes(\"test assets/prefab\", function (err, prefab) &#123; var newNode = cc.instantiate(prefab); cc.director.getScene().addChild(newNode);&#125;); 加载 SpriteFrame 但如果直接加载 test assets/image，得到的类型将会是 cc.Texture2D。你必须指定第二个参数为资源的类型，才能加载到图片生成的 cc.SpriteFrame：12345// 加载 SpriteFramevar self = this;cc.loader.loadRes(\"test assets/image\", cc.SpriteFrame, function (err, spriteFrame) &#123; self.node.getComponent(cc.Sprite).spriteFrame = spriteFrame;&#125;); 加载图集中的 SpriteFrame 只能先加载图集，再获取其中的 SpriteFrame。这是一种特殊情况。123456// 加载 SpriteAtlas（图集），并且获取其中的一个 SpriteFrame// 注意 atlas 资源文件（plist）通常会和一个同名的图片文件（png）放在一个目录下, 所以需要在第二个参数指定资源类型cc.loader.loadRes(\"test assets/sheep\", cc.SpriteAtlas, function (err, atlas) &#123; var frame = atlas.getSpriteFrame('sheep_down_0'); sprite.spriteFrame = frame;&#125;); 资源批量加载123456789// 加载 test assets 目录下所有资源cc.loader.loadResDir(\"test assets\", function (err, assets) &#123; // ...&#125;);// 加载 test assets 目录下所有 SpriteFrame，并且获取它们的路径cc.loader.loadResDir(\"test assets\", cc.SpriteFrame, function (err, assets, urls) &#123; // ...&#125;); 加载远程资源和设备资源 原生平台远程加载不支持图片文件以外类型的资源 这种加载方式只支持图片、声音、文本等原生资源类型，不支持 SpriteFrame、SpriteAtlas、Tilemap 等资源的直接加载和解析（需要后续版本中的 AssetBundle 支持） Web 端的远程加载受到浏览器的 CORS 跨域策略限制，如果对方服务器禁止跨域访问，那么会加载失败，而且由于 WebGL 安全策略的限制，即便对方服务器允许 http 请求成功之后也无法渲染。1234567891011121314151617// 远程 url 带图片后缀名var remoteUrl = \"http://unknown.org/someres.png\";cc.loader.load(remoteUrl, function (err, texture) &#123; // Use texture to create sprite frame&#125;);// 远程 url 不带图片后缀名，此时必须指定远程图片文件的类型remoteUrl = \"http://unknown.org/emoji?id=124982374\";cc.loader.load(&#123;url: remoteUrl, type: 'png'&#125;, function () &#123; // Use texture to create sprite frame&#125;);// 用绝对路径加载设备存储内的资源，比如相册var absolutePath = \"/dara/data/some/path/to/image.png\"cc.loader.load(absolutePath, function () &#123; // Use texture to create sprite frame&#125;); 资源释放 loadRes 加载进来的单个资源如果需要释放，可以调用 cc.loader.releaseRes，releaseRes 可以传入和 loadRes 相同的路径和类型参数123cc.loader.releaseRes(\"test assets/image\", cc.SpriteFrame);cc.loader.releaseRes(\"test assets/anim\");cc.loader.releaseAsset(spriteFrame);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"14、cocos creator 之Texture、SpriteFrame、Sprite的区别","slug":"Cocos Creator/14、cocos creator 之Texture、SpriteFrame、Sprite的区别","date":"2019-01-04T06:00:00.000Z","updated":"2020-08-07T14:10:11.676Z","comments":true,"path":"2019/01/04/Cocos Creator/14、cocos creator 之Texture、SpriteFrame、Sprite的区别/","link":"","permalink":"https://www.zackaddy.xin/2019/01/04/Cocos Creator/14、cocos creator 之Texture、SpriteFrame、Sprite的区别/","excerpt":"","text":"cocos creator 之Texture、SpriteFrame、Sprite的区别简介Texture是保存在GPU缓冲中的一张纹理。是由一张图片创建获得的。 SpriteFrame是Texture+Rect，根据一张纹理材质来剪切获得。 使用SpriteFrame 我们可以创建想要见到的Sprite。 通过剪切的Texture创建出了我们想要的Sprite。 Sprite 可以使用 TextureRegion构造，TextureRegion可以使用Texture构造。所以SpriteBatch在底层最终操作的还是Texture。 Texture :保存在GPU缓冲中的一张纹理。 TextureRegion： 定义了一块矩形区域的纹理。主要作用是从一块纹理中择取需要使用的矩形区域。 Sprite：Holds the geometry, color, and texture information for drawing 2D。这个类是继承于TextureRegion，是对TextureRegion的功能的扩展，相比增加了旋转，动画等效果。 SpriteBatch：A SpriteBatch is used to draw 2D rectangles that reference a texture (region). 主要处理对纹理的绘画，绘画前的优化等。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"13、cocos creator 之加载和切换场景","slug":"Cocos Creator/13、cocos creator 之加载和切换场景","date":"2019-01-04T05:00:00.000Z","updated":"2020-08-07T14:10:11.676Z","comments":true,"path":"2019/01/04/Cocos Creator/13、cocos creator 之加载和切换场景/","link":"","permalink":"https://www.zackaddy.xin/2019/01/04/Cocos Creator/13、cocos creator 之加载和切换场景/","excerpt":"","text":"cocos creator 之加载和切换场景加载并切换场景在 Cocos Creator 中，我们使用场景文件名（不包含扩展名）来索引指代场景。并通过以下接口进行加载和切换操作： 1cc.director.loadScene(\"MyScene\"); 场景加载回调加载场景时，可以附加一个参数用来指定场景加载后的回调函数： 1cc.director.loadScene(\"MyScene\", onSceneLaunched); 预加载场景使用 preloadScene 接口对场景进行预加载： 123cc.director.preloadScene(\"table\", function () &#123; cc.log(\"Next scene preloaded\");&#125;); 之后在合适的时间调用 loadScene, 就可以真正切换场景。 1cc.director.loadScene(\"table\"); 就算预加载还没完成，你也可以直接调用 cc.director.loadScene，预加载完成后场景就会启动。 常驻节点常驻节点:常驻节点是在场景切换时不会被销毁的节点,它会从旧场景中被拿岀来放到新场景,默认放置到根节点。由于它默认不在画布中,所以不适合做渲染,但是它常驻内存的特性十分适合传递数据。用如下接口注册一个常驻节点 1cc.game.addPersistRootNode(myNode); 如果要取消一个节点的常驻属性： 1cc.game.removePersistRootNode(myNode); 需要注意的是上面的 API 并不会立即销毁指定节点，只是将节点还原为可在场景切换时销毁的节点。 获取常驻节点 1cc.director.getScene().getChildByName(\"你要找的常驻节点\").getComponent(\"你的脚本\");","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"12、cocos creator 之创建和销毁节点","slug":"Cocos Creator/12、cocos creator 之创建和销毁节点","date":"2019-01-03T08:00:00.000Z","updated":"2020-08-07T14:10:11.675Z","comments":true,"path":"2019/01/03/Cocos Creator/12、cocos creator 之创建和销毁节点/","link":"","permalink":"https://www.zackaddy.xin/2019/01/03/Cocos Creator/12、cocos creator 之创建和销毁节点/","excerpt":"","text":"cocos creator 之创建和销毁节点创建新节点除了通过场景编辑器创建节点外，我们也可以在脚本中动态创建节点。通过 new cc.Node() 并将它加入到场景中，可以实现整个创建过程。 123456789101112131415161718cc.Class(&#123; extends: cc.Component, properties: &#123; sprite: &#123; default: null, type: cc.SpriteFrame, &#125;, &#125;, start: function () &#123; var node = new cc.Node('Sprite'); var sp = node.addComponent(cc.Sprite); sp.spriteFrame = this.sprite; node.parent = this.node; &#125;,&#125;); 克隆已有节点有时我们希望动态的克隆场景中的已有节点，我们可以通过 cc.instantiate 方法完成。使用方法如下： 123456789101112131415161718cc.Class(&#123; extends: cc.Component, properties: &#123; target: &#123; default: null, type: cc.Node, &#125;, &#125;, start: function () &#123; var scene = cc.director.getScene(); var node = cc.instantiate(this.target); node.parent = scene; node.setPosition(0, 0); &#125;,&#125;); 创建预制节点和克隆已有节点相似，你可以设置一个预制（Prefab）并通过 cc.instantiate 生成节点。使用方法如下： 123456789101112131415161718cc.Class(&#123; extends: cc.Component, properties: &#123; target: &#123; default: null, type: cc.Prefab, &#125;, &#125;, start: function () &#123; var scene = cc.director.getScene(); var node = cc.instantiate(this.target); node.parent = scene; node.setPosition(0, 0); &#125;,&#125;); 销毁节点通过 node.destroy() 函数，可以销毁节点。 销毁节点并不会立刻被移除，而是在当前帧逻辑更新结束后，统一执行。当一个节点销毁后，该节点就处于无效状态，可以通过 cc.isValid 判断当前节点是否已经被销毁。 1234567891011121314151617181920cc.Class(&#123; extends: cc.Component, properties: &#123; target: cc.Node, &#125;, start: function () &#123; // 5 秒后销毁目标节点 setTimeout(function () &#123; this.target.destroy(); &#125;.bind(this), 5000); &#125;, update: function (dt) &#123; if (cc.isValid(this.target)) &#123; this.target.rotation += dt * 10.0; &#125; &#125;,&#125;); destroy 和 removeFromParent 的区别调用一个节点的 removeFromParent 后，它不一定就能完全从内存中释放，因为有可能由于一些逻辑上的问题，导致程序中仍然引用到了这个对象。因此如果一个节点不再使用了，请直接调用它的 destroy 而不是 removeFromParent。destroy 不但会激活组件上的 onDestroy，还会降低内存泄露的几率，同时减轻内存泄露时的后果。 总之，如果一个节点不再使用，destroy 就对了，不需要 removeFromParent 也不需要设置 parent 为 null。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"11、cocos creator 之生命周期","slug":"Cocos Creator/11、cocos creator 之生命周期","date":"2019-01-03T07:00:00.000Z","updated":"2020-08-07T14:10:11.675Z","comments":true,"path":"2019/01/03/Cocos Creator/11、cocos creator 之生命周期/","link":"","permalink":"https://www.zackaddy.xin/2019/01/03/Cocos Creator/11、cocos creator 之生命周期/","excerpt":"","text":"cocos creator 之生命周期Cocos Creator 为组件脚本提供了生命周期的回调函数。用户只要定义特定的回调函数，Creator 就会在特定的时期自动执行相关脚本，用户不需要手工调用它们。 onLoad start update lateUpdate onDestroy onEnable onDisable onLoadonload是组件构造完成后最早被调用的回调。在所属节点被激活时,节点上所有的组件脚本会被依次激活(由上至下)。 onload总会在star之前执行。在通常的开发习惯中,会在 onload里做一些初始化,如果有强制先后顺序,建议把需要后置的内容放到 start中,比如在 onload中声明并初始化信息,在star中进行读取,范例代码如下。 12345678910111213cc.Class(&#123; extends: cc.Component, properties: &#123; bulletSprite: cc.SpriteFrame, gun: cc.Node, &#125;, onLoad: function () &#123; this._bulletRect = this.bulletSprite.getRect(); this.gun = cc.find('hand/weapon', this.node); &#125;,&#125;); 以上代码在onload中为属性做初始化。onload时节点和组件均已创建完成,可以在这里找到其他节点和其他组件,但是其他组件的onload不一定完成 onEnable当组件的 enabled 属性从 false 变为 true 时，或者所在节点的 active 属性从 false 变为 true 时，会激活 onEnable 回调。倘若节点第一次被创建且 enabled 为 true，则会在 onLoad 之后，start 之前被调用。 startstart 回调函数会在组件第一次激活前，也就是第一次执行 update 之前触发。start 通常用于初始化一些中间状态的数据，这些数据可能在 update 时会发生改变，并且被频繁的 enable 和 disable。 1234567cc.Class(&#123; extends: cc.Component, start: function () &#123; this._timer = 0.0; &#125;&#125;); update游戏开发的一个关键点是在每一帧渲染前更新物体的行为，状态和方位。这些更新操作通常都放在 update 回调中。 12345678cc.Class(&#123; extends: cc.Component, update: function (dt) &#123; cc.log(dt); this.node.setPosition( 0.0, this.node.y + 20 * dt ); &#125;&#125;); update 中 dt之所以是0.015, 0.016, 0.017这样的数字，是因为引擎尽可能地把帧率控制在每秒60帧，这样既流畅又不过分消耗计算资源。1/60 = 0.016666666循环，所以你获得的dt大概是0.016左右。但是如果游戏进行了比较消耗资源的操作，帧率达不到60帧，dt就会比0.016大了。 lateUpdateupdate 会在所有动画更新前执行，但如果我们要在动效（如动画、粒子、物理等）更新之后才进行一些额外操作，或者希望在所有组件的 update 都执行完之后才进行其它操作，那就需要用到 lateUpdate 回调。 1234567cc.Class(&#123; extends: cc.Component, lateUpdate: function (dt) &#123; this.node.rotation = 20; &#125;&#125;); onDisable当组件的 enabled 属性从 true 变为 false 时，或者所在节点的 active 属性从 true 变为 false 时，会激活 onDisable 回调。 onDestroy当组件或者所在节点调用了 destroy()，则会调用 onDestroy 回调，并在当帧结束时统一回收组件。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"10、cocos creator 之常用节点和组件接口","slug":"Cocos Creator/10、cocos creator 之常用节点和组件接口","date":"2019-01-03T06:00:00.000Z","updated":"2020-08-07T14:10:11.675Z","comments":true,"path":"2019/01/03/Cocos Creator/10、cocos creator 之常用节点和组件接口/","link":"","permalink":"https://www.zackaddy.xin/2019/01/03/Cocos Creator/10、cocos creator 之常用节点和组件接口/","excerpt":"","text":"cocos creator 之常用节点和组件接口激活/关闭节点12this.node.active = true;this.node.active = false; 在场景中隐藏该节点和节点下的所有子节点 该节点和所有子节点上的所有组件都将被禁用，也就是不会再执行这些组件中的 update 中的代码 这些组件上如果有onDisable方法，这些方法将被执行 更改节点的父节点1this.node.parent = parentNode; 12this.node.removeFromParent(false);parentNode.addChild(this.node); 这两种方法是等价的。 removeFromParent 通常需要传入一个 false，否则默认会清空节点上绑定的事件和 action 等。 创建出新节点后，要为节点设置一个父节点才能正确完成节点的初始化。 索引节点的子节点1this.node.children 将返回节点的所有子节点数组。 1this.node.childrenCount 将返回节点的子节点数量。 注意 以上两个API都只会返回节点的直接子节点，不会返回子节点的子节点。 更改节点位置分别对 x 轴和 y 轴坐标赋值： 1234567891011this.node.x = 100;this.node.y = 50;使用 setPosition 方法：this.node.setPosition(100, 50);this.node.setPosition(cc.v2(100, 50));设置 position 变量：this.node.position = cc.v2(100, 50); 以上两种用法等价。 更改节点旋转1234567this.node.scaleX = 2;this.node.scaleY = 2;或this.node.setScale(2);this.node.setScale(2, 2); 以上两种方法等价。setScale 传入单个参数时，会同时修改 scaleX 和 scaleY。 更改节点尺寸1234567this.node.setContentSize(100, 100);this.node.setContentSize(cc.size(100, 100));或this.node.width = 100;this.node.height = 100; 以上两种方式等价。 更改节点锚点位置123456this.node.anchorX = 1;this.node.anchorY = 0;或this.node.setAnchorPoint(1, 0); 注意以上这些修改变换的方法会影响到节点上挂载的渲染组件，比如 Sprite 图片的尺寸、旋转等等。 颜色和不透明度12345mySprite.node.color = cc.Color.RED;设置不透明度：mySprite.node.opacity = 128; 常用组件接口 this.node：该组件所属的节点实例 this.enabled：是否每帧执行该组件的 update 方法，同时也用来控制渲染组件是否显示 update(dt)：作为组件的成员方法，在组件的 - enabled 属性为 true 时，其中的代码会每帧执行 onLoad()：组件所在节点进行初始化时（节点添加到节点树时）执行 start()：会在该组件第一次 update 之前执行，通常用于需要在所有组件的 onLoad 初始化完毕后执行的逻辑","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"9、cocos creator 之获取节点与其它节点和组件","slug":"Cocos Creator/9、cocos creator 之获取节点与其它节点和组件","date":"2019-01-03T05:00:00.000Z","updated":"2020-08-07T14:10:11.687Z","comments":true,"path":"2019/01/03/Cocos Creator/9、cocos creator 之获取节点与其它节点和组件/","link":"","permalink":"https://www.zackaddy.xin/2019/01/03/Cocos Creator/9、cocos creator 之获取节点与其它节点和组件/","excerpt":"","text":"cocos creator 之获取节点与其它节点和组件访问当前脚本组件所在节点12var node = this.node; node.x = 100; 获得同节点上其它组件当获取自己节点上的其他组件时“node”可以省略,即this.node.getComponent(cc.Label)和this.getComponent(c.Label);效果一致。其他节点不可省略。 12345var label = this.getComponent(cc.Label);var text = this.name + 'started';// Change the text in Label Componentlabel.string = text; 12345var label = this.node.getComponent(cc.Label);var text = this.name + 'started';// Change the text in Label Componentlabel.string = text; 根据节点上的组件名称查找组件1var helloworld = this.getComponent(\"HelloWorld\"); 获取其它节点NodeA节点加入ScriptA脚本组件 123456cc.Class(&#123; extends: cc.Component, hello: function() &#123; cc.log(\"A:hello\"); &#125;&#125;); NodeB节点加入ScriptB脚本组件，并将NodeA节点拖入ScriptB脚本组件的nodeA属性上 1234567891011121314cc.Class(&#123; extends: cc.Component, properties: &#123; nodeA: cc.Node &#125;, onLoad: function() &#123; if (this.nodeA) &#123; var a = this.nodeA; if (a) &#123; a.hello(); &#125; &#125; &#125;&#125;); 查找子节点1var cannons = this.node.children; 1this.node.getChildByName(\"Cannon 01\"); 全局名称查找1this.backNode = cc.find(\"Canvas/Menu/Back\"); 通过模块访问每个脚本都能用 require + 文件名(不含路径) 来获取到对方 exports 的对象。 1234567891011// ScriptA.jsvar ScriptB = require(\"ScriptB\");cc.Class(&#123; extends: cc.Component, onLoad: function () &#123; ScriptB.x = 10; &#125;&#125;);","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"8、cocos creator 之cc.Class","slug":"Cocos Creator/8、cocos creator 之cc.Class","date":"2019-01-02T08:00:00.000Z","updated":"2020-08-07T14:10:11.687Z","comments":true,"path":"2019/01/02/Cocos Creator/8、cocos creator 之cc.Class/","link":"","permalink":"https://www.zackaddy.xin/2019/01/02/Cocos Creator/8、cocos creator 之cc.Class/","excerpt":"","text":"cocos creator 之cc.Class简介cc.Class 是一个很常用的 API，用于声明 Cocos Creator 中的类 一份简单脚本如下 1234567891011121314cc.Class(&#123; extends: cc.Component, properties: &#123; &#125;, // use this for initialization onLoad: function () &#123; &#125;, // called every frame, uncomment this function to activate update callback update: function (dt) &#123; &#125;,&#125;); 定义123var Sprite = cc.Class(&#123; name: \"sprite\"&#125;); 实例化1var obj = new Sprite(); 构造函数使用 ctor 声明构造函数 12345var Sprite = cc.Class(&#123; ctor: function () &#123; cc.log(this instanceof Sprite); // true &#125;&#125;); 继承1234567// 父类var Shape = cc.Class();// 子类var Rect = cc.Class(&#123; extends: Shape&#125;); 父构造函数继承后，CCClass 会统一自动调用父构造函数，你不需要显式调用。 1234567891011121314151617181920var Shape = cc.Class(&#123; ctor: function () &#123; cc.log(\"Shape\"); // 实例化时，父构造函数会自动调用， &#125;&#125;);var Rect = cc.Class(&#123; extends: Shape&#125;);var Square = cc.Class(&#123; extends: Rect, ctor: function () &#123; cc.log(\"Square\"); // 再调用子构造函数 &#125;&#125;);var square = new Square();// 以上代码将依次输出 \"Shape\" 和 \"Square\"。 声明属性通过在组件脚本中声明属性，我们可以将脚本组件中的字段可视化地展示在 属性检查器 中，从而方便地在场景中调整属性值。 1234567cc.Class(&#123; extends: cc.Component, properties: &#123; userID: 20, userName: \"Foobar\" &#125;&#125;); 当声明的属性为基本 JavaScript 类型时，可以直接赋予默认值： 123456properties: &#123; height: 20, // number type: \"actor\", // string loaded: false, // boolean target: null, // object &#125; 当声明的属性具备类型时（如：cc.Node，cc.Vec2 等），可以在声明处填写他们的构造函数来完成声明，如： 1234properties: &#123; target: cc.Node, pos: cc.Vec2,&#125; 当声明属性的类型继承自 cc.ValueType 时（如：cc.Vec2，cc.Color 或 cc.Rect），除了上面的构造函数，还可以直接使用实例作为默认值： 1234properties: &#123; pos: new cc.Vec2(10, 20), color: new cc.Color(255, 255, 255, 128), &#125; 当声明属性是一个数组时，可以在声明处填写他们的类型或构造函数来完成声明，如： 1234567891011properties: &#123; any: [], // 不定义具体类型的数组 bools: [cc.Boolean], strings: [cc.String], floats: [cc.Float], ints: [cc.Integer], values: [cc.Vec2], nodes: [cc.Node], frames: [cc.SpriteFrame],&#125; 完整声明12345678// 查看全部参数 http://docs.cocos.com/creator/manual/zh/scripting/reference/attributes.htmlproperties: &#123; score: &#123; default: 0, displayName: \"Score (player)\", tooltip: \"The score of player\", &#125;&#125; default: 设置属性的默认值，这个默认值仅在组件第一次添加到节点上时才会用到 type: 限定属性的数据类型，详见 CCClass 进阶参考：type 参数 visible: 设为 false 则不在 属性检查器 面板中显示该属性 serializable: 设为 false 则不序列化（保存）该属性 displayName: 在 属性检查器 面板中显示成指定名字 tooltip: 在 属性检查器 面板中添加属性的 Tooltip 数组声明数组的 default 必须设置为 []，如果要在 属性检查器 中编辑，还需要设置 type 为构造函数，枚举，或者 cc.Integer，cc.Float，cc.Boolean 和 cc.String。 1234567891011properties: &#123; names: &#123; default: [], type: [cc.String] // 用 type 指定数组的每个元素都是字符串类型 &#125;, enemies: &#123; default: [], type: [cc.Node] // type 同样写成数组，提高代码可读性 &#125;,&#125; get/set 声明在属性中设置了 get 或 set 以后，访问属性的时候，就能触发预定义的 get 或 set 方法。定义方法如下： 12345678910properties: &#123; width: &#123; get: function () &#123; return this._width; &#125;, set: function (value) &#123; this._width = value; &#125; &#125;&#125; 判断类型123456var Child = cc.Class(&#123; extends: Father&#125;);var child = new Child();cc.log(child instanceof Child); // truecc.log(child instanceof Father); // true 12345var Father = cc.Class();var Child = cc.Class(&#123; extends: Father&#125;);cc.log(cc.isChildClassOf(child, Father)); // true 重写123456789101112131415var Father = cc.Class(&#123; getName: function() &#123; return \"father\"; &#125;&#125;);var Child = cc.Class(&#123; extends: Father, getName: function() &#123; return \"child\" + this._super(); &#125;&#125;);var obj = new Child():cc.log(obj.getName); // childfather","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"7、cocos creator 之预制","slug":"Cocos Creator/7、cocos creator 之预制","date":"2019-01-02T07:00:00.000Z","updated":"2020-08-07T14:10:11.687Z","comments":true,"path":"2019/01/02/Cocos Creator/7、cocos creator 之预制/","link":"","permalink":"https://www.zackaddy.xin/2019/01/02/Cocos Creator/7、cocos creator 之预制/","excerpt":"","text":"cocos creator 之预制简介预制( Prefab)是 Cocos Creator提出的新概念,针对 CocosCreator可视化编程,以及节点与组件等依附的复杂关系,提供的一种保存与复用方式。 预制必须是一个节点和其子节点构成的。 预制体( Prefabs)这个概念是引自Unity引擎的,它是一种可以被重复使用的游戏对象。例如射击游戏中的子弹都来自于同一个子弹模型,当发射子弹时,就创建一个子弹预制体。 也就是说,如果创建一个可以重复使用的对象,那么就该用到预制体了 创建预制 创建一个自定义节点,把需要大量复用的内容全部做成该节点的子节点。 将层级管理器中该节点拖曳至资源管理器內assets文件夹下形成预制资源 预制已形成,在创建好预制后,创建的节点已经可以删除了。 预制实例化预制的实例化是预制的主要使用方式,实例化方式分为编辑器方式与代码方式两种。 编辑器方式是将资源管理器中的预制拖曳到层级管理器中或场景编辑器中。 所有预制实例化的节点,称为预制节点。预制节点拥有普通节点所有的特性与功能。 此外,预制节点还保持着和预制的关联,可以通过预制节点修改预制也可以将预制节点还原至预制的初始状态。 修改预制预制一旦创建,就不能直接修改其内容,只能通过预制节点修改 步骤如下 给需要修改的预制实例化一个预制节点; 对预制节点按需求进行修改; 修改完成后,单击预制节点属性检查器中的保存 预制修改完成后,修改预制所实例化的预制节点就没有用了,可以随时删除。 还原预制预制的使用除了实例化外,还有很多情况需要实例化后再做属性调整。当调整至不理想状态,希望还原至预制原样的情况时,选中需要还原的预制节点,在属性检査器中选择“回退”按钮。 预制的自动同步每个场景中的预制实例都可以单独选择要自动同步还是手动同步。设为手动同步时,当预制对应的原始资源被修改后,场景中的预制实例不会同步刷新,只有在用户手动还原预制时才会刷新。设为自动同步时,该预制实例会自动和原始资源保持同步。 设置方式为选择场景中的预制实例,在属性检查器上单击左上角锁链图标。 一个预制在每个场景中的所有实例具有统一的同步属性。预制根节点自身的name、 active、 position和 rotation属性不会被自动步","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"6、cocos creator 之标签组件 label","slug":"Cocos Creator/6、cocos creator 之标签组件 label","date":"2019-01-02T06:00:00.000Z","updated":"2020-08-07T14:10:11.687Z","comments":true,"path":"2019/01/02/Cocos Creator/6、cocos creator 之标签组件 label/","link":"","permalink":"https://www.zackaddy.xin/2019/01/02/Cocos Creator/6、cocos creator 之标签组件 label/","excerpt":"","text":"cocos creator 之标签组件 label简介标签(Label)是Cocos系列的核心概念之一,是 Cocos Creator最常用文字显示的组件。 Cocos Creator中几乎所有的游戏内文字显示都是通过标签组件实现的 创建标签节点在层级管理器中“右键”→“创建节点“→”创建渲染节点“→“Label(文字)”新建一个精灵节点。 标签组件主要属性 属性 功能说明 String 渲染文字内容 Horizontal Align 文本的水平对齐方式。可选值有左对齐(LEFT)、居中对齐CENTER)和右对齐(RGHT)Vertical Align文本的垂直对齐方式。可选值有顶对齐(ToP)、中对齐(CENTER)和底对齐( BOTTOM) Font Size 字号 Line Height 文本的行高 Overflow 溢出处理办法,当文字超出节点尺寸时的处理办法。目前支持溢出不显示(CLAMP)、自动缩放文字( SHRINK)和自适应高度(RESIZE HEIGHT) Enable Wrap Text 是否开启文本换行 SpacingX 文本字符横向间距(只有BMFont字体可以设置) Font 字体文件,如果使用系统字体,则此属性可以为空 Use System Font 是否使用系统字体 简单使用在标签组件“ String”属性中输入希望显示的文字(注意换行)。之后调整节点尺寸、字号、字体高度、排版等内容至满意程度。 最后通过调整节点的位置、旋转和缩放等将标签节点布置到场景中。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"5、cocos creator 之精灵组件 sprite","slug":"Cocos Creator/5、cocos creator 之精灵组件 sprite","date":"2019-01-02T05:00:00.000Z","updated":"2020-08-07T14:10:11.687Z","comments":true,"path":"2019/01/02/Cocos Creator/5、cocos creator 之精灵组件 sprite/","link":"","permalink":"https://www.zackaddy.xin/2019/01/02/Cocos Creator/5、cocos creator 之精灵组件 sprite/","excerpt":"","text":"cocos creator 之精灵组件 sprite精灵( Sprite)是 Cocos系列的核心概念之一,是 Cocos Creator最常用的显示图像(图片)的组件。 创建精灵节点在层级管理器中“右键创建节点”→“创建渲染节点”→Sprite(精灵)”新建一个精灵节点。 精灵组件主要属性 属性 功能说明 Atlas 精灵显示图片资源所属的Atas图集资源 Sprite Frame 渲染精灵使用的 Sprite Frame图片资源 Type 渲染模式,包括普通( Simple)、九宫格( (Sliced)、平铺(Tiled）和填充(Filed)渲染4种模式。主要针对节点尺寸和图片资源尺寸不符时如何处理 Size Mode 指定精灵的尺寸, Trimmed 会使用原始图片资源裁剪透明外边后的尺寸;Raw会使用原始图片未经裁剪的尺寸;当用户手动修改过尺寸属性后, Size mode会被自动设置为Custom,除非再次指定为前两种尺寸 Trim 节点约束框是否包含图中透明部分 Src Blend Factor 混合模式显示两张图时,原图片的取值模式 Dst Bend Factor 背景图像混合模式,和上面的属性共同作用,可以将前景和背景精灵用不同的方式混合渲染,效果预览可以参考glBlendFunc Tool 渲染模式精灵中使用的渲染模式有以下4种。 普通模式( Simple):最常用的渲染模式,适用于不需要调整大小的图片;当调整尺寸时会拉伸图片。 九宫格模式( Sliced:适用于需要无限拉伸的U,常用于底框、背景、按钮底图等。 平铺模式(Tiled):一种像是Windows桌面平铺效果的渲染方式当尺寸大于图片原有尺寸时会将图片不断重复渲染。适用于背景、底纹等不断重复的图片。 填充模式(Filled):可按照多种方式、不同进度填充渲染图片,常见的填充方式有横向填充( HORIZONTAL)、纵向填充( VERTICAL)和扇形填充( RADIAL)。适用于各种进度条、进度表示等。 简单使用通过从资源管理器中拖曳素材图片类型资源( Cocos支持jgp.bmp、png等格式图片资源)到组件“ Sprite Frame”属性引用中,就可以使用精灵节点渲染指定图片。 之后调整节点尺寸与渲染模式、填充模式将图片的指定部分渲染出来(不一定渲染整张图片)。 最后通过调整节点的位置、旋转和缩放等将精灵节点布置到场景中","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"4、cocos creator 之节点与渲染","slug":"Cocos Creator/4、cocos creator 之节点与渲染","date":"2019-01-01T08:00:00.000Z","updated":"2020-08-07T14:10:11.686Z","comments":true,"path":"2019/01/01/Cocos Creator/4、cocos creator 之节点与渲染/","link":"","permalink":"https://www.zackaddy.xin/2019/01/01/Cocos Creator/4、cocos creator 之节点与渲染/","excerpt":"","text":"cocos creator 之节点与渲染简介上文中简单提及了遮挡关系,2D世界不存在近大远小,但是需要明确其遮挡关系。 Cocos Creator通过渲染顺序来处理遮挡问题后渲染的图像会挡住先渲染的图像。 同级别遮挡同级别节点的绘制顺序是由上至下的,即下面的节点内容会遮挡上面的节点内容。 不同级别遮挡这里的不同级别,指的是不同父节点。在子节点和父节点中,子节点会遮挡父节点。而在不同级别的各节点,遵照子节点遮挡父节点,同级别节点下方节点遮挡上方节点并且遮挡上方节点拥有的所有子节点规则进行遮挡。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"3、cocos creator 之坐标系","slug":"Cocos Creator/3、cocos creator 之坐标系","date":"2019-01-01T07:00:00.000Z","updated":"2020-08-07T14:10:11.684Z","comments":true,"path":"2019/01/01/Cocos Creator/3、cocos creator 之坐标系/","link":"","permalink":"https://www.zackaddy.xin/2019/01/01/Cocos Creator/3、cocos creator 之坐标系/","excerpt":"","text":"cocos creator 之坐标系笛卡尔坐标系x 向右，y 向上，z 向外，creator使用的坐标系就是笛卡尔右手系。 世界坐标系与本地坐标系通常的开发者提到的位置或坐标有两种意义,一是在世界坐标系内的世界坐标或是在本地坐标系内的本地坐标。 世界坐标系( World coordinate):也叫绝对坐标系,指的是相对上述 Cocos坐标系的坐标,即以屏幕左下角为原点,无旋转、无缩放的坐标系。 本地坐标系( Local coordinate):也叫相对坐标系,指的是相对父节点的坐标系,即以父节点的锚点( Ancho)为原点,父节点的旋转为方向,父节点缩放为缩放的坐标系。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"2、cocos creator 之节点与子节点","slug":"Cocos Creator/2、cocos creator 之节点与子节点","date":"2019-01-01T06:00:00.000Z","updated":"2020-08-07T14:10:11.681Z","comments":true,"path":"2019/01/01/Cocos Creator/2、cocos creator 之节点与子节点/","link":"","permalink":"https://www.zackaddy.xin/2019/01/01/Cocos Creator/2、cocos creator 之节点与子节点/","excerpt":"","text":"cocos creator 之节点与子节点简介 节点(Node)是渲染的必要组成部分。所有需要在屏幕中显示的内容都必须是节点或者依附于节点上。节点负责控制显示内容的位置、旋转、缩放、颜色等属性。 锚点锚点( Ancho):锚点是节点位置的参照点,也是自身旋转、缩放的基准点。同时锚点也是该节点子节点的坐标原点。Ⅹ和Y两个成员描述横向和纵向的锚点位置。取(0,0)即在节点的左下角,取(1,1)即在节点的右上角,默认为(0.5,0.5)即节点的正中央。 尺寸尺寸(size):本节点的大小,对节点自身没有太多影响,但是会影响节点上的组件。具体参照各组件,比如常见的精灵组件会根据节点尺寸对渲染图片进行缩放。 颜色颜色(color):节点颜色,影响本节点及其所属组件的渲染,以及其子节点和其所属组件的渲染。在不透明的情况下,设置节点颜色会直接叠加到节点与所属组件的渲染效果上,并影响其子节点 透明度透明度( Opacity):0-255,0代表完全透明,255代表完全不透明,128则大致表示半透明。会影响本节点及其所属组件的渲染,以及其子节点和其所属组件的渲染 倾斜值倾斜值(Skew):或者叫倾斜度数,斜向拉伸,0的效果和180的效果一致 分组分组( Group):任意字符串,不可重复。节点分组是为了做属性判断。比如需求是“友方子弹”分组只和“敌人”做碰撞判断,而不和“友方”做碰撞判断;那么至少需要拥有“敌人”和“友方”两个分组,并把节点正确的配置分组。 组件组件是 CocosCreator的主体构成,渲染(显示内容)、逻辑、用户输入反馈、计时器等几个方面均是由组件完成的。根据 Cocos Creator的总体架构,组件和节点配合完成游戏所需内容 所有的组件都是脚本(代码)。一部分是 Cocos creator提供的源码在 Cocos creator安装目录中,在编辑器中无法直接查看;一些是用户自定义脚本,可在资源管理器中找到对应的脚本文件。组件脚本需要添加到节点上才能执行。 子节点每个节点都有自己的父节点(parent),父节点与子节点(child)以一对多的方式形成树形结构。最根部的节点以根节点为自己的父节点。通常用户自定义节点都会是画布的子节点或者更深层子节点。 子节点的节点属性受父节点的节点属性影响:位置、旋转和缩放均是相对父节点的锚点为原点的,父节点旋转为正方向,父节点缩放为尺度的坐标系下相对值。 颜色与透明度等属性则是基于父节点的颜色与透明度进行叠加: 相乘叠加,比如子节点的透明度为128约半透明(05),其父节点透明度同样为128约半透明(05),则子节点的显示效果透明度约为(255×0.5×0.5)。","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"1、cocos creator 之项目结构","slug":"Cocos Creator/1、cocos creator 之项目结构","date":"2019-01-01T05:00:00.000Z","updated":"2020-08-07T14:10:11.678Z","comments":true,"path":"2019/01/01/Cocos Creator/1、cocos creator 之项目结构/","link":"","permalink":"https://www.zackaddy.xin/2019/01/01/Cocos Creator/1、cocos creator 之项目结构/","excerpt":"","text":"cocos creator 之项目结构123456|---assets|---library|---local|---setting|---temp|---project.json assets assets（资源文件夹）放置游戏中所有本地资源、脚本和第三方资源 assets每个文件导入后会生成一个相同名的.meta文件，用于存储该文件作为资源导入后的信息与其它资源的关联 其它游戏运行不需要的文件，可以选择放在assets外面来管理 library library（资源库）是将assets中的资源导入后生成的，在这里的文件结构和资源格式将被处理成最终游戏发布时需要的形式。 如果使用版本控制系统管理项目，这个文件夹不需要进入版本控制的 当library丢失或损坏时，只要删除整个library文件夹再打开项目，就回重新生成 local local（本地设置）文件夹中包含该项目的本地设置，包括编辑器面板布局、窗口大小和位置等信息。 不需要关心这里的内容。只要按照习惯设置编辑器的布局，这些就回自动保存在该文件夹中。 与library一样，local也不需要进入版本控制。 settings settings（项目设置）里保存项目相关的设置，如“构建发布”菜单里的包名、场景和平台选择等。 temp temp（临时文件夹）中包含被编辑器打开在本地产生的临时文件 一般temp也不需要进入版本控制。 project.json project.json文件和assets文件夹一起，作为验证cocos creator项目合法性的标志。 只有包括这两个内容的文件夹才能作为cocos creator项目打开 project.json目前只用来规定当前使用的引擎类型和插件存储位置,不需要用户关心其内容","categories":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}],"tags":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/tags/Cocos-Creator/"}],"keywords":[{"name":"Cocos Creator","slug":"Cocos-Creator","permalink":"https://www.zackaddy.xin/categories/Cocos-Creator/"}]},{"title":"4.0、代码重构 之何时重构","slug":"代码重构/4.0、代码重构 之何时重构","date":"2018-08-15T07:46:12.000Z","updated":"2020-08-07T14:10:11.895Z","comments":true,"path":"2018/08/15/代码重构/4.0、代码重构 之何时重构/","link":"","permalink":"https://www.zackaddy.xin/2018/08/15/代码重构/4.0、代码重构 之何时重构/","excerpt":"","text":"何时重构 遵循”三次法则”，事不过三，三则重构。第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。 预备性重构：让添加新功能更容易 帮助理解的重构：使代码更易懂 捡垃圾式重构 有计划的重构和见机行事的重构 长期重构 复审代码时重构 预备性重构你可能会遇到在添加新功能时，有个函数已经提供了你需要的大部分功能，但是有几处与你需要的略有冲突。如果不做预备性重构，你可能会把这个函数复制一份改改，将来需要做修改的话就需要修改两处，而且修改时会有概率造成bug。 帮助理解的重构 你需要先理解一段代码，然后才能着手修改 添加可以帮助理解的注释 给一两个变量改名，让它们更清楚的表达意图，以方便理解 将一个长函数拆成几个小函数。 让代码变得更清晰一些时，你就会看见之前看不见的设计问题，如果不做前面的重构，你可能永远看不见这些设计问题。 捡垃圾式重构 你的代码经过之处至少比你写之前要干净 在添加新的功能下，你已经阅读相关代码处，发现有几处不够好。 如：两个几乎相同的函数；逻辑不必要的迂回复杂； 你不想耽误本周工作添加新功能的进度，这就可以先把这些需要改的地方记下来。 不过，添加新功能时稍微花功夫做一点清理，这样，每次添加功能做清理都会让代码更干净点，积少成多。即便每次清理并不完整，代码也不会破坏。 有计划的重构和见机行事的重构 有计划的重构：预备性重构、帮助理解的重构、捡垃圾式重构。 见机行事的重构：绝大多数的重构都是在做其它事情的时候发生，不会专门安排时间进行重构。 长期重构大多数重构可以在几分钟，最多几小时内完成。 有一些大型的重构需要花费上周的时间，这种方式是不妥的。你可以在几周或上月内逐步解决这个问题，这是一个有效的策略。这有一个好处，每次改动一小点，整个系统仍然正常工作。 复审代码时重构 一些公司会做常规的code review至于什么是code review会在后面的文章详细说明。 何时不应该重构一段丑陋的代码隐藏在一个API下，是可以容忍它继续保持丑陋。只有当需要理解其工作原理时，对其进行重构才有价值。如果重写比重构更容易，那就别重构了。","categories":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}],"tags":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/tags/代码重构/"}],"keywords":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}]},{"title":"3.0、代码重构 之为何重构","slug":"代码重构/3.0、代码重构 之为何重构","date":"2018-08-13T21:10:23.000Z","updated":"2020-08-07T14:10:11.895Z","comments":true,"path":"2018/08/14/代码重构/3.0、代码重构 之为何重构/","link":"","permalink":"https://www.zackaddy.xin/2018/08/14/代码重构/3.0、代码重构 之为何重构/","excerpt":"","text":"为何重构 如果没有重构，程序内部设计会逐渐腐败，程序员为了短期目的而修改代码时，经常没有完全理解架构的整体设计，代码逐渐失去了自己的结构。 重构使代码更容易理解（你愿意花费一周时间修改某段代码吗？？？） 重构的过程中对代码的理解可以帮助你找到bug 重构可以提高添加新功能的开发速度（你想通过细致的考古工作才能弄懂一段代码的含义，然后补丁+补丁吗？）","categories":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}],"tags":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/tags/代码重构/"}],"keywords":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}]},{"title":"2.0、代码重构 之新功能与重构","slug":"代码重构/2.0、代码重构 之新功能与重构","date":"2018-08-13T18:28:46.000Z","updated":"2020-08-07T14:10:11.895Z","comments":true,"path":"2018/08/14/代码重构/2.0、代码重构 之新功能与重构/","link":"","permalink":"https://www.zackaddy.xin/2018/08/14/代码重构/2.0、代码重构 之新功能与重构/","excerpt":"","text":"新功能与重构 Kent Beck提出”两顶帽子”的比喻。 重构时要明确两种不同的行为 添加新功能 重构 添加新功能 添加新功能时不应该修改既有代码，只管添加新功能 通过添加测试让测试正常运行 可以衡量自己的工作进度 重构 重构时不能再添加新功能，只管调整代码结构 重构时不应该添加任何测试（除非是之前遗漏的东西），只有在必要（用以处理接口变化）时才修改测试 ++这里的“任何测试”是非重构代码段的测试++ ==在编写代码时会遇到一会重构一会添加新功能。== ==这可能是在几分钟内发生的事。== ==这时无论怎样切换都要记住，重构时不能添加新功能，添加新功能不能重构。==","categories":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}],"tags":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/tags/代码重构/"}],"keywords":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}]},{"title":"1.0、代码重构 之什么是重构","slug":"代码重构/1.0、代码重构 之什么是重构","date":"2018-08-12T22:53:49.000Z","updated":"2020-08-07T14:10:11.894Z","comments":true,"path":"2018/08/13/代码重构/1.0、代码重构 之什么是重构/","link":"","permalink":"https://www.zackaddy.xin/2018/08/13/代码重构/1.0、代码重构 之什么是重构/","excerpt":"","text":"什么是重构 重构分为名词与动词 名词：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本 动词：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构 可观察行为 经过重构之后的代码所做的事应该与重构前大致一样。 “大致一样”是因为重构后的代码不一定与重构前的行为完全一致。如： 可能会改变函数调用栈 可能会改变函数声明 等等 重构与性能优化 都需要修改代码 两者不会改变程序整体功能 重构是为了让代码容易理解，易于修改，可能会使程序运行更快或更慢 性能优化只需关心让程序运行更快，可能会让代码更难理解和维护","categories":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}],"tags":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/tags/代码重构/"}],"keywords":[{"name":"代码重构","slug":"代码重构","permalink":"https://www.zackaddy.xin/categories/代码重构/"}]},{"title":"44、Flutter Widget 之 Expand","slug":"Flutter Widget/44、Flutter Widget 之 Expand","date":"2018-03-16T19:05:24.000Z","updated":"2020-08-07T14:10:11.739Z","comments":true,"path":"2018/03/17/Flutter Widget/44、Flutter Widget 之 Expand/","link":"","permalink":"https://www.zackaddy.xin/2018/03/17/Flutter Widget/44、Flutter Widget 之 Expand/","excerpt":"","text":"简介 一个用于撑开 flex 布局子组件空间的widget 用于在Row、Column、Flex子组件内 会沾满所有可用空间 Expanded继承了Flexible 基本用法 以下示例对比使用 123- 使用Expanded 可以使 Row、Column或者Flex的子项能够填充主轴的全部可用空间- 如果存在多个子项，则根据 flex 属性来划分可用空间- Expanded widget 必须是Row,Column或者Flex的后代 import ‘package:flutter/material.dart’; class ExpandedDemo extends StatelessWidget { final TextStyle txtColor = TextStyle(color: Colors.white); @override Widget build(BuildContext context) { return Column( children: [ Text(‘Expanded’), Row(children: [ RaisedButton( onPressed: () { print(‘点击红色按钮事件’); }, color: const Color(0xffcc0000), child: Text(‘红色按钮’,style: txtColor,), ), Expanded( flex: 1,//flex用来设置当前可用空间的占优比 child: RaisedButton( onPressed: () { print(‘点击黄色按钮事件’); }, color: const Color(0xfff1c232), child: Text(‘黄色按钮’,style: txtColor,), ), ), RaisedButton( onPressed: () { print(‘点击粉色按钮事件’); }, color: const Color(0xffea9999), child: Text(‘粉色按钮’,style: txtColor,), ), ]), Text(‘Flexible’), Row(children: [ RaisedButton( onPressed: () { print(‘点击红色按钮事件’); }, color: const Color(0xffcc0000), child: Text(‘红色按钮’,style: txtColor,), ), Flexible( fit: FlexFit.tight, flex: 1, child: RaisedButton( onPressed: () { print(‘点击黄色按钮事件’); }, color: const Color(0xfff1c232), child: Text(‘黄色按钮’,style: txtColor,), ), ), RaisedButton( onPressed: () { print(‘点击粉色按钮事件’); }, color: const Color(0xffea9999), child: Text(‘粉色按钮’,style: txtColor,), ), ]), ], ); }}```","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"43、Flutter Widget 之 Align","slug":"Flutter Widget/43、Flutter Widget 之 Align","date":"2018-03-16T00:16:34.000Z","updated":"2020-08-07T14:10:11.739Z","comments":true,"path":"2018/03/16/Flutter Widget/43、Flutter Widget 之 Align/","link":"","permalink":"https://www.zackaddy.xin/2018/03/16/Flutter Widget/43、Flutter Widget 之 Align/","excerpt":"","text":"简介 Align控件即对齐控件，能将子控件所指定方式对齐，并根据子控件的大小调整自己的大小。 根据自己需求，进行控件对齐基本用法 alignment → AlignmentGeometry 要对齐右下方的框，那么对这个框对要求会比对子控件更加严肃的约束，使用：Alignment.bottomRight 同理：Alignment.center，Alignment.bottomLeft，Alignment.topLeft等 widthFactor / heightFactor → double 如果widthFactor / heightFactor 为空，并且外部无任何约束，child控件大小默认，那么这个控件将根据自身尺寸最大化 如果widthFactor / heightFactor 不为空，并且外部无约束，align将匹配对应的child尺寸 ex：widthFactor/ heightFactor 为2.0；那么widget的宽高为child宽高的两倍 如果widthFactor / heightFactor 为空，并且外部无约束，child控件将会设置自身大小 1234567891011121314151617181920212223242526272829303132class AlignFactor extends StatelessWidget &#123; final Alignment status; final double wFactor; final double hFactor; final String dec; const AlignFactor( this.status, this.wFactor, this.hFactor, this.dec) : super(); @override Widget build(BuildContext context) &#123; return Container( margin: EdgeInsets.only(top: 10.0, bottom: 10.0), color: Color(0xffd81b60), child: Align( alignment: status, widthFactor: wFactor, heightFactor: hFactor, child: Container( color: Color(0xfff06292), width: 100.0, height: 50.0, child: Text( dec, style: TextStyle(color: Color(0xffffffff)), ), ), ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"42、Flutter Widget 之 IndexStack","slug":"Flutter Widget/42、Flutter Widget 之 IndexStack","date":"2018-03-15T03:49:11.000Z","updated":"2020-08-07T14:10:11.738Z","comments":true,"path":"2018/03/15/Flutter Widget/42、Flutter Widget 之 IndexStack/","link":"","permalink":"https://www.zackaddy.xin/2018/03/15/Flutter Widget/42、Flutter Widget 之 IndexStack/","excerpt":"","text":"简介 显示一个子项列表的单个子项。 只显示指定位置的widget，其他的位置的widget不会显示，所以indexedStack的尺寸永远和最大的子节点一样。 显示的子项widget是给到了具体的索引选择出来的widget 如果value 为null，将不显示任何内容 基本用法 index → int 控制显示child的索引 ex:可以通过多个图片转化表示状态（正确，错误，警告等）。 123456789101112131415161718192021222324252627282930313233343536373839class StackIndex extends StatelessWidget &#123; final int currIndex; const StackIndex(this.currIndex) : super(); @override Widget build(BuildContext context) &#123; return IndexedStack( index: currIndex, children: [ Icon( Icons.update, size: 40.0, color: Color(0xffe91e63), ), Icon( Icons.access_alarm, size: 40.0, color: Color(0xffe91e63), ), Icon( Icons.add_alarm, size: 40.0, color: Color(0xffe91e63), ), Icon( Icons.access_time, size: 40.0, color: Color(0xffe91e63), ), Icon( Icons.alarm_off, size: 40.0, color: Color(0xffe91e63), ), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"41、Flutter Widget 之 Stack","slug":"Flutter Widget/41、Flutter Widget 之 Stack","date":"2018-03-14T01:13:59.000Z","updated":"2020-08-07T14:10:11.738Z","comments":true,"path":"2018/03/14/Flutter Widget/41、Flutter Widget 之 Stack/","link":"","permalink":"https://www.zackaddy.xin/2018/03/14/Flutter Widget/41、Flutter Widget 之 Stack/","excerpt":"","text":"简介 用于将多个childs相对于其框的边缘定位，多用于以简单方式重叠children 当第一个child置于底部时，堆栈按顺序绘制其子项。如果更改子项绘制顺序，可以使用新顺序重新建立堆栈 注意：stack的每一个子节点都已定位或未定位，定位子项必须至少一个非null属性的定位。 基本用法 1.alignment → AlignmentGeometry 对齐方式，默认是右上角,详情请点击Layout-row页面，类似 多个positioned叠加图层，Alignment.center事例 fit → StackFit loose:放开了子节点宽高的约束，可以让子节点从0到最大尺寸 expand: 子节点最大可能的占用空间，允许最大大小 passthrough：不改变子节点约束 textDirection → TextDirection 文本方向 overflow → Overflow 超过的部分是否裁剪掉 overflow: Overflow.clip/visible 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';class StackDefault extends StatelessWidget &#123; const StackDefault() : super(); @override Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ Stack( //fit :定义如何设置non-positioned节点尺寸 fit: StackFit.loose, overflow: Overflow.clip, textDirection: TextDirection.ltr, alignment: Alignment.center, children: [ Container( color: Color(0xfff48fb1), width: 100.0, height: 50.0, ), Text(\"stack demo\", textDirection: TextDirection.ltr, style: TextStyle( fontSize: 20.0, fontWeight: FontWeight.bold, letterSpacing: 5.0, color: Colors.white)), ], ), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"40、Flutter Widget 之 Row","slug":"Flutter Widget/40、Flutter Widget 之 Row","date":"2018-03-12T17:54:34.000Z","updated":"2020-08-07T14:10:11.737Z","comments":true,"path":"2018/03/13/Flutter Widget/40、Flutter Widget 之 Row/","link":"","permalink":"https://www.zackaddy.xin/2018/03/13/Flutter Widget/40、Flutter Widget 之 Row/","excerpt":"","text":"简介 Row 是一个将其child显示在水平数组的widget 将其child填充可用的横向水平空间，一行高度是childs的最大高度（即：总是满足传入的垂直约束） 如果你只有一个child，只需要考虑使用对其或者中间位置，如果多个child，注意扩展水平空间(Expanded)，可以将child封装在一个扩展部件里面 当我们看到行有黄色和黑色条纹警告时候，说明行已经溢出，当行溢出，行之间空间将没有任何空间可供扩展。 基本用法 水平布局，设置位置对齐方式 mainAxisSize 属性 一行的高度是有mainAxisSize属性控制，默认是max mainAxisAlignment属性 将children放置在主轴某位置 CrossAxisAlignment 属性 crossAxisAlignment: crossAxisAlignment.center/end/start, 即，根据设定的位置交叉对齐 12345678910111213141516171819202122232425262728class RowExpanded extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return Row( children: &lt;Widget&gt;[ ////填充数据 Expanded(child: new RaisedButton( onPressed: ()&#123; &#125;, color: Color(0xfffce4ec), child:new Text('flutter',style: TextStyle(color: Colors.white),) ),), Expanded(child: new RaisedButton( onPressed: ()&#123; &#125;, color: Color(0xfff8bbd0), child:new Text('Expanded',style: TextStyle(color: Colors.white),) ),), Expanded(child: new RaisedButton( onPressed: ()&#123; &#125;, color: Color(0xfff48fb1), child:new Text('flutter',style: TextStyle(color: Colors.white),) ),), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"39、Flutter Widget 之 Column","slug":"Flutter Widget/39、Flutter Widget 之 Column","date":"2018-03-12T01:03:08.000Z","updated":"2020-08-07T14:10:11.737Z","comments":true,"path":"2018/03/12/Flutter Widget/39、Flutter Widget 之 Column/","link":"","permalink":"https://www.zackaddy.xin/2018/03/12/Flutter Widget/39、Flutter Widget 之 Column/","excerpt":"","text":"简介 Column 是一个将其child显示在竖直方向数组的widget，于Row相对 将其child填充可用的竖直水平空间，默认竖直空间无法滚动，如有很多children，竖直空间饱和无法放置，你可以使用listView搭配使用 如果你只有一个child，只需要使用对齐（Align）或者居中（Center）来展示child 基本用法 竖直布局，设置位置对齐方式 mainAxisSize 属性 一行的高度是有mainAxisSize属性控制，默认是max mainAxisAlignment属性 将children放置在主轴某位置 CrossAxisAlignment 属性 crossAxisAlignment: crossAxisAlignment.center/end/start, 即，根据设定的位置交叉对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import 'package:flutter/widgets.dart';class ColumnDefault extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Column( // - MainAxisAlignment.spaceEvenly/spaceAround/spaceBetween, // - spaceEvenly：将主轴方向空白区域均分，使得children之间空间相等，包括首尾childre // - spaceAround：将主轴方向空白区域均分，使得children之间空间相等，但是首尾childre的空白部分为一半 // - spaceBetween：将主轴方向空白区域均分，使得children之间空间相等，但是首尾childre靠近收尾，没有空细逢 // - MainAxisAlignment.start/end/center, // - start：将children放置在主轴起点方向 // - end：将children放置在主轴末尾方向 // - center：将children放置在主轴中间方向 mainAxisAlignment: MainAxisAlignment.center, // &gt; mainAxisSize 属性 // - 一行的高度是有mainAxisSize属性控制，默认是max // - mainAxisSize: MainAxisSize.min,一行的宽度是child传入的约束 // - mainAxisSize: MainAxisSize.max,一行的宽度的最大宽度是传入的约束。 // &gt; mainAxisAlignment属性 // mainAxisSize: MainAxisSize.max, //- crossAxisAlignment: CrossAxisAlignment.center/end/start, // - 即，根据设定的位置交叉对齐 // - center/end/start: children在交叉轴上居中/末端/起点 对齐展示 // - stretch：让children填满交叉轴方向 // - baseline：在交叉轴方向，使得于这个baseline对齐，如果主轴是垂直的，那么这个值是当作开始 children: &lt;Widget&gt;[ Container( color: Color(0xfffce4ec), width: 90.0, height: 50.0, ), Container( color: Color(0xfff8bbd0), width: 90.0, height: 50.0, ), Container( color: Color(0xfff48fb1), width: 90.0, height: 50.0, ), Container( color: Color(0xfff06292), width: 90.0, height: 50.0, ), Text('We move under cover and we move as one'), Text('Through the night, we have one shot to live another day'), Text('We cannot let a stray gunshot give us away'), Text('We will fight up close, seize the moment and stay in it'), Text('It’s either that or meet the business end of a bayonet'), Text('The code word is ‘Rochambeau,’ dig me?'), Text('Rochambeau!', style: DefaultTextStyle.of(context).style.apply(fontSizeFactor: 1.0)), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"38、Flutter Widget 之 Center","slug":"Flutter Widget/38、Flutter Widget 之 Center","date":"2018-03-10T21:21:40.000Z","updated":"2020-08-07T14:10:11.736Z","comments":true,"path":"2018/03/11/Flutter Widget/38、Flutter Widget 之 Center/","link":"","permalink":"https://www.zackaddy.xin/2018/03/11/Flutter Widget/38、Flutter Widget 之 Center/","excerpt":"","text":"简介 一个将child 放置于中心 如果它的尺寸受到外界约束，并且widthFactor和heightFactor 为null，则widget将会尽可能的大。 如果它的尺寸不受外界约束，并且相应的大小为null，则widget将会匹配child widget的大小 如果相应尺寸不为null，则widget的相应尺寸将是child 尺寸和尺寸因子的乘积（例如：widthFactor是2.0,那么widget的宽度始终是其child widget宽度的2倍） 基本用法 widthFacto/heightFactor 非null，将其宽/高度设置为子宽/高度乘以此系数 如果widthFactor是2.0，那么widget的宽度将始终是其子宽度的两倍。 如果heightFactor是2.0，那么widget的高度将始终是其子高度的两倍。 1234567891011121314class CenterDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Center( widthFactor: 2.0, heightFactor: 2.0, child: Container( color: Color(0xfff48fb1), width: 90.0, height: 50.0, ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"37、Flutter Widget 之 Container","slug":"Flutter Widget/37、Flutter Widget 之 Container","date":"2018-03-09T22:02:07.000Z","updated":"2020-08-07T14:10:11.736Z","comments":true,"path":"2018/03/10/Flutter Widget/37、Flutter Widget 之 Container/","link":"","permalink":"https://www.zackaddy.xin/2018/03/10/Flutter Widget/37、Flutter Widget 之 Container/","excerpt":"","text":"简介 一个常用的widget，它结合了常见的绘画，定位和大小调整 该容器首先让child填充绘制，然后再将其他的约束应用于填充范围。 在绘画过程中，容器先应用给定的转换，再绘制装饰以填充的范围，然后绘制child，最后绘制前景，同时填充需要填充的范围 没有child的容器将尽可能的大，除非传入的约束是无限制的。child的大小会被width，height等约束覆盖。 基本用法 Container 可以结合多种其他widget，每个widget都有自己的布局行为，因此Container的布局行为有点复杂。 简单说，就是如果窗口小部件没有子窗口，没有height，没有width，没有约束，并且父窗口提供无限制约束，则Container会尝试尽可能小。 1234567891011121314151617181920212223class ContainerDefault extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( height: Theme.of(context).textTheme.display1.fontSize * 1.1 + 200.0, padding: const EdgeInsets.all(8.0), color: Colors.teal.shade700, alignment: Alignment.center, child: Text('Hello World', style: Theme.of(context) .textTheme .display1 .copyWith(color: Colors.white)), foregroundDecoration: BoxDecoration( image: DecorationImage( image: NetworkImage('https://www.example.com/images/frame.png'), centerSlice: Rect.fromLTRB(270.0, 180.0, 1360.0, 730.0), ), ), transform: Matrix4.rotationZ(0.1), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"36、Flutter Widget 之 SliverPersistentHeader 吸附头部","slug":"Flutter Widget/36、Flutter Widget 之 SliverPersistentHeader 吸附头部","date":"2018-03-08T19:37:40.000Z","updated":"2020-08-07T14:10:11.736Z","comments":true,"path":"2018/03/09/Flutter Widget/36、Flutter Widget 之 SliverPersistentHeader 吸附头部/","link":"","permalink":"https://www.zackaddy.xin/2018/03/09/Flutter Widget/36、Flutter Widget 之 SliverPersistentHeader 吸附头部/","excerpt":"","text":"简介 滚动到viewport时吸附到顶部widget 使用12345678910SliverPersistentHeader( delegate: new DropdownSliverChildBuilderDelegate( builder: (BuildContext context) &#123; return new Container( color: Theme.of(context).scaffoldBackgroundColor, child: buildDropdownHeader(onTap: this._onTapHead)); &#125;), pinned: true, floating: true,), 详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/// A sliver whose size varies when the sliver is scrolled to the leading edge/// of the viewport.////// 当sliver滚动到viewport边缘缘时，位置变化的sliver。////// This is the layout primitive that [SliverAppBar] uses for its/// shrinking/growing effect.class SliverPersistentHeader extends StatelessWidget &#123; /// Creates a sliver that varies its size when it is scrolled to the start of /// a viewport. /// /// 创建一个在滚动到viewport开头时会改变其位置的sliver /// /// The [delegate], [pinned], and [floating] arguments must not be null. /// [delegate], [pinned], and [floating] 参数不能为null const SliverPersistentHeader(&#123; Key key, @required this.delegate, this.pinned = false, this.floating = false, &#125;) : assert(delegate != null), assert(pinned != null), assert(floating != null), super(key: key); /// sliver布局的配置 /// /// The delegate provides the following information: /// 提供以下委托信息 /// /// * The minimum and maximum dimensions of the sliver. /// * sliver的最小和最大尺寸。 /// /// * The builder for generating the widgets of the sliver. /// * 用于生成sliver widget的builder。 /// /// * The instructions for snapping the scroll offset, if [floating] is true. /// * 如果[floating]为真则捕捉滚动偏移 final SliverPersistentHeaderDelegate delegate; /// Whether to stick the header to the start of the viewport once it has /// reached its minimum size. /// /// If this is false, the header will continue scrolling off the screen after /// it has shrunk to its minimum extent. /// /// 当header到达视图顶部是否粘贴在顶部 /// /// 如果false，header将滚动到视图外 final bool pinned; /// Whether the header should immediately grow again if the user reverses /// scroll direction. /// /// If this is false, the header only grows again once the user reaches the /// part of the viewport that contains the sliver. /// /// The [delegate]'s [SliverPersistentHeaderDelegate.snapConfiguration] is /// ignored unless [floating] is true. /// /// 如果用户反转滚动方向，标题是否应立即再次增长。 /// 如果为false，则只有当用户到达包含条子的视口部分时，标题才会再次增长。 /// /// 如果为true，[delegate]的[SliverPersistentHeaderDelegate.snapConfiguration]被忽略 final bool floating; @override Widget build(BuildContext context) &#123; if (floating &amp;&amp; pinned) return _SliverFloatingPinnedPersistentHeader(delegate: delegate); if (pinned) return _SliverPinnedPersistentHeader(delegate: delegate); if (floating) return _SliverFloatingPersistentHeader(delegate: delegate); return _SliverScrollingPersistentHeader(delegate: delegate); &#125; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123; super.debugFillProperties(properties); properties.add(DiagnosticsProperty&lt;SliverPersistentHeaderDelegate&gt;('delegate', delegate)); final List&lt;String&gt; flags = &lt;String&gt;[]; if (pinned) flags.add('pinned'); if (floating) flags.add('floating'); if (flags.isEmpty) flags.add('normal'); properties.add(IterableProperty&lt;String&gt;('mode', flags)); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"35、Flutter Widget 之 Chipe 小贴片","slug":"Flutter Widget/35、Flutter Widget 之 Chipe 小贴片","date":"2018-03-08T02:41:25.000Z","updated":"2020-08-07T14:10:11.736Z","comments":true,"path":"2018/03/08/Flutter Widget/35、Flutter Widget 之 Chipe 小贴片/","link":"","permalink":"https://www.zackaddy.xin/2018/03/08/Flutter Widget/35、Flutter Widget 之 Chipe 小贴片/","excerpt":"","text":"简介 所有chip widget类型的基础，集合所有功能，我们通常不是直接使用它，而是根据自己需要选择， 比如： chip ,一个简单的芯片，只能显示信息，并被删除 inputChip,以紧凑的形式表现复杂的信息，例如：实体（人，地点，或者事物）或者会话文本 choiceChip,允许从一组选项中进行单一的选择 FilterChip,使用标签或描述作为过滤内容的方式 基本用法 inputChip可以通过设置进行选择onSelected，通过设置onDeleted可以删除，并且可以通过OnPressed表现按压效果 inputChip 有一个前导图标和尾随图标，填充颜色可以订制 inputChip 可以和其他UI元素搭配使用，比如：wrap,ListView(scrollDirection为Axis.horizo​​ntal) 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import 'package:flutter/material.dart';class ChipDemo extends StatefulWidget &#123; _ChipDemoState createState() =&gt; _ChipDemoState();&#125;class _ChipDemoState extends State&lt;ChipDemo&gt; &#123; String dec = '点击回收'; int count = 0; _modifty() &#123; setState(() &#123; dec = 'delete success: $count'; &#125;); &#125; @override Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ Container( child: Chip( padding: EdgeInsets.only( right: 100.0, ), //标签前面的小widget avatar: CircleAvatar( backgroundColor: Colors.red.shade200, child: Text( 'A', style: TextStyle(color: Colors.white), ), ), label: Text( 'pai mai ', style: TextStyle(color: Colors.white, fontSize: 18.0), ), backgroundColor: Colors.red.shade100, labelPadding: EdgeInsets.all(6.0), ), ), Container( height: 100.0, child: Chip( //头像 avatar: CircleAvatar( child: Icon( Icons.account_circle, color: Colors.red.shade200, ), backgroundColor: Colors.white, ), //设置widget背景颜色 backgroundColor: Colors.red.shade100, //剪辑窗口widget内容 // antiAlias:剪辑具有抗锯齿功能，它比antiAliasWithSaveLayer快得多，但比hardEdge慢。 //antiAliasWithSaveLayer:立即剪辑具有抗锯齿，并且可以分配屏幕外缓冲区，后续涂料都在该缓冲区完成，然后再进行修剪和合成 clipBehavior: Clip.antiAlias, //设置padding值 labelPadding: EdgeInsets.all(8.0), label: Text(dec), //设置onDeleted时候显示的图标 deleteIcon: Icon( Icons.delete, color: Colors.white, size: 20.0, ), onDeleted: () &#123; count++; _modifty(); &#125;, deleteButtonTooltipMessage: '删除', deleteIconColor: Colors.blueGrey.shade100, //将最小点击目标大小扩展到48*48px materialTapTargetSize: MaterialTapTargetSize.padded, padding: EdgeInsets.all(2.0), //修改字体格式 labelStyle: TextStyle(fontWeight: FontWeight.bold), // shape: _MyBorder(), ), ) ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"34、Flutter Widget 之 ExpansionPanel 可折叠面板","slug":"Flutter Widget/34、Flutter Widget 之 ExpansionPanel 可折叠面板","date":"2018-03-06T18:21:49.000Z","updated":"2020-08-07T14:10:11.735Z","comments":true,"path":"2018/03/07/Flutter Widget/34、Flutter Widget 之 ExpansionPanel 可折叠面板/","link":"","permalink":"https://www.zackaddy.xin/2018/03/07/Flutter Widget/34、Flutter Widget 之 ExpansionPanel 可折叠面板/","excerpt":"","text":"简介 扩展面板，包含一个标题和一个正文，可以展开或者折叠。面板展开，主体可见。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271import 'package:flutter/material.dart';@visibleForTestingenum Location &#123; Barbados, Bahamas, Bermuda&#125;typedef DemoItemBodyBuilder&lt;T&gt; = Widget Function(DemoItem&lt;T&gt; item);typedef ValueToString&lt;T&gt; = String Function(T value);class DualHeaderWithHint extends StatelessWidget &#123; const DualHeaderWithHint(&#123; this.name, this.value, this.hint, this.showHint &#125;); final String name; final String value; final String hint; final bool showHint; Widget _crossFade(Widget first, Widget second, bool isExpanded) &#123; return AnimatedCrossFade( firstChild: first, secondChild: second, firstCurve: const Interval(0.0, 0.6, curve: Curves.fastOutSlowIn), secondCurve: const Interval(0.4, 1.0, curve: Curves.fastOutSlowIn), sizeCurve: Curves.fastOutSlowIn, crossFadeState: isExpanded ? CrossFadeState.showSecond : CrossFadeState.showFirst, duration: const Duration(milliseconds: 200), ); &#125; @override Widget build(BuildContext context) &#123; final ThemeData theme = Theme.of(context); final TextTheme textTheme = theme.textTheme; return Row( children: &lt;Widget&gt;[ Expanded( flex: 2, child: Container( margin: const EdgeInsets.only(left: 24.0), child: FittedBox( fit: BoxFit.scaleDown, alignment: Alignment.centerLeft, child: Text( name, style: textTheme.body1.copyWith(fontSize: 15.0), ), ), ), ), Expanded( flex: 3, child: Container( margin: const EdgeInsets.only(left: 24.0), child: _crossFade( Text(value, style: textTheme.caption.copyWith(fontSize: 15.0)), Text(hint, style: textTheme.caption.copyWith(fontSize: 15.0)), showHint ) ) ) ] ); &#125;&#125;class CollapsibleBody extends StatelessWidget &#123; const CollapsibleBody(&#123; this.margin = EdgeInsets.zero, this.child, this.onSave, this.onCancel &#125;); final EdgeInsets margin; final Widget child; final VoidCallback onSave; final VoidCallback onCancel; @override Widget build(BuildContext context) &#123; final ThemeData theme = Theme.of(context); final TextTheme textTheme = theme.textTheme; return Column( children: &lt;Widget&gt;[ Container( margin: const EdgeInsets.only( left: 24.0, right: 24.0, bottom: 24.0 ) - margin, child: Center( child: DefaultTextStyle( style: textTheme.caption.copyWith(fontSize: 15.0), child: child ) ) ), const Divider(height: 1.0), Container( padding: const EdgeInsets.symmetric(vertical: 16.0), child: Row( mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Container( margin: const EdgeInsets.only(right: 8.0), child: FlatButton( onPressed: onCancel, child: const Text('CANCEL', style: TextStyle( color: Colors.black54, fontSize: 15.0, fontWeight: FontWeight.w500 )) ) ), Container( margin: const EdgeInsets.only(right: 8.0), child: FlatButton( onPressed: onSave, textTheme: ButtonTextTheme.accent, child: const Text('SAVE') ) ) ] ) ) ] ); &#125;&#125;class DemoItem&lt;T&gt; &#123; DemoItem(&#123; this.name, this.value, this.hint, this.builder, this.valueToString &#125;) : textController = TextEditingController(text: valueToString(value)); final String name; final String hint; final TextEditingController textController; final DemoItemBodyBuilder&lt;T&gt; builder; final ValueToString&lt;T&gt; valueToString; T value; bool isExpanded = false; ExpansionPanelHeaderBuilder get headerBuilder &#123; return (BuildContext context, bool isExpanded) &#123; return DualHeaderWithHint( name: name, value: valueToString(value), hint: hint, showHint: isExpanded ); &#125;; &#125; Widget build() =&gt; builder(this);&#125;class ExpansionPanelsDemo extends StatefulWidget &#123; static const String routeName = '/material/expansion_panels'; @override _ExpansionPanelsDemoState createState() =&gt; _ExpansionPanelsDemoState();&#125;class _ExpansionPanelsDemoState extends State&lt;ExpansionPanelsDemo&gt; &#123; List&lt;DemoItem&lt;dynamic&gt;&gt; _demoItems; @override void initState() &#123; super.initState(); _demoItems = &lt;DemoItem&lt;dynamic&gt;&gt;[ DemoItem&lt;Location&gt;( name: 'Location', value: Location.Bahamas, hint: 'Select location', valueToString: (Location location) =&gt; location.toString().split('.')[1], builder: (DemoItem&lt;Location&gt; item) &#123; void close() &#123; setState(() &#123; item.isExpanded = false; &#125;); &#125; return Form( child: Builder( builder: (BuildContext context) &#123; return CollapsibleBody( onSave: () &#123; Form.of(context).save(); close(); &#125;, onCancel: () &#123; Form.of(context).reset(); close(); &#125;, child: FormField&lt;Location&gt;( initialValue: item.value, onSaved: (Location result) &#123; item.value = result; &#125;, builder: (FormFieldState&lt;Location&gt; field) &#123; return Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ RadioListTile&lt;Location&gt;( value: Location.Bahamas, title: const Text('Bahamas'), groupValue: field.value, onChanged: field.didChange, ), RadioListTile&lt;Location&gt;( value: Location.Barbados, title: const Text('Barbados'), groupValue: field.value, onChanged: field.didChange, ), RadioListTile&lt;Location&gt;( value: Location.Bermuda, title: const Text('Bermuda'), groupValue: field.value, onChanged: field.didChange, ), ] ); &#125; ), ); &#125; ) ); &#125; ), ]; &#125; @override Widget build(BuildContext context) &#123; return SingleChildScrollView( child: SafeArea( top: false, bottom: false, child: Container( margin: const EdgeInsets.all(24.0), child: ExpansionPanelList( expansionCallback: (int index, bool isExpanded) &#123; setState(() &#123; _demoItems[index].isExpanded = !isExpanded; &#125;); &#125;, children: _demoItems.map&lt;ExpansionPanel&gt;((DemoItem&lt;dynamic&gt; item) &#123; return ExpansionPanel( isExpanded: true, headerBuilder: item.headerBuilder, body: item.build() ); &#125;).toList() ), ), ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"33、Flutter Widget 之 showDatePicker、showTimePicker 日期时间选择器","slug":"Flutter Widget/33、Flutter Widget 之 showDatePicker、showTimePicker 日期时间选择器","date":"2018-03-06T00:48:20.000Z","updated":"2020-08-07T14:10:11.735Z","comments":true,"path":"2018/03/06/Flutter Widget/33、Flutter Widget 之 showDatePicker、showTimePicker 日期时间选择器/","link":"","permalink":"https://www.zackaddy.xin/2018/03/06/Flutter Widget/33、Flutter Widget 之 showDatePicker、showTimePicker 日期时间选择器/","excerpt":"","text":"简介 显示给定月份的日期，并可以选择一天 该选择器widget很少使用，相反，请考虑使用showDatePicker,它会创建一个日期选择器对话框 基本用法 currentDate,设置显示器当前显示时间 displayedMonth ,设置选择器显示天数的月份 firstDate,设置选择的最早日期 lastDate,设置可选择的最晚日期 selectedDate，设置当前选择的日期 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import 'dart:async';import 'package:flutter/material.dart';class DayPickerDemo extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() =&gt; _DayPickerState();&#125;class _DayPickerState extends State&lt;DayPickerDemo&gt; &#123; DateTime _date = DateTime.now(); TimeOfDay _time = TimeOfDay.now(); Future&lt;void&gt; _selectDate(BuildContext context) async &#123; final DateTime picked = await showDatePicker( context: context, initialDate: _date, firstDate: DateTime(2015, 8), lastDate: DateTime(2101)); if (picked != null &amp;&amp; picked != _date) print(\"data selectied :$&#123;_date.toString()&#125;\"); setState(() &#123; _date = picked; &#125;); if (picked == null) _date = DateTime.now(); &#125; Future&lt;void&gt; _selectTime(BuildContext context) async &#123; final TimeOfDay picked = await showTimePicker(context: context, initialTime: _time); if (picked != null &amp;&amp; picked != _time) print(\"data selectied :$&#123;_time.toString()&#125;\"); setState(() &#123; _time = picked; &#125;); if (picked == null) _time = TimeOfDay.now(); &#125; @override Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ Text('日期选择'), RaisedButton( child: Text('date selected:$&#123;_date.toString()&#125;'), onPressed: () &#123; _selectDate(context); &#125;, ), Text('时间选择'), RaisedButton( child: Text('date selected:$&#123;_time.toString()&#125;'), onPressed: () &#123; _selectTime(context); &#125;, ) ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"32、Flutter Widget 之 LinearProgressIndicator","slug":"Flutter Widget/32、Flutter Widget 之 LinearProgressIndicator","date":"2018-03-05T01:04:21.000Z","updated":"2020-08-07T14:10:11.735Z","comments":true,"path":"2018/03/05/Flutter Widget/32、Flutter Widget 之 LinearProgressIndicator/","link":"","permalink":"https://www.zackaddy.xin/2018/03/05/Flutter Widget/32、Flutter Widget 之 LinearProgressIndicator/","excerpt":"","text":"简介 一个线性进度条 有两种线性进度条：确定和不确定。 确定：确定进度条在每个时间点都有一个特定的值，并且该值应该是0.0递增到1.0。 不确定：不确定的进度条在每一个时间点都没有特定到值。只是表明此时取得的进度，没有表明多少未完成。 基本用法 创建确定进度条，需要使用介于0.0和1.0的非空值 要创建不确定的进度条，需要使用空值 示例1234567891011import 'package:flutter/material.dart';class LinearProgressIndicatorDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( width: 200.0, child: LinearProgressIndicator(), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"31、Flutter Widget 之 CircularProgressIndicator","slug":"Flutter Widget/31、Flutter Widget 之 CircularProgressIndicator","date":"2018-03-03T17:36:48.000Z","updated":"2020-08-07T14:10:11.734Z","comments":true,"path":"2018/03/04/Flutter Widget/31、Flutter Widget 之 CircularProgressIndicator/","link":"","permalink":"https://www.zackaddy.xin/2018/03/04/Flutter Widget/31、Flutter Widget 之 CircularProgressIndicator/","excerpt":"","text":"简介 循环进度条，旋转表示进度 有两种线性进度条：确定和不确定。 确定：确定进度条在每个时间点都有一个特定的值，并且该值应该是0.0递增到1.0。 不确定：不确定的进度条在每一个时间点都没有特定到值。只是表明此时取得的进度，没有表明多少未完成。 基本用法 创建确定进度条，需要使用介于0.0和1.0的非空值 要创建不确定的进度条，需要使用空值 示例1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';class CircularDemo extends StatefulWidget &#123; @override _CircularDemoState createState() =&gt; _CircularDemoState();&#125;class _CircularDemoState extends State&lt;CircularDemo&gt; &#123; @override Widget build(BuildContext context) &#123; return Row( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ SizedBox( height: 20, width: 20, child: CircularProgressIndicator( backgroundColor: Colors.red, ), ), SizedBox( height: 30, width: 30, child: CircularProgressIndicator( backgroundColor: Colors.red, ), ), CircularProgressIndicator( backgroundColor: Colors.redAccent, ), SizedBox( height: 50, width: 50, child: CircularProgressIndicator( backgroundColor: Colors.red, ), ), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"30、Flutter Widget 之 CustomScrollView 自定义滚动","slug":"Flutter Widget/30、Flutter Widget 之 CustomScrollView 自定义滚动","date":"2018-03-03T03:41:01.000Z","updated":"2020-08-07T14:10:11.734Z","comments":true,"path":"2018/03/03/Flutter Widget/30、Flutter Widget 之 CustomScrollView 自定义滚动/","link":"","permalink":"https://www.zackaddy.xin/2018/03/03/Flutter Widget/30、Flutter Widget 之 CustomScrollView 自定义滚动/","excerpt":"","text":"简介 使用Slivers创建自定义滚动效果的ScrollView CustomScrollView 主要是配合Slivers大家族使用，创建自定义的滚动效果 如果需要创建可展开的AppBar，后跟list和grid，可使用这三种Slivers：SliverAppBar、SliverList和SliverGrid 这些Slivers必须生成RenderSliver对象 基本用法 配合 Slivers使用 slivers 属性中我们添加SliverAppBar SliverAppBar下方放置SliverFixedExtentList，注意此处并没有滚动冲突 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import 'package:flutter/material.dart';import 'package:flutter_go/widgets/components/Scroll/CustomScrollView/product_list.dart';class CustomScrollViewDemo extends StatelessWidget &#123; Widget _buildItem(BuildContext context, ProductItem product) &#123; return Container( height: 100.0, margin: const EdgeInsets.only(bottom: 5.0), padding: const EdgeInsets.only(left: 10.0), color: Colors.blueGrey, child: Stack( alignment: AlignmentDirectional.centerStart, children: &lt;Widget&gt;[ Positioned( right: 40.0, child: Card( child: Center( child: Text( product.name, style: Theme.of(context).textTheme.title, textAlign: TextAlign.center, ), ), )), ClipRRect( child: SizedBox( width: 70.0, height: 70.0, child: Image.asset( product.asset, fit: BoxFit.cover, ), ), borderRadius: BorderRadius.all(Radius.circular(8.0)), ), ], ), ); &#125; @override Widget build(BuildContext context) &#123; return Container( height: 400.0, child: CustomScrollView( slivers: &lt;Widget&gt;[ SliverAppBar( actions: &lt;Widget&gt;[ // _buildAction(), ], title: Text('CustomScrollView'), backgroundColor: Theme.of(context).primaryColor, expandedHeight: 200.0, flexibleSpace: FlexibleSpaceBar( background: Image.asset('assets/images/food01.jpeg', fit: BoxFit.cover), ), pinned: true,//固定导航 ), SliverFixedExtentList( delegate: SliverChildListDelegate(products.map((product) &#123; return _buildItem(context, product); &#125;).toList()), itemExtent: 120.0, ) ], ), ); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ProductItem &#123; final String name; final String tag; final String asset; final int stock; final double price; ProductItem(&#123; this.name, this.tag, this.asset, this.stock, this.price, &#125;);&#125;final List&lt;ProductItem&gt; products = [ ProductItem( name: 'Bueno Chocolate', tag: '1', asset: 'assets/images/food01.jpeg', stock: 1, price: 71.0), ProductItem( name: 'Chocolate with berries', tag: '2', asset: 'assets/images/food02.jpeg', stock: 1, price: 71.0), ProductItem( name: 'Trumoo Candies', tag: '3', asset: 'assets/images/food03.jpeg', stock: 1, price: 71.0), ProductItem( name: 'Choco-coko', tag: '4', asset: 'assets/images/food04.jpeg', stock: 1, price: 71.0), ProductItem( name: 'Chocolate tree', tag: '5', asset: 'assets/images/food05.jpeg', stock: 1, price: 71.0), ProductItem( name: 'Chocolate', tag: '6', asset: 'assets/images/food06.jpeg', stock: 1, price: 71.0),];","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"29、Flutter Widget 之 NestedScrollView 嵌套滚动","slug":"Flutter Widget/29、Flutter Widget 之 NestedScrollView 嵌套滚动","date":"2018-03-02T03:07:17.000Z","updated":"2020-08-07T14:10:11.733Z","comments":true,"path":"2018/03/02/Flutter Widget/29、Flutter Widget 之 NestedScrollView 嵌套滚动/","link":"","permalink":"https://www.zackaddy.xin/2018/03/02/Flutter Widget/29、Flutter Widget 之 NestedScrollView 嵌套滚动/","excerpt":"","text":"简介 一个可以嵌在另一个滚动视图中的Scroll view，本质上，他们的滚动是连接着的 最常见的用例就是一个可滚动的视图，包含一个 flexible SliverAppBar，并且包含TabBar和TabBarView 在普通的ScrollView中包含一系列 slivers ，会出现滚动冲突的问题 NestedScrollView 通过为外部ScrollView和内部的ScrollViews提供自定义的ScrollController来解决滚动冲突的问题，将他们“连接”起来，以便他们滚动时看起来更像是一个整体 基本用法 Demo演示NestedScrollView最常见的使用实例 头部为一个SliverAppBar，折叠部分的内容都放在了flexibleSpace中 由 headerSliverBuilder 构建出来一个包含TabBar的SliverAppBar，并且在body中包含 TabBarView 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import 'package:flutter/material.dart';class NestedScrollViewDemo extends StatefulWidget &#123; _NestedScrollViewDemoState createState() =&gt; _NestedScrollViewDemoState();&#125;class _NestedScrollViewDemoState extends State&lt;NestedScrollViewDemo&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; ScrollController _scrollViewController; @override void initState() &#123; super.initState(); _tabController = TabController(vsync: this, length: 2); _scrollViewController = ScrollController(initialScrollOffset: 0.0); &#125; @override void dispose() &#123; _tabController.dispose(); _scrollViewController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Container( height: 700.0, child: Scaffold( body: NestedScrollView( controller: _scrollViewController, headerSliverBuilder: (BuildContext context, bool boxIsScrolled) &#123; return &lt;Widget&gt;[ SliverAppBar( title: Text('Tab Controller'), pinned: true, floating: true, forceElevated: boxIsScrolled, expandedHeight: 200.0, flexibleSpace: Container( child: Image.asset( 'assets/images/timg.jpeg', width: double.infinity, repeat: ImageRepeat.repeat, height: double.infinity, ), ), bottom: TabBar( controller: _tabController, tabs: &lt;Widget&gt;[ Tab( text: \"Home\", icon: Icon(Icons.home), ), Tab( text: \"Help\", icon: Icon(Icons.help), ), ], ), ) ]; &#125;, body: TabBarView( children: &lt;Widget&gt;[ PageOne(), PageTwo(), ], controller: _tabController, ), ), floatingActionButton: FloatingActionButton( child: Icon(Icons.control_point), onPressed: () &#123; _tabController.animateTo(1, curve: Curves.bounceInOut, duration: Duration(milliseconds: 10)); _scrollViewController .jumpTo(_scrollViewController.position.maxScrollExtent); &#125;, ), ), ); &#125;&#125;class PageOne extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Center( child: Column( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ Image.asset( 'assets/images/food06.jpeg', width: 300.0, fit: BoxFit.contain, ), Image.asset( 'assets/images/food02.jpeg', width: 300.0, fit: BoxFit.contain, ), ], )); &#125;&#125;class PageTwo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return ListView.builder( itemExtent: 250.0, itemBuilder: (context, index) =&gt; Container( padding: EdgeInsets.all(10.0), child: Material( elevation: 4.0, borderRadius: BorderRadius.circular(5.0), color: index % 2 == 0 ? Colors.cyan : Colors.deepOrange, child: Center( child: Text(index.toString()), ), ), ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"28、Flutter Widget 之 BoxScrollView 自定义单子滚动布局","slug":"Flutter Widget/28、Flutter Widget 之 BoxScrollView 自定义单子滚动布局","date":"2018-02-28T18:29:23.000Z","updated":"2020-08-07T14:10:11.733Z","comments":true,"path":"2018/03/01/Flutter Widget/28、Flutter Widget 之 BoxScrollView 自定义单子滚动布局/","link":"","permalink":"https://www.zackaddy.xin/2018/03/01/Flutter Widget/28、Flutter Widget 之 BoxScrollView 自定义单子滚动布局/","excerpt":"","text":"简介 使用单个子布局模型的ScrollView ListView：一个使用的线性布局的BoxScrollView GridView：一个使用二维布局模型的BoxScrollView CustomScrollView：可以将多个子布局模型组合到一个滚动视图中 基本用法 由于是抽象类，所以不能直接实例化 如上简介，我们可以写一个类继承BoxScrollView Demo中，演示ListView的部分源码，用以实现继承BoxScrollView的代码编写，效果和ListView并无两样 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import 'package:flutter/material.dart';import 'package:flutter/rendering.dart';class BoxScrollViewDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Center( child: Column( children: &lt;Widget&gt;[ Text('滚动一下就看看吧 s(￣▽￣)~*'), Container( height: 300.0, child: ListViewDemo( children: &lt;Widget&gt;[ BoxItem(), BoxItem(), BoxItem(), BoxItem(), BoxItem(), BoxItem(), BoxItem(), BoxItem(), BoxItem(), ], ), ) ], ), ); &#125;&#125;class BoxItem extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( height: 60.0, margin: const EdgeInsets.symmetric(vertical: 20.0), color: Theme.of(context).primaryColor, child: Text( '测试继承BoxScrollView', style: TextStyle(color: Colors.white), ), ); &#125;&#125;class ListViewDemo extends BoxScrollView &#123; // 构造函数 ListViewDemo(&#123; Key key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, this.itemExtent, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double cacheExtent, List&lt;Widget&gt; children = const &lt;Widget&gt;[], int semanticChildCount, &#125;) : childrenDelegate = SliverChildListDelegate( children, addAutomaticKeepAlives: addAutomaticKeepAlives, addRepaintBoundaries: addRepaintBoundaries, addSemanticIndexes: addSemanticIndexes, ), super( key: key, scrollDirection: scrollDirection, reverse: reverse, controller: controller, primary: primary, physics: physics, shrinkWrap: shrinkWrap, padding: padding, cacheExtent: cacheExtent, semanticChildCount: semanticChildCount ?? children.length, ); final double itemExtent; final SliverChildDelegate childrenDelegate;// 子类应重写此方法以构建布局模型。 @override Widget buildChildLayout(BuildContext context) &#123; if (itemExtent != null) &#123; return SliverFixedExtentList( delegate: childrenDelegate, itemExtent: itemExtent, ); &#125; return SliverList(delegate: childrenDelegate); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"27、Flutter Widget 之 Dialog 基础对话框","slug":"Flutter Widget/27、Flutter Widget 之 Dialog 基础对话框","date":"2018-02-27T22:27:39.000Z","updated":"2020-08-07T14:10:11.733Z","comments":true,"path":"2018/02/28/Flutter Widget/27、Flutter Widget 之 Dialog 基础对话框/","link":"","permalink":"https://www.zackaddy.xin/2018/02/28/Flutter Widget/27、Flutter Widget 之 Dialog 基础对话框/","excerpt":"","text":"简介 Dialog 向用户传递信息的弹出层。-这个组件没有任何可操作的选项. 相比使用这个组件, 通常我们更喜欢使用 AlertDialog或者SimpleDialog 基本用法 通常作为子窗口小部件传递给showDialog，后者显示对话框。 进阶用法 犹豫当前组件没有任何可选项目, 我们可以通过自定义样式, 去完成自己想要的各种样式的弹框, 满足我们的个性化需求 注意事项: 当前弹出的dialog并非是一个单纯的组件, 而是一个新路由界面, 如果我想通过操作dialog中的内容, 直接使用setState触发的是原界面中的状态 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import 'package:flutter/material.dart';class DialogDemo extends StatefulWidget &#123; _Demo createState() =&gt; _Demo();&#125;class _Demo extends State&lt;DialogDemo&gt; &#123; void showAlertDialog(BuildContext context) &#123; showDialog&lt;void&gt;( context: context, barrierDismissible: false, // user must tap button! builder: (BuildContext context) &#123; return Dialog( child: Container( height: 100, child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ Text('我是一个dialog'), RaisedButton( child: Text('取消'), onPressed: () &#123; Navigator.of(context).pop(); &#125;, ) ], ), ) ); &#125;, ); &#125; Widget build(BuildContext context) &#123; return RaisedButton( padding: EdgeInsets.fromLTRB(10.0, 10.0, 10.0, 10.0), //padding child: Text( '点我显示 Dialog', style: TextStyle( fontSize: 18.0, //textsize color: Colors.white, // textcolor ), ), color: Theme.of(context).accentColor, elevation: 4.0, //shadow splashColor: Colors.blueGrey, onPressed: () &#123; showAlertDialog(context); &#125;); &#125;&#125;class DialogMoreDemo extends StatefulWidget &#123; _DialogMoreDemo createState() =&gt; _DialogMoreDemo();&#125;class _DialogMoreDemo extends State&lt;DialogMoreDemo&gt; &#123; int value = 0; void showCommonDialog(BuildContext context) &#123; showDialog&lt;void&gt;( context: context, barrierDismissible: false, // user must tap button! builder: (context) &#123; return StatefulBuilder( builder: (context, state) &#123; return Dialog( child: Container( height: 150, child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ Text('我是一个dialog'), RaisedButton( onPressed: () &#123; state(() &#123; value += 1; &#125;); &#125;, child: Text(\"我是一个Dialog, 点我更新value: $value\"), ), RaisedButton( onPressed: () &#123; Navigator.of(context).pop(); &#125;, child: Text(\"取消\"), ) ], ), ), ); &#125; ); &#125; ); &#125; Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ RaisedButton( padding: EdgeInsets.fromLTRB(10.0, 10.0, 10.0, 10.0), //padding child: Text( '点我显示Dialog', style: TextStyle( fontSize: 18.0, //textsize color: Colors.white, // textcolor ), ), color: Theme.of(context).accentColor, elevation: 4.0, //shadow splashColor: Colors.blueGrey, onPressed: () &#123; showCommonDialog(context); &#125; ) ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"26、Flutter Widget 之 SimpleDialog 选项对话框","slug":"Flutter Widget/26、Flutter Widget 之 SimpleDialog 选项对话框","date":"2018-02-26T20:46:13.000Z","updated":"2020-08-07T14:10:11.732Z","comments":true,"path":"2018/02/27/Flutter Widget/26、Flutter Widget 之 SimpleDialog 选项对话框/","link":"","permalink":"https://www.zackaddy.xin/2018/02/27/Flutter Widget/26、Flutter Widget 之 SimpleDialog 选项对话框/","excerpt":"","text":"简介 SimpleDialog 是一个用于向用户传递确定信息并提供选项的弹出层 SimpleDialog 可为用户提供多个选项选择。有一个可选的标题，显示在选项上方 基本用法 通常作为子窗口小部件传递给showDialog，后者显示对话框。 选择通常使用SimpleDialogOption表示 对于通知用户情况的对话框，请考虑使用 AlertDialog。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';class SimpleDialogDemo extends StatefulWidget &#123; _Demo createState() =&gt; _Demo();&#125;class _Demo extends State&lt;SimpleDialogDemo&gt; &#123; void showAlertDialog(BuildContext context) &#123; showDialog&lt;Null&gt;( context: context, builder: (BuildContext context) &#123; return SimpleDialog( title: Text('选择'), children: &lt;Widget&gt;[ SimpleDialogOption( child: Text('选项 1'), onPressed: () &#123; Navigator.of(context).pop(); &#125;, ), SimpleDialogOption( child: Text('选项 2'), onPressed: () &#123; Navigator.of(context).pop(); &#125;, ), ], ); &#125;, ); &#125; Widget build(BuildContext context) &#123; return RaisedButton( padding: EdgeInsets.fromLTRB(10.0, 10.0, 10.0, 10.0), //padding child: Text( 'show SimpleDialog', style: TextStyle( fontSize: 18.0, //textsize color: Colors.white, // textcolor ), ), color: Theme.of(context).accentColor, elevation: 4.0, //shadow splashColor: Colors.blueGrey, onPressed: () &#123; showAlertDialog(context); &#125;); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"25、Flutter Widget 之 AboutDialog 关于对话框","slug":"Flutter Widget/25、Flutter Widget 之 AboutDialog 关于对话框","date":"2018-02-25T18:51:51.000Z","updated":"2020-08-07T14:10:11.732Z","comments":true,"path":"2018/02/26/Flutter Widget/25、Flutter Widget 之 AboutDialog 关于对话框/","link":"","permalink":"https://www.zackaddy.xin/2018/02/26/Flutter Widget/25、Flutter Widget 之 AboutDialog 关于对话框/","excerpt":"","text":"简介 AboutDialog 通常用于传递企业或者app的官方信息 这个对话框包含应用程序的图标，名称，版本号，版权和应用程序使用到的软件许可证的按钮 基本用法 要显示的AboutDialog，使用showAboutDialog。 如果应用程序具有Drawer，则AboutListTile可以使显示AboutDialog的过程更简单。 AboutDialog通过showAboutDialog 显示按钮调用 showLicensePage。 示例1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';class AboutDialogDemo extends StatefulWidget &#123; _Demo createState() =&gt; _Demo();&#125;class _Demo extends State&lt;AboutDialogDemo&gt; &#123; void showAlertDialog(BuildContext context) &#123; showDialog( context: context, builder: (_) =&gt; AboutDialog( applicationName: '名称', applicationIcon: Icon(Icons.ac_unit), applicationVersion: 'V1.0', children: &lt;Widget&gt;[ Text('我是一个关于的dialog') ] )); &#125; Widget build(BuildContext context) &#123; return RaisedButton( padding: EdgeInsets.fromLTRB(10.0, 10.0, 10.0, 10.0), //padding child: Text( 'show aboutDialog', style: TextStyle( fontSize: 18.0, //textsize color: Colors.white, // textcolor ), ), color: Theme.of(context).accentColor, elevation: 4.0, //shadow splashColor: Colors.blueGrey, onPressed: () &#123; showAlertDialog(context); &#125;); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"24、Flutter Widget 之 AlertDialog 提示对话框","slug":"Flutter Widget/24、Flutter Widget 之 AlertDialog 提示对话框","date":"2018-02-24T21:42:42.000Z","updated":"2020-08-07T14:10:11.732Z","comments":true,"path":"2018/02/25/Flutter Widget/24、Flutter Widget 之 AlertDialog 提示对话框/","link":"","permalink":"https://www.zackaddy.xin/2018/02/25/Flutter Widget/24、Flutter Widget 之 AlertDialog 提示对话框/","excerpt":"","text":"简介 AlertDialog 向用户传递信息的弹出层。警报对话框 一般使用在通知用户需要确认的情况，具有可选标题和可选的操纵列表。标题显示在上方，操纵内容显示在内容区域，即下方 基本用法 通常作为子窗口小部件传递给showDialog，后者显示对话框。 当AlertDialog的的元素过多过长时, 请优先考虑SingleChildScrollView 用来避免内容溢出 需要注意的是，由于AlertDialog 通常使用child的大小来调整自身大小，所以使用一些widget（如ListView，GridView和CustomScrollView）将无法正常工作 当需要给用户提供多个选项的供选择时，请使用SimpleDialog 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';class AlertDialogDemo extends StatelessWidget&#123; // _Demo createState() =&gt; _Demo(); void showAlertDialog(BuildContext context) &#123; showDialog&lt;void&gt;( context: context, barrierDismissible: false, // user must tap button! builder: (BuildContext context) &#123; return AlertDialog( title: Text('title'), content: SingleChildScrollView( child: ListBody( children: &lt;Widget&gt;[ Text('too long~~~'), Text('too long~~~'), Text('too long~~~'), ], ), ), actions: &lt;Widget&gt;[ FlatButton( child: Text('关闭'), onPressed: () &#123; Navigator.of(context).pop(); &#125;, ), ], ); &#125;, ); &#125; Widget build(BuildContext context) &#123; return RaisedButton( padding: EdgeInsets.fromLTRB(10.0, 10.0, 10.0, 10.0), //padding child: Text( '点我显示 AlertDialog', style: TextStyle( fontSize: 18.0, //textsize color: Colors.white, // textcolor ), ), color: Theme.of(context).accentColor, elevation: 4.0, //shadow splashColor: Colors.blueGrey, onPressed: () &#123; showAlertDialog(context); &#125;); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"23、Flutter Widget 之 CustomClipper 裁剪路径","slug":"Flutter Widget/23、Flutter Widget 之 CustomClipper 裁剪路径","date":"2018-02-23T22:24:30.000Z","updated":"2020-08-07T14:10:11.731Z","comments":true,"path":"2018/02/24/Flutter Widget/23、Flutter Widget 之 CustomClipper 裁剪路径/","link":"","permalink":"https://www.zackaddy.xin/2018/02/24/Flutter Widget/23、Flutter Widget 之 CustomClipper 裁剪路径/","excerpt":"","text":"将矩形裁剪出圆形弧度123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body:Column( children: &lt;Widget&gt;[ ClipPath( clipper:BottomClipper(), child: Container( color:Colors.deepPurpleAccent, height: 200.0, ), ) ], ) ); &#125;&#125;class BottomClipperTest extends CustomClipper&lt;Path&gt;&#123; @override Path getClip(Size size) &#123; // TODO: implement getClip var path = Path(); path.lineTo(0, 0); path.lineTo(0, size.height-30); var firstControlPoint =Offset(size.width/2,size.height); var firstEndPoint = Offset(size.width,size.height-30); path.quadraticBezierTo(firstControlPoint.dx, firstControlPoint.dy, firstEndPoint.dx, firstEndPoint.dy); path.lineTo(size.width, size.height-30); path.lineTo(size.width, 0); return path; &#125; @override bool shouldReclip(CustomClipper&lt;Path&gt; oldClipper) &#123; // TODO: implement shouldReclip return false; &#125;&#125; 将矩形裁剪出波浪线1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body:Column( children: &lt;Widget&gt;[ ClipPath( clipper:BottomClipper(), child: Container( color:Colors.deepPurpleAccent, height: 200.0, ), ) ], ) ); &#125;&#125;class BottomClipper extends CustomClipper&lt;Path&gt;&#123; @override Path getClip(Size size) &#123; // TODO: implement getClip var path = Path(); path.lineTo(0, size.height-20); var firstControlPoint =Offset(size.width/4,size.height); var firstEndPoint = Offset(size.width/2.25,size.height-30); path.quadraticBezierTo(firstControlPoint.dx, firstControlPoint.dy, firstEndPoint.dx, firstEndPoint.dy); var secondControlPoint = Offset(size.width/4*3,size.height-80); var secondEndPoint = Offset(size.width,size.height-40); path.quadraticBezierTo(secondControlPoint.dx, secondControlPoint.dy, secondEndPoint.dx, secondEndPoint.dy); path.lineTo(size.width, size.height-40); path.lineTo(size.width, 0); return path; &#125; @override bool shouldReclip(CustomClipper&lt;Path&gt; oldClipper) &#123; // TODO: implement shouldReclip return false; &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"22、Flutter Widget 之 Card 卡片","slug":"Flutter Widget/22、Flutter Widget 之 Card 卡片","date":"2018-02-22T20:19:59.000Z","updated":"2020-08-07T14:10:11.731Z","comments":true,"path":"2018/02/23/Flutter Widget/22、Flutter Widget 之 Card 卡片/","link":"","permalink":"https://www.zackaddy.xin/2018/02/23/Flutter Widget/22、Flutter Widget 之 Card 卡片/","excerpt":"","text":"简介 Card “卡片” 卡片用于表示一些相关信息，例如相册，地理位置，用餐，联系方式等 基本用法 此示例显示了创建卡片窗口组件，其中显示了相册信息和两个操作 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import 'package:flutter/material.dart';/** Checkbox 默认Card的实例* */class CardFullDefault extends StatefulWidget &#123; const CardFullDefault() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _CardFullDefault();&#125;/** Card 默认的实例,有状态* */class _CardFullDefault extends State &#123; @override Widget build(BuildContext context) &#123; return Card( // ... // 如果没有,就是不需要有状态的 StatefulWidget ); &#125;&#125;/** Card 默认的实例,无状态* */class CardLessDefault extends StatelessWidget &#123; final widget; final parent; const CardLessDefault([this.widget, this.parent]) : super(); @override Widget build(BuildContext context) &#123; return Card( clipBehavior:Clip.antiAlias,// 根据设置裁剪内容 color:Colors.green, // 卡片背景颜色 elevation:20.0, // 卡片的z坐标,控制卡片下面的阴影大小 margin:EdgeInsets.all(20.0), // margin: EdgeInsetsDirectional.only(bottom: 30.0, top: 30.0, start: 30.0),// 边距 semanticContainer:true, // 表示单个语义容器，还是false表示单个语义节点的集合，接受单个child，但该child可以是Row，Column或其他包含子级列表的widget// shape:new Border.all(// color: Colors.indigo, width: 1.0, style: BorderStyle.solid), // 卡片材质的形状，以及边框 shape:RoundedRectangleBorder(borderRadius: new BorderRadius.circular(20.0)), // 圆角 //borderRadius: BorderRadius.all(Radius.circular(8.0)), child: Column( //card里面的子控件 mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ const ListTile( leading: Icon(Icons.access_time), title: Text('The Enchanted Nightingale',style: TextStyle(color: Colors.white, fontSize: 40.0)), subtitle: Text('Music by Julie Gable. Lyrics by Sidney Stein.',style: TextStyle(color: Colors.yellow, fontSize: 16.0)), contentPadding: EdgeInsets.all(20.0),// item 内容内边距 ), ButtonTheme.bar( // make buttons use the appropriate styles for cards child: ButtonBar( children: &lt;Widget&gt;[ FlatButton( child: const Text('BUY TICKETS',style: TextStyle(color: Colors.black, fontSize: 14.0)), onPressed: () &#123; /* ... */ &#125;, ), FlatButton( child: const Text('LISTEN',style: TextStyle(color: Colors.black, fontSize: 14.0)), onPressed: () &#123; /* ... */ &#125;, ), ], ), ), ], ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"21、Flutter Widget 之 GridView 网格列表","slug":"Flutter Widget/21、Flutter Widget 之 GridView 网格列表","date":"2018-02-21T20:37:31.000Z","updated":"2020-08-07T14:10:11.731Z","comments":true,"path":"2018/02/22/Flutter Widget/21、Flutter Widget 之 GridView 网格列表/","link":"","permalink":"https://www.zackaddy.xin/2018/02/22/Flutter Widget/21、Flutter Widget 之 GridView 网格列表/","excerpt":"","text":"简介 GridView在移动端上非常的常见的滚动列表, 会占满给出的空间区域. 基本用法 创建一个列表 属性介绍 scrollDirection：滚动的方向，有垂直和水平两种，默认为垂直方向（Axis.vertical）。 reverse：默认是从上或者左向下或者右滚动的，这个属性控制是否反向，默认值为false，不反向滚动。 controller：控制child滚动时候的位置。 primary：是否是与父节点的PrimaryScrollController所关联的主滚动视图。 physics：滚动的视图如何响应用户的输入。 shrinkWrap：滚动方向的滚动视图内容是否应该由正在查看的内容所决定。 padding：四周的空白区域。 gridDelegate：控制GridView中子节点布局的delegate。 cacheExtent：缓存区域。 进阶用法 GridView 提供其他四种构造方法 GridView.builder GridView.custom GridView.count GridView.extent 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import 'package:flutter/material.dart';class GridTileDemo extends StatefulWidget &#123; _Demo createState() =&gt; _Demo();&#125;class _Demo extends State&lt;GridTileDemo&gt; &#123; Widget build(BuildContext context) &#123; return Container( height: 400, color: Color(0xffc91b3a), child: new GridView.count( crossAxisCount: 2, mainAxisSpacing: 10.0, crossAxisSpacing: 4.0, padding: const EdgeInsets.all(4.0), childAspectRatio: 1.3, children: &lt;Widget&gt;[ GridTile( header: GridTileBar( title: Text('title'), subtitle: Text('subtitle'), leading: Icon(Icons.add), trailing: Text(\"trailing\"), ), child: Container(), ), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), new Image.network( 'https://flutter.io/assets/homepage/news-2-599aefd56e8aa903ded69500ef4102cdd8f988dab8d9e4d570de18bdb702ffd4.png', scale: 1, fit: BoxFit.cover), ], )); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"20、Flutter Widget 之 AnimatedList 动画列表","slug":"Flutter Widget/20、Flutter Widget 之 AnimatedList 动画列表","date":"2018-02-20T23:27:16.000Z","updated":"2020-08-07T14:10:11.730Z","comments":true,"path":"2018/02/21/Flutter Widget/20、Flutter Widget 之 AnimatedList 动画列表/","link":"","permalink":"https://www.zackaddy.xin/2018/02/21/Flutter Widget/20、Flutter Widget 之 AnimatedList 动画列表/","excerpt":"","text":"简介 AnimatedList “动画滚动容器” 一个滚动容器，可在插入或移除项目时为其设置动画 基本用法 AnimatedList AnimatedListState 可用于动态插入或删除项目。 下面示例展示效果:点击+号增加 card, 点击 card 保持激活状态，再点击-号，减少 card。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import 'package:flutter/material.dart';import './model.dart';class AnimatedListFullDefault extends StatefulWidget &#123; AnimatedListFullDefault(&#123;Key key, this.parent&#125;) : super(key: key); final parent; @override _AnimatedListFullDefault createState() =&gt; _AnimatedListFullDefault();&#125;/** AnimatedList 默认的实例,有状态* */class _AnimatedListFullDefault extends State&lt;AnimatedListFullDefault&gt; &#123; final GlobalKey&lt;AnimatedListState&gt; _listKey = new GlobalKey&lt;AnimatedListState&gt;(); ListModel&lt;int&gt; _list; int _selectedItem; int _nextItem; // The next item inserted when the user presses the '+' button. @override void initState() &#123; super.initState(); if (widget.parent is State) &#123; widget.parent.animatedList = this; // 修改父级的对象引用 &#125; _list = new ListModel&lt;int&gt;( listKey: _listKey, initialItems: &lt;int&gt;[0, 1, 2], removedItemBuilder: _buildRemovedItem, ); _nextItem = 3; &#125; void insert() &#123; final int index = _selectedItem == null ? _list.length : _list.indexOf(_selectedItem); _list.insert(index, _nextItem++); &#125; // Remove the selected item from the list model. void remove() &#123; if (_selectedItem != null) &#123; _list.removeAt(_list.indexOf(_selectedItem)); setState(() &#123; _selectedItem = null; &#125;); &#125; &#125; Widget _buildItem(BuildContext context, int index, Animation&lt;double&gt; animation) &#123; return new CardItem( animation: animation, item: _list[index], selected: _selectedItem == _list[index], onTap: () &#123; setState(() &#123; _selectedItem = _selectedItem == _list[index] ? null : _list[index]; &#125;); &#125;, ); &#125; Widget _buildRemovedItem(int item, BuildContext context, Animation&lt;double&gt; animation) &#123; return new CardItem( animation: animation, item: item, selected: false, // No gesture detector here: we don't want removed items to be interactive. ); &#125; @override Widget build(BuildContext context) &#123; return SizedBox( height: 500.0, child:AnimatedList( //shrinkWrap: true, key: _listKey, initialItemCount: _list.length, itemBuilder: _buildItem, )); &#125; void methodA() &#123;&#125;&#125;class CardItem extends StatelessWidget &#123; const CardItem(&#123; Key key, @required this.animation, this.onTap, @required this.item, this.selected: false &#125;) : assert(animation != null), assert(item != null &amp;&amp; item &gt;= 0), assert(selected != null), super(key: key); final Animation&lt;double&gt; animation; final VoidCallback onTap; final int item; final bool selected; @override Widget build(BuildContext context) &#123; TextStyle textStyle = Theme.of(context).textTheme.display1; if (selected) textStyle = textStyle.copyWith(color: Colors.lightGreenAccent[400]); return new Padding( padding: const EdgeInsets.all(2.0), child: new SizeTransition( axis: Axis.vertical, sizeFactor: animation, child: new GestureDetector( behavior: HitTestBehavior.opaque, onTap: onTap, child: new SizedBox( height: 128.0, child: new Card( color: Colors.primaries[item % Colors.primaries.length], child: new Center( child: new Text('Item $item', style: textStyle), ), ), ), ), ), ); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Created with Android Studio. * User: 一晟 * Date: 2018/12/31 * Time: 下午10:15 * email: zhu.yan@alibaba-inc.com * tartget: FlatButton 的示例 *//// Keeps a Dart List in sync with an AnimatedList.////// The [insert] and [removeAt] methods apply to both the internal list and the/// animated list that belongs to [listKey].////// This class only exposes as much of the Dart List API as is needed by the/// sample app. More list methods are easily added, however methods that mutate the/// list must make the same changes to the animated list in terms of/// [AnimatedListState.insertItem] and [AnimatedList.removeItem].///import 'package:flutter/material.dart';class ListModel&lt;E&gt; &#123; ListModel(&#123; @required this.listKey, @required this.removedItemBuilder, Iterable&lt;E&gt; initialItems, &#125;) : assert(listKey != null), assert(removedItemBuilder != null), _items = new List&lt;E&gt;.from(initialItems ?? &lt;E&gt;[]); final GlobalKey&lt;AnimatedListState&gt; listKey; final dynamic removedItemBuilder; final List&lt;E&gt; _items; AnimatedListState get _animatedList =&gt; listKey.currentState; void insert(int index, E item) &#123; _items.insert(index, item); _animatedList.insertItem(index); &#125; E removeAt(int index) &#123; final E removedItem = _items.removeAt(index); if (removedItem != null) &#123; _animatedList.removeItem(index, (BuildContext context, Animation&lt;double&gt; animation) &#123; return removedItemBuilder(removedItem, context, animation); &#125;); &#125; return removedItem; &#125; int get length =&gt; _items.length; E operator [](int index) =&gt; _items[index]; int indexOf(E item) =&gt; _items.indexOf(item);&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"19、Flutter Widget 之 ListBody 列表","slug":"Flutter Widget/19、Flutter Widget 之 ListBody 列表","date":"2018-02-20T02:59:04.000Z","updated":"2020-08-07T14:10:11.730Z","comments":true,"path":"2018/02/20/Flutter Widget/19、Flutter Widget 之 ListBody 列表/","link":"","permalink":"https://www.zackaddy.xin/2018/02/20/Flutter Widget/19、Flutter Widget 之 ListBody 列表/","excerpt":"","text":"简介 ListBody “列表组件” 作用是按给定的轴方向，按照顺序排列子节点。 是一个不常直接使用的控件，一般都会配合ListView或者Column等控件使用。 基本用法 布局行为 在主轴上，子节点按照顺序进行布局，在交叉轴上，子节点尺寸会被拉伸，以适应交叉轴的区域。 在主轴上，给予子节点的空间必须是不受限制的（unlimited），使得子节点可以全部被容纳，ListBody不会去裁剪或者缩放其子节点。 ListBody的布局代码非常简单，根据主轴的方向，对子节点依次排布。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import 'package:flutter/material.dart';/** Checkbox 默认ListBody的实例* */class ListBodyFullDefault extends StatefulWidget &#123; const ListBodyFullDefault() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _ListBodyFullDefault();&#125;/** ListBody 默认的实例,有状态* */class _ListBodyFullDefault extends State &#123; @override Widget build(BuildContext context) &#123; return ListBody( // ... // 如果没有,就是不需要有状态的 StatefulWidget ); &#125;&#125;/** ListBody 默认的实例,无状态* */class ListBodyLessDefault extends StatelessWidget &#123; final widget; final parent; const ListBodyLessDefault([this.widget, this.parent]) : super(); @override Widget build(BuildContext context) &#123; return ListBody( mainAxis: Axis.vertical, // 排列的主轴方向 reverse: false, // 是否反向 children: &lt;Widget&gt;[ Container(color: Colors.red, width: 50.0, height: 150.0, child: Text('标题1', style: TextStyle(color: Color(0xffffffff)))), Container(color: Colors.yellow, width: 50.0, height: 50.0, child: Text('标题2', style: TextStyle(color: Color(0xffffffff)))), Container(color: Colors.green, width: 50.0, height: 50.0, child: Text('标题3', style: TextStyle(color: Color(0xffffffff)))), Container(color: Colors.blue, width: 50.0, height: 50.0, child: Text('标题4', style: TextStyle(color: Color(0xffffffff)))), Container(color: Colors.black, width: 50.0, height: 50.0, child: Text('标题5', style: TextStyle(color: Color(0xffffffff)))) ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"18、Flutter Widget 之 ListView 列表","slug":"Flutter Widget/18、Flutter Widget 之 ListView 列表","date":"2018-02-18T19:38:27.000Z","updated":"2020-08-07T14:10:11.729Z","comments":true,"path":"2018/02/19/Flutter Widget/18、Flutter Widget 之 ListView 列表/","link":"","permalink":"https://www.zackaddy.xin/2018/02/19/Flutter Widget/18、Flutter Widget 之 ListView 列表/","excerpt":"","text":"简介 ListView “滚动列表” 一个非常常用的控件，涉及到数据列表展示的，一般情况下都会选用该控件。 跟GridView相似，基本上是一个slivers里面只包含一个SliverList的CustomScrollView。 基本用法 布局行为 ListView在主轴方向可以滚动，在交叉轴方向，则是填满ListView。 一个组合控件。ListView跟GridView类似，都是继承自BoxScrollView。 在Flutter中有几种构建ListView的方式,分别是: 默认List，ListView.builder， ListView.separated，ListView.custom。 ListView() 默认 List 方式，是把数据 Iterable 添加到列表中，之后直接添加到 ListView 即可。 Tips: 如果需要设置分割线，需要对列表 item 添加处理，ListTile.divideTiles。 仅适用于内容较少的情形，因为它是一次性渲染所有的 items ，当 items 的数目较多时，很容易出现卡顿现象的，导致滑动不流畅。 ListView.builder() 设置单个item的属性，懒加载的，假如有 1000 个列表，初始渲染时并不会所有都渲染，而只会特定数量的 item ，这对于性能和用户体验来说，是很好的提升。 官方示例 ListView.separated() 带分割线的item，separated 相比较于 builder，又多了一个参数 separatorBuilder ，用于控制列表各个元素的间隔如何渲染。 官方示例 ListView.custom() 必须的参数就是 childrenDelegate , 然后传入一个 实现了 SliverChildDelegate 的组件，如 SliverChildListDelegate 和 SliverChildBuilderDelegate。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import 'package:flutter/material.dart';/** ListView 默认ListView的实例* */class ListViewFullDefault extends StatefulWidget &#123; const ListViewFullDefault() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _ListViewFullDefault();&#125;/** ListView 默认的实例,有状态* */class _ListViewFullDefault extends State &#123; @override Widget build(BuildContext context) &#123; return ListView( ); &#125;&#125;/** ListView 默认的实例,无状态* */class ListViewLessDefault extends StatelessWidget &#123; final widget; final parent; final index; const ListViewLessDefault([this.index, this.widget, this.parent,]) : super(); @override Widget build(BuildContext context) &#123; switch(index)&#123; case 0: return ListView( shrinkWrap: true, padding: EdgeInsets.all(20.0), children: &lt;Widget&gt;[ Text('I\\'m dedicating every day to you'), ListTile( leading: Icon(Icons.map), title: Text('Maps'), ), Text('Domestic life was never quite my style'), ListTile( leading: Icon(Icons.photo_album), title: Text('Album'), ), Text('When you smile, you knock me out, I fall apart'), ListTile( leading: Icon(Icons.phone), title: Text('Phone'), ), Text('And I thought I was so smart'), ], ); break; case 1: return SizedBox( height: 300.0, child: ListView.builder( scrollDirection: Axis.vertical, itemCount: 10, // item 的个数 itemExtent: 50.0, // 如果为非null，则强制子项在滚动方向上具有给定范围 itemBuilder: (BuildContext context, int index) &#123; return ListTile( title: Text(\"title $index\"), // item 标题 leading: Icon(Icons.keyboard), // item 前置图标 subtitle: Text(\"subtitle $index\"), // item 副标题 trailing: Icon(Icons.keyboard_arrow_right),// item 后置图标 isThreeLine:false, // item 是否三行显示 dense:true, // item 直观感受是整体大小 contentPadding: EdgeInsets.all(10.0),// item 内容内边距 enabled:true, onTap:()&#123;print('点击:$index');&#125;,// item onTap 点击事件 onLongPress:()&#123;print('长按:$index');&#125;,// item onLongPress 长按事件 selected:false, // item 是否选中状态 ); &#125;, ), ); break; case 2: return SizedBox( height: 300.0, child: ListView.separated( scrollDirection: Axis.vertical, itemCount: 100, // item 的个数 separatorBuilder: (BuildContext context, int index) =&gt; Divider(height:1.0,color: Colors.blue), // 添加分割线 itemBuilder: (BuildContext context, int index) &#123; return ListTile( title: Text(\"title $index\"), // item 标题 leading: Icon(Icons.keyboard), // item 前置图标 subtitle: Text(\"subtitle $index\"), // item 副标题 trailing: Icon(Icons.keyboard_arrow_right),// item 后置图标 isThreeLine:false, // item 是否三行显示 dense:true, // item 直观感受是整体大小 contentPadding: EdgeInsets.all(10.0),// item 内容内边距 enabled:true, onTap:()&#123;print('点击:$index');&#125;,// item onTap 点击事件 onLongPress:()&#123;print('长按:$index');&#125;,// item onLongPress 长按事件 selected:false, // item 是否选中状态 ); &#125;, ), ); break; case 3: return SizedBox( height: 300.0, child: ListView.custom( scrollDirection: Axis.vertical, childrenDelegate:SliverChildBuilderDelegate((BuildContext context, int index) &#123; return Container( height: 50.0, alignment: Alignment.center, color: Colors.lightBlue[100 * (index % 9)], child: Text('list item $index'), ); &#125;, childCount: 10), ), ); break; default: return null; break; &#125; &#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"17、Flutter Widget 之 ScaffoldState  控制（侧边抽屉等）显示与隐藏","slug":"Flutter Widget/17、Flutter Widget 之 ScaffoldState  控制（侧边抽屉等）显示与隐藏","date":"2018-02-17T22:55:25.000Z","updated":"2020-08-07T14:10:11.729Z","comments":true,"path":"2018/02/18/Flutter Widget/17、Flutter Widget 之 ScaffoldState  控制（侧边抽屉等）显示与隐藏/","link":"","permalink":"https://www.zackaddy.xin/2018/02/18/Flutter Widget/17、Flutter Widget 之 ScaffoldState  控制（侧边抽屉等）显示与隐藏/","excerpt":"","text":"简介 Scaffold的State对象 通常用来控制SnackBars和BottomSheets和Drawer的显示与隐藏. 基本用法 通过为Scaffold定义key属性, 声明_scaffoldState, 通过_scaffoldState直接调用scaffoldState方法 当组件无法直接为Scaffold定义key属性时, 可以通过 Context与Scaffold.of获取父级scaffoldState 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import 'package:flutter/material.dart';class ScaffoldStateDemo extends StatefulWidget &#123; const ScaffoldStateDemo() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _ScaffoldStateDemo();&#125;/** AppBar 默认的实例,有状态* */class _ScaffoldStateDemo extends State with SingleTickerProviderStateMixin &#123; int count = 0; final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;(); @override Widget build(BuildContext context) &#123; // 如果省略了 leading ，但 AppBar 在带有 Drawer 的 Scaffold 中，则会插入一个 button 以打开 Drawer。 // 否则，如果最近的 Navigator 具有任何先前的 router ，则会插入BackButton。 // 这种行为可以通过设置来关闭automaticallyImplyLeading 为false。在这种情况下，空的 leading widget 将导致 middle/title widget 拉伸开始。 return new SizedBox( height: 500, child:new Scaffold( key:_scaffoldKey, appBar: AppBar( title: Text('ScaffoldState Demo'), ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text('点我试试呼出SnackBar&amp;Drawer'), onPressed: () &#123; _scaffoldKey.currentState.openDrawer(); _scaffoldKey.currentState.showSnackBar(const SnackBar( content: Text(\"我是通过ScaffoldState的方式呼出的SnackBar.\") )); &#125;, ) ], ), ), drawer: Drawer( child: Column( children: &lt;Widget&gt;[ const UserAccountsDrawerHeader( accountName: Text('Peter Widget'), accountEmail: Text('peter.widget@example.com'), currentAccountPicture: CircleAvatar( backgroundImage: AssetImage( 'people/square/peter.png', package: 'flutter_gallery_assets', ), ), margin: EdgeInsets.zero, ),// MediaQuery.removePadding(// context: context,// // DrawerHeader consumes top MediaQuery padding.// removeTop: true,// child: const ListTile(// leading: Icon(Icons.payment),// title: Text('Placeholder'),// ),// ), ], ), ), ) ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"16、Flutter Widget 之 Scaffold 布局","slug":"Flutter Widget/16、Flutter Widget 之 Scaffold 布局","date":"2018-02-17T02:25:02.000Z","updated":"2020-08-07T14:10:11.729Z","comments":true,"path":"2018/02/17/Flutter Widget/16、Flutter Widget 之 Scaffold 布局/","link":"","permalink":"https://www.zackaddy.xin/2018/02/17/Flutter Widget/16、Flutter Widget 之 Scaffold 布局/","excerpt":"","text":"简介 Scaffold 实现了基本的Material Design布局结构 在Material设计中定义的单个界面上的各种布局元素，在 Scaffold 中都有支持，比如 左边栏（Drawers）、snack bars、以及 bottom sheets。 基本用法Scaffold 有下面几个主要属性： appBar：显示在界面顶部的一个 AppBar body：当前界面所显示的主要内容 Widget floatingActionButton：Material设计中所定义的 FAB，界面的主要功能按钮 persistentFooterButtons：固定在下方显示的按钮，比如对话框下方的确定、取消按钮 drawer：侧边栏控件 backgroundColor： 内容的背景颜色，默认使用的是 ThemeData.scaffoldBackgroundColor 的值 bottomNavigationBar： 显示在页面底部的导航栏 resizeToAvoidBottomPadding：控制界面内容 body 是否重新布局来避免底部被覆盖了，比如当键盘显示的时候，重新布局避免被键盘盖住内容。默认值为 true。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import 'package:flutter/material.dart';class ScaffoldDemo extends StatefulWidget &#123; const ScaffoldDemo() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _ScaffoldDemo();&#125;/** AppBar 默认的实例,有状态* */class _ScaffoldDemo extends State with SingleTickerProviderStateMixin &#123; int count = 0; @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 如果省略了 leading ，但 AppBar 在带有 Drawer 的 Scaffold 中，则会插入一个 button 以打开 Drawer。 // 否则，如果最近的 Navigator 具有任何先前的 router ，则会插入BackButton。 // 这种行为可以通过设置来关闭automaticallyImplyLeading 为false。在这种情况下，空的 leading widget 将导致 middle/title widget 拉伸开始。 return new SizedBox( height: 500, child: new Scaffold( appBar: AppBar( title: Text('Sample Code'), ), body: Center( child: Text('You have pressed the button times. $count'), ), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, floatingActionButton: FloatingActionButton( onPressed: () =&gt; setState(() &#123; count += 1; &#125;), tooltip: 'Increment Counter', child: Icon(Icons.add), ), )); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"15、Flutter Widget 之 SnackBar 底部通知栏","slug":"Flutter Widget/15、Flutter Widget 之 SnackBar 底部通知栏","date":"2018-02-15T20:23:27.000Z","updated":"2020-08-07T14:10:11.728Z","comments":true,"path":"2018/02/16/Flutter Widget/15、Flutter Widget 之 SnackBar 底部通知栏/","link":"","permalink":"https://www.zackaddy.xin/2018/02/16/Flutter Widget/15、Flutter Widget 之 SnackBar 底部通知栏/","excerpt":"","text":"简介 SnackBar “屏幕底部消息” 带有可选操作的轻量级消息，短暂显示在屏幕底部 SnackBar是用户操作后，显示提示信息的一个控件，类似Toast，会自动隐藏; 基本用法 Scaffold.of(context).showSnackBar()，传递描述消息的 SnackBar 实例; 要控制SnackBar保持可见的时间，请指定持续时间。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import 'package:flutter/material.dart';/** SnackBar 默认的实例,无状态* */class SnackBarLessDefault extends StatelessWidget &#123; final widget; final parent; const SnackBarLessDefault([this.widget, this.parent]) : super(); @override Widget build(BuildContext context) &#123; // 当BuildContext在Scaffold之前时，调用Scaffold.of(context)会报错。这时可以通过Builder Widget来解决 return new Center( child: new Column( children: &lt;Widget&gt;[ new GestureDetector( onTap: () &#123; final snackBar = new SnackBar( content: new Text('这是一个SnackBar, 右侧有SnackBarAction'), backgroundColor:Colors.red, action: new SnackBarAction( // 提示信息上添加一个撤消的按钮 textColor:Colors.black, label: '撤消', onPressed: () &#123; // Some code to undo the change! &#125;, ), duration:Duration(minutes: 1),// 持续时间 //animation, ); Scaffold.of(context).showSnackBar(snackBar); &#125;, child: new Text('显示SnackBar'), ), new GestureDetector( onTap: () &#123; final snackBar = new SnackBar( content: new Text('右侧无SnackBarAction'), backgroundColor:Colors.red, duration:Duration(minutes: 1),// 持续时间 //animation, ); Scaffold.of(context).showSnackBar(snackBar); &#125;, child: new Text('显示无SnackBarAction的SnackBar'), ), ], ) ); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import 'package:flutter/material.dart';class SnackBarActionDemo extends StatefulWidget &#123; _Demo createState() =&gt; _Demo();&#125;class _Demo extends State&lt;SnackBarActionDemo&gt; &#123; Widget build(BuildContext context) &#123; return new Center( child: new Column( children: &lt;Widget&gt;[ new GestureDetector( onTap: () &#123; final snackBar = new SnackBar( content: new Text('这是一个SnackBar, 右侧有SnackBarAction, 3秒后消失'), backgroundColor:Color(0xffc91b3a), action: new SnackBarAction( // 提示信息上添加一个撤消的按钮 textColor:Colors.white, label: '撤消', onPressed: () &#123; // Some code to undo the change! &#125;, ), duration:Duration(seconds: 3),// 持续时间 //animation, ); Scaffold.of(context).showSnackBar(snackBar); &#125;, child: new Text('点我显示有action的SnackBar'), ), new GestureDetector( onTap: () async &#123; final snackBar = new SnackBar( content: new Text('右侧无SnackBarAction, 3秒后消失'), backgroundColor:Color(0xffc91b3a), duration:Duration(seconds: 3),// 持续时间 //animation, ); Scaffold.of(context).showSnackBar(snackBar); &#125;, child: new Text('点我显示无SnackBarAction的SnackBar'), ), ], ) ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"14、Flutter Widget 之 SliverAppBar 导航栏背景视差效果","slug":"Flutter Widget/14、Flutter Widget 之 SliverAppBar 导航栏背景视差效果","date":"2018-02-14T18:08:56.000Z","updated":"2020-08-07T14:10:11.728Z","comments":true,"path":"2018/02/15/Flutter Widget/14、Flutter Widget 之 SliverAppBar 导航栏背景视差效果/","link":"","permalink":"https://www.zackaddy.xin/2018/02/15/Flutter Widget/14、Flutter Widget 之 SliverAppBar 导航栏背景视差效果/","excerpt":"","text":"简介 SliverAppBar “应用栏” 它类似于Android中的toolbar; 基本用法 虽然基本相同，构造方法也是非常的简单，但是却不能直接使用它，由官方文档可以看到通常结合 ScrollView 来使用它; AppBar 和 SliverAppBar 都是继承StatefulWidget 类，都代表 Toobar; 二者的区别在于 AppBar 位置的固定的应用最上面的;而 SliverAppBar 是可以跟随内容滚动的; 下面的示例,放在 NestedScrollView 实现上提到顶的悬停; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import 'package:flutter/material.dart';/** 默认 SliverAppBar 的实例* */class SliverAppBarFullDefault extends StatefulWidget &#123; const SliverAppBarFullDefault() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _SliverAppBarFullDefault();&#125;/** SliverAppBar 默认的实例,有状态* */class _SliverAppBarFullDefault extends State &#123; @override Widget build(BuildContext context) &#123; return SliverAppBar( // ... // 如果没有,就是不需要有状态的 StatefulWidget ); &#125;&#125;/** SliverAppBar 默认的实例,无状态* */class SliverAppBarLessDefault extends StatelessWidget &#123;// final widget;// final parent;// const SliverAppBarLessDefault([this.widget, this.parent])// : super(); final List&lt;ListItem&gt; listData = []; @override Widget build(BuildContext context) &#123; for (int i = 0; i &lt; 20; i++) &#123; listData.add(new ListItem(\"我是测试标题$i\", Icons.cake)); &#125; return new SizedBox( height: 500.0, child:NestedScrollView( headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) &#123; return &lt;Widget&gt;[ SliverAppBar( //leading, // 在标题前面显示的一个控件，在首页通常显示应用的 logo；在其他界面通常显示为返回按钮 //title, // Toolbar 中主要内容，通常显示为当前界面的标题文字 //actions, // 一个 Widget 列表，代表 Toolbar 中所显示的菜单，对于常用的菜单，通常使用 IconButton 来表示；对于不常用的菜单通常使用 PopupMenuButton 来显示为三个点，点击后弹出二级菜单 //flexibleSpace, //bottom, //底部内容区域 //elevation, //阴影,纸墨设计中控件的 z 坐标顺序，默认值为 4，对于可滚动的 SliverAppBar，当 SliverAppBar 和内容同级的时候，该值为 0， 当内容滚动 SliverAppBar 变为 Toolbar 的时候，修改 elevation 的值 //flexibleSpace：一个显示在 AppBar 下方的控件，高度和 AppBar 高度一样，可以实现一些特殊的效果，该属性通常在 SliverAppBar 中使用 //backgroundColor, // 背景色,APP bar 的颜色，默认值为 ThemeData.primaryColor。改值通常和下面的三个属性一起使用 //brightness, // 主题明亮,App bar 的亮度，有白色和黑色两种主题，默认值为 ThemeData.primaryColorBrightness //iconTheme, // 图标主题,App bar 上图标的颜色、透明度、和尺寸信息。默认值为 ThemeData.primaryIconTheme //textTheme, //文字主题, App bar 上的文字样式。默认值为 ThemeData.primaryTextTheme //centerTitle, //标题是否居中, 标题是否居中显示，默认值根据不同的操作系统，显示方式不一样 primary: true, //是否预留高度 forceElevated:false, automaticallyImplyLeading:true, titleSpacing: NavigationToolbar.kMiddleSpacing, snap:false, //与floating结合使用 expandedHeight: 200.0,//展开高度 floating: false,//是否随着滑动隐藏标题 pinned: true,//是否固定在顶部 flexibleSpace: FlexibleSpaceBar( //可以展开区域，通常是一个FlexibleSpaceBar centerTitle: true, title: Text(\"我是一个帅气的标题\", style: TextStyle( color: Colors.white, fontSize: 16.0, )), background: Image.network( //\"http://h.hiphotos.baidu.com/image/pic/item/342ac65c103853434cc02dda9f13b07eca80883a.jpg\", \"http://b.zol-img.com.cn/desk/bizhi/image/6/960x600/1432800027589.jpg\", //\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1531798262708&amp;di=53d278a8427f482c5b836fa0e057f4ea&amp;imgtype=0&amp;src=http%3A%2F%2Fh.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F342ac65c103853434cc02dda9f13b07eca80883a.jpg\", fit: BoxFit.fill, )), ), // SliverPersistentHeader( // delegate: _SliverAppBarDelegate( // TabBar( // controller: new TabController(length: 2, vsync: this), // labelColor: Colors.black87, // unselectedLabelColor: Colors.grey, // tabs: [ // Tab(icon: Icon(Icons.security), text: \"security\"), // Tab(icon: Icon(Icons.cake), text: \"cake\"), // ], // ), // )) ]; &#125;, body: Center( child: new ListView.builder( shrinkWrap: true, itemBuilder: (BuildContext context, int index) &#123; return new ListItemWidget(listData[index]); &#125;, itemCount: listData.length, ), ), )); &#125;&#125;class ListItem &#123; final String title; final IconData iconData; ListItem(this.title, this.iconData);&#125;class ListItemWidget extends StatelessWidget &#123; final ListItem listItem; ListItemWidget(this.listItem); @override Widget build(BuildContext context) &#123; return new InkWell( child: new ListTile( leading: new Icon(listItem.iconData), title: new Text(listItem.title), ), onTap: () &#123;&#125;, ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"13、Flutter Widget 之 TabBar 标签选项卡","slug":"Flutter Widget/13、Flutter Widget 之 TabBar 标签选项卡","date":"2018-02-13T21:20:21.000Z","updated":"2020-08-07T14:10:11.727Z","comments":true,"path":"2018/02/14/Flutter Widget/13、Flutter Widget 之 TabBar 标签选项卡/","link":"","permalink":"https://www.zackaddy.xin/2018/02/14/Flutter Widget/13、Flutter Widget 之 TabBar 标签选项卡/","excerpt":"","text":"简介 SnackBarAction 来实现并行界面的横向滑动展示 TabBar，是材料设计中很常用的一种横向标签. 来实现并行界面的横向滑动展示，在Flutter的世界中，TabBar有着相同的作用。通常，我们会在AppBar的底部部分结合TabBarView来使用TabBar; 基本用法 在容器顶部或者底部配置, TabBar组件, 横向切换视口窗口中的内容 TabBar 有以下几项属性 tabs 一般使用Tab对象,当然也可以是其他的Widget controller TabController对象 isScrollable 是否可滚动 indicatorColor 指示器颜色 indicatorWeight 指示器厚度 indicatorPadding 底部指示器的Padding indicator 指示器decoration，例如边框等 indicatorSize 指示器大小计算方式 labelColor 选中Tab文字颜色 labelStyle 选中Tab文字Style unselectedLabelColor 未选中Tab中文字颜色 unselectedLabelStyle 未选中Tab中文字style TabBarView 有以下几项属性 children tabBar中对象分别对应的视图窗口内容, children的长度通常与tabs中的tab对象长度相同 controller TabController对象 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import 'package:flutter/material.dart';class TabBarDemo extends StatefulWidget &#123; const TabBarDemo() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _TabBarDemo();&#125;/** AppBar 默认的实例,有状态* */class _TabBarDemo extends State with SingleTickerProviderStateMixin &#123; ScrollController _scrollViewController; TabController _tabController; @override void initState() &#123; super.initState(); _scrollViewController = new ScrollController(); _tabController = new TabController(vsync: this, length: 6);// 和下面的 TabBar.tabs 数量对应 &#125; @override void dispose() &#123; _scrollViewController.dispose(); _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 如果省略了 leading ，但 AppBar 在带有 Drawer 的 Scaffold 中，则会插入一个 button 以打开 Drawer。 // 否则，如果最近的 Navigator 具有任何先前的 router ，则会插入BackButton。 // 这种行为可以通过设置来关闭automaticallyImplyLeading 为false。在这种情况下，空的 leading widget 将导致 middle/title widget 拉伸开始。 return new SizedBox( height: 500, child:new Scaffold( appBar: new AppBar( // 大量配置属性参考 SliverAppBar 示例 title: new Text('TabBar'), leading: new Icon(Icons.home), backgroundColor: Colors.amber[1000], bottom: new TabBar( isScrollable: true, controller: _tabController, tabs: &lt;Widget&gt;[ new Tab(text: \"Tabs 1\"), new Tab(text: \"Tabs 2\"), new Tab(text: \"Tabs 3\"), new Tab(text: \"Tabs 4\"), new Tab(text: \"Tabs 5\"), new Tab(text: \"Tabs 6\"), ], ), ), body: new TabBarView(controller: _tabController, children: &lt;Widget&gt;[ Text('TabsView 1'), Text('TabsView 2'), Text('TabsView 3'), Text('TabsView 4'), Text('TabsView 5'), Text('TabsView 6'), ]), ) ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"12、Flutter Widget 之 BottomAppBar 底部导航栏","slug":"Flutter Widget/12、Flutter Widget 之 BottomAppBar 底部导航栏","date":"2018-02-12T16:55:51.000Z","updated":"2020-08-07T14:10:11.727Z","comments":true,"path":"2018/02/13/Flutter Widget/12、Flutter Widget 之 BottomAppBar 底部导航栏/","link":"","permalink":"https://www.zackaddy.xin/2018/02/13/Flutter Widget/12、Flutter Widget 之 BottomAppBar 底部导航栏/","excerpt":"","text":"简介 BottomAppBar “底部应用栏” 一个通常与 Scaffold.bottomNavigationBar 一起使用的容器，可以在顶部有一个凹口，为重叠的FloatingActionButton腾出空间; 基本用法 通常与 Scaffold 和 FloatingActionButton 一起使用; 12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';/** AppBar 默认的实例,无状态* */class AppBarLessDefaultSimple extends StatelessWidget &#123; final widget; final parent; const AppBarLessDefaultSimple([this.widget, this.parent]) : super(); @override Widget build(BuildContext context) &#123; return new SizedBox( height: 100, child: Scaffold( //appBar: AppBar(title: const Text('Bottom App Bar')), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, floatingActionButton: FloatingActionButton( child: const Icon(Icons.add), onPressed: () &#123;&#125;,), bottomNavigationBar: BottomAppBar( shape: CircularNotchedRectangle(), notchMargin: 10.0,// FloatingActionButton和BottomAppBar 之间的差距 color:Colors.pink, child: Row( mainAxisSize: MainAxisSize.max, mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ IconButton(icon: Icon(Icons.menu), onPressed: () &#123;&#125;,), IconButton(icon: Icon(Icons.search), onPressed: () &#123;&#125;,), ], ), ), ) );&#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"11、Flutter Widget 之 AppBar 顶部导航栏","slug":"Flutter Widget/11、Flutter Widget 之 AppBar 顶部导航栏","date":"2018-02-11T18:05:41.000Z","updated":"2020-08-07T14:10:11.727Z","comments":true,"path":"2018/02/12/Flutter Widget/11、Flutter Widget 之 AppBar 顶部导航栏/","link":"","permalink":"https://www.zackaddy.xin/2018/02/12/Flutter Widget/11、Flutter Widget 之 AppBar 顶部导航栏/","excerpt":"","text":"简介 AppBar “应用栏” 应用栏由工具栏组成，或者是工具栏和其他 widget 组合形成，例如 TabBar和FlexibleSpaceBar; 应用栏通常用于 Scaffold.appBar 属性，该属性将应用栏放置在屏幕顶部的固定高度小部件中; 对于可滚动的应用栏，请参阅SliverAppBar，它将AppBar嵌入 sliver 中以便在CustomScrollView中使用; 基本用法 AppBar AppBar 在底部上方显示工具栏 widget，前导 leading ，标题 title 和操作 actions; 进阶用法 AppBar 一个完整的 AppBar 的例子, 增加 PopupMenuButton,TabBar 的示例子; 所述底部通常用于一个的 TabBar; 如果指定了 flexibleSpace 窗口 widget，则它将堆叠在工具栏和底部窗口 widget 后面; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import 'package:flutter/material.dart';/** 默认 AppBar 的实例* index 当前AppBar 的索引值* */class AppBarLessDefaultComplex extends StatefulWidget &#123; const AppBarLessDefaultComplex() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _AppBarLessDefaultComplex();&#125;/** AppBar 默认的实例,有状态* */class _AppBarLessDefaultComplex extends State with SingleTickerProviderStateMixin &#123; ScrollController _scrollViewController; TabController _tabController; @override void initState() &#123; super.initState(); _scrollViewController = new ScrollController(); _tabController = new TabController(vsync: this, length: 6);// 和下面的 TabBar.tabs 数量对应 &#125; @override void dispose() &#123; _scrollViewController.dispose(); _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 如果省略了 leading ，但 AppBar 在带有 Drawer 的 Scaffold 中，则会插入一个 button 以打开 Drawer。 // 否则，如果最近的 Navigator 具有任何先前的 router ，则会插入BackButton。 // 这种行为可以通过设置来关闭automaticallyImplyLeading 为false。在这种情况下，空的 leading widget 将导致 middle/title widget 拉伸开始。 return new SizedBox( height: 500, child:new AppBar( // 大量配置属性参考 SliverAppBar 示例 title: new Text('title'), leading: new Icon(Icons.home), backgroundColor: Colors.amber[500], centerTitle: true, actions: &lt;Widget&gt;[ new IconButton( icon: new Icon(Icons.add_alarm), tooltip: 'Add Alarm', onPressed: () &#123; // do nothing &#125;), new PopupMenuButton&lt;String&gt;( itemBuilder: (BuildContext context) =&gt; &lt;PopupMenuItem&lt;String&gt;&gt;[ new PopupMenuItem&lt;String&gt;( value: \"price\", child: new Text('Sort by price')), new PopupMenuItem&lt;String&gt;( value: \"time\", child: new Text('Sort by time')), ], onSelected: (String action) &#123; switch (action) &#123; case \"price\": // do nothing break; case \"time\": // do nothing break; &#125; &#125;) ], bottom: new TabBar( isScrollable: true, controller: _tabController, tabs: &lt;Widget&gt;[ new Tab(text: \"Tabs 1\"), new Tab(text: \"Tabs 2\"), new Tab(text: \"Tabs 3\"), new Tab(text: \"Tabs 4\"), new Tab(text: \"Tabs 5\"), new Tab(text: \"Tabs 6\"), ], ), ), ); &#125;&#125;/** AppBar 默认的实例,无状态* */class AppBarLessDefaultSimple extends StatelessWidget &#123; final widget; final parent; const AppBarLessDefaultSimple([this.widget, this.parent]) : super(); @override Widget build(BuildContext context) &#123; return new SizedBox( height: 200, child:AppBar( title: Text('My Fancy Dress'), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.playlist_play), tooltip: 'Air it', onPressed: ()=&gt;&#123;&#125;, ), IconButton( icon: Icon(Icons.playlist_add), tooltip: 'Restitch it', onPressed: ()=&gt;&#123;&#125;, ), IconButton( icon: Icon(Icons.playlist_add_check), tooltip: 'Repair it', onPressed: ()=&gt;&#123;&#125;, ), ], ) ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"10、Flutter Widget 之 BottomNavigationBar 底部选项卡","slug":"Flutter Widget/10、Flutter Widget 之 BottomNavigationBar 底部选项卡","date":"2018-02-10T22:52:01.000Z","updated":"2020-08-07T14:10:11.727Z","comments":true,"path":"2018/02/11/Flutter Widget/10、Flutter Widget 之 BottomNavigationBar 底部选项卡/","link":"","permalink":"https://www.zackaddy.xin/2018/02/11/Flutter Widget/10、Flutter Widget 之 BottomNavigationBar 底部选项卡/","excerpt":"","text":"简介 BottomNavigationBar “底部导航栏” 显示在应用程序底部的导航栏,由文本标签，图标或两者形式的多个项目组成; 它提供了应用程序顶级视图之间的快速导航; 基本用法 BottomNavigationBar 底部导航栏通常与Scaffold结合使用 它作为 Scaffold.bottomNavigationBar 参数; BottomNavigationBar 支持0-4个之间个底部按钮数量，超出4个系统将会报异常; 默认0-3个底部按钮数量时，BottomNavigationBar采用fixed的模式摆放底部按钮，当有4个时默认使用 BottomNavigationBarType.shifting 模式摆放底部按钮; 下面的底部导航即是效果; 12345678910111213141516171819202122232425262728293031323334353637383940414243import 'package:flutter/material.dart';/** BottomNavigationBar 默认的实例* */class BottomNavigationBarFullDefault extends StatefulWidget &#123; const BottomNavigationBarFullDefault() : super(); @override State&lt;StatefulWidget&gt; createState() =&gt; _BottomNavigationBarFullDefault();&#125;/** BottomNavigationBar 默认的实例,有状态* */class _BottomNavigationBarFullDefault extends State &#123; int _currentIndex = 1; void _onItemTapped(int index) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125; @override Widget build(BuildContext context) &#123; return BottomNavigationBar( type: BottomNavigationBarType.fixed, // BottomNavigationBarType 中定义的类型，有 fixed 和 shifting 两种类型 iconSize: 24.0, // BottomNavigationBarItem 中 icon 的大小 currentIndex: _currentIndex, // 当前所高亮的按钮index onTap: _onItemTapped, // 点击里面的按钮的回调函数，参数为当前点击的按钮 index fixedColor: Colors.deepPurple, // 如果 type 类型为 fixed，则通过 fixedColor 设置选中 item 的颜色 items: &lt;BottomNavigationBarItem&gt; [ BottomNavigationBarItem( title: new Text(\"Home\"), icon: new Icon(Icons.home)), BottomNavigationBarItem( title: new Text(\"List\"), icon: new Icon(Icons.list)), BottomNavigationBarItem( title: new Text(\"Message\"), icon: new Icon(Icons.message)), ], ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"9、Flutter Widget 之 BottomNavigationBarItem 底部选项卡","slug":"Flutter Widget/9、Flutter Widget 之 BottomNavigationBarItem 底部选项卡","date":"2018-02-09T21:55:43.000Z","updated":"2020-08-07T14:10:11.740Z","comments":true,"path":"2018/02/10/Flutter Widget/9、Flutter Widget 之 BottomNavigationBarItem 底部选项卡/","link":"","permalink":"https://www.zackaddy.xin/2018/02/10/Flutter Widget/9、Flutter Widget 之 BottomNavigationBarItem 底部选项卡/","excerpt":"","text":"简介 BottomNavigationBarItem “底部导航应用栏” material 的 BottomNavigationBar 或带有图标和标题的 iOS主题 CupertinoTabBar 中的交互式按钮; 基本用法 这个类很少单独使用。通常嵌入在上面的一个底部 bottom navigation widgets 中; 示例1234567891011121314151617181920212223242526272829303132import 'package:flutter/material.dart';/** BottomNavigationBarItem 默认的实例,无状态* */class BottomNavigationBarItemLessDefault extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new SizedBox( height: 100, child: Scaffold(// appBar: AppBar(title: Text(\"666\"),), bottomNavigationBar: new BottomNavigationBar(items: [ new BottomNavigationBarItem( icon: new Icon(Icons.laptop_chromebook), title: new Text(\"主页\"), backgroundColor: Colors.red ), new BottomNavigationBarItem( icon: new Icon(Icons.list), title: new Text(\"分类\"),backgroundColor: Colors.grey), new BottomNavigationBarItem( icon: new Icon(Icons.local_grocery_store), title: new Text(\"购物车\")), new BottomNavigationBarItem(icon: new Icon(Icons.person), title: new Text(\"我的\")) ], //onTap: onTap, //currentIndex: page ), ) ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"8、Flutter Widget 之 MaterialPageRoute 路由","slug":"Flutter Widget/8、Flutter Widget 之 MaterialPageRoute 路由","date":"2018-02-09T00:19:15.000Z","updated":"2020-08-07T14:10:11.740Z","comments":true,"path":"2018/02/09/Flutter Widget/8、Flutter Widget 之 MaterialPageRoute 路由/","link":"","permalink":"https://www.zackaddy.xin/2018/02/09/Flutter Widget/8、Flutter Widget 之 MaterialPageRoute 路由/","excerpt":"","text":"简介 页面跳转携带参数替换整个屏幕的页面路由。 对于Android，页面的进入以下方滑动向上，页面退出，以上方滑动向下方。在ios上，页面进度从右边滑入，退出相反。 默认情况下，当路由器被另外一个替换时，前一个路由将被保留在内存中，如果希望在不需要的时候能够释放资源，请将maintainState设置为false 基本用法 如下示例： 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import 'package:flutter/material.dart';class User &#123; final String account, email; const User(&#123; this.account, this.email, &#125;);&#125;class FirstPage extends StatefulWidget &#123; _FirstPageState createState() =&gt; _FirstPageState();&#125;class _FirstPageState extends State&lt;FirstPage&gt; &#123; var _usernameController = new TextEditingController(); var _emailController = new TextEditingController(); @override Widget build(BuildContext context) &#123; return Column( children: &lt;Widget&gt;[ Padding( child: new Text( \"账号登录\", textAlign: TextAlign.center, style: new TextStyle(fontWeight: FontWeight.bold, fontSize: 20), ), padding: EdgeInsets.only(bottom: 10.0), ), TextFormField( decoration: InputDecoration(labelText: 'account'), controller: _usernameController, ), TextFormField( decoration: InputDecoration(labelText: \"email\"), controller: _emailController, ), new RaisedButton( child: Text(\"点击跳转\"), onPressed: () &#123; var route = new MaterialPageRoute( builder: (BuildContext context) =&gt; new SecondPage( value: User( account: _usernameController.text, email: _emailController.text)), ); Navigator.of(context).push(route); &#125;, ) ], ); &#125;&#125;class SecondPage extends StatefulWidget &#123; final User value; SecondPage(&#123;Key key, this.value&#125;) : super(key: key); _SecondPageState createState() =&gt; _SecondPageState();&#125;class _SecondPageState extends State&lt;SecondPage&gt; &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: Text(\"MaterialPageRoute2\"), ), body: new Container( child: new Center( child: Column( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.only(top: 30.0), child: new Text(\"登陆成功！！！\", style: TextStyle( fontSize: 28, fontWeight: FontWeight.bold))), Padding( child: new Text( 'account:$&#123;widget.value.account&#125;', textAlign: TextAlign.center, style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), padding: EdgeInsets.only(bottom: 20.0, top: 40.0), ), Padding( child: new Text( 'email:$&#123;widget.value.email&#125;', textAlign: TextAlign.center, style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold), ), padding: EdgeInsets.only(bottom: 20.0), ), ], ), ), ), ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"7、Flutter Widget 之 自定义按钮外观 按钮","slug":"Flutter Widget/7、Flutter Widget 之 自定义按钮外观 按钮","date":"2018-02-08T03:30:59.000Z","updated":"2020-08-07T14:10:11.740Z","comments":true,"path":"2018/02/08/Flutter Widget/7、Flutter Widget 之 自定义按钮外观 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/08/Flutter Widget/7、Flutter Widget 之 自定义按钮外观 按钮/","excerpt":"","text":"1234567891011121314const FlatButton(&#123; ... @required this.onPressed, //按钮点击回调 this.textColor, //按钮文字颜色 this.disabledTextColor, //按钮禁用时的文字颜色 this.color, //按钮背景颜色 this.disabledColor,//按钮禁用时的背景颜色 this.highlightColor, //按钮按下时的背景颜色 this.splashColor, //点击时，水波动画中水波的颜色 this.colorBrightness,//按钮主题，默认是浅色主题 this.padding, //按钮的填充 this.shape, //外形 @required this.child, //按钮的内容&#125;)","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"6、Flutter Widget 之 IconButton 按钮","slug":"Flutter Widget/6、Flutter Widget 之 IconButton 按钮","date":"2018-02-06T16:05:11.000Z","updated":"2020-08-07T14:10:11.740Z","comments":true,"path":"2018/02/07/Flutter Widget/6、Flutter Widget 之 IconButton 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/07/Flutter Widget/6、Flutter Widget 之 IconButton 按钮/","excerpt":"","text":"简介 IconButton 默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱) 基本用法 这里我们着重介绍MaterialApp 主要属性 this.iconSize = 24.0, this.padding = const EdgeInsets.all(8.0), this.alignment = Alignment.center, this.icon, this.color, this.highlightColor, this.splashColor, this.disabledColor, this.onPressed, this.tooltip 代码示例1234IconButton( icon: Icon(Icons.thumb_up), onPressed: () =&gt; &#123;&#125;,)","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"5、Flutter Widget 之 OutlineButton 按钮","slug":"Flutter Widget/5、Flutter Widget 之 OutlineButton 按钮","date":"2018-02-06T04:34:22.000Z","updated":"2020-08-07T14:10:11.739Z","comments":true,"path":"2018/02/06/Flutter Widget/5、Flutter Widget 之 OutlineButton 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/06/Flutter Widget/5、Flutter Widget 之 OutlineButton 按钮/","excerpt":"","text":"简介 OutlineButton OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱) 基本用法 这里我们着重介绍MaterialApp 主要属性 VoidCallback onPressed, ButtonTextTheme textTheme, Color textColor, Color disabledTextColor, Color color, Color highlightColor, Color splashColor, double highlightElevation, this.borderSide, this.disabledBorderColor, this.highlightedBorderColor, EdgeInsetsGeometry padding, ShapeBorder shape, Clip clipBehavior = Clip.none, Widget child, 代码示例1234OutlineButton( child: Text(\"normal\"), onPressed: () =&gt; &#123;&#125;,)","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"4、Flutter Widget 之 FlatButton 按钮","slug":"Flutter Widget/4、Flutter Widget 之 FlatButton 按钮","date":"2018-02-04T22:00:58.000Z","updated":"2020-08-07T14:10:11.739Z","comments":true,"path":"2018/02/05/Flutter Widget/4、Flutter Widget 之 FlatButton 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/05/Flutter Widget/4、Flutter Widget 之 FlatButton 按钮/","excerpt":"","text":"简介 RaisedButton FlatButton即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色 基本用法 这里我们着重介绍MaterialApp 主要属性 VoidCallback onPressed, ValueChanged onHighlightChanged, ButtonTextTheme textTheme, Color textColor, Color disabledTextColor, Color color, Color disabledColor, Color highlightColor, Color splashColor, Brightness colorBrightness, EdgeInsetsGeometry padding, ShapeBorder shape, Clip clipBehavior = Clip.none, MaterialTapTargetSize materialTapTargetSize, Widget child, 代码示例1234FlatButton( child: Text(\"normal\"), onPressed: () =&gt; &#123;&#125;,)","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"3、Flutter Widget 之 RaisedButton 按钮","slug":"Flutter Widget/3、Flutter Widget 之 RaisedButton 按钮","date":"2018-02-03T21:55:05.000Z","updated":"2020-08-07T14:10:11.737Z","comments":true,"path":"2018/02/04/Flutter Widget/3、Flutter Widget 之 RaisedButton 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/04/Flutter Widget/3、Flutter Widget 之 RaisedButton 按钮/","excerpt":"","text":"简介 RaisedButton 即”漂浮”按钮，它默认带有阴影和灰色背景。按下后，漂浮、阴影会变大 基本用法 这里我们着重介绍MaterialApp 主要属性 VoidCallback onPressed, ValueChanged onHighlightChanged, ButtonTextTheme textTheme, Color textColor, Color disabledTextColor, Color color, Color disabledColor, Color highlightColor, Color splashColor, Brightness colorBrightness, double elevation, double highlightElevation, double disabledElevation, EdgeInsetsGeometry padding, ShapeBorder shape, Clip clipBehavior = Clip.none, MaterialTapTargetSize materialTapTargetSize, Duration animationDuration, Widget child, 代码示例1234RaisedButton( child: Text(\"normal\"), onPressed: () =&gt; &#123;&#125;,);","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"2、Flutter Widget 之 MaterialButton 按钮","slug":"Flutter Widget/2、Flutter Widget 之 MaterialButton 按钮","date":"2018-02-02T17:59:13.000Z","updated":"2020-08-07T14:10:11.734Z","comments":true,"path":"2018/02/03/Flutter Widget/2、Flutter Widget 之 MaterialButton 按钮/","link":"","permalink":"https://www.zackaddy.xin/2018/02/03/Flutter Widget/2、Flutter Widget 之 MaterialButton 按钮/","excerpt":"","text":"简介 用于构建一个依赖于ButtonThem 和 Theme的按钮widget 如果有必要，按钮的大小是自是适配于其子widget的 最好不要直接使用这个widget，而应该可以考虑使用FlatButton、OutlineButton或者RaiseButton,他们包含一些和主题风格相适配的一些基础样式 如果要直接创建按钮而不继承主题默认值，可以考虑使用 RawMaterialButton 如果想使用ink-splash的效果但是又不想使用button，可以考虑使用InkWell 基本用法 尽量不要直接使用 MaterialButton 如果 MaterialButton上的onPress为null，则按钮处于被禁用状态 IconButton 可以创建一些带有 图标的按钮 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'package:flutter/material.dart';class MaterialButtonDemo extends StatelessWidget &#123; final TextStyle txtStyle = TextStyle(color: Colors.white); @override Widget build(BuildContext context) &#123; return Container( child: Column( children: &lt;Widget&gt;[ MaterialButton( onPressed: () &#123; print('click MaterialButton'); &#125;, child: Text( 'MaterialButton', style: txtStyle, ), color: Theme.of(context).primaryColor, ), FlatButton.icon( icon: Icon( Icons.bubble_chart, color: Colors.white, ), label: Text( 'FlatButton', style: txtStyle, ), onPressed: () &#123; print('click FlatButton'); &#125;, color: Theme.of(context).primaryColor, ), RaisedButton( onPressed: () &#123; print('click RaisedButton'); &#125;, child: Text('RaisedButton'), ) ], ), ); &#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"1、Flutter Widget 之 MaterialApp 主题","slug":"Flutter Widget/1、Flutter Widget 之 MaterialApp 主题","date":"2018-02-01T21:29:11.000Z","updated":"2020-08-07T14:10:11.730Z","comments":true,"path":"2018/02/02/Flutter Widget/1、Flutter Widget 之 MaterialApp 主题/","link":"","permalink":"https://www.zackaddy.xin/2018/02/02/Flutter Widget/1、Flutter Widget 之 MaterialApp 主题/","excerpt":"","text":"简介 MaterialApp 代表 Material 设计风格的应用 包含许多 Material设计风格所需要的一些基本控件 在 WidgetsApp 中通过添加一些特定与 Material 设计风格的属性 基本用法 这里我们着重介绍MaterialApp 主要属性 title ： 在任务管理窗口中所显示的应用名字 theme ： 应用各种 UI 所使用的主题颜色 color ： 应用的主要颜色值（primary color），也就是安卓任务管理窗口中所显示的应用颜色 home ： 应用默认所显示的界面 Widget routes ： 应用的顶级导航表格，这个是多页面应用用来控制页面跳转的，类似于网页的网址 initialRoute ：第一个显示的路由名字，默认值为 Window.defaultRouteName onGenerateRoute ： 生成路由的回调函数，当导航的命名路由的时候，会使用这个来生成界面 onLocaleChanged ： 当系统修改语言的时候，会触发å这个回调 navigatorObservers ： 应用 Navigator 的监听器 debugShowMaterialGrid ： 是否显示 Material design 基础布局网格，用来调试 UI 的工具 showPerformanceOverlay ： 显示性能标签 checkerboardRasterCacheImages 、showSemanticsDebugger、debugShowCheckedModeBanner 各种调试开关 代码示例123456789101112131415161718192021222324import 'package:flutter/material.dart';class MaterialApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'title', theme: new ThemeData( primaryColor: Color(ThemeColor), backgroundColor: Color(0xFFEFEFEF), accentColor: Color(0xFF888888), textTheme: TextTheme( //设置Material的默认字体样式 body1: TextStyle(color: Color(0xFF888888), fontSize: 16.0), ), iconTheme: IconThemeData( color: Color(ThemeColor), size: 35.0, ), ), home: new MyHomePage(), onGenerateRoute: Application.router.generator, ); &#125;&#125;","categories":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}],"tags":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/tags/Flutter-Widget/"}],"keywords":[{"name":"Flutter Widget","slug":"Flutter-Widget","permalink":"https://www.zackaddy.xin/categories/Flutter-Widget/"}]},{"title":"41、异步执行命令","slug":"PHP/41、异步执行命令","date":"2017-09-30T04:07:31.000Z","updated":"2020-08-07T14:10:11.878Z","comments":true,"path":"2017/09/30/PHP/41、异步执行命令/","link":"","permalink":"https://www.zackaddy.xin/2017/09/30/PHP/41、异步执行命令/","excerpt":"","text":"通过fsockopen 访问index.php不会阻塞，但是通过fsockopen访问的test.php会造成阻塞 test.php阻塞后再次访问index.php，test.php不会执行 ==注意：fsockopen 访问本地端口会卡死，需要开启两个php服务端测试== 12345678910111213141516ignore_user_abort (true);set_time_limit (30);$filename = $request-&gt;input(\"param\");$fp = fsockopen(\"localhost\", 8001, $errno, $errstr, 30);if (!$fp) &#123; echo \"$errstr ($errno)&lt;br /&gt;\\n\";&#125; else &#123; $out = \"GET /test?param=&#123;$filename&#125; / HTTP/1.1\\r\\n\"; $out .= \"Host: localhost\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; @stream_set_blocking($fp, 0); @stream_set_timeout($fp, 3); fwrite($fp, $out); sleep(2); //等待300ms fclose($fp);&#125; 通过CURL 访问index.php不会阻塞，但是通过CURL访问的test.php会造成阻塞 test.php阻塞后再次访问index.php，test.php不会执行 ==注意：CURL 访问本地端口会卡死，需要开启两个php服务端测试== 123456789101112ignore_user_abort (true);set_time_limit (30);$curl = curl_init(); // 启动一个CURL会话curl_setopt($curl, CURLOPT_URL, \"localhost:8001/test?param=&#123;$filename&#125;\");curl_setopt($curl, CURLOPT_HEADER, 0);curl_setopt($curl, CURLOPT_TIMEOUT_MS, 10);curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 1);curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); // 跳过证书检查curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); // 从证书中检查SSL加密算法是否存在$tmpInfo = curl_exec($curl); //返回api的json对象curl_close($curl); 在Linux下要使程序后台运行，可通过&amp; 来实现 在Windows下，则通过 start来实现 windows123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public function test(Request $request)&#123; $taskId = $request-&gt;input(\"param\"); $file_path = \"task-&#123;$taskId&#125;.pid\"; $taskPid = 0; if (file_exists($file_path)) &#123; $fp = fopen($file_path, \"r\"); $taskPid = fread($fp, filesize($file_path)); &#125; echo $taskPid; if ($taskPid) &#123; $pid = popen(\"taskkill /pid &#123;$taskPid&#125;\", \"r\"); pclose($pid); &#125; return 66684884;&#125;public static function generateNum()&#123; //strtoupper转换成全大写的 $charid = strtoupper(md5(uniqid(mt_rand(), true))); $uuid = substr($charid, 0, 8) . substr($charid, 8, 4) . substr($charid, 12, 4) . substr($charid, 16, 4) . substr($charid, 20, 12); return $uuid;&#125;public function index(Request $request)&#123; $taskId = self::generateNum(); $hookFileName = \"task-&#123;$taskId&#125;.hook\"; $pidFilename = \"task-&#123;$taskId&#125;.pid\"; $batFilename = \"task-&#123;$taskId&#125;.bat\"; // $fp = fopen(\"E:/blog/php-script/task-&#123;$taskId&#125;.php\",'w'); // $filename = $request-&gt;input(\"param\"); $status = 0; if (file_exists(\"./&#123;$hookFileName&#125;\")) &#123; if (@unlink(\"./&#123;$hookFileName&#125;\")) &#123; //\"解码已结束\" $status = 2; &#125; else &#123; //\"解码未完成\" $status = 1; &#125; &#125; else &#123; //\"解码开始\" $status = 3; &#125; switch ($status) &#123; case 1: $text = \"解码未完成\"; break; case 2: $text = \"解码重新开始\"; break; case 3: $text = \"解码开始\"; break; default: $text = \"状态异常\"; break; &#125; $bat = fopen(\"&#123;$batFilename&#125;\", \"w\") or die(\"Unable to open file!\"); $txt = &lt;&lt;&lt;EOF@ echo offREM get cmd pidset TempFile=%TEMP%\\sthUnique.tmpwmic process where (Name=\"wmic.exe\" AND CommandLine LIKE \"%%%TIME%%%\") get ParentProcessId /value | find \"ParentProcessId\" &gt;%TempFile%set /P _string=&lt;%TempFile%set _pid=%_string:~16%echo %_pid% &gt; &#123;$pidFilename&#125; 2&gt;&amp;1:chongfuecho 666ping 127.0.1 -n \"2\"&gt;nulgoto chongfuEOF; fwrite($bat, $txt); fclose($bat); while (!file_exists(\"./&#123;$batFilename&#125;\")); echo file_exists(\"./&#123;$batFilename&#125;\") ? \"yes\" : \"no\"; $pid = popen(\"start .\\\\&#123;$batFilename&#125; &gt;&gt; &#123;$hookFileName&#125; 2&gt;&amp;1\", \"r\"); pclose($pid); return $text;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"40、zip压缩","slug":"PHP/40、zip压缩","date":"2017-09-29T02:04:41.000Z","updated":"2020-08-07T14:10:11.877Z","comments":true,"path":"2017/09/29/PHP/40、zip压缩/","link":"","permalink":"https://www.zackaddy.xin/2017/09/29/PHP/40、zip压缩/","excerpt":"","text":"压缩一个文件我们将一个文件生成一个压缩包。 1234567&lt;?php$path = \"c:/wamp/www/log.txt\";$filename = \"test.zip\";$zip = new ZipArchive();$zip-&gt;open($filename,ZipArchive::CREATE); //打开压缩包$zip-&gt;addFile($path,basename($path)); //向压缩包中添加文件$zip-&gt;close(); //关闭压缩包 上述代码将c:/wamp/www/log.txt文件压缩生成了test.zip，并保存在当前目录。 压缩多个文件压缩多个文件，其实就是addFile执行多次，可以通过数组的遍历来实现。 123456789101112&lt;?php$fileList = array( \"c:/wamp/www/log.txt\", \"c:/wamp/www/weixin.class.php\");$filename = \"test.zip\";$zip = new ZipArchive();$zip-&gt;open($filename,ZipArchive::CREATE); //打开压缩包foreach($fileList as $file)&#123; $zip-&gt;addFile($file,basename($file)); //向压缩包中添加文件&#125;$zip-&gt;close(); //关闭压缩包 压缩一个目录12345678910111213141516171819&lt;?phpfunction addFileToZip($path,$zip)&#123; $handler=opendir($path); //打开当前文件夹由$path指定。 while(($filename=readdir($handler))!==false)&#123; if($filename != \".\" &amp;&amp; $filename != \"..\")&#123;//文件夹文件名字为'.'和‘..’，不要对他们进行操作 if(is_dir($path.\"/\".$filename))&#123;// 如果读取的某个对象是文件夹，则递归 addFileToZip($path.\"/\".$filename, $zip); &#125;else&#123; //将文件加入zip对象 $zip-&gt;addFile($path.\"/\".$filename); &#125; &#125; &#125; @closedir($path);&#125;$zip=new ZipArchive();if($zip-&gt;open('rsa.zip', ZipArchive::OVERWRITE)=== TRUE)&#123; addFileToZip('rsa/', $zip); //调用方法，对要打包的根目录进行操作，并将ZipArchive的对象传递给方法 $zip-&gt;close(); //关闭处理的zip文件&#125; 压缩zip包1234567891011121314151617181920212223242526272829&lt;?phpfunction addFileToZip($path,$zip)&#123; $handler=opendir($path); //打开当前文件夹由$path指定。 while(($filename=readdir($handler))!==false)&#123; if($filename != \".\" &amp;&amp; $filename != \"..\")&#123;//文件夹文件名字为'.'和‘..’，不要对他们进行操作 if(is_dir($path.\"/\".$filename))&#123;// 如果读取的某个对象是文件夹，则递归 addFileToZip($path.\"/\".$filename, $zip); &#125;else&#123; //将文件加入zip对象 $zip-&gt;addFile($path.\"/\".$filename); &#125; &#125; &#125; @closedir($path);&#125;$zip=new ZipArchive();if($zip-&gt;open('rsa.zip', ZipArchive::OVERWRITE)=== TRUE)&#123; $path = 'rsa/'; if(is_dir($path))&#123; //给出文件夹，打包文件夹 addFileToZip($path, $zip); &#125;else if(is_array($path))&#123; //以数组形式给出文件路径 foreach($path as $file)&#123; $zip-&gt;addFile($file); &#125; &#125;else&#123; //只给出一个文件 $zip-&gt;addFile($path); &#125; $zip-&gt;close(); //关闭处理的zip文件&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"39、下载文件","slug":"PHP/39、下载文件","date":"2017-09-27T18:29:38.000Z","updated":"2020-08-07T14:10:11.877Z","comments":true,"path":"2017/09/28/PHP/39、下载文件/","link":"","permalink":"https://www.zackaddy.xin/2017/09/28/PHP/39、下载文件/","excerpt":"","text":"header() 和 fread()函数把文件直接输出到浏览器12345678910111213141516171819202122232425&lt;?php $file_name = \"down\";$file_name = \"down.zip\"; //下载文件名 $file_dir = \"./down/\"; //下载文件存放目录 //检查文件是否存在 if (! file_exists ( $file_dir . $file_name )) &#123; header('HTTP/1.1 404 NOT FOUND'); &#125; else &#123; //以只读和二进制模式打开文件 $file = fopen ( $file_dir . $file_name, \"rb\" ); //告诉浏览器这是一个文件流格式的文件 Header ( \"Content-type: application/octet-stream\" ); //请求范围的度量单位 Header ( \"Accept-Ranges: bytes\" ); //Content-Length是指定包含于请求或响应中数据的字节长度 Header ( \"Accept-Length: \" . filesize ( $file_dir . $file_name ) ); //用来告诉浏览器，文件是可以当做附件被下载，下载后的文件名称为$file_name该变量的值。 Header ( \"Content-Disposition: attachment; filename=\" . $file_name ); //读取文件内容并直接输出到浏览器 echo fread ( $file, filesize ( $file_dir . $file_name ) ); fclose ( $file ); exit (); &#125; header() 和 readfile()函数把文件直接输出到浏览器123456789$zipname = 'E:\\zhongliangjq.zip';//这里是下载zip文件header(\"Content-Type: application/zip\");header(\"Content-Transfer-Encoding: Binary\");header(\"Content-Length: \" . filesize($zipname));header(\"Content-Disposition: attachment; filename=\\\"\" . basename($zipname) . \"\\\"\");readfile($zipname);","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"38、性能监控工具","slug":"PHP/38、性能监控工具","date":"2017-09-27T03:04:29.000Z","updated":"2020-08-07T14:10:11.877Z","comments":true,"path":"2017/09/27/PHP/38、性能监控工具/","link":"","permalink":"https://www.zackaddy.xin/2017/09/27/PHP/38、性能监控工具/","excerpt":"","text":"Xdebug xhprof New Relic OneAPM","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"37、启动OPCache缓存","slug":"PHP/37、启动OPCache缓存","date":"2017-09-25T20:43:21.000Z","updated":"2020-08-07T14:10:11.876Z","comments":true,"path":"2017/09/26/PHP/37、启动OPCache缓存/","link":"","permalink":"https://www.zackaddy.xin/2017/09/26/PHP/37、启动OPCache缓存/","excerpt":"","text":"OPCache缓存简介 简介 安装/配置 windows配置 详细配置 函数操作 详细操作 OPCache缓存简介简介OPcache通过将 PHP 脚本预编译的字节码存储到共享内存中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。 PHP 5.5.0 及后续版本中已经绑定了 OPcache 扩展。 对于 PHP 5.2，5.3 和 5.4 版本可以使用 PECL扩展中的 OPcache 库。 windows配置12345678[opcache]zend_extension=\"D:\\myphp_www\\PHPTutorial\\php\\php-7.0.12-nts\\ext\\php_opcache.dll\"opcache.memory_consumption=128opcache.interned_strings_buffer=8opcache.max_accelerated_files=4000opcache.revalidate_freq=60opcache.fast_shutdown=1opcache.enable_cli=1 详细配置http://www.php.cn/manual/view/534.html 函数操作详细操作http://www.php.cn/manual/view/536.html","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"36、APCU用户缓存","slug":"PHP/36、APCU用户缓存","date":"2017-09-25T03:53:37.000Z","updated":"2020-08-07T14:10:11.876Z","comments":true,"path":"2017/09/25/PHP/36、APCU用户缓存/","link":"","permalink":"https://www.zackaddy.xin/2017/09/25/PHP/36、APCU用户缓存/","excerpt":"","text":"APCU缓存简介 简介 apc与apcu的区别 APCU缓存简介简介php5.5以后，opcache将代替apc做为php加速的位置，也就是代替其系统缓存的位置。并将用户缓存功能独立出来，开启新的组件，这个组件名称叫做apcu。 apc与apcu的区别apcu前身是apc,大家知道apc缓存分为系统缓存和用户缓存，他们的区别是什么呢? 系统缓存是指php执行时增加缓存，减少php文件的反复检查和编译，从而达到系统加速的效果。 用户缓存是指，php代码中将数据写入缓存，是用户写入的数据，通过key和value的键值方式插入和读取。这种数据叫做用户缓存。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"35、使用APC缓存","slug":"PHP/35、使用APC缓存","date":"2017-09-23T17:57:25.000Z","updated":"2020-08-07T14:10:11.876Z","comments":true,"path":"2017/09/24/PHP/35、使用APC缓存/","link":"","permalink":"https://www.zackaddy.xin/2017/09/24/PHP/35、使用APC缓存/","excerpt":"","text":"APC缓存简介 使用版本 简介 系统缓存 用户数据缓存 安装/配置 windows安装 详细配置 apc使用操作类 APC缓存简介使用版本php5.5之前版本，之后版本改用Opcache 简介APC，全称是Alternative PHP Cache，官方翻译叫”可选PHP缓存”。它为我们提供了缓存和优化PHP的中间代码的框架。 APC的缓存分两部分:系统缓存和用户数据缓存。 系统缓存系统缓存 它是指APC把PHP文件源码的编译结果缓存起来，然后在每次调用时先对比时间标记。如果未过期，则使用缓存的中间代码运行。默认缓存 3600s(一小时)。但是这样仍会浪费大量CPU时间。因此可以在php.ini中设置system缓存为永不过期(apc.ttl=0)。不过如果这样设置，改运php代码后需要重启WEB服务器。目前使用较多的是指此类缓存。 用户数据缓存缓存由用户在编写PHP代码时用apc_store和apc_fetch函数操作读取、写入的。如果数据量不大的话，可以一试。如果数据量大，使用类似memcache此类的更加专著的内存缓存方案会更好 安装/配置windows安装123http://pecl.php.net/package/APC 下载php_apc.dll打开PHP.ini添加如下代码extension=php_apc.dll 详细配置http://sg2.php.net/manual/zh/apc.configuration.php apc使用操作类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpif (!defined('IS_INITPHP')) exit('Access Denied!');class apcInit &#123; /** * Apc缓存-设置缓存 * 设置缓存key，value和缓存时间 * @param string $key KEY值 * @param string $value 值 * @param string $time 缓存时间 */ public function set_cache($key, $value, $time = 0) &#123; if ($time == 0) $time = null; //null情况下永久缓存 return apc_store($key, $value, $time);; &#125; /** * Apc缓存-获取缓存 * 通过KEY获取缓存数据 * @param string $key KEY值 */ public function get_cache($key) &#123; return apc_fetch($key); &#125; /** * Apc缓存-清除一个缓存 * 从memcache中删除一条缓存 * @param string $key KEY值 */ public function clear($key) &#123; return apc_delete($key); &#125; /** * Apc缓存-清空所有缓存 * 不建议使用该功能 * @return */ public function clear_all() &#123; apc_clear_cache('user'); //清除用户缓存 return apc_clear_cache(); //清楚缓存 &#125; /** * 检查APC缓存是否存在 * @param string $key KEY值 */ public function exists($key) &#123; return apc_exists($key); &#125; /** * 字段自增-用于记数 * @param string $key KEY值 * @param int $step 新增的step值 */ public function inc($key, $step) &#123; return apc_inc($key, (int) $step); &#125; /** * 字段自减-用于记数 * @param string $key KEY值 * @param int $step 新增的step值 */ public function dec($key, $step) &#123; return apc_dec($key, (int) $step); &#125; /** * 返回APC缓存信息 */ public function info() &#123; return apc_cache_info(); &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"34、获取windows环境内存、CPU等使用信息","slug":"PHP/34、获取windows环境内存、CPU等使用信息","date":"2017-09-22T18:03:52.000Z","updated":"2020-08-07T14:10:11.876Z","comments":true,"path":"2017/09/23/PHP/34、获取windows环境内存、CPU等使用信息/","link":"","permalink":"https://www.zackaddy.xin/2017/09/23/PHP/34、获取windows环境内存、CPU等使用信息/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135class SystemInfoWindows&#123; /** * 判断指定路径下指定文件是否存在，如不存在则创建 * @param string $fileName 文件名 * @param string $content 文件内容 * @return string 返回文件路径 */ private function getFilePath($fileName, $content) &#123; $path = dirname(FILE) . \"\\\\$fileName\"; if (!file_exists($path)) &#123; file_put_contents($path, $content); &#125; return $path; &#125; /** * 获得cpu使用率vbs文件生成函数 * @return string 返回vbs文件路径 */ private function getCupUsageVbsPath() &#123; return $this-&gt;getFilePath( 'cpu_usage.vbs', \"On Error Resume Next Set objProc = GetObject(\\\"winmgmts:\\\\\\\\.\\\\root\\cimv2:win32_processor='cpu0'\\\") WScript.Echo(objProc.LoadPercentage)\" ); &#125; /** * 获得总内存及可用物理内存JSON vbs文件生成函数 * @return string 返回vbs文件路径 */ private function getMemoryUsageVbsPath() &#123; return $this-&gt;getFilePath( 'memory_usage.vbs', \"On Error Resume Next Set objWMI = GetObject(\\\"winmgmts:\\\\\\\\.\\\\root\\cimv2\\\") Set colOS = objWMI.InstancesOf(\\\"Win32_OperatingSystem\\\") For Each objOS in colOS Wscript.Echo(\\\"&#123;\\\"\\\"TotalVisibleMemorySize\\\"\\\":\\\" &amp; objOS.TotalVisibleMemorySize &amp; \\\",\\\"\\\"FreePhysicalMemory\\\"\\\":\\\" &amp; objOS.FreePhysicalMemory &amp; \\\"&#125;\\\") Next\" ); &#125; /** * 获得CPU使用率 * @return Number */ public function getCpuUsage() &#123; $path = $this-&gt;getCupUsageVbsPath(); exec(\"cscript -nologo $path\", $usage); return $usage[0]; &#125; /** * 获得内存使用率数组 * @return array */ public function getMemoryUsage() &#123; $path = $this-&gt;getMemoryUsageVbsPath(); exec(\"cscript -nologo $path\", $usage); $memory = json_decode($usage[0], true); $memory['usage'] = Round((($memory['TotalVisibleMemorySize'] - $memory['FreePhysicalMemory']) / $memory['TotalVisibleMemorySize']) * 100); return $memory; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?phpheader(\"Content-type: text/html; charset=utf-8\");echo \"&lt;pre&gt;\\r\\n\\r\\n\"; # 系统名称、版本和类型$out = '';$info = exec('wmic os get Caption,Version,OSArchitecture',$out,$status);$osinfo_array = explode(' ',$out[1]);$osinfo = array_values(array_filter($osinfo_array));echo \"系统名称: \" . $osinfo[0] .\"\\r\\n系统版本: \" . $osinfo[2] .\"\\r\\n系统类型: \" . $osinfo[1] .\"\\r\\n\\r\\n\"; # 系统配置$out = '';$info = exec('wmic os get producttype',$out,$status); #返回 3 是server ,返回其它的是 workstationif($out[1] == 3) $osconfig = \"Server\";else $osconfig = \"Workstatio\";echo \"系统配置: \" . $osconfig . \"\\r\\n\\r\\n\"; # 已运行时长$out = '';$info = exec('wmic os get lastBootUpTime,LocalDateTime',$out,$status);$datetime_array = explode('.',$out[1]);$dt_array = explode(' ',$datetime_array[1]);$localtime = substr($datetime_array[1],-14);$boottime = $datetime_array[0];$uptime = strtotime($localtime) - strtotime($datetime_array[0]); $day=floor(($uptime)/86400);$hour=floor(($uptime)%86400/3600);$minute=floor(($uptime)%86400/60);$second=floor(($uptime)%86400%60);echo \"已运行: \".$day.\"天\".$hour.\"小时\".$minute.\"分钟\".$second.\"秒\\r\\n\\r\\n\"; # 硬盘用量$out = '';$info = exec('wmic logicaldisk get FreeSpace,size /format:list',$out,$status);$hd = '';foreach($out as $vaule)&#123; $hd .= $vaule . ' ';;&#125;$hd_array = explode(' ', trim($hd));$key = 'CDEFGHIJKLMNOPQRSTUVWXYZ';foreach($hd_array as $k =&gt; $v)&#123; $s_array = explode('Size=', $v); $fs_array = explode('FreeSpace=', $s_array[0]); $size = round(trim($s_array[1])/(1024*1024*1024), 1); $freespace = round(trim($fs_array[1])/(1024*1024*1024), 1); $drive = $key[$k]; echo $drive . \"盘,\\r\\n已用空间: \" . ($size - $freespace) . \"GB/\" . $size . \"GB\\r\\n可用空间: \" . $freespace . \"GB\\r\\n\\r\\n\";&#125; # 物理内存$out = '';$info = exec('wmic os get TotalVisibleMemorySize,FreePhysicalMemory',$out,$status);# 多个空格转为一个空格$phymem = preg_replace ( \"/\\s(?=\\s)/\",\"\\\\1\",$out[1]);$phymem_array = explode(' ',$phymem);//print_r($phymem_array);$freephymem = ceil($phymem_array[0]/1024);$totalphymem = ceil($phymem_array[1]/1024);echo \"已用物理内存: \". ($totalphymem - $freephymem) .\"MB/\". $totalphymem . \"MB\\r\\n空闲物理内存: \" . $freephymem . \"MB\\r\\n\\r\\n\"; # 虚拟内存$out = '';$info = exec('wmic os get SizeStoredInPagingFiles,FreeSpaceInPagingFiles',$out,$status);$pagemem = preg_replace ( \"/\\s(?=\\s)/\",\"\\\\1\",$out[1]);$pagemem_array = explode(' ',$pagemem);$freepagemem = ceil($pagemem_array[0]/1024);$totalpagemem = ceil($pagemem_array[1]/1024);echo \"已用虚拟内存: \". ($totalpagemem - $freepagemem) .\"MB/\". $totalpagemem . \"MB\\r\\n空闲虚拟内存: \" . $freepagemem . \"MB\\r\\n\\r\\n\"; # 网卡名称$out = '';$info = exec('wmic nic list brief',$out,$status);$nic_array = explode(' ', $out[2], 2);$nic = $nic_array[0];echo \"当前网卡名称: \" . $nic . \"\\r\\n\\r\\n\"; # 网卡流量，最初计量为字节$out = '';$info = exec('netstat -e',$out,$status);$out_array = array();foreach ($out as $key =&gt; $value) &#123; $out_array[$key] = mb_convert_encoding ($value, 'utf-8', 'GBK');&#125;$net = preg_replace ( \"/\\s(?=\\s)/\",\"\\\\1\",$out_array[4]);$net_array = explode(' ',$net);echo \"当前数据流量\\r\\n已接收: \" .round($net_array[1]/(1024*1024), 3) . \"MB\\r\\n已发送: \" . round($net_array[2]/(1024*1024), 3) . \"MB\\r\\n\\r\\n\"; //$out = '';//$info = exec('wmic os get /all /format:list',$out,$status);//print_r($out); # 电脑信息//$out = '';//$info = exec('systeminfo',$out,$status);//print_r($out); //$info = exec('ipconfig',$out,$status);//print_r($out);//$out = ''; # 执行批处理，需要绝对路径//$info = exec('C:/Users/Administrator/Downloads/www/mem.bat',$out,$status);//print_r($out); //$out = '';//$info = exec('net statistics workstation | find \"Statistics since 统计数据开始于\"',$out,$status);//$boottime = preg_replace ( \"/\\s(?=\\s)/\",\"\\\\1\",$out[0]);//$boottime_array = explode(' ',$boottime,2);//echo $boottime_array[1];","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"33、查询操作系统版本","slug":"PHP/33、查询操作系统版本","date":"2017-09-22T04:47:46.000Z","updated":"2020-08-07T14:10:11.875Z","comments":true,"path":"2017/09/22/PHP/33、查询操作系统版本/","link":"","permalink":"https://www.zackaddy.xin/2017/09/22/PHP/33、查询操作系统版本/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public function getOS($isuser = false) &#123; $os = ''; $Agent = $isuser ? $_SERVER['HTTP_USER_AGENT'] : php_uname(); if (preg_match('/win/im', $Agent) &amp;&amp; strpos($Agent, '95')) &#123; $os = 'Windows 95'; &#125; elseif (preg_match('/win 9x/im', $Agent) &amp;&amp; strpos($Agent, '4.90')) &#123; $os = 'Windows ME'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/98/im', $Agent)) &#123; $os = 'Windows 98'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt.*5\\.0/im', $Agent)) &#123; $os = 'Windows 2000'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt.*6\\.0/im', $Agent)) &#123; $os = 'Windows Vista'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt.*6\\.1/im', $Agent)) &#123; $os = 'Windows 7'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt.*5\\.1/im', $Agent)) &#123; $os = 'Windows XP'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt.*10\\.0/im', $Agent)) &#123; $os = 'Windows 10'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/nt/im', $Agent)) &#123; $os = 'Windows NT'; &#125; elseif (preg_match('/win/im', $Agent) &amp;&amp; preg_match('/32/im', $Agent)) &#123; $os = 'Windows 32'; &#125; elseif (preg_match('/linux/im', $Agent)) &#123; $os = 'Linux'; &#125; elseif (preg_match('/unix/im', $Agent)) &#123; $os = 'Unix'; &#125; else if (preg_match('/sun/im', $Agent) &amp;&amp; preg_match('os', $Agent)) &#123; $os = 'SunOS'; &#125; elseif (preg_match('/ibm/im', $Agent) &amp;&amp; preg_match('os', $Agent)) &#123; $os = 'IBM OS/2'; &#125; elseif (preg_match('/Mac/im', $Agent) &amp;&amp; preg_match('PC', $Agent)) &#123; $os = 'Macintosh'; &#125; elseif (preg_match('/PowerPC/im', $Agent)) &#123; $os = 'PowerPC'; &#125; elseif (preg_match('/AIX/im', $Agent)) &#123; $os = 'AIX'; &#125; elseif (preg_match('/HPUX/im', $Agent)) &#123; $os = 'HPUX'; &#125; elseif (preg_match('/NetBSD/im', $Agent)) &#123; $os = 'NetBSD'; &#125; elseif (preg_match('/BSD/im', $Agent)) &#123; $os = 'BSD'; &#125; elseif (ereg('/OSF1/im', $Agent)) &#123; $os = 'OSF1'; &#125; elseif (ereg('/IRIX/im', $Agent)) &#123; $os = 'IRIX'; &#125; elseif (preg_match('/FreeBSD/im', $Agent)) &#123; $os = 'FreeBSD'; &#125; elseif ($os == '') &#123; $os = 'Unknown'; &#125; return $os; &#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"31、抽象类与接口的配合","slug":"PHP/31、抽象类与接口的配合","date":"2017-09-21T03:35:49.000Z","updated":"2020-08-07T14:10:11.875Z","comments":true,"path":"2017/09/21/PHP/31、抽象类与接口的配合/","link":"","permalink":"https://www.zackaddy.xin/2017/09/21/PHP/31、抽象类与接口的配合/","excerpt":"","text":"接口用来提供功能函数 抽象类（将具体进行抽象，如学生、老师可以抽象为人，三角形、矩形可以抽象为形状，防盗门、大铁门抽象为门）用来提供模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpinterface Alarm&#123; public function alarm();&#125;interface Toggle&#123; public function open(); public function close();&#125;abstract class Door implements Toggle&#123; public $name = 'default'; public $color = 'default'; public function desc() &#123; echo \"这是一个名为：&#123;$this-&gt;name&#125;的门，它的颜色是&#123;$this-&gt;color&#125;的\"; &#125; public function setName($name) &#123; $this-&gt;name = $name; &#125;&#125;abstract class NaoZhong implements Alarm&#123;&#125;/** * 门，拥有警报功能 */class DoorAlarm extends Door implements Alarm&#123; public function open() &#123; echo \"有警报的门被打开了\" . \"&lt;br&gt;\"; &#125; public function close() &#123; echo \"有警报的门被关闭了\" . \"&lt;br&gt;\"; &#125; public function alarm() &#123; echo \"有警报的门被关闭了\" . \"&lt;br&gt;\"; &#125;&#125;/** * 警报器，拥有门的功能 */class AlarmDoor extends NaoZhong implements Toggle&#123; public function open() &#123; echo \"警报器被打开了\" . \"&lt;br&gt;\"; &#125; public function close() &#123; echo \"警报器被关闭了\" . \"&lt;br&gt;\"; &#125; public function alarm() &#123; echo \"警报器发出警报\" . \"&lt;br&gt;\"; &#125;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"30、多文件上传","slug":"PHP/30、多文件上传","date":"2017-09-20T04:45:52.000Z","updated":"2020-08-07T14:10:11.874Z","comments":true,"path":"2017/09/20/PHP/30、多文件上传/","link":"","permalink":"https://www.zackaddy.xin/2017/09/20/PHP/30、多文件上传/","excerpt":"","text":"多文件上传表单有如下两种形式1234567&lt;form action=\"doAction.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; 请选择我的上传文件 &lt;input type=\"file\" name=\"myfile[]\"/&gt; &lt;input type=\"file\" name=\"myfile[]\" /&gt; &lt;input type=\"file\" name=\"myfile[]\" /&gt; &lt;input type=\"submit\" value=\"上传\" /&gt;&lt;/form&gt; 1234567&lt;form action=\"doAction.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; 请选择我的上传文件 &lt;input type=\"file\" name=\"myfil1\"/&gt; &lt;input type=\"file\" name=\"myfil2\"/&gt; &lt;input type=\"file\" name=\"myfil3\"/&gt; &lt;input type=\"submit\" value=\"上传\" /&gt; &lt;/form&gt; 显然我们处理第二种格式的FILES更加方便。当然我们也可以想办法将第一种格式的_FILES转化为第二种形式，如下1234567891011121314151617181920212223function getFiles()&#123; foreach($_FILES as $file)&#123; $fileNum=count($file['name']); if ($fileNum==1) &#123; $files=$file; &#125;else&#123; for ($i=0; $i &lt; $fileNum; $i++) &#123; $files[$i]['name']=$file['name'][$i]; $files[$i]['type']=$file['type'][$i]; $files[$i]['tmp_name']=$file['tmp_name'][$i]; $files[$i]['error']=$file['error'][$i]; $files[$i]['size']=$file['size'][$i]; &#125; &#125; &#125; return $files;&#125; 文件上传代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071function uploadFile($file,$path='./uploads',$max_size,$allowExt)&#123; $filename=$file['name']; $type=$file['type']; $temp_name=$file['tmp_name']; $error=$file['error']; $size=$file['size']; if ($error==UPLOAD_ERR_OK) &#123; if ($size&gt;$max_size) &#123; $res['mes']=$filename.\"文件超过规定上传大小\"; &#125; $ext=getExt($filename); if (!in_array($ext, $allowExt)) &#123; $res['mes']=$filename.'文件名不合乎规范'; &#125; if (!is_uploaded_file($temp_name)) &#123; $res['mes']=$filename.\"文件不是通过HTTP POST 方法上传上传过来的\"; &#125; if (@$res) &#123; return $res; &#125; if (!file_exists($path)) &#123; mkdir($path,0777,true); chmod($path, 0777); &#125; $fname=getUniName(); $destination=$path.'/'.$fname.'.'.$ext; if (move_uploaded_file($temp_name, $destination)) &#123; $res['mes']=$filename.'上传成功'; $res['dest']=$destination; &#125;else&#123; $res['mes']=$filename.\"文件上传失败\"; &#125; &#125;else&#123; switch ($error) &#123; case '1': $res['mes']=\"超过了配置文件上传文件的大小\"; break; case '2': $res['mes']=\"超过表单设置上传文件文件的大小\"; break; case '3': $res['mes']=\"文件部分被上传\"; break; case '4': $res['mes']=\"没有文件被上传\"; break; case '6': $res['mes']=\"没有找到临时目录\"; break; case '7': $res['mes']=\"文件不可写\"; break; default: $res['mes']=\"上传文件失败\"; break; &#125; &#125; return $res;&#125; 123456789101112131415161718/** * 获得文件扩展名 * @param string $filename 上传文件名 * @return string 返回扩展名 */function getExt($filename)&#123; $arr=explode('.', basename($filename)); return end($arr);&#125;/** * 获得文件唯一扩展名 * @return string 经过md5后生成32位唯一的上传文件名 */function getUniName()&#123; return md5(uniqid(microtime(true),true)); &#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"29、Closure动态添加类属性方法，你不知道的一些东西","slug":"PHP/29、Closure动态添加类属性方法，你不知道的一些东西","date":"2017-09-19T01:55:59.000Z","updated":"2020-08-07T14:10:11.874Z","comments":true,"path":"2017/09/19/PHP/29、Closure动态添加类属性方法，你不知道的一些东西/","link":"","permalink":"https://www.zackaddy.xin/2017/09/19/PHP/29、Closure动态添加类属性方法，你不知道的一些东西/","excerpt":"","text":"让我们看看错误的用法 给类动态添加静态属性 12345678910&lt;?phperror_reporting(E_ALL);class A&#123;&#125;$a = new A();A::$say = 8; //报错。赋值函数也一样echo A::$say; 给类动态添加静态函数 12345678910&lt;?phperror_reporting(E_ALL);class A&#123;&#125;$a = new A();A::$say = function()&#123;&#125;; //报错A::$say(); 给类动态添加实例函数 1234567891011121314&lt;?phperror_reporting(E_ALL);class A&#123; public function getSay() &#123; echo $this-&gt;say; &#125;&#125;$a = new A();$a-&gt;say = function() &#123;&#125;; //此处不报错，调用时报错$a-&gt;say();//此处报错 让我们看个正确的用法 给类动态添加实例属性 123456789class A&#123; function getSay() &#123; echo $this-&gt;say; &#125;&#125;$a = new A();$a-&gt;say = 8;$a-&gt;getSay(); 问题来了，我们想要这样添加如何做到？看下放实例 Closure 接口 12345Closure &#123; __construct ( void ) public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"28、让类支持数组形式访问","slug":"PHP/28、让类支持数组形式访问","date":"2017-09-17T23:09:23.000Z","updated":"2020-08-07T14:10:11.874Z","comments":true,"path":"2017/09/18/PHP/28、让类支持数组形式访问/","link":"","permalink":"https://www.zackaddy.xin/2017/09/18/PHP/28、让类支持数组形式访问/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass obj implements arrayaccess &#123; private $container = array(); public function __construct () &#123; $this -&gt; container = array( \"one\" =&gt; 1 , \"two\" =&gt; 2 , \"three\" =&gt; 3 , ); &#125; //$obj [ \"two\" ] = 5 //$obj [] = 5 public function offsetSet ( $offset , $value ) &#123; if ( is_null ( $offset )) &#123; $this -&gt; container [] = $value ; &#125; else &#123; $this -&gt; container [ $offset ] = $value ; &#125; &#125; //isset($obj [ \"two\" ]); public function offsetExists ( $offset ) &#123; echo \"offsetExists\".\"&lt;br&gt;\"; return isset( $this -&gt; container [ $offset ]); &#125; //unset( $obj [ \"two\" ]); public function offsetUnset ( $offset ) &#123; echo \"offsetUnset\".\"&lt;br&gt;\"; unset( $this -&gt; container [ $offset ]); &#125; //$obj [ \"two\" ]; public function offsetGet ( $offset ) &#123; echo \"offsetGet\".\"&lt;br&gt;\"; return isset( $this -&gt; container [ $offset ]) ? $this -&gt; container [ $offset ] : null ; &#125;&#125;$obj = new obj ;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"27、修改session你必须了解的知识","slug":"PHP/27、修改session你必须了解的知识","date":"2017-09-17T02:48:29.000Z","updated":"2020-08-07T14:10:11.873Z","comments":true,"path":"2017/09/17/PHP/27、修改session你必须了解的知识/","link":"","permalink":"https://www.zackaddy.xin/2017/09/17/PHP/27、修改session你必须了解的知识/","excerpt":"","text":"1. php.ini关于Session的相关设置 （打开php.ini文件，在“[Session]”部分）： session.use_cookies：默认的值是“1”，代表SessionID使用Cookie来传递，反之就是使用Query_String来传递； session.name: 这个就是SessionID储存的变量名称，可能是Cookie，也可能是Query_String来传递，默认值是“PHPSESSID”； session.cookie_lifetime：这个代表SessionID在客户端Cookie储存的时间，默认是0，代表浏览器一关闭SessionID就作废……就是因为这个所以Session不能永久使用！ session.gc_maxlifetime：这个是Session数据在服务器端储存的时间，如果超过这个时间，那么Session数据就自动删除！ 修改SESSION的生存时间，我们来手动设置 Session 的生存期： 通过setcookie设置过期时间 1234567// 1＜?php session_start(); // 保存一天 $lifeTime = 24 * 3600; setcookie(session_name(), session_id(), time() + $lifeTime, \"/\");?＞ 通过session_set_cookie_params设置过期时间如果客户端使用 IE 6.0会有问题，推荐上方设置 1234567＜?php // 保存一天 $lifeTime = 24 * 3600; session_set_cookie_params($lifeTime); session_start(); $_SESSION[\"admin\"] = true; ?＞ 服务端session“回收”何时发生？ 默认情况下，每一次php请求，就会有1/100的概率发生回收所以可能简单的理解为“每100次php请求就有一次回收发生”这个概率是通过以下参数控制的 123#概率是gc_probability/gc_divisor session.gc_probability = 1 session.gc_divisor = 100 ==注意1：假设这种情况gc_maxlifetime=120，如果某个session文件最后修改时间是120秒之前，那么在下一次回收（1/100的概率）发生前，这个session仍然是有效的。== ==注意2：如果你的session使用session.save_path中使用别的地方保存session，session回收机制有可能不会自动处理过期session文件。这时需要定时手动（或者crontab）的删除过期的session：cd /path/to/sessions; find -cmin +24 | xargs rm== PHP设置与获取Session 设置session 1234 &lt;?php session_start(); //设置一个session值 $_SESSION[\"name\"] = \"Hello\"; //将session以数组形式保存 $_SESSION[\"arr\"] = array('name' =&gt; 'Hello', 'url' =&gt; 'http://www.helloweba.com', 'type'=&gt; 'website'); ?&gt; 获取session 12345 &lt;?php session_start(); //获取保存的Session name echo $_SESSION[\"name\"]; //打印数组session print_r($_SESSION[\"arr\"]); ?&gt; 删除session内的变量 1&lt;?php unset($_SESSION[\"name\"]); ?&gt; 删除服务端session文件 1session_destory(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Session&#123; /** * 设置session * @param String $name session name * @param Mixed $data session data * @param Int $expire 超时时间(秒) */ public static function set($name, $data, $expire=600)&#123; $session_data = array(); $session_data['data'] = $data; $session_data['expire'] = time()+$expire; $_SESSION[$name] = $session_data; &#125; /** * 读取session * @param String $name session name * @return Mixed */ public static function get($name)&#123; if(isset($_SESSION[$name]))&#123; if($_SESSION[$name]['expire']&gt;time())&#123; return $_SESSION[$name]['data']; &#125;else&#123; self::clear($name); &#125; &#125; return false; &#125; /** * 清除session * @param String $name session name */ private static function clear($name)&#123; unset($_SESSION[$name]); &#125; &#125; demo.php session_start(); $data = '123456'; session::set('test', $data, 10); echo session::get('test'); // 未过期，输出 sleep(10); echo session::get('test'); // 已过期","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"26、需要知道的全局变量","slug":"PHP/26、需要知道的全局变量","date":"2017-09-15T21:22:07.000Z","updated":"2020-08-07T14:10:11.873Z","comments":true,"path":"2017/09/16/PHP/26、需要知道的全局变量/","link":"","permalink":"https://www.zackaddy.xin/2017/09/16/PHP/26、需要知道的全局变量/","excerpt":"","text":"1. $GLOBALS 以$开头定义的变量可以从$GLOBALS中渠道 2. $_GET 访问 http://example.com/?name=Hannes 123456&lt;?phpecho 'Hello ' . htmlspecialchars ( $_GET [ \"name\" ]) . '!' ;?&gt;//结果Hello Hannes! 3. $_POST 假设用户通过 HTTP POST 方式传递了参数 name=Hannes 123456&lt;?phpecho 'Hello ' . htmlspecialchars ( $_POST [ \"name\" ]) . '!' ;?&gt;//结果Hello Hannes! 4. $_FILES $_FILES[‘userfile’][‘name’]客户端机器文件的原名称。 $_FILES[‘userfile’][‘type’]文件的 MIME 类型，如果浏览器提供此信息的话。一个例子是“image/gif”。不过此MIME类型在PHP端并不检查，因此不要想当然认为有这个值。 $_FILES[‘userfile’][‘size’]已上传文件的大小，单位为字节。 $_FILES[‘userfile’][‘tmp_name’]文件被上传后在服务端储存的临时文件名。 $_FILES[‘userfile’][‘error’]和该文件上传相关的错误代码","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"25、高大上的生成器","slug":"PHP/25、高大上的生成器","date":"2017-09-15T02:48:02.000Z","updated":"2020-08-07T14:10:11.873Z","comments":true,"path":"2017/09/15/PHP/25、高大上的生成器/","link":"","permalink":"https://www.zackaddy.xin/2017/09/15/PHP/25、高大上的生成器/","excerpt":"","text":"生成器的接口实现1234567891011Generator implements Iterator &#123; /* 方法 */ public mixed current ( void ) public mixed key ( void ) public void next ( void ) public void rewind ( void ) public mixed send ( mixed $value ) public void throw ( Exception $exception ) public bool valid ( void ) public void __wakeup ( void )&#125; 简单事例1234567891011121314&lt;?phpfunction gen_one_to_three () &#123; for ( $i = 1 ; $i &lt;= 3 ; $i ++) &#123; //注意变量$i的值在不同的yield之间是保持传递的。 yield $i ; &#125;&#125;$generator = gen_one_to_three ();foreach ( $generator as $value ) &#123; echo \" $value \\n\" ;&#125;?&gt;// 123 如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的： $data = (yield $value); 而这样就不合法，并且在PHP5中会产生一个编译错误： $data = yield $value; 再看个手动控制1234567891011&lt;?phpfunction gen() &#123; $str = (yield 'str'); echo $str.\"&lt;br&gt;\"; yield 888;&#125;$g = gen();echo $g-&gt;current();echo $g-&gt;send(666);// str 666 888","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"24、使用自己的异常类","slug":"PHP/24、使用自己的异常类","date":"2017-09-14T03:48:30.000Z","updated":"2020-08-07T14:10:11.873Z","comments":true,"path":"2017/09/14/PHP/24、使用自己的异常类/","link":"","permalink":"https://www.zackaddy.xin/2017/09/14/PHP/24、使用自己的异常类/","excerpt":"","text":"系统的Exception类123456789101112131415161718192021222324252627&lt;?phpclass Exception&#123; protected $message = 'Unknown exception' ; // 异常信息 private $string ; // __toString cache protected $code = 0 ; // 用户自定义异常代码 protected $file ; // 发生异常的文件名 protected $line ; // 发生异常的代码行号 private $trace ; // backtrace private $previous ; // previous exception if nested exception public function __construct ( $message = null , $code = 0 , Exception $previous = null ); final private function __clone (); // Inhibits cloning of exceptions. final public function getMessage (); // 返回异常信息 final public function getCode (); // 返回异常代码 final public function getFile (); // 返回发生异常的文件名 final public function getLine (); // 返回发生异常的代码行号 final public function getTrace (); // backtrace() 数组 final public function getPrevious (); // 之前的 exception final public function getTraceAsString (); // 已格成化成字符串的 getTrace() 信息 // Overrideable public function __toString (); // 可输出的字符串&#125;?&gt; 下方为我们自己定义的异常类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?phpclass MyException extends Exception&#123; // 重定义构造器使 message 变为必须被指定的属性 public function __construct ( $message , $code = 0 , Exception $previous = null ) &#123; // 自定义的代码 // 确保所有变量都被正确赋值 parent :: __construct ( $message , $code , $previous ); &#125; // 自定义字符串输出的样式 public function __toString () &#123; return __CLASS__ . \": [ &#123; $this -&gt; code &#125; ]: &#123; $this -&gt; message &#125; \\n\" ; &#125; public function customFunction () &#123; echo \"A custom function for this type of exception\\n\" ; &#125;&#125;class TestException&#123; public $var ; const THROW_NONE = 0 ; const THROW_CUSTOM = 1 ; const THROW_DEFAULT = 2 ; function __construct ( $avalue = self :: THROW_NONE ) &#123; switch ( $avalue ) &#123; case self :: THROW_CUSTOM : // 抛出自定义异常 throw new MyException ( '1 is an invalid parameter' , 5 ); break; case self :: THROW_DEFAULT : // 抛出默认的异常 throw new Exception ( '2 is not allowed as a parameter' , 6 ); break; default: // 没有异常的情况下，创建一个对象 $this -&gt; var = $avalue ; break; &#125; &#125;&#125;// 例子 1try &#123; $o = new TestException ( TestException :: THROW_CUSTOM );&#125; catch ( MyException $e ) &#123; // 捕获异常 echo \"Caught my exception\\n\" , $e ; $e -&gt; customFunction ();&#125; catch ( Exception $e ) &#123; // 被忽略 echo \"Caught Default Exception\\n\" , $e ;&#125;// Continue executionvar_dump ( $o ); // Nullecho \"\\n\\n\" ;// 例子 2try &#123; $o = new TestException ( TestException :: THROW_DEFAULT );&#125; catch ( MyException $e ) &#123; // 不能匹配异常的种类，被忽略 echo \"Caught my exception\\n\" , $e ; $e -&gt; customFunction ();&#125; catch ( Exception $e ) &#123; // 捕获异常 echo \"Caught Default Exception\\n\" , $e ;&#125;// 执行后续代码var_dump ( $o ); // Nullecho \"\\n\\n\" ;// 例子 3try &#123; $o = new TestException ( TestException :: THROW_CUSTOM );&#125; catch ( Exception $e ) &#123; // 捕获异常 echo \"Default Exception caught\\n\" , $e ;&#125;// 执行后续代码var_dump ( $o ); // Nullecho \"\\n\\n\" ;// 例子 4try &#123; $o = new TestException ();&#125; catch ( Exception $e ) &#123; // 没有异常，被忽略 echo \"Default Exception caught\\n\" , $e ;&#125;// 执行后续代码var_dump ( $o ); // TestExceptionecho \"\\n\\n\" ;?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"23、受命名空间影响的定义","slug":"PHP/23、受命名空间影响的定义","date":"2017-09-12T23:47:22.000Z","updated":"2020-08-07T14:10:11.872Z","comments":true,"path":"2017/09/13/PHP/23、受命名空间影响的定义/","link":"","permalink":"https://www.zackaddy.xin/2017/09/13/PHP/23、受命名空间影响的定义/","excerpt":"","text":"只有以下类型的代码受命名空间的影响，它们是： 类（包括抽象类和traits） 接口 函数 const 常量 define 常量","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"22、对象序列化","slug":"PHP/22、对象序列化","date":"2017-09-11T20:09:15.000Z","updated":"2020-08-07T14:10:11.872Z","comments":true,"path":"2017/09/12/PHP/22、对象序列化/","link":"","permalink":"https://www.zackaddy.xin/2017/09/12/PHP/22、对象序列化/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031&lt;?php// classa.inc: class A &#123; public $one = 1 ; public function show_one () &#123; echo $this -&gt; one ; &#125; &#125; // page1.php: include( \"classa.inc\" ); $a = new A ; $s = serialize ( $a ); // 把变量$s保存起来以便文件page2.php能够读到 file_put_contents ( 'store' , $s );// page2.php: // 要正确了解序列化，必须包含下面一个文件 include( \"classa.inc\" ); $s = file_get_contents ( 'store' ); $a = unserialize ( $s ); // 现在可以使用对象$a里面的函数 show_one() $a -&gt; show_one ();?&gt; 继承序列化接口，更灵活的控制1234Serializable &#123; abstract public string serialize ( void ) abstract public mixed unserialize ( string $serialized )&#125; 123456789101112131415161718192021222324&lt;?phpclass obj implements Serializable &#123; private $data ; public function __construct () &#123; $this -&gt; data = \"My private data\" ; &#125; public function serialize () &#123; return serialize ( $this -&gt; data ); &#125; public function unserialize ( $data ) &#123; $this -&gt; data = unserialize ( $data ); &#125; public function getData () &#123; return $this -&gt; data ; &#125;&#125;$obj = new obj ;$ser = serialize ( $obj );$newobj = unserialize ( $ser );var_dump ( $newobj -&gt; getData ());?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"21、对象或数组之间的比较","slug":"PHP/21、对象或数组之间的比较","date":"2017-09-10T18:22:59.000Z","updated":"2020-08-07T14:10:11.872Z","comments":true,"path":"2017/09/11/PHP/21、对象或数组之间的比较/","link":"","permalink":"https://www.zackaddy.xin/2017/09/11/PHP/21、对象或数组之间的比较/","excerpt":"","text":"数组之间相等的比较 不判断地址 判断key、value、长度 ==判断长度与key,value是否相同 ===会多判断一条：顺序是否相同 如下 12345$a = array(\"apple\", \"banana\");$b = array(1 =&gt; \"banana\", \"0\" =&gt; \"apple\");var_dump($a == $b); // bool(true)var_dump($a === $b); // bool(false) 对象之间的比较 ==判断对象内属性是否相同，对象内的属性比较根据外层比较符号判断，外层用== 内层属性也用== 外层用=== 内层也用=== ===会多判断一条，两个对象地址是否相同","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"20、Final你需要知道","slug":"PHP/20、Final你需要知道","date":"2017-09-10T00:19:03.000Z","updated":"2020-08-07T14:10:11.872Z","comments":true,"path":"2017/09/10/PHP/20、Final你需要知道/","link":"","permalink":"https://www.zackaddy.xin/2017/09/10/PHP/20、Final你需要知道/","excerpt":"","text":"PHP 5 新增了一个 final 关键字。 如果父类中的方法被声明为final，则子类无法覆盖该方法。 如果一个类被声明为 final，则不能被继承。 123456789101112131415161718&lt;?phpclass BaseClass &#123; public function test () &#123; echo \"BaseClass::test() called\\n\" ; &#125; final public function moreTesting () &#123; echo \"BaseClass::moreTesting() called\\n\" ; &#125;&#125;class ChildClass extends BaseClass &#123; public function moreTesting () &#123; echo \"ChildClass::moreTesting() called\\n\" ; &#125;&#125;// 报错?&gt; 12345678910111213141516&lt;?phpfinal class BaseClass &#123; public function test () &#123; echo \"BaseClass::test() called\\n\" ; &#125; // 这里无论你是否将方法声明为final，都没有关系 final public function moreTesting () &#123; echo \"BaseClass::moreTesting() called\\n\" ; &#125;&#125;class ChildClass extends BaseClass &#123;&#125;// 产生 Fatal error: Class ChildClass may not inherit from final class (BaseClass)?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"19、序列化之魔术方面","slug":"PHP/19、序列化之魔术方面","date":"2017-09-08T18:24:02.000Z","updated":"2020-08-07T14:10:11.871Z","comments":true,"path":"2017/09/09/PHP/19、序列化之魔术方面/","link":"","permalink":"https://www.zackaddy.xin/2017/09/09/PHP/19、序列化之魔术方面/","excerpt":"","text":"__sleep() 触发事件：对象被序列化之前 作用：返回需要被序列化存储的成员属性，删减不必要 返回：array 需要被序列化存储的成员属性数组 __wakeup() 触发事件：类的实例的序列化串被反序列化时 作用：预先准备对象资源 返回：void 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php class Person&#123; private $name, $age, $sex, $info; public function __construct( $name, $age, $sex ) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; $this-&gt;info = sprintf(\"prepared by construct magic functionname: %s age: %d sex: %s\", $this-&gt;name, $this-&gt;age, $this-&gt;sex); &#125; public function getInfo() &#123; echo $this-&gt;info . PHP_EOL; &#125; /** * serialize前调用 用于删选需要被序列化存储的成员变量 * @return array [description] */ public function __sleep() &#123; echo __METHOD__ . PHP_EOL; //序列化时只会存储 name age sex, info 不会被序列化 return ['name', 'age', 'sex']; &#125; /** * unserialize前调用 用于预先准备对象资源 */ public function __wakeup() &#123; echo __METHOD__ . PHP_EOL; $this-&gt;info = sprintf(\"prepared by wakeup magic function name: %s age: %d sex: %s\", $this-&gt;name, $this-&gt;age, $this-&gt;sex); &#125;&#125;$boy = new Person( 'sallency', 25, 'male' );//构造函数组装的 $info$boy-&gt;getInfo();//序列化时并不会存储 $info 属性$temp = serialize($boy);echo $temp . PHP_EOL;//反序列化时会调用 __wakeup() 函数$boy = unserialize($temp);//__wakeup() 组装的 $info$boy-&gt;getInfo();?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"18、魔术方法很6看你如何秀操作","slug":"PHP/18、魔术方法很6看你如何秀操作","date":"2017-09-08T01:04:56.000Z","updated":"2020-08-07T14:10:11.871Z","comments":true,"path":"2017/09/08/PHP/18、魔术方法很6看你如何秀操作/","link":"","permalink":"https://www.zackaddy.xin/2017/09/08/PHP/18、魔术方法很6看你如何秀操作/","excerpt":"","text":"1. __construct()123类被初始化时调用，这个不错不用手动初始化了class A&#123; public function __construct()&#123;echo \"A __construct\"&#125; &#125;new A; // A __construct 2. __destruct()1类销毁前自动调用，收尾工作就交给这个了 3. __call()123456789101112131415调用一个不存在或私有的函数时触发，防止报错？。。。看你怎么用了&lt;?phperror_reporting(E_ALL);class foo&#123; function __call($name, $param)&#123; echo '你调用的函数名是' . $name; echo '调用参数是' . implode(',', $param); &#125; private function say() &#123; echo \"foo say\"; &#125;&#125;$f = new foo;$f-&gt;say();//你调用的函数名是say调用参数是 4. __callStatic()12345678910111213141516171819202122调用一个不存在静态函数时触发，防止报错？。。。看你怎么用了&lt;?phperror_reporting(E_ALL);class foo&#123; function __call($name, $param)&#123; echo '你调用的函数名是' . $name; echo '调用参数是' . implode(',', $param); &#125; private function say() &#123; echo \"foo say\"; &#125; public static function __callStatic($name, $arguments) &#123; // 注意: $name 的值区分大小写 echo \"Calling static method '$name' \" . implode(', ', $arguments). \"\\n\"; &#125;&#125;$f = new foo;$f::say();//Calling static method 'say' 5. __toString()12345678910111213141516171819很简单 不说了&lt;?php// Declare a simple classclass TestClass&#123; public $foo; public function __construct($foo) &#123; $this-&gt;foo = $foo; &#125; public function __toString() &#123; return $this-&gt;foo; &#125;&#125;$class = new TestClass('Hello');echo $class;?&gt; 6. __clone()123456789101112131. 通过clone关键字触发对象内的__call()方法2. 只要通过clone关键字克隆，就算__clone()不做任何处理，两个对象的地址也不相同了 $obj2 = clone $obj 那么 $obj与$obj2的地址是不同的， 但是它们内部的属性如果有地址这个说法，那么它们是相同的，属于浅复制 注意：php中数组判断相等不判断地址而判断key与value与长度 ==判断长度与key,value是否相同，===会多判断一条：顺序是否相同，如下 $a = array(\"apple\", \"banana\"); $b = array(1 =&gt; \"banana\", \"0\" =&gt; \"apple\"); var_dump($a == $b); // bool(true) var_dump($a === $b); // bool(false) 注意：对象之间的比较： ==判断属性是否相同，===会多判断，两个对象地址是否相同 7. __invoke()123456789101112//函数形式执行对象&lt;?phperror_reporting(E_ALL);class A&#123; public function __invoke() &#123; echo \"6666\"; &#125;&#125;(new A())();// 6666 8. __set_state()123456789101112131415161718192021222324252627281. 配合var_export(对象,true)，eval使用2. eval时才会调用__set_state&lt;?phperror_reporting(E_ALL);class C &#123; private $prop; public function __construct($val) &#123; $this-&gt;prop = $val; &#125; /** * @return array */ public function __debugInfo() &#123; echo 666; return [ 'propSquared' =&gt; $this-&gt;prop ** 2, ]; &#125; public static function __set_state($properties) &#123; echo \"ds465sd64sads5\"; &#125;&#125;$b = var_export(new C(42),true);eval('$new='.$b.';');// ds465sd64sads5 9. __debugInfo()123456789101112131415161718192021&lt;?phpclass C &#123; private $prop ; public function __construct ( $val ) &#123; $this -&gt; prop = $val ; &#125; public function __debugInfo () &#123; return [ 'propSquared' =&gt; $this -&gt; prop ** 2 , ]; &#125;&#125;var_dump (new C ( 42 ));?&gt;object(C)#1 (1) &#123; [\"propSquared\"]=&gt; int(1764)&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"17、给类加个可foreach遍历功能，看起来很吊","slug":"PHP/17、给类加个可foreach遍历功能，看起来很吊","date":"2017-09-07T01:14:35.000Z","updated":"2020-08-07T14:10:11.871Z","comments":true,"path":"2017/09/07/PHP/17、给类加个可foreach遍历功能，看起来很吊/","link":"","permalink":"https://www.zackaddy.xin/2017/09/07/PHP/17、给类加个可foreach遍历功能，看起来很吊/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849error_reporting(E_ALL);class MyIterator implements Iterator&#123; private $var = array(); public function __construct ( $array ) &#123; if ( is_array ( $array )) &#123; $this -&gt; var = $array ; &#125; &#125; public function rewind () &#123; echo \"reset-&gt;\" ; reset ( $this -&gt; var ); &#125; public function current () &#123; $var = current ( $this -&gt; var ); echo \"current: $var -&gt;\" ; return $var ; &#125; public function key () &#123; $var = key ( $this -&gt; var ); echo \"key: $var -&gt;\" ; return $var ; &#125; public function next () &#123; $var = next ( $this -&gt; var ); echo \"next: $var -&gt;\" ; return $var ; &#125; public function valid () &#123; $var = $this -&gt; current () !== false ; echo \"value: &#123; $var &#125; -&gt;\" ; return $var ; &#125;&#125;$values = array( 1 , 2 , 3 );$it = new MyIterator ( $values );foreach ( $it as $a =&gt; $b ) &#123; print \"【 $a : $b 】\".'&lt;br&gt;' ;&#125; 1234reset-&gt;current: 1 -&gt;value: &#123; 1 &#125; -&gt;current: 1 -&gt;key: 0 -&gt;【 0 : 1 】next: 2 -&gt;current: 2 -&gt;value: &#123; 1 &#125; -&gt;current: 2 -&gt;key: 1 -&gt;【 1 : 2 】next: 3 -&gt;current: 3 -&gt;value: &#123; 1 &#125; -&gt;current: 3 -&gt;key: 2 -&gt;【 2 : 3 】next: -&gt;current: -&gt;value: &#123; &#125; -&gt; 将上方类解耦，专门提供如何迭代方法下方我们的MyCollection类想迭代，直接实现IteratorAggregate接口，归还一个迭代器123456789101112131415161718192021222324class MyCollection implements IteratorAggregate&#123; private $items = array(); private $count = 0 ; // Required definition of interface IteratorAggregate public function getIterator () &#123; echo \"6666\"; return new MyIterator ( $this -&gt; items ); &#125; public function add ( $value ) &#123; $this -&gt; items [ $this -&gt; count ++] = $value ; &#125;&#125;$coll = new MyCollection ();$coll -&gt; add ( 'value 1' );$coll -&gt; add ( 'value 2' );$coll -&gt; add ( 'value 3' );foreach ( $coll as $key =&gt; $val ) &#123; echo \"[ $key -&gt; $val ]\".'&lt;br&gt;' ;&#125; 12346666reset-&gt;current: value 1 -&gt;value: &#123; 1 &#125; -&gt;current: value 1 -&gt;key: 0 -&gt;[ 0 -&gt; value 1 ]next: value 2 -&gt;current: value 2 -&gt;value: &#123; 1 &#125; -&gt;current: value 2 -&gt;key: 1 -&gt;[ 1 -&gt; value 2 ]next: value 3 -&gt;current: value 3 -&gt;value: &#123; 1 &#125; -&gt;current: value 3 -&gt;key: 2 -&gt;[ 2 -&gt; value 3 ]next: -&gt;current: -&gt;value: &#123; &#125; -&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"16、针对属性的魔术方法","slug":"PHP/16、针对属性的魔术方法","date":"2017-09-05T20:32:39.000Z","updated":"2020-08-07T14:10:11.871Z","comments":true,"path":"2017/09/06/PHP/16、针对属性的魔术方法/","link":"","permalink":"https://www.zackaddy.xin/2017/09/06/PHP/16、针对属性的魔术方法/","excerpt":"","text":"public void __set ( string $name , mixed $value ) public mixed __get ( string $name ) public bool __isset ( string $name ) public void __unset ( string $name ) 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问属性调用 unset() 时，__unset() 会被调用。 参数 $name 是指要操作的变量名称。__set() 方法的 $value 参数指定了 $name 变量的值。 属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被 声明为 static。从 PHP 5.3.0 起, 将这些魔术方法定义为 static 会产生一个警告。 调用不存在的静态属性属性不会触发__set __get,而且会报错 看下方表演1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpclass PropertyTest &#123; private $data = array(); public $declared = 1 ; private $hidden = 2 ; public function __set ( $name , $value ) &#123; echo \"Setting ' $name ' to ' $value '\\n\" ; $this -&gt; data [ $name ] = $value ; &#125; public function __get ( $name ) &#123; echo \"Getting ' $name '\\n\" ; if ( array_key_exists ( $name , $this -&gt; data )) &#123; return $this -&gt; data [ $name ]; &#125; $trace = debug_backtrace (); trigger_error ( 'Undefined property via __get(): ' . $name . ' in ' . $trace [ 0 ][ 'file' ] . ' on line ' . $trace [ 0 ][ 'line' ], E_USER_NOTICE ); return null ; &#125; public function __isset ( $name ) &#123; echo \"Is ' $name ' set?\\n\" ; return isset( $this -&gt; data [ $name ]); &#125; public function __unset ( $name ) &#123; echo \"Unsetting ' $name '\\n\" ; unset( $this -&gt; data [ $name ]); &#125; public function getHidden () &#123; return $this -&gt; hidden ; &#125;&#125;echo \"&lt;pre&gt;\\n\" ;$obj = new PropertyTest ;$obj -&gt; a = 1 ;echo $obj -&gt; a . \"\\n\\n\" ;var_dump (isset( $obj -&gt; a ));unset( $obj -&gt; a );var_dump (isset( $obj -&gt; a ));echo \"\\n\" ;echo $obj -&gt; declared . \"\\n\\n\" ;echo \"Let's experiment with the private property named 'hidden':\\n\" ;echo \"Privates are visible inside the class, so __get() not used...\\n\" ;echo $obj -&gt; getHidden () . \"\\n\" ;echo \"Privates not visible outside of class, so __get() is used...\\n\" ;echo $obj -&gt; hidden . \"\\n\" ;?&gt; 1234567891011Setting 'a' to '1'Getting 'a'1Is 'a' set?bool(true)Unsetting 'a'Is 'a' set?bool(false)1Let's experiment with the private property named 'hidden':Privates are visible inside the class, so __get() not used...2Privates not visible outside of class, so __get() is used...Getting 'hidden'Notice: Undefined property via __get(): hidden in &lt;file&gt; on line 70 in &lt;file&gt; on line 29","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"15、匿名类","slug":"PHP/15、匿名类","date":"2017-09-04T22:20:42.000Z","updated":"2020-08-07T14:10:11.870Z","comments":true,"path":"2017/09/05/PHP/15、匿名类/","link":"","permalink":"https://www.zackaddy.xin/2017/09/05/PHP/15、匿名类/","excerpt":"","text":"12345678910111213141516&lt;?phpclass SomeClass &#123;&#125;interface SomeInterface &#123;&#125;trait SomeTrait &#123;&#125;var_dump (new class( 10 ) extends SomeClass implements SomeInterface &#123; private $num ; public function __construct ( $num ) &#123; $this -&gt; num = $num ; &#125; use SomeTrait ;&#125;);","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"14、析构函数的顺序你不知道","slug":"PHP/14、析构函数的顺序你不知道","date":"2017-09-04T03:25:52.000Z","updated":"2020-08-07T14:10:11.870Z","comments":true,"path":"2017/09/04/PHP/14、析构函数的顺序你不知道/","link":"","permalink":"https://www.zackaddy.xin/2017/09/04/PHP/14、析构函数的顺序你不知道/","excerpt":"","text":"1234567891011class A&#123; public function __destruct() &#123; echo 'Destroying: A'; &#125;&#125;class B extends A&#123;&#125;new B; //Destroying: A 1234567891011121314class A&#123; public function __destruct() &#123; echo 'Destroying: A'; &#125;&#125;class B extends A&#123; public function __destruct() &#123; echo 'Destroying: B'; &#125;&#125;new B; //Destroying: B 由于类的创建与C++机制不同可以看到继承后销毁不像C++那样 C++执行结果如下 12Destroying: BDestroying: A","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"13、自动加载类","slug":"PHP/13、自动加载类","date":"2017-09-03T00:35:13.000Z","updated":"2020-08-07T14:10:11.870Z","comments":true,"path":"2017/09/03/PHP/13、自动加载类/","link":"","permalink":"https://www.zackaddy.xin/2017/09/03/PHP/13、自动加载类/","excerpt":"","text":"__autoload123456789101112131415&lt;?phpfunction __autoload ( $name ) &#123; echo \"Want to load $name .\\n\" ; throw new Exception ( \"Unable to load $name .\" );&#125;try &#123; $obj = new NonLoadableClass ();&#125; catch ( Exception $e ) &#123; echo $e -&gt; getMessage (), \"\\n\" ;&#125;?&gt;//Want to load NonLoadableClass.//Unable to load NonLoadableClass. spl_autoload_register 使用此函数可以生成一个__autoload()队列，可以注册多个函数。 1234567891011121314151617181920&lt;?phperror_reporting(E_ALL);//index.phpfunction autoload_test($class)&#123; $file = $class . '.php'; echo \"A\"; require $file;&#125;function autoload_vos($class)&#123; $file = $class . '.php'; echo \"B\"; require $file;&#125;spl_autoload_register(\"autoload_test\");spl_autoload_register(\"autoload_vos\");$text = new test();// A test 12345678910111213141516171819&lt;?phperror_reporting(E_ALL);//index.phpfunction autoload_test($class)&#123; $file = $class . '.php'; echo \"A\";&#125;function autoload_vos($class)&#123; $file = $class . '.php'; echo \"B\"; require $file;&#125;spl_autoload_register(\"autoload_test\");spl_autoload_register(\"autoload_vos\");$text = new test();// A B test","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"12、new static new self看起来很6","slug":"PHP/12、new static new self看起来很6","date":"2017-09-01T23:36:16.000Z","updated":"2020-08-07T14:10:11.869Z","comments":true,"path":"2017/09/02/PHP/12、new static new self看起来很6/","link":"","permalink":"https://www.zackaddy.xin/2017/09/02/PHP/12、new static new self看起来很6/","excerpt":"","text":"new static 调用者的实力new self 原本所在类的实例static::class;A::class;self::class; 123456789101112class A&#123; public static function foo() &#123; return new static; &#125; public function say() &#123; echo \"hello world\"; &#125;&#125;$ins = A::foo();$ins-&gt;say();","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"11、函数返回引用类型注意","slug":"PHP/11、函数返回引用类型注意","date":"2017-08-31T22:02:46.000Z","updated":"2020-08-07T14:10:11.869Z","comments":true,"path":"2017/09/01/PHP/11、函数返回引用类型注意/","link":"","permalink":"https://www.zackaddy.xin/2017/09/01/PHP/11、函数返回引用类型注意/","excerpt":"","text":"从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符＆： 12345678&lt;?phpfunction &amp; returns_reference ()&#123; return $someref ;&#125;$newref =&amp; returns_reference ();?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"10、函数的骚操作","slug":"PHP/10、函数的骚操作","date":"2017-08-31T03:32:33.000Z","updated":"2020-08-07T14:10:11.869Z","comments":true,"path":"2017/08/31/PHP/10、函数的骚操作/","link":"","permalink":"https://www.zackaddy.xin/2017/08/31/PHP/10、函数的骚操作/","excerpt":"","text":"想用外部变量，用global？，可以用use，可以不改变外部变量的值12345678$message = 'hello';// Inherit $message$example = function () use($message) &#123; $message = 666; var_dump($message);&#125;;echo $example(); // 666echo $message; // hello 可变函数12345function foo () &#123; echo \"In foo()&lt;br /&gt;\\n\" ;&#125;$func = 'foo' ;$func (); 限定函数归还类型与参数类型1）严格模式下必须为规定类型 2）非严格模式，隐式转换，转换失败报错 3） 定义严格模式 declare( strict_types = 1 ); 123456&lt;?php function wxc (int $var) : string &#123; return $var; &#125; echo is_string(wxc(6)); //1?&gt; 给函数形参加个初始值123456789101112&lt;?phpfunction makecoffee ( $type = \"cappuccino\" )&#123; return \"Making a cup of $type .\\n\" ;&#125;echo makecoffee ();echo makecoffee ( null );echo makecoffee ( \"espresso\" );?&gt;//Making a cup of cappuccino.//Making a cup of .//Making a cup of espresso. 让函数形参变成引用123456789&lt;?phpfunction add_some_extra (&amp; $string )&#123; $string .= 'and something extra.' ;&#125;$str = 'This is a string, ' ;add_some_extra ( $str );echo $str ; // outputs 'This is a string, and something extra.'?&gt; 形参太多参数，用可变参数1234567891011&lt;?phpfunction sum (... $numbers ) &#123; $acc = 0 ; foreach ( $numbers as $n ) &#123; $acc += $n ; &#125; return $acc ;&#125;echo sum ( 1 , 2 , 3 , 4 );?&gt; 形参太多参数传个数组？用解构12345678910&lt;?phpfunction add ( $a , $b ) &#123; return $a + $b ;&#125;echo add (...[ 1 , 2 ]). \"\\n\" ;$a = [ 1 , 2 ];echo add (... $a );?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"9、declare(ticks=N); 的作用","slug":"PHP/9、declare(ticks=N); 的作用","date":"2017-08-29T21:36:52.000Z","updated":"2020-08-07T14:10:11.879Z","comments":true,"path":"2017/08/30/PHP/9、declare(ticks=N); 的作用/","link":"","permalink":"https://www.zackaddy.xin/2017/08/30/PHP/9、declare(ticks=N); 的作用/","excerpt":"","text":"一般用法是 declare(ticks=N);拿declare(ticks=1)来说，这句主要作用有两种： 1） Zend引擎每执行1条低级语句就去执行一次 register_tick_function() 注册的函数。 2） 可以粗略的理解为每执行一句php代码（例如:$num=1;）就去执行下已经注册的tick函数。 3） 一个用途就是控制某段代码执行时间，例如下面的代码虽然最后有个死循环，但是执行时间不会超过5秒。运行 php timeout.php 123456789101112131415161718192021222324&lt;?phpdeclare(ticks=1);// 开始时间$time_start = time();// 检查是否已经超时function check_timeout()&#123; // 开始时间 global $time_start; // 5秒超时 $timeout = 5; if(time()-$time_start &gt; $timeout)&#123; exit(\"超时&#123;$timeout&#125;秒\\n\"); &#125;&#125;// Zend引擎每执行一次低级语句就执行一下check_timeoutregister_tick_function('check_timeout');// 模拟一段耗时的业务逻辑while(1)&#123; $num = 1;&#125;// 模拟一段耗时的业务逻辑，虽然是死循环，但是执行时间不会超过$timeout=5秒while(1)&#123; $num = 1;&#125; declare(ticks=1);每执行一次低级语句会检查一次该进程是否有未处理过的信号测试代码如下： 运行 php signal.php然后CTL+c 或者 kill -SIGINT PID 会导致运行代码跳出死循环去运行pcntl_signal注册的函数，效果就是脚本exit打印“Get signal SIGINT and exi”退出 123456789&lt;?phpdeclare(ticks=1);pcntl_signal(SIGINT, function()&#123; exit(\"Get signal SIGINT and exit\\n\");&#125;);echo \"Ctl + c or run cmd : kill -SIGINT \" . posix_getpid(). \"\\n\" ;while(1)&#123; $num = 1;&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"8、数组复制与操作符","slug":"PHP/8、数组复制与操作符","date":"2017-08-29T04:55:23.000Z","updated":"2020-08-07T14:10:11.879Z","comments":true,"path":"2017/08/29/PHP/8、数组复制与操作符/","link":"","permalink":"https://www.zackaddy.xin/2017/08/29/PHP/8、数组复制与操作符/","excerpt":"","text":"数组之间都是深复制123456$a = [ \"apple\" , \"banana\" , 'names'=&gt;['name'=&gt;'herghost']];$b = array($a);$b[0]['names']['name'] = 66;var_dump($a);var_dump($b);//数组没有浅复制 联合操作符+，联合规则为：以+号前的数组为主 +号后的数组键值在+号前数组内出现，以+号前数组为主 123456$a = [ \"apple\" , \"banana\" , 'names'=&gt;['name'=&gt;'herghost']];$b = [6,7,8];$c = $a+$b;$c['names']['name'] = 888;var_dump($c);var_dump($a);","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"7、反引号（``）之执行运算符","slug":"PHP/7、反引号（``）之执行运算符","date":"2017-08-27T16:10:42.000Z","updated":"2020-08-07T14:10:11.879Z","comments":true,"path":"2017/08/28/PHP/7、反引号（``）之执行运算符/","link":"","permalink":"https://www.zackaddy.xin/2017/08/28/PHP/7、反引号（``）之执行运算符/","excerpt":"","text":"1234&lt;?php$output = `dir`;echo \"&lt;pre&gt;$output&lt;/pre&gt;\";?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"6、魔术常量","slug":"PHP/6、魔术常量","date":"2017-08-27T01:35:48.000Z","updated":"2020-08-07T14:10:11.879Z","comments":true,"path":"2017/08/27/PHP/6、魔术常量/","link":"","permalink":"https://www.zackaddy.xin/2017/08/27/PHP/6、魔术常量/","excerpt":"","text":"12345678910111213141516171819202122&lt;?phperror_reporting(E_ALL);echo __LINE__ . '&lt;br&gt;'; //4echo __FILE__ . '&lt;br&gt;'; //D:\\myphp_www\\PHPTutorial\\WWW\\index.phpecho __DIR__ . '&lt;br&gt;';// D:\\myphp_www\\PHPTutorial\\WWWfunction printfn()&#123; echo __FUNCTION__ . '&lt;br&gt;';&#125;printfn(); // printfnclass printclazz&#123; static function print() &#123; echo __CLASS__ . '&lt;br&gt;'; &#125; public function say() &#123; echo __CLASS__ . '&lt;br&gt;'; &#125;&#125;printclazz::print(); // printclazz(new printclazz())-&gt;say(); // printclazz","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"5、可变变量与引用","slug":"PHP/5、可变变量与引用","date":"2017-08-25T21:50:19.000Z","updated":"2020-08-07T14:10:11.878Z","comments":true,"path":"2017/08/26/PHP/5、可变变量与引用/","link":"","permalink":"https://www.zackaddy.xin/2017/08/26/PHP/5、可变变量与引用/","excerpt":"","text":"引用变量1234$a = 5;$b = &amp;$a;$b = 6;echo $a;//6 可变变量123456$a = \"hello\";$$a = \"world\"echo $a;//helloecho $$a;//worldecho $hello;//world","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"4、字符串的几种赋值","slug":"PHP/4、字符串的几种赋值","date":"2017-08-24T17:40:45.000Z","updated":"2020-08-07T14:10:11.878Z","comments":true,"path":"2017/08/25/PHP/4、字符串的几种赋值/","link":"","permalink":"https://www.zackaddy.xin/2017/08/25/PHP/4、字符串的几种赋值/","excerpt":"","text":"双引号字符串用法 单引号不需要加\\转译 可以引用变量如val、${val}、{$val} {}内没有变量直接输出，反之括号消失1234567$val = 66;$s = \"$val\";echo $s; //66$val = 66;$s = \"$val\\\"\\'$&#123;val&#125;、&#123;$val&#125;\";echo $s; //66\"\\'66、66 单引号字符串用法 双引号不需要加\\转译 不可以引用变量如val、${val}、{$val} heredoc123$str = &lt;&lt;&lt;\"xxx\"6666xxx; nowdoc123$str = &lt;&lt;&lt;'xxx'6666xxx;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"3、数组几种创建赋值方式","slug":"PHP/3、数组几种创建赋值方式","date":"2017-08-24T00:30:09.000Z","updated":"2020-08-07T14:10:11.877Z","comments":true,"path":"2017/08/24/PHP/3、数组几种创建赋值方式/","link":"","permalink":"https://www.zackaddy.xin/2017/08/24/PHP/3、数组几种创建赋值方式/","excerpt":"","text":"123$arr = [7,8,9];$arr[] = 99;print_r($arr); // Array ( [0] =&gt; 7 [1] =&gt; 8 [2] =&gt; 9 [3] =&gt; 99 ) 1$arr = array('xx' =&gt; 66, 'bb' =&gt; '68') 用list解构取值提高逼格12list(,$v) = [7,8,9];echo $v;//8","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"2、其它类型转对象的特殊用法","slug":"PHP/2、其它类型转对象的特殊用法","date":"2017-08-23T01:48:18.000Z","updated":"2020-08-07T14:10:11.874Z","comments":true,"path":"2017/08/23/PHP/2、其它类型转对象的特殊用法/","link":"","permalink":"https://www.zackaddy.xin/2017/08/23/PHP/2、其它类型转对象的特殊用法/","excerpt":"","text":"字符串转对象1234&lt;?php$obj = (object) 'xxx' ;echo $obj -&gt; scalar ; // scalar为纯量 outputs 'xxx'?&gt; 数组转对象12345678&lt;?php $object = (object) [ 'propertyOne' =&gt; 'foo', 'propertyTwo' =&gt; 42, ]; echo $object -&gt; propertyOne ; // outputs 'foo' echo $object -&gt; scalar; // error?&gt;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"1、php判断文件夹是否存在不存在则创建","slug":"PHP/1、php判断文件夹是否存在不存在则创建","date":"2017-08-21T22:14:25.000Z","updated":"2020-08-07T14:10:11.871Z","comments":true,"path":"2017/08/22/PHP/1、php判断文件夹是否存在不存在则创建/","link":"","permalink":"https://www.zackaddy.xin/2017/08/22/PHP/1、php判断文件夹是否存在不存在则创建/","excerpt":"","text":"1234// 直接这样即可：$dir = './test/test';is_dir($dir) OR mkdir($dir, 0777, true); // 如果文件夹不存在，将以递归方式创建该文件夹 123if(!is_dir($dir_path))&#123; mkdir($dir_path);&#125;","categories":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/tags/PHP/"}],"keywords":[{"name":"PHP","slug":"PHP","permalink":"https://www.zackaddy.xin/categories/PHP/"}]},{"title":"87、mysql 之主从复制","slug":"Mysql/87、mysql 之主从复制","date":"2016-06-25T21:08:14.000Z","updated":"2020-08-07T14:10:11.863Z","comments":true,"path":"2016/06/26/Mysql/87、mysql 之主从复制/","link":"","permalink":"https://www.zackaddy.xin/2016/06/26/Mysql/87、mysql 之主从复制/","excerpt":"","text":"mysql 之主从复制简介数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。 用途 读写分离：主库负责写，从库负责读。即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。 数据实时备份：当系统中某个节点发生故障时，可以方便的故障切换 高可用（HA）架构 主从复制原理 主节点 binary log dump 线程当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。 从节点I/O线程当从节点上执行start slave命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点binlog dump 进程发来的更新之后，保存在本地relay-log中。 从节点SQL线程SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。 总结对于每一个主从连接，都需要三个进程来完成。 当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。 从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。 从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容； 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”； Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。 主从形式一主一从12graph LRMaster--&gt;Salve 一主多从 提高系统的读性能 一主一从和一主多从是最常见的主从架构，实施起来简单并且有效，不仅可以实现HA，而且还能读写分离，进而提升集群的并发能力。1234graph LRMaster--&gt;Salve1Master--&gt;Salve2Master--&gt;Salve3 多主一从 从5.7开始支持 多主一从可以将多个mysql数据库备份到一台存储性能比较好的服务器上。1234graph LRMaster1--&gt;SalveMaster2--&gt;SalveMaster3--&gt;Salve 双主复制 双主复制，也就是互做主从复制，每个master既是master，又是另外一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。123graph LRMaster1--&gt;Master2Master2--&gt;Master1 级联复制 级联复制模式下，部分slave的数据同步不连接主节点，而是连接从节点。 如果主节点有太多的从节点，就会损耗一部分性能用于replication， 我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响。12345graph LRMaster--&gt;Salve1Salve1--&gt;Salve2Salve1--&gt;Salve3Salve3--&gt;Salve4 配置准备工作 主从服务器需要有相同的初态 1、将主服务器要同步的数据库枷锁，避免同步时数据发生改变 12mysql&gt;use db;mysql&gt;flush tables with read lock; 2、将主服务器数据库中数据导出 12mysql&gt;mysqldump -uroot -pxxxx db &gt; db.sql;mysql&gt;mysqldump -R -ndt db -uroot -pxxxx &gt; db.sql #同时导出函数存储过程 3、备份完成后，解锁主服务器数据库 1mysql&gt;unlock tables; 4、将初始数据导入从服务器数据库 123mysql&gt;create database db;mysql&gt;use db;mysql&gt;source db.sql; 主服务器配置1、修改MySQL配置 1vi /etc/my.cnf 在[mysqld]中添加 123456789101112131415161718#主数据库端ID号server_id = 1 #开启二进制日志 log-bin = mysql-bin #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可 binlog-do-db = db #将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中 log-slave-updates #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) sync_binlog = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_offset = 1 #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_increment = 1 #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除 expire_logs_days = 7 #将函数复制到slave log_bin_trust_function_creators = 1 2、重启MySQL，创建允许从服务器同步数据的账户 1234#创建slave账号account，密码123456mysql&gt;grant replication slave on *.* to 'account'@'从机器数据库IP' identified by '123456';#更新数据库权限mysql&gt;flush privileges; 3、查看主服务器状态 123456mysql&gt;show master status\\G;***************** 1. row **************** File: mysql-bin.000033 #当前记录的日志 Position: 337523 #日志中记录的位置 Binlog_Do_DB: Binlog_Ignore_DB: 执行完这个步骤后不要再操作主服务器数据库了，防止其状态值发生变化 从服务器配置1、修改MySQL配置 1vi /etc/my.cnf 在[mysqld]中添加 1234567891011server_id = 2log-bin = mysql-binlog-slave-updatessync_binlog = 0#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作innodb_flush_log_at_trx_commit = 0 #指定slave要复制哪个库replicate-do-db = db #MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据slave-net-timeout = 60 log_bin_trust_function_creators = 1 2、执行同步命令 1234#执行同步命令，设置主服务器ip，同步账号密码，同步位置mysql&gt;change master to master_host='10.10.20.111',master_user='account',master_password='123456',master_log_file='mysql-bin.000033',master_log_pos=337523;#开启同步功能mysql&gt;start slave; 3、查看从服务器状态 1234567891011121314151617mysql&gt;show slave status\\G;*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 10.10.20.111 Master_User: account Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000033 Read_Master_Log_Pos: 337523 Relay_Log_File: db2-relay-bin.000002 Relay_Log_Pos: 337686 Relay_Master_Log_File: mysql-bin.000033 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: ... Slave_IO_Running及Slave_SQL_Running进程必须正常运行，即Yes状态，否则说明同步失败 若失败查看mysql错误日志中具体报错详情来进行问题定位最后可以去主服务器上的数据库中创建表或者更新表数据来测试同步","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"86、mysql 之行锁","slug":"Mysql/86、mysql 之行锁","date":"2016-06-25T00:32:12.000Z","updated":"2020-08-07T14:10:11.863Z","comments":true,"path":"2016/06/25/Mysql/86、mysql 之行锁/","link":"","permalink":"https://www.zackaddy.xin/2016/06/25/Mysql/86、mysql 之行锁/","excerpt":"","text":"mysql 之行锁简介 先看42、mysql 之事务 行锁的劣势：开销大；加锁慢；会出现死锁 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁： 共享锁：select * from tableName where … + lock in share more 排他锁：select * from tableName where … + for update 偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁 ==varchar 不用 ‘ ‘ 导致系统自动转换类型, 行锁变表锁== 间隙锁使用范围查询并请求共享或排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁（where id &gt;= 1 and id &lt;= 50 id在1-50之间不管存不存在这条数据都会被锁住）；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）” InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。 危害造成在锁定下无法插入锁定键值范围内的任何数据，在某些场景可能对性能造成很大的危害 行锁定分析通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 12345678910mysql&gt; show status like 'innodb_row_lock%';+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 0 || Innodb_row_lock_time_avg | 0 || Innodb_row_lock_time_max | 0 || Innodb_row_lock_waits | 0 |+-------------------------------+-------+ innodb_row_lock_current_waits: 当前正在等待锁定的数量 innodb_row_lock_time:从系统启动到现在锁定总时间长度；非常重要的参数， innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数， innodb_row_lock_time_max: 从系统启动到现在等待最长的一次所花的时间； innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。 innodb_row_lock_time_avg innodb_row_lock_waits innodb_row_lock_time这三个状态比较重要 行锁优化 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"85、mysql 之表锁","slug":"Mysql/85、mysql 之表锁","date":"2016-06-24T03:21:01.000Z","updated":"2020-08-07T14:10:11.862Z","comments":true,"path":"2016/06/24/Mysql/85、mysql 之表锁/","link":"","permalink":"https://www.zackaddy.xin/2016/06/24/Mysql/85、mysql 之表锁/","excerpt":"","text":"mysql 之表锁简介偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低 MyISAM在执行查询语句前，会自动给涉及到的表加读锁，在执行增删改前，会自动给涉及的表加写锁 mysql的表级锁有两种方式 表共享读锁 表独占写锁 当前锁模式 | 可否兼容 | 读锁 | 写锁 读锁 | 是 | 是 | 否写锁 | 是 | 否 | 否 结合上表： 对MyISAM表的读操作（加读锁），不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作 对MyISAM表的写操作（加写锁），会阻塞其它进程对同一表的读请求，只有当写锁释放后，才会执行其它进程的读写操作 表锁定分析1show status like 'table%' Table_locks_immediate：产生表级锁定的次数，表锁可以立即获取锁的查询次数，每立即获取锁值加1 Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况 myISAM锁调度MyISAM存储引擎的读锁和写锁是互斥的，读写操作室串行的，那么如果读写两个进程同时请求同一张表，Mysql将会使写进程先获得锁。不仅仅如此，即使读请求先到达锁等待队列，写锁后到达，写锁也会先执行。因为mysql因为写请求比读请求更加重要。这也正是MyISAM不适合含有大量更新操作和查询操作应用的原因。调节办法： 通过指定启动参数low-priority-updates,使MyISAM引擎默认给与读请求优先的权限 通过执行set low_PRIORITY_UPDATES=1，降低更新请求的优先级。 指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"84、mysql 之锁的概述","slug":"Mysql/84、mysql 之锁的概述","date":"2016-06-22T22:42:05.000Z","updated":"2020-08-07T14:10:11.862Z","comments":true,"path":"2016/06/23/Mysql/84、mysql 之锁的概述/","link":"","permalink":"https://www.zackaddy.xin/2016/06/23/Mysql/84、mysql 之锁的概述/","excerpt":"","text":"mysql 之锁的概述简介锁是计算机协调 多个进程或线程并发访问某一资源的机制 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用之外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个终于因素。从这个角度来说，锁对数据库而言显得尤为重要，也更加复杂。 特性 模式 开锁、加锁速度、死锁、粒度、并发性能 表级锁 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 行级锁 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 页面锁 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 加锁1lock table tablename read/write; 解锁1unlock tables; 查看哪些表被加锁1show open tables; 读锁 共享锁，多个读操作可以同时进行而不会互相影响 被锁的连接不能读其它表 被锁的连接不能写操作，其它连接写操作将被阻塞 写锁 排它锁，当前写操作没有完成前，它会阻断其它连接读写操作 被锁的连接不能读其它表 被锁的连接可以读写操作，","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"22、nginx 之 rewrite 实现防盗链","slug":"Nginx/22、nginx 之 rewrite 实现防盗链","date":"2016-06-22T02:00:11.000Z","updated":"2020-08-07T14:10:11.867Z","comments":true,"path":"2016/06/22/Nginx/22、nginx 之 rewrite 实现防盗链/","link":"","permalink":"https://www.zackaddy.xin/2016/06/22/Nginx/22、nginx 之 rewrite 实现防盗链/","excerpt":"","text":"nginx 之 rewrite 实现防盗链什么是防盗链盗链可以理解盗图链接，也就是说在别人的网站上使用自己站点图片的链接，增加自己站点的压力。 防盗链的实现原理客户端向服务器端请求资源时，为了减少网络带宽，提高响应时间，服务器一般不会一次将所有资源完整地传回客户端。比如请求一个网页时，首先会传回该网页的文本内容，当客户端浏览器在解析文本的过程中发现有图片存在时，会再次向服务器发起对该图片资源的请求，服务器将存储的图片资源再发送给客户端。但是如果这个图片是链接到其他站点的服务器上去了呢，比如在我项目中，我引用了的是淘宝中的一张图片的话，那么当我们网站重新加载的时候，就会请求淘宝的服务器，那么这就很有可能造成淘宝服务器负担。因此这个就是盗链行为。因此我们要实现防盗链。 实现Nginx中有一个指令 valid_referers. 该指令可以用来获取 Referer 头域中的值，并且根据该值的情况给 Nginx全局变量invalid_referer赋值。如果Referer头域中没有符合valid_referers指令的值的话，invalid_referer变量将会赋值为1. valid_referers 指令基本语法如下： 1valid_referers none | blocked | server_names none: 检测Referer头域不存在的情况。 blocked： 检测Referer头域的值被防火墙或者代理服务器删除或伪装的情况 server_names: 设置一个或多个URL，检测Referer头域的值是否是URL中的某个。 有了 valid_referers指令和$invalid_referer变量的话，我们就可以通过 Rewrite功能来实现防盗链。 12345678910server &#123; listen 8080; server_name xxx.abc.com location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)$ &#123; valid_referers none blocked www.xxx.com www.yyy.com *.baidu.com *.tabobao.com; if ($invalid_referer) &#123; rewrite ^/ http://www.xxx.com/images/forbidden.png; &#125; &#125;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"83、mysql 之全局查询日志","slug":"Mysql/83、mysql 之全局查询日志","date":"2016-06-22T00:15:21.000Z","updated":"2020-08-07T14:10:11.862Z","comments":true,"path":"2016/06/22/Mysql/83、mysql 之全局查询日志/","link":"","permalink":"https://www.zackaddy.xin/2016/06/22/Mysql/83、mysql 之全局查询日志/","excerpt":"","text":"mysql 之全局查询日志在mysql的my.cnf中，设置如下： 123456#开启general_log=1#记录日志文件的路径general_log_file=/path/logfile#输出格式log_output=FILE 命令启用 123set global general_log=1set golbal log_output='TABLE'select * from mysql.general_log ==不要在生产环境启用该功能==","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"82、mysql 之用show profile进行sql分析","slug":"Mysql/82、mysql 之用show profile进行sql分析","date":"2016-06-21T02:56:27.000Z","updated":"2020-08-07T14:10:11.862Z","comments":true,"path":"2016/06/21/Mysql/82、mysql 之用show profile进行sql分析/","link":"","permalink":"https://www.zackaddy.xin/2016/06/21/Mysql/82、mysql 之用show profile进行sql分析/","excerpt":"","text":"mysql 之用show profile进行sql分析简介show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量 官网：http://dev.mysql.com/doc/refman/5.5/en/show-profile.html 默认情况下，参数处于关闭状态，并保存最近15次的运行结果 查看是否开启1show variables like 'profiling'; 执行sql语句1xxxxxx 查看结果1show profiles; 诊断SQL1show profile cpu,block io for query 上一步前面的问题SQL 数字号码； all 显示所有开销信息 block io 显示块io相关开销 context switches 上下文切换相关开销 cpu 显示cpu相关开销信息 ipc 显示发送和接收相关开销信息 memory 显示内存相关开销信息 page faults 显示页面错误相关开销信息 source 显示和source_function，source_file,source_line相关的开销信息 swaps 显示交换次数相关开销信息 日常开发需要注意的结论 converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。 Creating tmp table 创建临时表 Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！。 locked","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"21、nginx 之 rewrite","slug":"Nginx/21、nginx 之 rewrite","date":"2016-06-21T02:33:41.000Z","updated":"2020-08-07T14:10:11.867Z","comments":true,"path":"2016/06/21/Nginx/21、nginx 之 rewrite/","link":"","permalink":"https://www.zackaddy.xin/2016/06/21/Nginx/21、nginx 之 rewrite/","excerpt":"","text":"nginx 之 rewrite地址重写与地址转发地址重写：是为了实现地址的标准化，比如我们可以在地址栏中中输入 www.baidu.com. 我们也可以输入 www.baidu.cn. 最后都会被重写到 www.baidu.com 上。浏览器的地址栏也会显示www.baidu.com。 地址转发：它是指在网络数据传输过程中数据分组到达路由器或桥接器后，该设备通过检查分组地址并将数据转发到最近的局域网的过程。 因此地址重写和地址转发有以下不同点： 地址重写会改变浏览器中的地址，使之变成重写成浏览器最新的地址。而地址转发他是不会改变浏览器的地址的。 地址重写会产生两次请求，而地址转发只会有一次请求。 地址转发一般发生在同一站点项目内部，而地址重写且不受限制。 地址转发的速度比地址重定向快。 使用1rewrite regex replacement [flag]; 1server块或location块中配置 rewrite的含义：该指令是实现URL重写的指令。 regex的含义：用于匹配URI的正则表达式。 replacement：将regex正则匹配到的内容替换成 replacement。 flag: flag标记。 last: 本条规则匹配完成后，继续向下匹配新的location URI 规则。(不常用) break: 本条规则匹配完成即终止，不再匹配后面的任何规则(不常用)。 redirect: 返回302临时重定向，浏览器地址会显示跳转新的URL地址。 permanent: 返回301永久重定向。浏览器地址会显示跳转新的URL地址。 举例1rewrite ^/(.*) http://www.baidu.com/$1 permanent; rewrite 为固定关键字，表示开始进行rewrite匹配规则。 regex 为 ^/(.*)。 这是一个正则表达式，匹配完整的域名和后面的路径地址。 replacement就是 http://www.baidu.com/1这块了，其中1是取regex部分()里面的内容。如果匹配成功后跳转到的URL。 flag 就是 permanent，代表永久重定向的含义，即跳转到 http://www.baidu.com/$1 地址上。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"81、mysql 之慢查询日志","slug":"Mysql/81、mysql 之慢查询日志","date":"2016-06-19T23:58:07.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/06/20/Mysql/81、mysql 之慢查询日志/","link":"","permalink":"https://www.zackaddy.xin/2016/06/20/Mysql/81、mysql 之慢查询日志/","excerpt":"","text":"mysql 之慢查询日志 MySQL的慢查询日志是MySQL提供的一种日志记录它用来记录在MySQL中响应时间超过阀值的语句具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中 具体指运行时间超过long_query_time值的SQL则会被记录到慢查询日志中long_query_time的默认值为10 意思是运行10秒以上的语句 由它来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟我们就算慢SQL并结合之前的explain进行全面解析 默认清况下MYSQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。 当然如果不是调优需要的话一般不建议启动该参数因为开启慢查询日志会或多或少带来一定的性能影响。慢杳询日志支持将日志记录写入文件 查看与开启 是否开启 1SHOW VARIABLES LIKE '%slow_query_log%' 开启 1set global slow_query_log = 1 查看当前多少秒算慢 1SHOW VARIABLES LIKE 'long_query_time%'; 设置慢查询时间 1set global long_query_time=3; 为什么设置后看不出变化？ 需要重新连接或者新开一个回话才能看到修改值。12SHOW VARIABLES LIKE 'long_query_time%';show global variables like 'long_query_time'; 查询当前系统中有多少条慢查询记录1show global status like '%Slow_queries%'; 日志分析工具mysqldumpshow查看mysqldumpshow的帮助信息 s:是表示按何种方式排序 c:访问次数 l:锁定时间 r:返回记录 t:查询时间 al:平均锁定时间 ar:平均返回记录数 at:平均查询时间 t:即为返回前面多少条的数据 g:后边搭配一个正则匹配模式，大小写不敏感的 常用参考 12345678得到返回记录最多的10个SQLmysqldumpshow -s r -t 10 /var/lib/mysql/slow.log得到访问次数最多的10个SQLmysqldumpshow -s c -t 10 /var/lib/mysql/slow.log得到按照时间排序的前10条里面含有左连接的查询语句mysqldumpshow -s t -t 10 -g /var/lib/mysql/slow.log另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况mysqldumpshow -s r -t 10 /var/lib/mysql/slow.log | more","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"20、nginx 之 if 条件判断语句","slug":"Nginx/20、nginx 之 if 条件判断语句","date":"2016-06-19T20:00:23.000Z","updated":"2020-08-07T14:10:11.866Z","comments":true,"path":"2016/06/20/Nginx/20、nginx 之 if 条件判断语句/","link":"","permalink":"https://www.zackaddy.xin/2016/06/20/Nginx/20、nginx 之 if 条件判断语句/","excerpt":"","text":"nginx 之 if 条件判断语句正则表达式匹配 ==:等值比较; ~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写； ~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写； !~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写； !~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写； 文件及目录匹配判断 -f, !-f：判断指定的路径是否为存在且为文件； -d, !-d：判断指定的路径是否为存在且为目录； -e, !-e：判断指定的路径是否存在，文件或目录均可； -x, !-x：判断指定路径的文件是否存在且可执行； 为了配置if的条件判断，部分需要用到nginx中内置的全局变量变量 | 含义–|–$args | 这个变量等于请求行中的参数，同$query_string$content_length | 请求头中的Content-length字段。$content_type | 请求头中的Content-Type字段。$document_root | 当前请求在root指令中指定的值。$host | 请求主机头字段，否则为服务器名称。$http_user_agent | 客户端agent信息$http_cookie | 客户端cookie信息$limit_rate | 这个变量可以限制连接速率。$request_method | 客户端请求的动作，通常为GET或POST。$remote_addr | 客户端的IP地址。$remote_port | 客户端的端口。$remote_user | 已经经过Auth Basic Module验证的用户名。$request_filename | 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme | HTTP方法（如http，https）。$server_protocol | 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr | 服务器地址，在完成一次系统调用后可以确定这个值。$server_name | 服务器名称。$server_port | 请求到达服务器的端口号。$request_uri | 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri | 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri | 与$uri相同。等等… | 等等… 举例 如果文件不存在则返回400123if (!-f $request_filename) &#123; return 400;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"19、nginx 之 location 配置","slug":"Nginx/19、nginx 之 location 配置","date":"2016-06-19T02:58:41.000Z","updated":"2020-08-07T14:10:11.866Z","comments":true,"path":"2016/06/19/Nginx/19、nginx 之 location 配置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/19/Nginx/19、nginx 之 location 配置/","excerpt":"","text":"nginx 之 location 配置语法123456789101112131415普通匹配：location = URI &#123; configuration &#125; # 精确匹配location ^~ URI &#123; configuration &#125; # 非正则匹配，表示URI以某个常规字符串开头location URI &#123; configuration&#125; # 前缀匹配, 匹配后，继续更长前缀匹配和正则匹配。 正则匹配location ~ URI &#123; configuration &#125; # 区分大小写匹配location ~* URI &#123; configuration &#125; # 不区分大小写匹配location !~ URI &#123; configuration &#125; # 区分大小写不匹配location !~* URI &#123; configuration &#125; # 不区分大小写不匹配内部重定向location @name &#123; configuration &#125; # 定义一个location，用于处理内部重定向 ==非正则匹配需要以/开头== 优先级1(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径(前缀匹配)) &gt; (/) 示例 等号( = )123location = /index&#123; [configuration A]&#125; 当URL为http://{domain-name}/index时，才会执行配置中操作。 波浪号 ( ~ )123location ~ /page/\\d&#123;1,2&#125; &#123; [ configuration B ]&#125; URL存在/page/\\d{1,2}，配置生效 波浪号与星号( ~* )123location ~ .*\\.(gif|jpg|jpeg|png)$ &#123; &#125; 匹配所有URL以.jpg、.jpeg、.gif、.png结尾时， 配置生效 脱字符与波浪号（ ^~ ）123location ^~ /images/ &#123; [ cofigurations D ]&#125; 非正则匹配则URL以/images/开头时，配置生效。 @符号12345location @error &#123; proxy_pass http://error;&#125;error_page 404 @error;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"80、mysql 之查询优化","slug":"Mysql/80、mysql 之查询优化","date":"2016-06-18T20:30:54.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/06/19/Mysql/80、mysql 之查询优化/","link":"","permalink":"https://www.zackaddy.xin/2016/06/19/Mysql/80、mysql 之查询优化/","excerpt":"","text":"mysql 之查询优化 慢查询开启与捕获 explain+慢SQL分析 show profile查询SQL在mysql服务器里面的执行细节和生命周期情况 SQL数据库服务器的参数调优 小表驱动大表永远小表驱动大表 类似嵌套循环Nested Loop Case优化原则：小表驱动大表，即小的数据集驱动大的数据集 1234select * from A where id in (select id from B)等价于for select id from B for select * from A where A.id = B.id 当B表的数据集小于A表的数据集，用in优于exists 1234select * from A where exists (select 1 from B where B.id = A.id)等价于for select * from A for select * from B where B.id = A.id 当A表的数据集小于B表的数据集，用exists优于in ==注意：A表与B表的id字段应建立索引== EXISTS1SELECT ...... FROM table WHERE EXISTS(subquery) 该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（true或false）来决定主查询的数据结果是否得以保留。 提示 EXISTS（subquery）只返回true或false，因此子查询中的select * 也可以是select 1 或 select ‘X’，根据官方的说法是实际执行时会忽略select清单，因此没有区别。 EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率。 EXISTS子查询往往也可以用条件表达式，其它子查询或join来代替，何种何种最优需要具体问题具体分析。 order by关键字优化 ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序 MySQL支持二种方式的排序，FileSort和Index,Index效率高。它指MySQL扫描索引本身完成排序。FileSort方式效率较低。 ORDER BY满足两情况，会使用Index方式排序 ORDER BY语句使用索引最左前列 使用where子句与OrderBy子句条件列组合满足索引最左前列 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀 如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序 双路排序 MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。 取一批数据，要对磁盘进行两次扫描，众所周知，I\\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。 单路排序 从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。 由于单路是后出来的，总体而言好过双路 但是用单路有问题，sort_buffer小了会导致大量I/O操作 优化策略 增大sort_buffer_size参数的设置 增大max_length_for_sort_data参数的设置 order by时select * 是大忌。只查询需要字段，这点非常重要 当查询的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。 尝试提高sort_buffer_size 不管哪种算法， 提高这个参数都会提高效率，当然，要根据系统的能力提高，因为这个参数是针对每个进程的。 尝试提高max_length_for_sort_data 提高这个参数，会增加用改进算法的概率，但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低处理器使用率。 为排序使用索引 mysql有两种排序方式：文件排序或扫描有序索引排序 mysql能够为排序与查询使用相同的索引1key a_b_c(a,b,c) order by能使用索引最左前缀 1234- order by a- order by a,b- order by a,b,c- order by a DESC,b DESC,c DESC 如果where使用索引的最左前缀定义为常量，则order by能使用索引 123- where a = const order by b,c- where a = const and b = const order by c- where a = const and b &gt; const order by b,c 不能使用索引进行排序 12345- order by a asc, b desc, c desc /*排序不一致*/- where g = const order by b,c /*丢失a索引*/- where a = const order by c /*丢失b索引*/- where a = const order by a, d /*d不是索引的一部分*/- where a in(......) order by b,c /*对于排序来说，多个相等条件也是范围条件*/ group by关键字优化 groupby实质是先排序后进行分组，遵照索引建的最佳左前缀 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置 where高于having,能写在where限定的条件就不要去having限定了。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"79、mysql 之索引优化","slug":"Mysql/79、mysql 之索引优化","date":"2016-06-18T01:31:14.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/06/18/Mysql/79、mysql 之索引优化/","link":"","permalink":"https://www.zackaddy.xin/2016/06/18/Mysql/79、mysql 之索引优化/","excerpt":"","text":"mysql 之索引优化单表分析1EXPLAIN SELECT id,author_id FROM article WHERE category_id = 1 AND comments &gt; 1 ORDER BY views DESC LIMIT 1; 在未建索引时，分析后，type为ALL，Extra出现Using filesort。 优化 方式一（失败）1create index idx_article_ccv on article(category_id,comments,views); 执行EXPLAIN后，type为range，Extra出现filesort，range类型查询字段后面的索引无效。2. 方式二（成功） 1create index idx_article_ccv on article(category_id,views); 执行EXPLAIN后，type为ref,filesort消失 两表left join 索引建在右表right join 索引建在左表 多个单列索引1234CREATE INDEX first_name on user100w_optimizition(first_name);CREATE INDEX last_name on user100w_optimizition(last_name);EXPLAIN SELECT * FROM user100w_optimizition WHERE first_name = '江' AND last_name = '八'; ==此时只有last_name索引生效== 优化 如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描 范围条件右边列的索引失效 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select* mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描 is null,is not null 也无法使用索引 like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作 字符串不加单引号索引失效 少用or,用它连接时会索引失效 示例假设index(a,b,c) where语句 | 索引是否被使用 where a = 3 | Y，使用awhere a = 3 and b = 5 | Y，使用a，bwhere a = 3 and b = 5 and c = 4 | Y，使用a，b，cwhere b = 3 或者 where b = 3 and c = 4 或者 where c = 4 | Nwhere a = 3 and c = 5 | 使用到a，但是c不可以，b中间断了where a = 3 and b &gt; 4 and c = 5 | 使用后到a，b，c不能用在范围后，b断了where a = 3 and b like ‘kk%’ and c = 4 | Y，使用到a，b，cwhere a = 3 and b like ‘%kk’ and c = 4 | Y，只用到awhere a = 3 and b like ‘%kk%’ and c = 4 | Y，只用到awhere a = 3 and b like ‘k%kk%’ and c = 4 | Y，只用到a，b，c 建议 对于单键索引，尽量选择针对当前query过滤性更好的索引 在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。 在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引 尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"18、nginx 之 X-Forwarded-For 信息头处理","slug":"Nginx/18、nginx 之 X-Forwarded-For 信息头处理","date":"2016-06-18T01:15:54.000Z","updated":"2020-08-07T14:10:11.866Z","comments":true,"path":"2016/06/18/Nginx/18、nginx 之 X-Forwarded-For 信息头处理/","link":"","permalink":"https://www.zackaddy.xin/2016/06/18/Nginx/18、nginx 之 X-Forwarded-For 信息头处理/","excerpt":"","text":"nginx 之 X-Forwarded-For 信息头处理X-Forwarded-For的定义X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP代理或者负载均衡服务器时才会添加该项。它不是RFC中定义的标准请求头信息，在squid缓存代理服务器开发文档中可以找到该项的详细介绍。标准格式如下： 1X-Forwarded-For: client1, proxy1, proxy2 从标准格式可以看出，X-Forwarded-For头信息可以有多个，中间用逗号分隔，第一项为真实的客户端ip，剩下的就是曾经经过的代理或负载均衡的ip地址，经过几个就会出现几个。 按照上图的Web架构图，可以很容易的看出，当用户请求经过CDN后到达Nginx负载均衡服务器时，其X-Forwarded-For头信息应该为 客户端IP,CDN的IP 但实际情况并非如此，一般情况下CDN服务商为了自身安全考虑会将这个信息做些改动，只保留客户端IP。我们可以通过程序获得X-Forwarded-For信息或者通过Nginx的dd header方法来设置返回头来查看。 下面来分析请求头到达Nginx负载均衡服务器的情况；在默认情况下，Nginx并不会对X-Forwarded-For头做任何的处理，除非用户使用proxy_set_header 参数设置： 1proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; $proxy_add_x_forwarded_for变量包含客户端请求头中的X-Forwarded-For，与$remote_addr用逗号分开，如果没有X-Forwarded-For 请求头，则$proxy_add_x_forwarded_for等于$remote_addr。 $remote_addr变量的值是客户端的IP X-Forwarded-For等于$proxy_add_x_forwarded_for后会有两种情况发生1、如果从CDN过来的请求没有设置X-Forwarded-For头（通常这种事情不会发生），而到了我们这里Nginx设置将其设置为$proxy_add_x_forwarded_for的话，X-Forwarded-For的信息应该为CDN的IP，因为相对于Nginx负载均衡来说客户端即为CDN，这样的话，后端的web程序时死活也获得不了真实用户的IP的。 2、CDN设置了X-Forwarded-For，我们这里又设置了一次，且值为$proxy_add_x_forwarded_for的话，那么X-Forwarded-For的内容变成 ”客户端IP,Nginx负载均衡服务器IP“如果是这种情况的话，那后端的程序通过X-Forwarded-For获得客户端IP，则取逗号分隔的第一项即可。 如上两点所说，如果我们知道了CDN设置了X-Forwarded-For信息，且只有客户端真实的IP的话，那么我们的Nginx负载均衡服务器可以不必理会该头，让它默认即可。 其实Nginx中还有一个$http_x_forwarded_for变量，这个变量中保存的内容就是请求中的X-Forwarded-For信息","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"17、nginx 之反向代理的基本配置","slug":"Nginx/17、nginx 之反向代理的基本配置","date":"2016-06-16T23:52:04.000Z","updated":"2020-08-07T14:10:11.865Z","comments":true,"path":"2016/06/17/Nginx/17、nginx 之反向代理的基本配置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/17/Nginx/17、nginx 之反向代理的基本配置/","excerpt":"","text":"nginx 之反向代理的基本配置proxy_pass1proxy_pass URL; 1配置块： location、if 此配置项将当前请求反向代理到URL参数指定的服务器上，URL可以是主机名或IP地址 加端口的形式，例如： 12proxy_pass http://localhost:8000/uri/;proxy_pass http://unix:/path/to/backend.socket:/uri/ 直接使用upstream块 12345upstream backend &#123; ...&#125;proxy_pass http://backend; 默认情况下反向代理是不会转发请求中的Host头部的。如果需要转发，那么必须加上配 置： 1proxy_set_header Host $host; proxy_method1proxy_method method; 1配置块： http、server、location 此配置项表示转发时的协议方法名。例如设置为： 1proxy_method POST; 客户端发来的GET请求在转发时方法名也会改为POST。 proxy_hide_header1proxy_hide_header the_header; 1配置块： http、server、location Nginx会将上游服务器的响应转发给客户端，但默认不会转发以下HTTP头部字段： Date、Server、X-Pad和X-Accel-*。使用proxy_hide_header后可以任意地指定哪些HTTP头部 字段不能被转发。例如： 12proxy_hide_header Cache-Control; proxy_hide_header MicrosoftOfficeWebServer; proxy_pass_header1proxy_pass_header the_header; 1配置块： http、server、location 与proxy_hide_header功能相反，proxy_pass_header会将原来禁止转发的header设置为允许 转发。例如： 1proxy_pass_header X-Accel-Redirect; proxy_pass_request_body1proxy_pass_request_body on|off; #默认： proxy_pass_request_body on; 1配置块： http、server、location 作用为确定是否向上游服务器发送HTTP body部分。 proxy_pass_request_headers1proxy_pass_request_headers on|off; #默认： proxy_pass_request_headers on; 1配置块： http、server、location 作用为确定是否转发HTTP头部。 proxy_redirect1proxy_redirect[default|off|redirect replacement]; #默认： proxy_redirect default; 1配置块： http、server、location 当上游服务器返回的响应是重定向或刷新请求（如HTTP响应码是301或者302）时， proxy_redirect可以重设HTTP头部的location或refresh字段。 示例：访问a.jsp跳转到b.jsphostA/app/a.jsp jump to hostB:8080/test_app/b.jsp 12345678server &#123; listen 80; server_name hostA; location /app/ &#123; proxy_pass hostB:8080/test_app/; proxy_redirect xxx; &#125;&#125; 以下为测试结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051访问测试地址：hostA/app/a.jsp测试代理地址：proxy_pass hostB:8080/test_app/;未配置则重定向为：hostB:8080/test_app/b.jsp;用法对比：proxy_redirect hostB:8080/ /app/跳转到：hostA/app/test_app/b.jspproxy_redirect hostB:8080/ /跳转到：hostA/test_app/b.jspproxy_redirect / /;跳转到：hostB:8080/test_app/b.jspproxy_redirect default;跳转到：hostA/app/b.jspproxy_redirect hostB:8080/test_app/ /app/;（与default等同）跳转到：hostA/app/b.jspproxy_redirect hostB:8080/test_app/ hostA/app/;跳转到：hostA/app/b.jspproxy_redirect(不加)跳转到：hostA/app/b.jspproxy_redirect off;跳转到：hostB:8080/test_app/b.jspproxy_redirect hostB:8080/test_app/ /;跳转到：hostA/b.jsp proxy_next_upstream1proxy_next_upstream[error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off]; #默认： proxy_next_upstream error timeout; 1配置块： http、server、location 此配置项表示当向一台上游服务器转发请求出现错误时，继续换一台上游服务器处理这个请求。 上游服务器一旦开始发送应答，Nginx反向代理服务器会立刻把应 答包转发给客户端。因此，一旦Nginx开始向客户端发送响应包，之后的过程中若出现错误 也是不允许换下一台上游服务器继续处理的。这很好理解，这样才可以更好地保证客户端只收到来自一个上游服务器的应答。 proxy_next_upstream的参数用来说明在哪些情况下会继续 选择下一台上游服务器转发请求。 error：当向上游服务器发起连接、发送请求、读取响应时出错。 timeout：发送请求或读取响应时发生超时。 invalid_header：上游服务器发送的响应是不合法的。 http_500：上游服务器返回的HTTP响应码是500。 http_502：上游服务器返回的HTTP响应码是502。 http_503：上游服务器返回的HTTP响应码是503。 http_504：上游服务器返回的HTTP响应码是504。 http_404：上游服务器返回的HTTP响应码是404。 off：关闭proxy_next_upstream功能—出错就选择另一台上游服务器再次转发。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"78、mysql 之explain查看执行计划","slug":"Mysql/78、mysql 之explain查看执行计划","date":"2016-06-16T17:57:23.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/06/17/Mysql/78、mysql 之explain查看执行计划/","link":"","permalink":"https://www.zackaddy.xin/2016/06/17/Mysql/78、mysql 之explain查看执行计划/","excerpt":"","text":"mysql 之explain查看执行计划简介MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如: 1SELECT * FROM tablename; expain出来的信息有10列 分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra 下面对这些字段出现的可能进行解释： idselect查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序 id相同，执行顺序由上至下 id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 id有相同和不同，这时按1、2步骤执行 select_type查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询 SIMPLE 简单的select查询，查询中不包含子查询或者UNION PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为 SUBQUERY 在SELECT或者WHERE列表中包含了子查询 DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。 UNION 若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED UNION RESULT 从UNION表获取结果的SELECT table显示这一行的数据是关于哪张表的 type显示查询使用了何种类型 从最好到最差依次是： 1NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL NULL MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 system 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计 const 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量 explain select * from (select * from t1 where id = 1) d1 eq_ref 唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描 explain select * from t1, t2 where t1.id = t2.id ref 非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体 explain select * from t1 where col1 = &#39;ac&#39; range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束语另一点，不用扫描全部索引 explain select * from t1 where id between 30 and 60; explain select * from t1 where id in (1,2,6); index Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的） all FullTable Scan,将遍历全表以找到匹配的行 ==一般来说，得保证查询只是达到range级别，最好达到ref== possible_keys显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用 key 实际使用的索引。如果为null则没有使用索引 查询中若使用了覆盖索引，则索引和查询的select字段重叠 CREATE INDEX index_name ON table_name(col1,col2); select col1, col2 where table_name key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的） 不损失精确性的情况下，长度越短越好 ref显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值 rows根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 越少越好 Extra该列包含MySQL解决查询的详细信息,有以下几种情况： Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤 Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询 Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序” Using join buffer：该值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。 Impossible where：这个值强调了where语句会导致没有符合条件的行。 Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 总结 EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 EXPLAIN不考虑各种Cache EXPLAIN不能显示MySQL在执行查询时所作的优化工作 部分统计信息是估算的，并非精确值 EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"16、nginx 之负载均衡的基本配置","slug":"Nginx/16、nginx 之负载均衡的基本配置","date":"2016-06-16T01:40:17.000Z","updated":"2020-08-07T14:10:11.865Z","comments":true,"path":"2016/06/16/Nginx/16、nginx 之负载均衡的基本配置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/16/Nginx/16、nginx 之负载均衡的基本配置/","excerpt":"","text":"nginx 之负载均衡的基本配置作为代理服务器，一般都需要向上游服务器的集群转发请求。这里的负载均衡是指选择 一种策略，尽量把请求平均地分布到每一台上游服务器上。 upstream块1upstream name&#123;...&#125; 1配置块： http upstream块定义了一个上游服务器的集群，便于反向代理中的proxy_pass使用。例如： 12345678910upstream backend &#123; server backend1.example.com; server backend2.example.com; server backend3.example.com; &#125;server &#123; location / &#123; proxy_pass http://backend; &#125; &#125; server1server name[parameters]; 1配置块： upstream server配置项指定了一台上游服务器的名字，这个名字可以是域名、IP地址端口、UNIX 句柄等，在其后还可以跟下列参数。 weight=number：设置向这台上游服务器转发的权重，默认为1。 max_fails=number：该选项与fail_timeout配合使用，指在fail_timeout时间段内，如果向 当前的上游服务器转发失败次数超过number，则认为在当前的fail_timeout时间段内这台上游 服务器不可用。max_fails默认为1，如果设置为0，则表示不检查失败次数。 fail_timeout=time：fail_timeout表示该时间段内转发失败多少次后就认为上游服务器暂 时不可用，用于优化反向代理功能。它与向上游服务器建立连接的超时时间、读取上游服务 器的响应超时时间等完全无关。fail_timeout默认为10秒。 down：表示所在的上游服务器永久下线，只在使用ip_hash配置项时才有用。 backup：在使用ip_hash配置项时它是无效的。它表示所在的上游服务器只是备份服务 器，只有在所有的非备份上游服务器都失效后，才会向所在的上游服务器转发请求。 12345upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; &#125; ip_hash1ip_hash; 1配置块： upstream 在有些场景下，我们可能会希望来自某一个用户的请求始终落到固定的一台上游服务器 中。例如，假设上游服务器会缓存一些信息，如果同一个用户的请求任意地转发到集群中的 任一台上游服务器中，那么每一台上游服务器都有可能会缓存同一份信息，这既会造成资源 的浪费，也会难以有效地管理缓存信息。ip_hash就是用以解决上述问题的，它首先根据客户 端的IP地址计算出一个key，将key按照upstream集群里的上游服务器数量进行取模，然后以取 模后的结果把请求转发到相应的上游服务器中。这样就确保了同一个客户端的请求只会转发 到指定的上游服务器中 ip_hash与weight（权重）配置不可同时使用。如果upstream集群中有一台上游服务器暂 时不可用，不能直接删除该配置，而是要down参数标识，确保转发策略的一贯性。例如： 1234567upstream backend &#123; ip_hash; server backend1.example.com; server backend2.example.com; server backend3.example.com down; server backend4.example.com; &#125; fair（第三方）1fair; 1配置块： upstream 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backserver &#123; server server1; server server2; fair;&#125; 记录日志时支持的变量如果需要将负载均衡时的一些信息记录到access_log日志中，那么在定义日志格式时可 以使用负载均衡功能提供的变量 变量名 | 意义 $upstream_addr | 处理请求的上游服务器地址$upstream_cache_status | 表示是否命中缓存。取值范围：MISS EXPIRED UPDATING STALE HIT$upstream_status | 上游服务器返回的响应中的HTTP响应码$upstream_response_time | 上游服务器的响应时间，精度到毫秒$upstream_http_$HEADER | HTTP的头部，如upstream_http_host 例如，可以在定义access_log访问日志格式时使用表中的变量。 1log_format timing '$remote_addr - $remote_user [$time_local] $request ' 'upstream_response_time $upstream_response_time ' 'msec $msec request_time $request_time'; log_format up_head '$remote_addr - $remote_user [$time_local] $request ' 'upstream_http_content_type $upstream_http_content_type';","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"77、mysql 之性能下降原因","slug":"Mysql/77、mysql 之性能下降原因","date":"2016-06-15T18:21:25.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/06/16/Mysql/77、mysql 之性能下降原因/","link":"","permalink":"https://www.zackaddy.xin/2016/06/16/Mysql/77、mysql 之性能下降原因/","excerpt":"","text":"mysql 之性能下降原因等待时间长锁表导致查询一直处于等待状态，后续我们从MySQL锁的机制去分析SQL执行的原理 执行时间长 运行环境的原因（可忽略） 例如：磁盘空间满了 查询语句写的烂 例如：各种join、各种子查询、没建索引 索引失效（分单值、复合） 建了索引，但执行SQL的时候没用上 关联查询太多join（设计缺陷或不得已的需求） 服务器调优及各个参数设置（缓存、线程数等）","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"15、nginx 之反向代理概述","slug":"Nginx/15、nginx 之反向代理概述","date":"2016-06-15T03:05:09.000Z","updated":"2020-08-07T14:10:11.865Z","comments":true,"path":"2016/06/15/Nginx/15、nginx 之反向代理概述/","link":"","permalink":"https://www.zackaddy.xin/2016/06/15/Nginx/15、nginx 之反向代理概述/","excerpt":"","text":"nginx 之反向代理概述正向代理：代理服务器为客户端服务，在客户端与目标服务地址中间 反向代理：代理服务器为服务端服务，在目标服务地址后方 反向代理（reverse proxy）方式是指用代理服务器来接受Internet上的连接请求，然后将 请求转发给内部网络中的上游服务器，并将从上游服务器上得到的结果返回给Internet上请求 连接的客户端，此时代理服务器对外的表现就是一个Web服务器。充当反向代理服务器也是 Nginx的一种常见用法（反向代理服务器必须能够处理大量并发请求），本节将介绍Nginx作 为HTTP反向代理服务器的基本用法。 由于Nginx具有“强悍”的高并发高负载能力，因此一般会作为前端的服务器直接向客户 端提供静态文件服务。但也有一些复杂、多变的业务不适合放到Nginx服务器上，这时会用 Apache、Tomcat等服务器来处理。于是，Nginx通常会被配置为既是静态Web服务器也是反向 代理服务器，不适合Nginx处理的请求就会直接转发到上游服务器中处理。 12345678graph LR电脑1--&gt;nginx服务器反向代理电脑2--&gt;nginx服务器反向代理电脑3--&gt;nginx服务器反向代理nginx服务器反向代理--&gt;内网主机1nginx服务器反向代理--&gt;内网主机2nginx服务器反向代理--&gt;内网主机3nginx服务器反向代理--&gt;内网主机4 当客户端发来HTTP请求时，Nginx并不会立刻转发到上游服务器，而是先把用户的请求 （包括HTTP包体）完整地接收到Nginx所在服务器的硬盘或者内存中，然后再向上游服务器 发起连接，把缓存的客户端请求转发到上游服务器 Nginx的这种工作方式为什么会降低上游服务器的负载呢？通常，客户端与代理服务器 之间的网络环境会比较复杂，多半是“走”公网，网速平均下来可能较慢，因此，一个请求可 能要持续很久才能完成。而代理服务器与上游服务器之间一般是“走”内网，或者有专线连 接，传输速度较快。 例如，某个请求要上传一个1GB的文件，那么每次 Squid在收到一个TCP分包（如2KB）时，就会即时地向上游服务器转发。在接收客户端完整 HTTP包体的漫长过程中，上游服务器始终要维持这个连接，这直接对上游服务器的并发处 理能力提出了挑战 Nginx则不然，它在接收到完整的客户端请求（如1GB的文件）后，才会与上游服务器 建立连接转发请求，由于是内网，所以这个转发过程会执行得很快。这样，一个客户端请求 占用上游服务器的连接时间就会非常短，也就是说，Nginx的这种反向代理方案主要是为了 降低上游服务器的并发压力。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"76、mysql 之存储引擎简介","slug":"Mysql/76、mysql 之存储引擎简介","date":"2016-06-14T21:24:39.000Z","updated":"2020-08-07T14:10:11.860Z","comments":true,"path":"2016/06/15/Mysql/76、mysql 之存储引擎简介/","link":"","permalink":"https://www.zackaddy.xin/2016/06/15/Mysql/76、mysql 之存储引擎简介/","excerpt":"","text":"mysql 之存储引擎简介查看提供了哪些存储引擎1show engines; 查看默认的存储引擎1show variables like '%storage_engine%'; myisam与innodb 对比项 myisam innodb 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发操作 行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y ### 存储引擎的选择 存储引擎 说明 – – MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务 InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 ISAM MyISAM的前身，MySQL5.0以后不再默认安装 MRG_MyISAM(MERGE) 将多个表联合成一个表使用，在超大规模数据存储时很有用 Memory 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 Falcon 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 Archive 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 CSV CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换) 存储引擎支持的索引 索引 MyISAM引擎 InnoDB引擎 Memory引擎 B-Tree 索引 支持 支持 支持 HASH 索引 不支持 不支持 支持 R-Tree 索引 支持 不支持 不支持 Full-text 索引 不支持 暂不支持 不支持 Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有着很显著的提升。该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。 该公司新建了一款存储引擎叫xtradb完全可替代innodb，并且在性能h和并发上做的更好。 阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改 AliSql+AliRedis","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"75、mysql 之逻辑架构介绍","slug":"Mysql/75、mysql 之逻辑架构介绍","date":"2016-06-14T02:22:56.000Z","updated":"2020-08-07T14:10:11.860Z","comments":true,"path":"2016/06/14/Mysql/75、mysql 之逻辑架构介绍/","link":"","permalink":"https://www.zackaddy.xin/2016/06/14/Mysql/75、mysql 之逻辑架构介绍/","excerpt":"","text":"mysql 之逻辑架构介绍逻辑架构图总体概览和数据库相比，MySQL有点与众不同，他的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据存储的存储提取相分离，这种架构可以个根据业务的需求和实际需要选择合适的存储引擎。 1. 连接层最上层是一些客户端和连接服务，包括本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引出了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSl的安全链接。服务器也会为安全接入的每个客户端验证它所具有的的操作权限。 2. 服务层第二层架构主要大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析及优化及部分内置函数的执行。所有跨存储引擎的功能也在这层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化，如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作，如select语句，服务器还会查询内部的缓存。如果缓存空间足够大这样在解决大量读操作的环境中能够良好的提升系统的性能。 3. 引擎层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和读取，服务器通过api与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需求进行选取，后面介绍MyISAM和InnoDB 4. 存储层数据存储层，只要将数据存储在运行与裸设备的文件系统上，并完成与存储引擎的交互。 Connectors指的是不同语言中与SQL的交互 Management Serveices &amp; Utilities：系统管理和控制工具 Connection Pool: 连接池管理缓冲用户连接，线程处理等需要缓存的需求。 负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信， 接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。 SQL Interface: SQL接口。接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface Parser: 解析器。SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。主要功能： 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的Optimizer: 查询优化器。SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果他使用的是“选取-投影-联接”策略进行查询。 用一个例子就可以理解： select uid,name from user where gender = 1;这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤 这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤将这两个查询条件联接起来生成最终查询结果 Cache和Buffer： 查询缓存。他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 存储引擎接口存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。 从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。 注意：存储引擎是基于表的，而不是数据库。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"14、nginx 之 ngx_http_core_module 模块提供的变量","slug":"Nginx/14、nginx 之 ngx_http_core_module 模块提供的变量","date":"2016-06-14T02:07:00.000Z","updated":"2020-08-07T14:10:11.865Z","comments":true,"path":"2016/06/14/Nginx/14、nginx 之 ngx_http_core_module 模块提供的变量/","link":"","permalink":"https://www.zackaddy.xin/2016/06/14/Nginx/14、nginx 之 ngx_http_core_module 模块提供的变量/","excerpt":"","text":"nginx 之 ngx_http_core_module 模块提供的变量ngx_http_core_module 模块支持嵌入式变量名称与 Apache 服务器变量匹配。首先，这些是出现在客户端请求头字段的变量，例如 $http_user_agent、$http_cookie 等等。还有其他变量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110$arg_name请求行中的 name 参数$args请求行中的参数$binary_remote_addr客户端地址以二进制形式表示，值的长度对于 IPv4 地址总是 4 个字节，对于 IPv6 地址总是 16 个字节$body_bytes_sent发送到客户端的字节数，不包括响应头。此变量与 mod_log_config Apache 模块的 ％B 参数兼容$bytes_sent发送到客户端的字节数（1.3.8、1.2.5）$connection连接序列号（1.3.8、1.2.5）$connection_requests当前通过连接请求的请求数（1.3.8、1.2.5）$connect_lengthContent-Length 请求头字段$content_typeContent-Type 请求头字段$cookie_name名称为 name 的 cookie$document_root根目录或别名指令的当前请求的值$document_uri与 $uri 相同$host按照以下优先顺序：来自请求行的主机名，来自 Host 请求头字段的主机名，或与请求匹配的服务器名$hostname主机名$http_name任意请求头字段,变量名称的最后一部分是将字段名称转换为小写，并用破折号替换为下划线$https如果连接以 SSL 模式运行，则为 on，否则为空字符串$is_args如果请求行有参数则为 ?，否则为空字符串$limit_rate设置这个变量可以实现响应速率限制，见 limit_rate$msec当前时间以毫秒为单位（1.3.9、1.2.6）$nginx_versionnginx 版本$pid工作进程的 PID$pipe如果请求是管道模式则为 p，否则为 .（1.3.12、1.2.7）$proxy_protocol_addr来自 PROXY 协议头的客户端地址，否则为空字符串（1.5.12）要在 listen 指令中设置 proxy_protocol 参数，必须先启用 PROXY 协议。$proxy_protocol_portPROXY 协议头中的客户端口，否则为空字符串（1.11.0）要在 listen 指令中设置 proxy_protocol 参数，必须先启用 PROXY 协议。$query_string与 $args 相同$realpath_root与当前请求的 root 或 alias 指令值相对应的绝对路径名，所有符号链接都将解析为实际路径$remote_addr客户端地址$remote_port客户端端口$remote_user基本身份验证提供的用户名$request完整的原始请求行$request_body请求正文当请求正文被读取到内存缓冲区时，变量的值在由proxy_pass、fastcgi_pass、uwsgi_pass 和 scgi_pass 指令处理的 location 中可用。$request_body_file带有请求正文的临时文件的名称在处理结束时，文件需要被删除。想始终将请求主体写入文件中，需要启用 client_body_in_file_only。当临时文件的名称在代理请求中或在向 FastCGI/uwsgi/SCGI 服务器的请求中传递时，应该分别通过 proxy_pass_request_body off、fastcgi_pass_request_body off、uwsgi_pass_request_body off 或 scgi_pass_request_body off 指令禁用传递请求正文。$request_completion如果请求已经完成，则返回 OK，否则返回空字符串$request_filename当前请求的文件路径，基于 root 或 alias 指令以及请求 URI$request_id由 16 个随机字节生成的唯一请求标识符，以十六进制表示（1.11.0）$request_length请求长度（包括请求行、头部和请求体）（1.3.12、1.2.7）$request_method请求方法，通常为 GET 或 POST$request_time请求处理时间以毫秒为单位（1.3.9、1.2.6）。自客户端读取第一个字节的时间起$request_uri完整的原始请求 URI（带参数）$scheme请求模式，http 或 https$sent_http_name任意响应头字段。变量名称的最后一部分是将字段名称转换为小写，并用破折号替换为下划线$sent_trailer_name响应结束时发送的任意字段（1.13.2）。变量名称的最后一部分是将字段名称转换为小写，并用破折号替换为下划线$server_addr接受请求的服务器地址通常需要一个系统调用来计算这个变量的值。为了避免系统调用，listen 指令必须指定地址并使用 bind 参数。$server_name接受请求的服务器名称$server_port接受请求的服务器端口$server_protocol请求协议，通常为 HTTP/1.0、HTTP/1.1 或 HTTP/2.0$status响应状态（1.3.2、1.2.2）$tcpinfo_rtt、$tcpinfo_rttvar、$tcpinfo_snd_cwnd、$tcpinfo_rcv_space有关客户端 TCP 连接的信息。在支持 TCP_INFO 套接字选项的系统上可用$time_iso8601本地时间采用 ISO 8601 标准格式（1.3.12、1.2.7）$time_local通用日志格式（Common Log Format）中的本地时间（1.3.12、1.2.7）$uri规范化过的当前请求 URI$uri 的值可能在请求期间会改变","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"13、nginx 之对客户端请求的特殊处理","slug":"Nginx/13、nginx 之对客户端请求的特殊处理","date":"2016-06-13T00:56:27.000Z","updated":"2020-08-07T14:10:11.864Z","comments":true,"path":"2016/06/13/Nginx/13、nginx 之对客户端请求的特殊处理/","link":"","permalink":"https://www.zackaddy.xin/2016/06/13/Nginx/13、nginx 之对客户端请求的特殊处理/","excerpt":"","text":"nginx 之对客户端请求的特殊处理忽略不合法的HTTP头部1ignore_invalid_headers on|off; #默认： ignore_invalid_headers on; 1配置块： http、server 如果将其设置为off，那么当出现不合法的HTTP头部时，Nginx会拒绝服务，并直接向用 户发送400（Bad Request）错误。如果将其设置为on，则会忽略此HTTP头部。 HTTP头部是否允许下划线1underscores_in_headers on|off; #默认： underscores_in_headers off; 1配置块： http、server 默认为off，表示HTTP头部的名称中不允许带“_”（下划线）。 对If-Modified-Since头部的处理策略1if_modified_since[off|exact|before]; #默认： if_modified_since exact; 1配置块： http、server、location If-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。 如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。 如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。 相关参数说明如下。 off：表示忽略用户请求中的If-Modified-Since头部。这时，如果获取一个文件，那么会 正常地返回文件内容。HTTP响应码通常是200。 exact：将If-Modified-Since头部包含的时间与将要返回的文件上次修改的时间做精确比 较，如果没有匹配上，则返回200和文件的实际内容，如果匹配上，则表示浏览器缓存的文 件内容已经是最新的了，没有必要再返回文件从而浪费时间与带宽了，这时会返回304 Not Modified，浏览器收到后会直接读取自己的本地缓存。 before：是比exact更宽松的比较。只要文件的上次修改时间等于或者早于用户请求中的If-Modified-Since头部的时间，就会向客户端返回304 Not Modified。 文件未找到时是否记录到error日志1log_not_found on|off; #默认： log_not_found on; 1配置块： http、server、location 此配置项表示当处理用户请求且需要访问文件时，如果没有找到文件，是否将错误日志 记录到error.log文件中。这仅用于定位问题。 merge_slashes1merge_slashes on|off; #默认： merge_slashes on; 1配置块： http、server、location 此配置项表示是否合并相邻的“”，例如，/test///a.txt，在配置为on时，会将其匹配为 location/test/a.txt；如果配置为off，则不会匹配，URI将仍然是//test///a.txt。 DNS解析地址1resolver address...; 1配置块： http、server、location 设置DNS名字解析服务器的地址，例如： 1resolver 127.0.0.1 192.0.2.1; DNS解析的超时时间1resolver_timeout time; #默认： resolver_timeout 30s; 1配置块： http、server、location 此配置项表示DNS解析的超时时间。 返回错误页面时是否在Server中注明Nginx版本1server_tokens on|off; #默认： server_tokens on; 1配置块： http、server、location 表示处理请求出错时是否在响应的Server头部中标明Nginx版本，这是为了方便定位问题","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"74、mysql 之全文索引与like模糊查询","slug":"Mysql/74、mysql 之全文索引与like模糊查询","date":"2016-06-12T21:40:30.000Z","updated":"2020-08-07T14:10:11.860Z","comments":true,"path":"2016/06/13/Mysql/74、mysql 之全文索引与like模糊查询/","link":"","permalink":"https://www.zackaddy.xin/2016/06/13/Mysql/74、mysql 之全文索引与like模糊查询/","excerpt":"","text":"mysql 之全文索引与like模糊查询LIKE搜索的耗时随着记录数的增加而线性增长，但对于10万行记录以下的表（这里共100000*50个单词）搜索时间基本上能保持在1秒以内，所以like搜索的性能也不是特别差。由不同词汇量生成的文本对LIKE搜索的性能影响不大，不同词汇量对应的搜索时间基本上在一个很小的时间范围内变化。 FULLTEXT搜索耗时也随表中记录数的增长而线性增加。对于10万行记录以下的表（这里共100000*50个单词）搜索时间基本上能保持在0.01秒以内。由不同词汇量生成的随机文本对FULLTEXT搜索性能有相对来说比较显著的影响。每行记录中含同样的单词数，这样，较大的词汇量倾向于生成冗余度更低的文本，相应的搜索耗时倾向于更少。这可能与FULLTEXT索引建立单词索引的机制有关，较大的词汇量倾向于生成范围广但相对较浅的索引，因而能快速确定文本是否匹配。 与LIKE搜索相比，FULLTEXT全文搜索的性能要强很多，对于10万行记录的表，搜索时间都在0.02秒以下。因此可以将基于FULLTEXT索引的文本搜索部署于网站项目中的文本搜索功能中。但是，正如上述提到的，无论是LIKE搜索还是FULLTEXT搜索，其性能都会随着记录数的增长而下降，因此，若网站项目中的文本搜索数据库记录数庞大的一定规模后，可能需要考虑使用MySQL数据库全文搜索以外的文本搜索解决方案了。 搜索功能一般都用带有中文分词的开源产品，像xunsearch。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"12、nginx 之文件操作的优化","slug":"Nginx/12、nginx 之文件操作的优化","date":"2016-06-12T04:52:23.000Z","updated":"2020-08-07T14:10:11.864Z","comments":true,"path":"2016/06/12/Nginx/12、nginx 之文件操作的优化/","link":"","permalink":"https://www.zackaddy.xin/2016/06/12/Nginx/12、nginx 之文件操作的优化/","excerpt":"","text":"nginx 之文件操作的优化sendfile系统调用1sendfile on|off; #默认： sendfile off; 1配置块： http、server、location 可以启用Linux上的sendfile系统调用来发送文件，它减少了内核态与用户态之间的两次内存复制，这样就会从磁盘中读取文件后直接在内核态发送到网卡设备，提高了发送文件的效率。 AIO系统调用1aio on|off; #默认： aio off; 1配置块： http、server、location 此配置项表示是否在FreeBSD或Linux系统上启用内核级别的异步文件I/O功能。注意， 它与sendfile功能是互斥的。 directio1directio size|off; #默认： directio off; 1配置块： http、server、location 此配置项在FreeBSD和Linux系统上使用O_DIRECT选项去读取文件，缓冲区大小为size， 通常对大文件的读取速度有优化作用。注意，它与sendfile功能是互斥的。 directio_alignment1directio_alignment size; #默认： directio_alignment 512; 1配置块： http、server、location 它与directio配合使用，指定以directio方式读取文件时的对齐方式。一般情况下，512B 已经足够了，但针对一些高性能文件系统，如Linux下的XFS文件系统，可能需要设置到4KB 作为对齐方式。 打开文件缓存1open_file_cache max=N[inactive=time]|off; #默认： open_file_cache off; 1配置块： http、server、location 文件缓存会在内存中存储以下3种信息： 文件句柄、文件大小和上次修改时间。 已经打开过的目录结构。 没有找到的或者没有权限操作的文件信息 这样，通过读取缓存就减少了对磁盘的操作。 该配置项后面跟3种参数。 max：表示在内存中存储元素的最大个数。当达到最大限制数量后，将采用 LRU（Least Recently Used）算法从缓存中淘汰最近最少使用的元素。 inactive：表示在inactive指定的时间段内没有被访问过的元素将会被淘汰。默认时间为 60秒。 off：关闭缓存功能。1open_file_cache max=1000 inactive=20s; 是否缓存打开文件错误的信息1open_file_cache_errors on|off; #默认： open_file_cache_errors off; 1配置块： http、server、location 此配置项表示是否在文件缓存中缓存打开文件时出现的找不到路径、没有权限等错误信 息 不被淘汰的最小访问次数1open_file_cache_min_uses number; #默认： open_file_cache_min_uses 1; 1配置块： http、server、location 它与open_file_cache中的inactive参数配合使用。如果在inactive指定的时间段内，访问次 数超过了open_file_cache_min_uses指定的最小次数，那么将不会被淘汰出缓存。 检验缓存中元素有效性的频率1open_file_cache_valid time; #默认： open_file_cache_valid 60s; 1配置块： http、server、location 默认为每60秒检查一次缓存中的元素是否仍有效。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"73、mysql 之窗口函数","slug":"Mysql/73、mysql 之窗口函数","date":"2016-06-11T17:37:19.000Z","updated":"2020-08-07T14:10:11.860Z","comments":true,"path":"2016/06/12/Mysql/73、mysql 之窗口函数/","link":"","permalink":"https://www.zackaddy.xin/2016/06/12/Mysql/73、mysql 之窗口函数/","excerpt":"","text":"mysql 之窗口函数从version 8.0开始，MySQL支持在查询中使用窗口函数 文中的示例用到的建表语句和插值语句如下： 1234567891011121314151617CREATE TABLE sales( sales_employee VARCHAR(50) NOT NULL, fiscal_year INT NOT NULL, sale DECIMAL(14,2) NOT NULL, PRIMARY KEY(sales_employee,fiscal_year)); INSERT INTO sales(sales_employee,fiscal_year,sale)VALUES('Bob',2016,100), ('Bob',2017,150), ('Bob',2018,200), ('Alice',2016,150), ('Alice',2017,100), ('Alice',2018,200), ('John',2016,200), ('John',2017,150), ('John',2018,250); 先看一个例子： 1234567SELECT fiscal_year, sales_employee, sale, SUM(sale) OVER (PARTITION BY fiscal_year) total_salesFROM sales; 执行后得到的结果如下： 1234567891011121314+-------------+----------------+--------+-------------+| fiscal_year | sales_employee | sale | total_sales |+-------------+----------------+--------+-------------+| 2016 | Alice | 150.00 | 450.00 || 2016 | Bob | 100.00 | 450.00 || 2016 | John | 200.00 | 450.00 || 2017 | Alice | 100.00 | 400.00 || 2017 | Bob | 150.00 | 400.00 || 2017 | John | 150.00 | 400.00 || 2018 | Alice | 200.00 | 650.00 || 2018 | Bob | 200.00 | 650.00 || 2018 | John | 250.00 | 650.00 |+-------------+----------------+--------+-------------+9 rows in set (0.00 sec) 这里，sum()函数充当了窗口函数，得到了根据fiscal_year计算出的sale的总和total_sales列，但是又不像它作为聚合函数使用时一样，这里的结果保留了每一行的信息。 窗口函数的结果集是在FROM，JOIN，WHERE，GROUP BY，HAVING之后，在ORDER BY，LIMIT，SELECT DISTINCT之前。它执行时GROUP BY的聚合过程已经完成了，所以不会再产生数据聚合。 窗口函数的语法123456window_function_name(expression) OVER ( [partition_defintion] [order_definition] [frame_definition] ) 先指定作为窗口函数的函数名，然后是OVER(…)，就算OVER里面没有内容，括号也需要保留。窗口函数的一个概念是当前行，当前行属于某个窗口，窗口由“[partition_defintion]”，“[order_definition]”，“[frame_definition]“确定。 partition_defintion翻译过来应该是分区，语法是”PARTITION BY &lt; expression&gt;[{,&lt; expression&gt;…}]”，它会根据单个或者多个表达式的计算结果来分区（列名也是一种表达式，它的结果就是列名本身）。在前面的例子中，结果中的每一行都有自己的分区，total_sales列的值就是它所属的分区里面的sum(sale)的结果。 frame_definition这里先讲frame_definition，可能应该是叫帧吧。它的作用是在分区里面再进一步细分窗口。语法是1frame_unit &#123;&lt;frame_start&gt;|&lt;frame_between&gt;&#125; frame_unit有两种，分别是ROWS和RANGE，由ROWS定义的frame是由开始和结束位置的行确定的，由RANGE定义的frame由在某个值区间的行确定。如果只指定了frame的开始位置，那么结束位置就默认为当前行。 frame_start有三种： UNBOUNDED PRECEDING: 区间的第一行 N PRECEDING: 当前行之前的N行，N可以是数字，也可以是一个能计算出数字的表达式 CURRENT ROW: 当前行 frame_between的可以取的值如下： frame_start：如前面所列 UNBOUNDED FOLLOWING：区间的最后一行 N FOLLOWING：当前行之后的N行，N可以是数字，也可以是一个能计算出数字的表达式如果没显式指定frame的话，MySQL会认为frame是“ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING” 这个有点复杂，看个例子： 12345678SELECT fiscal_year, sales_employee, sale, SUM(sale) OVER (PARTITION BY sales_employee ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) total_salesFROM sales; 执行结果如下： 1234567891011121314+-------------+----------------+--------+-------------+| fiscal_year | sales_employee | sale | total_sales |+-------------+----------------+--------+-------------+| 2016 | Alice | 150.00 | 150.00 || 2017 | Alice | 100.00 | 250.00 || 2018 | Alice | 200.00 | 450.00 || 2016 | Bob | 100.00 | 100.00 || 2017 | Bob | 150.00 | 250.00 || 2018 | Bob | 200.00 | 450.00 || 2016 | John | 200.00 | 200.00 || 2017 | John | 150.00 | 350.00 || 2018 | John | 250.00 | 600.00 |+-------------+----------------+--------+-------------+9 rows in set (0.00 sec) 第一行所在的区间是sales_employee为Alice的区间，所在的帧是区间第一行到当前行，只有一行，total_sales为150； 第二行所在的区间是sales_employee为Alice的区间，所在的帧是区间第一行到当前行，有两行，total_sales为150+100=250； 第一行所在的区间是sales_employee为Alice的区间，所在的帧是区间第一行到当前行，有三行，total_sales为150+100+200=450。 order_definition定义了分区内的行的排列顺序，语法是1ORDER BY &lt; expression&gt; [ASC|DESC],[&#123;,&lt;expression&gt;…&#125;]","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"11、nginx 之对客户端的请求限制","slug":"Nginx/11、nginx 之对客户端的请求限制","date":"2016-06-10T22:13:45.000Z","updated":"2020-08-07T14:10:11.864Z","comments":true,"path":"2016/06/11/Nginx/11、nginx 之对客户端的请求限制/","link":"","permalink":"https://www.zackaddy.xin/2016/06/11/Nginx/11、nginx 之对客户端的请求限制/","excerpt":"","text":"nginx 之对客户端的请求限制按HTTP方法名限制用户请求1limit_except method...&#123;...&#125; 1配置块： location Nginx通过limit_except后面指定的方法名来限制用户请求。方法名可取值包括：GET、 HEAD、POST、PUT、DELETE、MKCOL、COPY、MOVE、OPTIONS、PROPFIND、 PROPPATCH、LOCK、UNLOCK或者PATCH。例如： 1234limit_except GET &#123; allow 192.168.1.0/32; deny all; &#125; 注意，允许GET方法就意味着也允许HEAD方法。因此，上面这段代码表示的是禁止 GET方法和HEAD方法，但其他HTTP方法是允许的。 HTTP请求body的最大值1client_max_body_size size; #默认： client_max_body_size 1m; 1配置块： http、server、location 浏览器在发送含有较大HTTP包体的请求时，其头部会有一个Content-Length字段， client_max_body_size是用来限制Content-Length所示值的大小的。因此，这个限制包体的配置 非常有用处，因为不用等Nginx接收完所有的HTTP包体——这有可能消耗很长时间——就可 以告诉用户请求过大不被接受。例如，用户试图上传一个10GB的文件，Nginx在收完包头 后，发现Content-Length超过client_max_body_size定义的值，就直接发送413(“Request EntityToo Large”)响应给客户端。 对请求的限速1limit_rate speed; #默认： limit_rate 0; 1配置块： http、server、location、if 此配置是对客户端请求限制每秒传输的字节数。speed可以使用2.2.4节中提到的多种单 位，默认参数为0，表示不限速。 针对不同的客户端，可以用$limit_rate参数执行不同的限速策略。例如： 12345server &#123; if ($slow) &#123; set $limit_rate 4k; &#125; &#125; limit_rate_after1limit_rate_after time; #默认： limit_rate_after 1m; 1配置块： http、server、location、if 此配置表示Nginx向客户端发送的响应长度超过limit_rate_after后才开始限速。例如： 12limit_rate_after 1m; limit_rate 100k;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"72、mysql 之ngram全文解析器","slug":"Mysql/72、mysql 之ngram全文解析器","date":"2016-06-10T21:27:15.000Z","updated":"2020-08-07T14:10:11.859Z","comments":true,"path":"2016/06/11/Mysql/72、mysql 之ngram全文解析器/","link":"","permalink":"https://www.zackaddy.xin/2016/06/11/Mysql/72、mysql 之ngram全文解析器/","excerpt":"","text":"mysql 之ngram全文解析器内置的MySQL全文解析器使用空格确定单词的开头和结尾。当涉及到诸如中文，日文或韩文等的表意语言时，这是一个限制，因为这些语言不使用单词分隔符。 为了解决这个问题，MySQL提供了ngram全文解析器。从版本5.7.6开始，MySQL包含ngram全文解析器作为内置服务器插件，这意味着MySQL在MySQL数据库服务器启动时自动加载此插件。MySQL支持InnoDB和MyISAM存储引擎的ngram全文解析器。 根据定义，ngram是来自文本序列的许多字符的连续序列。ngram全文解析器的主要功能是将一系列文本标记为一个由n个字符组成的连续序列。 下面说明了ngram全文解析器如何为不同的n值标记一系列文本： 12345n = 1: 'm','y','s','q','l'n = 2: 'my', 'ys', 'sq','ql' n = 3: 'mys', 'ysq', 'sql'n = 4: 'mysq', 'ysql'n = 5: 'mysql' 使用ngram解析器创建FULLTEXT索引要创建一个FULLTEXT索引，使用NGRAM全文解析器，你加WITH PARSER ngram的CREATE TABLE，ALTER TABLE或CREATE INDEX声明。 例如，以下语句创建新posts表，并将title和body列添加到FULLTEXT使用ngram全文解析器的索引。 1234567DROP TABLE IF EXISTS posts;CREATE TABLE posts ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(255), body TEXT, FULLTEXT ( title , body ) WITH PARSER NGRAM) ENGINE=INNODB CHARACTER SET UTF8MB4; 以下INSERT语句在posts表中插入一个新行： 12345SET NAMES utf8mb4; INSERT INTO posts(title,body)VALUES('MySQL全文搜索','MySQL提供了具有许多好的功能的内置全文搜索'), ('MySQL教程','学习MySQL快速，简单和有趣'); 请注意，SET NAMES语句设置客户端和服务器将用于发送和接收数据的字符集; 在这种情况下，它是utf8mb4。 要查看ngram如何标记文本，请使用以下语句： 1234567SET GLOBAL innodb_ft_aux_table=\"mysqldemo/posts\"; SELECT *FROM information_schema.innodb_ft_index_cacheORDER BY doc_id , position; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455+--------+--------------+-------------+-----------+--------+----------+| WORD | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |+--------+--------------+-------------+-----------+--------+----------+| my | 2 | 3 | 2 | 2 | 0 || ys | 2 | 3 | 2 | 2 | 1 || sq | 2 | 3 | 2 | 2 | 2 || ql | 2 | 3 | 2 | 2 | 3 || l全 | 2 | 2 | 1 | 2 | 4 || 全文 | 2 | 2 | 1 | 2 | 5 || 文搜 | 2 | 2 | 1 | 2 | 8 || 搜索 | 2 | 2 | 1 | 2 | 11 || ql | 2 | 3 | 2 | 2 | 18 || ys | 2 | 3 | 2 | 2 | 18 || my | 2 | 3 | 2 | 2 | 18 || sq | 2 | 3 | 2 | 2 | 18 || l提 | 2 | 2 | 1 | 2 | 22 || 提供 | 2 | 2 | 1 | 2 | 23 || 供了 | 2 | 2 | 1 | 2 | 26 || 了具 | 2 | 2 | 1 | 2 | 29 || 具有 | 2 | 2 | 1 | 2 | 32 || 有许 | 2 | 2 | 1 | 2 | 35 || 许多 | 2 | 2 | 1 | 2 | 38 || 多好 | 2 | 2 | 1 | 2 | 41 || 好的 | 2 | 2 | 1 | 2 | 44 || 的功 | 2 | 2 | 1 | 2 | 47 || 功能 | 2 | 2 | 1 | 2 | 50 || 能的 | 2 | 2 | 1 | 2 | 53 || 的内 | 2 | 2 | 1 | 2 | 56 || 内置 | 2 | 2 | 1 | 2 | 59 || 文搜 | 2 | 2 | 1 | 2 | 60 || 全文 | 2 | 2 | 1 | 2 | 60 || 搜索 | 2 | 2 | 1 | 2 | 60 || 置全 | 2 | 2 | 1 | 2 | 62 || my | 2 | 3 | 2 | 3 | 0 || ys | 2 | 3 | 2 | 3 | 1 || sq | 2 | 3 | 2 | 3 | 2 || ql | 2 | 3 | 2 | 3 | 3 || l教 | 3 | 3 | 1 | 3 | 4 || 教程 | 3 | 3 | 1 | 3 | 5 || 学习 | 3 | 3 | 1 | 3 | 12 || 习m | 3 | 3 | 1 | 3 | 15 || my | 2 | 3 | 2 | 3 | 18 || sq | 2 | 3 | 2 | 3 | 18 || ql | 2 | 3 | 2 | 3 | 18 || ys | 2 | 3 | 2 | 3 | 18 || l快 | 3 | 3 | 1 | 3 | 22 || 快速 | 3 | 3 | 1 | 3 | 23 || 速， | 3 | 3 | 1 | 3 | 26 || ，简 | 3 | 3 | 1 | 3 | 29 || 简单 | 3 | 3 | 1 | 3 | 32 || 单和 | 3 | 3 | 1 | 3 | 35 || 和有 | 3 | 3 | 1 | 3 | 38 || 有趣 | 3 | 3 | 1 | 3 | 41 |+--------+--------------+-------------+-----------+--------+----------+50 rows in set (0.02 sec) 此查询对于故障排除非常有用。例如，如果单词未包含在搜索结果中，则单词可能未被索引，因为它是一个停用词，或者可能是另一个原因。 设置ngram令牌大小如您所见，前面的示例中，ngram中的令牌大小（n）默认为2.要更改令牌大小，请使用ngram_token_size配置选项，其值介于1和10之间。 请注意，较小的令牌大小会使较小的全文搜索索引成为可能，因此您可以更快地进行搜索。 因为ngram_token_size是只读变量，所以您只能使用两个选项设置其值： 首先，在启动字符串中： 1mysqld --ngram_token_size=1 二，在配置文件中： 12[mysqld]ngram_token_size=1 ngram解析器短语搜索MySQL将短语搜索转换为ngram短语搜索。例如，”abc”转换为”ab bc”，返回包含”ab bc”和的文档”abc”。 下面的示例显示了搜索短语搜索中的posts表： 123456SELECT id, title, bodyFROM postsWHERE MATCH (title , body) AGAINST ('搜索' ); 123456+----+-------------------+-------------------------------------------------------------+| id | title | body |+----+-------------------+-------------------------------------------------------------+| 1 | MySQL全文搜索 | MySQL提供了具有许多好的功能的内置全文搜索 |+----+-------------------+-------------------------------------------------------------+1 row in set (7.74 sec) 用ngram处理搜索结果自然语言模式在NATURAL LANGUAGE MODE搜索中，搜索项将转换为ngram值的并集。假设令牌大小为2或bigram，搜索项mysql将转换为my ys sq和ql。 123456SELECT *FROM postsWHERE MATCH (title , body) AGAINST ('简单和有趣' IN natural language MODE); 123456+----+-------------+-------------------------------------+| id | title | body |+----+-------------+-------------------------------------+| 2 | MySQL教程 | 学习MySQL快速，简单和有趣 |+----+-------------+-------------------------------------+1 row in set (0.01 sec) 布尔模式在BOOLEAN MODE搜索中，搜索项将转换为ngram短语搜索。例如： 123456SELECT *FROM postsWHERE MATCH (title , body) AGAINST ('简单和有趣' IN BOOLEAN MODE); 123456+----+-------------+-------------------------------------+| id | title | body |+----+-------------+-------------------------------------+| 2 | MySQL教程 | 学习MySQL快速，简单和有趣 |+----+-------------+-------------------------------------+1 row in set (0.16 sec) ngram通配符搜索ngram FULLTEXT索引只包含ngrams ，因此它不知道术语的开头。执行通配符搜索时，可能会返回意外结果。 以下规则适用于使用ngram FULLTEXT搜索索引的通配符搜索： 如果通配符中的前缀术语短于ngram令牌大小，则查询将返回包含以前缀术语开头的ngram令牌的所有文档。例如： 123456SELECT id, title, bodyFROM postsWHERE MATCH (title , body) AGAINST ('my*' ); 1234567+----+-------------------+-------------------------------------------------------------+| id | title | body |+----+-------------------+-------------------------------------------------------------+| 1 | MySQL全文搜索 | MySQL提供了具有许多好的功能的内置全文搜索 || 2 | MySQL教程 | 学习MySQL快速，简单和有趣 |+----+-------------------+-------------------------------------------------------------+2 rows in set (4.40 sec) 如果通配符中的前缀术语长于ngram令牌大小，MySQL将把前缀术语转换为ngram短语并忽略通配符运算符。请参阅以下示例： 123456SELECT id, title, bodyFROM postsWHERE MATCH (title , body) AGAINST ('mysqld*' ); 1234567+----+-------------------+-------------------------------------------------------------+| id | title | body |+----+-------------------+-------------------------------------------------------------+| 1 | MySQL全文搜索 | MySQL提供了具有许多好的功能的内置全文搜索 || 2 | MySQL教程 | 学习MySQL快速，简单和有趣 |+----+-------------------+-------------------------------------------------------------+2 rows in set (0.01 sec) 在这个例子中，术语“ mysqld”被转换成ngram短语：”my” “ys” “sq” “ql” “ld”。因此，将返回包含这些短语之一的所有文档。 添加或修改 ngram 的索引要向FULLTEXT现有表添加索引，可以使用ALTER TABLE或 CREATE INDEX。 1ALTER TABLE posts ADD FULLTEXT INDEX ft_index (title,body) WITH PARSER ngram; 或者 1CREATE FULLTEXT INDEX ft_index ON posts (title,body) WITH PARSER ngram; 处理停用词ngram解析器排除包含禁用词列表中的停用词的令牌。例如，假设ngram_token_size为2且文档包含”abc”。ngram解析器将文档标记为”ab”和”bc”。如果”b”是一个停用词，ngram将排除两者”ab”，”bc”因为它们包含”b”。 请注意，如果语言不是英语，则必须定义自己的禁用词列表。此外，长度大于的停用词将ngram_token_size被忽略。 在本教程中，您学习了如何使用MySQL ngram全文解析器来处理表意语言的全文搜索。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"71、mysql 之查询扩展","slug":"Mysql/71、mysql 之查询扩展","date":"2016-06-09T22:25:23.000Z","updated":"2020-08-07T14:10:11.859Z","comments":true,"path":"2016/06/10/Mysql/71、mysql 之查询扩展/","link":"","permalink":"https://www.zackaddy.xin/2016/06/10/Mysql/71、mysql 之查询扩展/","excerpt":"","text":"mysql 之查询扩展简介在某些情况下，用户希望根据他们拥有的知识搜索信息。用户使用他们的经验来定义搜索信息的关键字，通常这些关键字太短。 为了帮助用户根据过短的关键字查找信息，MySQL全文搜索引擎引入了一种称为查询扩展的概念。 查询扩展用于基于自动相关性反馈（或盲查询扩展）来扩展全文搜索的搜索结果。从技术上讲，MySQL全文搜索引擎在使用查询扩展时执行以下步骤： 首先，MySQL全文搜索引擎查找与搜索查询匹配的所有行。 其次，它检查搜索结果中的所有行并找到相关的单词。 第三，它基于相关词而不是用户提供的原始关键词再次执行搜索。 从应用程序的角度来看，您可以在搜索结果太少时使用查询扩展。您再次执行搜索但使用查询扩展为用户提供与他们要查找的内容相关且更多相关信息。 要使用查询扩展，请使用AGAINST()函数中的WITH QUERY EXPANSION搜索修饰符。以下说明了使用WITH QUERY EXPANSION搜索修饰符的查询语法。 1234SELECT column1, column2FROM table1WHERE MATCH(column1,column2) AGAINST('keyword',WITH QUERY EXPANSION); 查询扩展示例让我们看一下查询扩展的示例，看看它是如何工作的。 我们将使用products表的productName列来演示查询扩展功能。 首先，我们为此列启用全文搜索索引。 12ALTER TABLE products ADD FULLTEXT(productName); 其次，我们搜索产品名称包含1992术语而不使用查询扩展的产品。 123SELECT productNameFROM productsWHERE MATCH(productName) AGAINST('1992'); 1234567+-----------------------------------+| productName |+-----------------------------------+| 1992 Ferrari 360 Spider red || 1992 Porsche Cayenne Turbo Silver |+-----------------------------------+2 rows in set (0.00 sec) 如您所见，搜索结果有两个产品，其产品名称包含术语1992。 第三，我们可以通过使用查询扩展来扩大搜索结果，如下所示： 1234SELECT productNameFROM productsWHERE MATCH(productName) AGAINST('1992' WITH QUERY EXPANSION); 123456789101112+-------------------------------------+| productName |+-------------------------------------+| 1992 Porsche Cayenne Turbo Silver || 1992 Ferrari 360 Spider red || 2001 Ferrari Enzo || 1932 Alfa Romeo 8C2300 Spider Sport || 1948 Porsche 356-A Roadster || 1948 Porsche Type 356 Roadster || 1956 Porsche 356A Coupe |+-------------------------------------+7 rows in set (0.00 sec) 当我们使用查询扩展时，我们在搜索结果中获得了更多行。前两行是最相关的，其他行来自前两行中的相关关键字，例如，Ferrari 请注意，盲查询扩展会通过返回不相关的结果而显着增加噪声。强烈建议您仅在搜索关键字较短时使用查询扩展。 在本教程中，我们向您介绍了MySQL查询扩展，以便在用户提供的关键字很短时扩大搜索结果。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"10、nginx 之MIME类型的设置","slug":"Nginx/10、nginx 之MIME类型的设置","date":"2016-06-09T20:30:41.000Z","updated":"2020-08-07T14:10:11.864Z","comments":true,"path":"2016/06/10/Nginx/10、nginx 之MIME类型的设置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/10/Nginx/10、nginx 之MIME类型的设置/","excerpt":"","text":"nginx 之MIME类型的设置MIME type与文件扩展的映射1type&#123;...&#125;; 1配置块： http、server、location 定义MIME type到文件扩展名的映射。多个扩展名可以映射到同一个MIME type。例如： 123456types &#123; text/html html; text/html conf; image/gif gif; image/jpeg jpg; &#125; 默认MIME type1default_type MIME-type; #默认： default_type text/plain; 1配置块： http、server、location 当找不到相应的MIME type与文件扩展名之间的映射时，使用默认的MIME type作为 HTTP header中的Content-Type。 types_hash_bucket_size1types_hash_bucket_size size; #types_hash_bucket_size 32|64|128; 1配置块： http、server、location 为了快速寻找到相应MIME type，Nginx使用散列表来存储MIME type与文件扩展名。 types_hash_bucket_size设置了每个散列桶占用的内存大小。 types_hash_max_size1types_hash_max_size size; #默认： types_hash_max_size 1024; 1配置块： http、server、location types_hash_max_size影响散列表的冲突率。types_hash_max_size越大，就会消耗更多的内 存，但散列key的冲突率会降低，检索速度就更快。types_hash_max_size越小，消耗的内存就 越小，但散列key的冲突率可能上升。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"9、nginx 之网络连接的设置","slug":"Nginx/9、nginx 之网络连接的设置","date":"2016-06-08T23:51:31.000Z","updated":"2020-08-07T14:10:11.869Z","comments":true,"path":"2016/06/09/Nginx/9、nginx 之网络连接的设置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/09/Nginx/9、nginx 之网络连接的设置/","excerpt":"","text":"nginx 之网络连接的设置读取HTTP头部的超时时间1client_header_timeout time（默认单位：秒）; #默认： client_header_timeout 60; 1配置块： http、server、location 客户端与服务器建立连接后将开始接收HTTP头部，在这个过程中，如果在一个时间间 隔（超时时间）内没有读取到客户端发来的字节，则认为超时，并向客户端返回 408(“Request timed out”)响应。 读取HTTP body的超时时间1client_body_timeout time（默认单位：秒）；# 默认： client_body_timeout 60; 1配置块： http、server、location 此配置项与client_header_timeout相似，只是这个超时时间只在读取HTTP body时才有效 发送响应的超时时间1send_timeout time; #默认： send_timeout 60; 1配置块： http、server、location 这个超时时间是发送响应的超时时间，即Nginx服务器向客户端发送了数据包，但客户 端一直没有去接收这个数据包。如果某个连接超过send_timeout定义的超时时间，那么Nginx 将会关闭这个连接。 reset_timeout_connection1reset_timeout_connection on|off; #默认： reset_timeout_connection off; 1配置块： http、server、location 连接超时后将通过向客户端发送RST包来直接重置连接。这个选项打开后，Nginx会在某 个连接超时后，不是使用正常情形下的四次握手关闭TCP连接，而是直接向用户发送RST重 置包，不再等待用户的应答，直接释放Nginx服务器上关于这个套接字使用的所有缓存（如 TCP滑动窗口）。相比正常的关闭方式，它使得服务器避免产生许多处于FIN_WAIT_1、 FIN_WAIT_2、TIME_WAIT状态的TCP连接 注意，使用RST重置包关闭连接会带来一些问题，默认情况下不会开启。 lingering_close1lingering_close off|on|always; #默认： lingering_close on; 1配置块： http、server、location 该配置控制Nginx关闭用户连接的方式。always表示关闭用户连接前必须无条件地处理连 接上所有用户发送的数据。off表示关闭连接时完全不管连接上是否已经有准备就绪的来自用 户的数据。on是中间值，一般情况下在关闭连接前都会处理连接上的用户发送的数据，除了 有些情况下在业务上认定这之后的数据是不必要的。 lingering_time1lingering_time time; #默认： lingering_time 30s; 1配置块： http、server、location lingering_close启用后，这个配置项对于上传大文件很有用。上文讲过，当用户请求的 Content-Length大于max_client_body_size配置时，Nginx服务会立刻向用户发送413（Request entity too large）响应。但是，很多客户端可能不管413返回值，仍然持续不断地上传HTTP body，这时，经过了lingering_time设置的时间后，Nginx将不管用户是否仍在上传，都会把连接关闭掉。 lingering_timeout1lingering_timeout time; #默认： lingering_timeout 5s; 1配置块： http、server、location lingering_close生效后，在关闭连接前，会检测是否有用户发送的数据到达服务器，如果 超过lingering_timeout时间后还没有数据可读，就直接关闭连接；否则，必须在读取完连接缓 冲区上的数据并丢弃掉后才会关闭连接。 对某些浏览器禁用keepalive功能1keepalive_disable [msie6|safari|none]... #默认： keepalive_disable msie6 safari 1配置块： http、server、location HTTP请求中的keepalive功能是为了让多个请求复用一个HTTP长连接，这个功能对服务 器的性能提高是很有帮助的。但有些浏览器，如IE 6和Safari，它们对于使用keepalive功能的 POST请求处理有功能性问题。因此，针对IE 6及其早期版本、Safari浏览器默认是禁用keepalive功能的。 keepalive超时时间1keepalive_timeout time（默认单位：秒）; #默认： keepalive_timeout 75; 1配置块： http、server、location 一个keepalive连接在闲置超过一定时间后（默认的是75秒），服务器和浏览器都会去关 闭这个连接。当然，keepalive_timeout配置项是用来约束Nginx服务器的，Nginx也会按照规范 把这个时间传给浏览器，但每个浏览器对待keepalive的策略有可能是不同的。 一个keepalive长连接上允许承载的请求最大数1keepalive_requests n; #默认： keepalive_requests 100; 1配置块： http、server、location 一个keepalive连接上默认最多只能发送100个请求。 tcp_nodelay1tcp_nodelay on|off; #默认： tcp_nodelay on; 1配置块： http、server、location 确定对keepalive连接是否使用TCP_NODELAY选项。 tcp_nopush1tcp_nopush on|off; #默认： tcp_nopush off; 1配置块： http、server、location 在打开sendfile选项时，确定是否开启FreeBSD系统上的TCP_NOPUSH或Linux系统上的 TCP_CORK功能。打开tcp_nopush后，将会在发送响应时把整个响应包头放到一个TCP包中 发送。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"70、mysql 之布尔全文搜索##","slug":"Mysql/70、mysql 之布尔全文搜索##","date":"2016-06-08T16:32:06.000Z","updated":"2020-08-07T14:10:11.859Z","comments":true,"path":"2016/06/09/Mysql/70、mysql 之布尔全文搜索##/","link":"","permalink":"https://www.zackaddy.xin/2016/06/09/Mysql/70、mysql 之布尔全文搜索##/","excerpt":"","text":"mysql 之布尔全文搜索简介除了自然语言全文搜索，MySQL还支持另一种形式的全文搜索，称为布尔全文搜索。在布尔模式下，MySQL搜索单词而不是自然语言搜索中的概念。 MySQL允许您在布尔模式下基于非常复杂的查询以及布尔运算符执行全文搜索。这就是布尔模式下的全文搜索适合有经验的用户的原因。 要在布尔模式下执行全文搜索，请使用 AGAINST表达式中的IN BOOLEAN MODE修饰符。以下示例说明如何搜索产品名称中包含Truck单词的产品。 1234SELECT productName, productlineFROM productsWHERE MATCH(productName) AGAINST('Truck' IN BOOLEAN MODE ); 1234567+------------------------+------------------+| productName | productline |+------------------------+------------------+| 1940 Ford Pickup Truck | Trucks and Buses || 1940s Ford truck | Trucks and Buses |+------------------------+------------------+2 rows in set (0.00 sec) 返回两个产品名称包含Truck 单词的产品。 要查找产品名称中包含 Truck单词但不包含任何行的产品， Pickup可以使用运算符（-）返回排除Pickup关键字的结果，如下所示： 123SELECT productName, productlineFROM productsWHERE MATCH(productName) AGAINST('Truck -Pickup' IN BOOLEAN MODE ); 123456+------------------+------------------+| productName | productline |+------------------+------------------+| 1940s Ford truck | Trucks and Buses |+------------------+------------------+1 row in set (0.00 sec) 布尔全文搜索运算符 操作者 描述 + 包括，这个词必须存在。 - 排除，词不得出现。 &gt; 包括，并提高排名值。 &lt; 包括，并降低排名值。 () 将单词分组为子表达式（允许将它们作为一组包括在内，排除在外，排名等等）。 〜 否定单词的排名值。 * 通配符在这个词的结尾。 “” 定义短语（与单个单词列表相对，整个短语匹配以包含或排除）。 以下示例说明如何在搜索查询中使用布尔全文运算符： 示例 描述 ‘mysql tutorial’ 要搜索包含两个单词中至少一个的行：mysql或tutorial ‘+ mysql + tutorial’ 要搜索包含两个单词的行：mysql和tutorial ‘+ mysql tutorial’ 要搜索包含单词“mysql”的行，但为包含“tutorial”的行添加更高的排名： ‘+ mysql -tutorial’ 要搜索包含单词“mysql”但不包含“tutorial”的行 ‘+ mysql~tutorial’ 要搜索包含单词“mysql”的行，如果它包含单词“tutorial”，则将行排名更低。 ‘+ mysql +（&gt; tutorial &lt;training）’ 要以任何顺序搜索包含单词“mysql”和“tutorial”，或“mysql”和“training”的行，但将包含“mysql tutorial”的行放在“mysql training”之上。 ‘my*’ 要查找包含以“my”开头的单词的行，例如“mysql”，“myyahoo”等，请使用以下命令： 布尔全文搜索主要功能 MySQL不会按照布尔全文搜索中相关性降低的顺序自动对行进行排序。 要执行布尔查询，InnoDB表要求MATCH表达式的所有列都有FULLTEXT索引。请注意，虽然搜索速度很慢，但MyISAM表并不需要这样。 MySQL在InnoDB表上的搜索查询中不支持多个布尔运算符，例如’++ mysql’。如果你这样做，MySQL将返回错误。但是，MyISAM的行为有所不同。它忽略其他运算符并使用最接近搜索词的运算符，例如，’+ -mysql’将变为’-mysql’。 InnoDB全文搜索不支持尾随加号（+）或减号（ - ）。它只支持前导加号或减号。如果搜索单词是’mysql +’或’mysql-‘，MySQL将报告错误。此外，带有通配符的以下前导加号或减号无效：+ *，+ - 50％阈值意味着如果一个单词出现在超过50％的行中，MySQL将在搜索结果中忽略它。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"69、mysql 之自然语言全文搜索","slug":"Mysql/69、mysql 之自然语言全文搜索","date":"2016-06-07T22:29:57.000Z","updated":"2020-08-07T14:10:11.858Z","comments":true,"path":"2016/06/08/Mysql/69、mysql 之自然语言全文搜索/","link":"","permalink":"https://www.zackaddy.xin/2016/06/08/Mysql/69、mysql 之自然语言全文搜索/","excerpt":"","text":"mysql 之自然语言全文搜索在自然语言全文搜索中，MySQL查找与自由文本自然人类语言查询相关的行或文档 相关性是一个正浮点数。当相关性为零时，意味着没有相似性。MySQL根据各种因素计算相关性，包括文档中的单词数，文档中唯一单词的数量，集合中单词的总数以及包含特定单词的文档（行）数。 要执行自然语言全文搜索，请使用MATCH() 和 AGAINST()运行。MATCH() 函数指定要搜索的列，AGAINST() 函数确定要使用的搜索表达式。 在MySQL全文搜索引擎定义的搜索词的最小长度为4。这意味着，如果你搜索其长度小于4，你不会得到任何结果。 如果修改长度可以在my.ini配置文件中添加 123# MySQL全文索引查询关键词最小长度限制[mysqld]ft_min_word_len = 1 123SELECT column1, column1FROM tablenameWHERE MATCH(column1, column2) AGAINST('Classic'); AGAINST() 函数默认使用IN NATURAL LANGUAGE MODE搜索修饰符，因此您可以在查询中省略它。还有其他搜索修饰符，例如， IN BOOLEAN MODE 用于布尔文本搜索。 您可以 在查询中明确使用IN NATURAL LANGUAGE MODE搜索修饰符，如下所示： 1234SELECT column1, column2FROM tablenameWHERE MATCH(column1) AGAINST('Classic' IN NATURAL LANGUAGE MODE);","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"8、nginx 之内存及磁盘资源的分配","slug":"Nginx/8、nginx 之内存及磁盘资源的分配","date":"2016-06-07T17:05:16.000Z","updated":"2020-08-07T14:10:11.868Z","comments":true,"path":"2016/06/08/Nginx/8、nginx 之内存及磁盘资源的分配/","link":"","permalink":"https://www.zackaddy.xin/2016/06/08/Nginx/8、nginx 之内存及磁盘资源的分配/","excerpt":"","text":"nginx 之内存及磁盘资源的分配HTTP body只存储到磁盘文件中1client_body_in_file_only on|clean|off; #默认： client_body_in_file_only off; 1配置块： http、server、location 此指令禁用NGINX缓冲区并将请求体存储在临时文件中。 文件包含纯文本数据。 该指令在NGINX配置的http，server和location区块使用。 可选值有： off:该值将禁用文件写入 clean：请求body将被写入文件。 该文件将在处理请求后删除。 on: 请求正文将被写入文件。 处理请求后，将不会删除该文件。 默认情况下，指令值为关闭。 如下： 123http &#123; client_body_in_file_only clean;&#125; HTTP body尽量写入到一个内存buffer中1client_body_in_single_buffer on|off; #默认： client_body_in_single_buffer off; 1配置块： http、server、location 是否将请求体完整的存储在一块连续的内存中，默认为off，如果此指令被设置为on，则nginx会保证请求体在不大于client_body_buffer_size设置的值时，被存放在一块连续的内存中，但超过大小时会被整个写入一个临时文件； 存储HTTP头部的内存buffer大小1client_header_buffer_size size; #默认： client_header_buffer_size 1k; 1配置块： http、server 此指令与client_body_buffer_size类似。 它为请求头分配一个缓冲区。 如果请求头大小大于指定的缓冲区，则使用large_client_header_buffers指令分配更大的缓冲区。如下例子： 123http&#123; client_header_buffer_size 1m;&#125; 存储超大HTTP头部的内存buffer大小1large_client_header_buffers number size; #默认： large_client_header_buffers 4 8k; 1配置块： http、server large_client_header_buffers定义了Nginx接收一个超大HTTP头部请求的buffer个数和每个 buffer的大小。如果HTTP请求行（如GET/index HTTP/1.1）的大小超过上面的单个buffer，则 返回”Request URI too large”(414)。请求中一般会有许多header，每一个header的大小也不能超 过单个buffer的大小，否则会返回”Bad request”(400)。当然，请求行和请求头部的总和也不可 以超过buffer个数*buffer大小。 存储HTTP body的内存buffer大小1client_body_buffer_size size; #默认： client_body_buffer_size 8k/16k; 1配置块： http、server、location 上面配置项定义了Nginx接收HTTP body的内存缓冲区大小。也就是说，HTTP body会先 接收到指定的这块缓存中，之后才决定是否写入磁盘。 如果用户请求中含有HTTP头部Content-Length，并且其标识的长度小于定义 的buffer大小，那么Nginx会自动降低本次请求所使用的内存buffer，以降低内存消耗。 HTTP包体的临时存放目录1client_body_temp_path dir-path[level1[level2[level3]]] #默认： client_body_temp_path client_body_temp; 1配置块： http、server、location 上面配置项定义HTTP body存放的临时目录。在接收HTTP body时，如果body的大小大于 client_body_buffer_size，则会以一个递增的整数命名并存放到client_body_temp_path指定的目 录中。后面跟着的level1、level2、level3，是为了防止一个目录下的文件数量太多，从而导 致性能下降，因此使用了level参数，这样可以按照临时文件名最多再加三层目录。例如： 1client_body_temp_path optnginx/client_temp 1 2; 如果新上传的HTTP包体使用00000123456作为临时文件名，就会被存放在这个目录中。 1optnginx/client_temp/6/45/00000123456 connection_pool_size1connection_pool_size size; #connection_pool_size 256; 1配置块： http、server Nginx对于每个建立成功的TCP连接会预先分配一个内存池，上面的size配置项将指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。需慎重设置，因为更大 的size会使服务器消耗的内存增多，而更小的size则会引发更多的内存分配次数。 request_pool_size1request_pool_size size; #默认： request_pool_size 4k; 1配置块： http、server Nginx开始处理HTTP请求时，将会为每个请求都分配一个内存池，size配置项将指定这个内存池的初始大小，用于减少内核对于小块内存的分配次数。TCP连接关闭时会销毁 connection_pool_size指定的连接内存池，HTTP请求结束时会销毁request_pool_size指定的 HTTP请求内存池，但它们的创建、销毁时间并不一致，因为一个TCP连接可能被复用于多个HTTP请求。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"68、mysql 之FULLTEXT索引","slug":"Mysql/68、mysql 之FULLTEXT索引","date":"2016-06-06T23:14:49.000Z","updated":"2020-08-07T14:10:11.858Z","comments":true,"path":"2016/06/07/Mysql/68、mysql 之FULLTEXT索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/07/Mysql/68、mysql 之FULLTEXT索引/","excerpt":"","text":"mysql 之FULLTEXT索引简介在表的列中执行全文搜索之前，必须将其数据编入索引。只要列的数据发生变化，MySQL就会重新创建全文索引。在MySQL中，全文索引是一种具有名称FULLTEXT的索引。 MySQL支持 为启用全文搜索的列自动索引和重新索引数据 。MySQL的5.6或更高版本允许你定义一个全文索引的数据类型为一列CHAR，VARCHAR或TEXT 在MyISAM中或InnoDB的表型。请注意，自5.6版以来，MySQL支持InnoDB表中的全文索引。 MySQL允许您在为现有表创建表或ALTER TABLE或CREATE INDEX语句时使用CREATE TABLE语句定义FULLTEXT索引。 使用CREATE TABLE语句定义FULLTEXT索引12345678910111213141516CREATE TABLE table_name( column1 data_type, column2 data_type, column3 data_type, …PRIMARY_KEY(key_column),FULLTEXT (column1,column2,..)); CREATE TABLE posts ( id int(4) NOT NULL AUTO_INCREMENT, title varchar(255) NOT NULL, post_content text, PRIMARY KEY (id), FULLTEXT KEY post_content (post_content)); 使用ALTER TABLE语句定义FULLTEXT索引12345ALTER TABLE table_name ADD FULLTEXT(column_name1, column_name2,…) ALTER TABLE products ADD FULLTEXT(productDescription,productLine); 使用CREATE INDEX语句定义FULLTEXT索引12345CREATE FULLTEXT INDEX index_nameON table_name(idx_column_name,...) CREATE FULLTEXT INDEX addressON offices(addressLine1,addressLine2); 删除全文搜索列12ALTER TABLE officesDROP INDEX address;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"7、nginx 之文件路径的定义","slug":"Nginx/7、nginx 之文件路径的定义","date":"2016-06-06T19:58:11.000Z","updated":"2020-08-07T14:10:11.868Z","comments":true,"path":"2016/06/07/Nginx/7、nginx 之文件路径的定义/","link":"","permalink":"https://www.zackaddy.xin/2016/06/07/Nginx/7、nginx 之文件路径的定义/","excerpt":"","text":"nginx 之文件路径的定义以root方式设置资源路径1语法： root path; #默认： root html; 1配置块： http、server、location、if 123location /download/ &#123; root optwebhtml/; &#125; 如果有一个请求的URI是/download/index/test.html，那么Web服务器将 会返回服务器上optwebhtml/download/index/test.html文件的内容 以alias方式设置资源路径1语法： alias path; 1配置块： location 123location /download/ &#123; alias optwebhtml/; &#125; 如果有一个请求的URI是/download/index/test.html，那么Web服务器将 会返回服务器上optwebhtml/index/test.html文件的内容 alias后面还可以添加正则表达式 123location ~ ^/test/(\\w+)\\.(\\w+)$ &#123; alias usrlocal/nginx/$2/$1.$2; &#125; 访问首页1index file...; #默认： index index.html; 1配置块： http、server、location 1234location &#123; root path; index index.html htmlindex.php /index.php; &#125; 根据HTTP返回码重定向页面1error_page code[code...][=|=answer-code] uri|@named_location 1配置块： http、server、location、if 当对于某个请求返回错误码时，如果匹配上了error_page中设置的code，则重定向到新 的URI中 1234error_page 404 404.html; error_page 502 503 504 50x.html; error_page 403 http://example.com/forbidden.html ;error_page 404 = @fetch; 用户可以通 过“=”来更改返回的错误码 12error_page 404 =200 empty.gif; error_page 404 =403 forbidden.gif; 也可以不指定确切的返回错误码，而是由重定向后实际处理的真实结果来决定，这时， 只要把“=”后面的错误码去掉即可 1error_page 404 = /empty.gif; 如果不想修改URI，只是想让这样的请求重定向到另一个location中进行处理，那么可以 这样设置 123456location / ( error_page 404 @fallback; )location @fallback ( proxy_pass http://backend ;) 返回404的请求会被反向代理到http://backend 上游服务器中处理 是否允许递归使用error_page1recursive_error_pages[on|off]; #默认： recursive_error_pages off; 1配置块： http、server、location 确定是否允许递归地定义error_page。 try_files1try_files path1[path2] uri; 1配置块： server、location try_files后要跟若干路径，如path1 path2…，而且最后必须要有uri参数，意义如下：尝试 按照顺序访问每一个path，如果可以有效地读取，就直接向用户返回这个path对应的文件结 束请求，否则继续向下访问。如果所有的path都找不到有效的文件，就重定向到最后的参数 uri上。因此，最后这个参数uri必须存在，而且它应该是可以有效重定向的。 1234try_files systemmaintenance.html $uri $uri/index.html $uri.html @other; location @other &#123; proxy_pass http://backend ;&#125; 可以用指定错误码的方式与error_page配合使用 123location &#123; try_files $uri $uri /error.phpc=404 =404; &#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"6、nginx 之虚拟主机与请求的分发","slug":"Nginx/6、nginx 之虚拟主机与请求的分发","date":"2016-06-06T03:02:07.000Z","updated":"2020-08-07T14:10:11.868Z","comments":true,"path":"2016/06/06/Nginx/6、nginx 之虚拟主机与请求的分发/","link":"","permalink":"https://www.zackaddy.xin/2016/06/06/Nginx/6、nginx 之虚拟主机与请求的分发/","excerpt":"","text":"nginx 之虚拟主机与请求的分发监听端口123listen address:port[default(deprecated in0.8.21)|default_server|[backlog=num|rcvbuf=size|sndbuf=size|accept_filter=filter|deferred|bind|ipv6only=[on|off]|ssl]]; #默认：listen 80; 1配置块： server 12345678910listen 127.0.0.1:8000; listen 127.0.0.1; #注意：不加端口时，默认监听 80端口 listen 8000; listen *:8000; listen localhost:8000;listen [::]:8000; listen [fe80::1]; listen [:::a8c9:1234]:80;listen 443 default_server ssl; listen 127.0.0.1 default_server accept_filter=dataready backlog=1024; default：将所在的server块作为整个Web服务的默认server块。如果没有设置这个参数， 那么将会以在nginx.conf中找到的第一个server块作为默认server块。为什么需要默认虚拟主机 呢？当一个请求无法匹配配置文件中的所有主机域名时，就会选用默认的虚拟主机（在11.3 节介绍默认主机的使用）。 default_server：同上。 backlog=num：表示TCP中backlog队列的大小。默认为–1，表示不予设置。在TCP建 立三次握手过程中，进程还没有开始处理监听句柄，这时backlog队列将会放置这些新连接。 可如果backlog队列已满，还有新的客户端试图通过三次握手建立TCP连接，这时客户端将会建立连接失败。 rcvbuf=size：设置监听句柄的SO_RCVBUF参数。 sndbuf=size：设置监听句柄的SO_SNDBUF参数。 accept_filter：设置accept过滤器，只对FreeBSD操作系统有用。 deferred：在设置该参数后，若用户发起建立连接请求，并且完成了TCP的三次握手， 内核也不会为了这次的连接调度worker进程来处理，只有用户真的发送请求数据时（内核已 经在网卡中收到请求数据包），内核才会唤醒worker进程处理这个连接。这个参数适用于大 并发的情况下，它减轻了worker进程的负担。当请求数据来临时，worker进程才会开始处理 这个连接。只有确认上面所说的应用场景符合自己的业务需求时，才可以使用deferred配 置。 bind：绑定当前端口/地址对，如127.0.0.1:8000。只有同时对一个端口监听多个地址时 才会生效。 ssl：在当前监听的端口上建立的连接必须基于SSL协议。 主机名称配置项针对特定Host域名的请求提供不同的服务， 以此实现虚拟主机功能 1server_name name[...]; #默认：server_name \"\"; 1配置块： server server_name后可以跟多个主机名称，如server_name www.example.com 、 download.example.com;。 在开始处理一个HTTP请求时，Nginx会取出header头中的Host，与每个server中的 server_name进行匹配，以此决定到底由哪一个server块来处理这个请求。有可能一个Host与 多个server块中的server_name都匹配，这时就会根据匹配优先级来选择实际处理的server块。 server_name与Host的匹配优先级如下： 首先选择所有字符串完全匹配的server_name，如www.example.com 。 其次选择通配符在前面的server_name，如*.example.com。 再次选择通配符在后面的server_name，如www.example.* 。 最后选择使用正则表达式才匹配的server_name，如~^.example.com$。 如果Host与所有的server_name都不匹配，这时将会按下列顺序选 择处理的server块 优先选择在listen配置项后加入[default|default_server]的server块。 找到匹配listen端口的第一个server块。 如果server_name后跟着空字符串（如server_name””;），那么表示匹配没有Host这个 HTTP头部的请求。 散列桶占用的内存大小1server_names_hash_bucket_size size; #默认：server_names_hash_bucket_size 32|64|128; 1配置块： http、server、location 为了提高快速寻找到相应server name的能力，Nginx使用散列表来存储server name。 server_names_hash_bucket_size设置了每个散列桶占用的内存大小。 散列表的冲突率1server_names_hash_max_size size; #默认： server_names_hash_max_size 512; 1配置块： http、server、location server_names_hash_max_size会影响散列表的冲突率。server_names_hash_max_size越大， 消耗的内存就越多，但散列key的冲突率则会降低，检索速度也更快。 server_names_hash_max_size越小，消耗的内存就越小，但散列key的冲突率可能增高。 重定向主机名称的处理1server_name_in_redirect on|off; #默认： server_name_in_redirect on; 1配置块： http、server或者location 该配置需要配合server_name使用。在使用on打开时，表示在重定向请求时会使用 server_name里配置的第一个主机名代替原先请求中的Host头部，而使用off关闭时，表示在重 定向请求时使用请求本身的Host头部 location1location [=|~|~*|^~|@]/uri/&#123;...&#125; 1配置块： server location会尝试根据用户请求中的URI来匹配上面的/uri表达式，如果可以匹配，就选择 location{}块中的配置来处理用户请求。当然，匹配方式是多样的，下面介绍location的匹配 规则 =表示把URI作为字符串，以便与参数中的uri做完全匹配 1234location = / &#123; #只有当用户请求是 /时，才会使用该 location下的配置 … &#125; ~表示匹配URI时是字母大小写敏感的。 ~*表示匹配URI时忽略字母大小写问题 ^~表示匹配URI时只需要其前半部分与uri参数匹配即可。例如 1234location ^~ images &#123; # 以 images开始的请求都会匹配上 … &#125; @表示仅用于Nginx服务内部请求之间的重定向，带有@的location不直接处理用户请 求 在uri参数里是可以用正则表达式 1234location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配以 .gif、 .jpg、 .jpeg结尾的请求 … &#125; 在最后一个location中使用/作为参数，它会匹配 所有的HTTP请求，这样就可以表示如果不能匹配前面的所有location，则由“/”这个location处 理。 1234location / &#123; # /可以匹配所有请求 … &#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"67、mysql 之全文搜索介绍","slug":"Mysql/67、mysql 之全文搜索介绍","date":"2016-06-05T17:55:28.000Z","updated":"2020-08-07T14:10:11.858Z","comments":true,"path":"2016/06/06/Mysql/67、mysql 之全文搜索介绍/","link":"","permalink":"https://www.zackaddy.xin/2016/06/06/Mysql/67、mysql 之全文搜索介绍/","excerpt":"","text":"mysql 之全文搜索介绍简介 MySQL全文搜索提供了一种简单的方法来实现各种高级搜索技术，如自然语言搜索，布尔文本搜索和查询扩展。 并非所有存储引擎都支持全文搜索功能。在MySQL 5.6或更高版本中，只有MyISAM和InnoDB存储引擎支持全文搜索。 普通与全文搜索对比 MySQL支持使用LIKE运算符和正则表达式进行文本搜索 。但是，当text列很大并且表中的行数增加时，使用这些方法有一些限制： 性能：MySQL必须扫描整个表，以根据LIKE 正则表达式中的语句或模式中的模式查找确切的文本。 灵活的搜索：通过LIKE运算符和正则表达式搜索，很难有灵活的搜索查询，例如，查找描述中包含car 但不 包含的产品classic. 相关性排名：无法指定结果集中哪一行与搜索项更相关。 由于这些限制，MySQL扩展了一个非常好的功能，即所谓的全文搜索。从技术上讲，MySQL根据启用的全文搜索列的单词创建索引，并对此索引执行搜索。MySQL使用复杂的算法来确定与搜索查询匹配的行。 以下是MySQL全文搜索的一些重要功能： SQL-LIKE接口：您使用SQL-LIKE语句来使用全文搜索。 完全动态索引：只要列的数据发生更改，MySQL就会自动更新文本列的索引。 中等索引大小：存储索引不需要太多内存。 最后但并非最不重要的是，基于复杂的搜索查询搜索速度很快。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"5、nginx 之服务的基本配置","slug":"Nginx/5、nginx 之服务的基本配置","date":"2016-06-04T21:22:36.000Z","updated":"2020-08-07T14:10:11.868Z","comments":true,"path":"2016/06/05/Nginx/5、nginx 之服务的基本配置/","link":"","permalink":"https://www.zackaddy.xin/2016/06/05/Nginx/5、nginx 之服务的基本配置/","excerpt":"","text":"nginx 之服务的基本配置 Nginx在运行时，至少必须加载几个核心模块和一个事件类模块。这些模块运行时所支 持的配置项称为基本配置——所有其他模块执行时都依赖的配置项。 用于调试、定位问题的配置项。 正常运行的必备配置项。 优化性能的配置项。 事件类配置项（有些事件类配置项归纳到优化性能类，这是因为它们虽然也属于 events{}块，但作用是优化性能）。 用于调试进程和定位问题的配置项 是否以守护进程方式运行Nginx1daemon on|off; #默认值 daemon on; 守护进程（daemon）是脱离终端并且在后台运行的进程。2. 是否以master/worker方式工作 1master_process on|off; #默认： master_process on; 以一个master进程管理多个worker进程的方式运行,与daemon配置相同，提供master_process配置也是为了方便跟踪调试Nginx。3. error日志的设置 1error_log pathfile level; #默认： error_log logs/error.log error; level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、 emerg，从左至右级别依次增大。当设定为一个级别时，大于或等于该级别的日志都会被输 出到pathfile文件中，小于该级别的日志则不会输出。例如，当设定为error级别时，error、 crit、alert、emerg级别的日志都会输出。4. 是否处理几个特殊的调试点 1debug_points[stop|abort] Nginx 在一些关键的错误逻辑中（Nginx 1.0.14版本中有8处）设置了调试点。如果设置了 debug_points为stop，那么Nginx的代码执行到这些调试点时就会发出SIGSTOP信号以用于调 试。如果debug_points设置为abort，则会产生一个coredump文件，可以使用gdb来查看Nginx当 时的各种信息。 通常不会使用这个配置项。5. 仅对指定的客户端输出debug级别的日志 1debug_connection[IP|CIDR] 1234events &#123; debug_connection 10.224.66.14; debug_connection 10.224.57.0/24; &#125; 仅仅来自以上IP地址的请求才会输出debug级别的日志，其他请求仍然沿用 error_log中配置的日志级别。 使用debug_connection前，需确保在执行configure时已经加入了–with-debug参 数，否则不会生效。6. 限制coredump核心转储文件的大小 1worker_rlimit_core size; 在Linux系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内 容（核心映像）写入一个文件（core文件），以作为调试之用，这就是所谓的核心转储 （core dumps）。当Nginx进程出现一些非法操作（如内存越界）导致进程直接被操作系统强 制结束时，会生成核心转储core文件，可以从core文件获取当时的堆栈、寄存器等信息，从 而帮助我们定位问题。但这种core文件中的许多信息不一定是用户需要的，如果不加以限 制，那么可能一个core文件会达到几GB，这样随便coredumps几次就会把磁盘占满，引发严 重问题。通过worker_rlimit_core配置可以限制core文件的大小，从而有效帮助用户定位问 题。7. 指定coredump文件生成目录 1working_directory path; worker进程的工作目录。这个配置项的唯一用途就是设置coredump文件所放置的目录， 协助定位问题。因此，需确保worker进程有权限向working_directory指定的目录中写入文件 正常运行的配置项 定义环境变量1env VAR|VAR=VALUE 这个配置项可以让用户直接设置操作系统上的环境变量 1env TESTPATH=/tmp/; 嵌入其他配置文件1include pathfile; include配置项可以将其他配置文件嵌入到当前的nginx.conf文件中，它的参数既可以是绝 对路径，也可以是相对路径 12include mime.types; include vhost/*.conf; pid文件的路径1pid path/file; #默认： pid logs/nginx.pid; 保存master进程ID的pid文件存放路径。默认与configure执行时的参数“–pid-path”所指定 的路径是相同的，也可以随时修改，但应确保Nginx有权在相应的目标中创建pid文件，该文 件直接影响Nginx是否可以运行。4. Nginx worker进程运行的用户及用户组 1user username [groupname]; #默认： user nobody nobody; user用于设置master进程启动后，fork出的worker进程运行在哪个用户和用户组下。当按 照“user username;”设置时，用户组名与用户名相同。 若用户在configure命令执行时使用了参数–user=username和–group=groupname，此时 nginx.conf将使用参数中指定的用户和用户组。 指定Nginx worker进程可以打开的最大句柄描述符个数1worker_rlimit_nofile limit; 设置一个worker进程可以打开的最大文件句柄数。6. 限制信号队列 1worker_rlimit_sigpending limit; 设置每个用户发往Nginx的信号队列的大小。也就是说，当某个用户的信号队列满了， 这个用户再发送的信号量会被丢掉。 优化性能的配置项 Nginx worker进程个数1worker_processes number; #默认： worker_processes 1; 在master/worker运行方式下，定义worker进程的个数。 worker进程的数量会直接影响性能。 每个worker进程都是单线程的进程，它们会调用各个模块以实现多种多样的功能。如果 这些模块确认不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程；反 之，如果有可能出现阻塞式调用，那么需要配置稍多一些的worker进程。 例如，如果业务方面会致使用户请求大量读取本地磁盘上的静态资源文件，而且服务器 上的内存较小，以至于大部分的请求访问静态资源文件时都必须读取磁盘（磁头的寻址是缓 慢的），而不是内存中的磁盘缓存，那么磁盘I/O调用可能会阻塞住worker进程少量时间，进 而导致服务整体性能下降。 多worker进程可以充分利用多核系统架构，但若worker进程的数量多于CPU内核数，那 么会增大进程间切换带来的消耗（Linux是抢占式内核）。一般情况下，用户要配置与CPU内 核数相等的worker进程，并且使用下面的worker_cpu_affinity配置来绑定CPU内核。 绑定Nginx worker进程到指定的CPU内核1234worker_cpu_affinity cpumask[cpumask...]worker_processes 2;worker_cpu_affinity 01 10; 解释：01表示启用第一个CPU内核，10表示启用第二个CPU内核worker_cpu_affinity 01 10;表示开启两个进程，第一个进程对应着第一个CPU内核，第二个进程对应着第二个CPU内核。 worker_processes最多开启8个，8个以上性能提升不会再提升了，而且稳定性变得更低，所以8个进程够用了。 配置完之后可以重启nginx，用ab工具或者wrk工具，可以进行性能测试，在服务器上执行top，然后按1，就可以看到cpu工作情况，如果多个cpu内核的利用率差不多，就证明nginx已经成功利用了多核cpu，测试结束后，cpu内核的负载都同时降低。 为什么要绑定worker进程到指定的CPU内核呢？假定每一个worker进程都是非常繁忙的，如果多个worker进程都在抢同一个CPU，那么这就会出现同步问题。反之，如果每一个 worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。 ==worker_cpu_affinity配置仅对Linux操作系统有效。Linux操作系统使用 sched_setaffinity()系统调用实现这个功能。== SSL硬件加速1ssl_engine device； 如果服务器上有SSL硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。 用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备： 1openssl engine -t 系统调用gettimeofday的执行频率1timer_resolution t; 默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执 行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。在早期的Linux内核中， gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。当需要降低 gettimeofday的调用频率时，可以使用timer_resolution配置。例如，“timer_resolution 100ms；”表示至少每100ms才调用一次gettimeofday。 但在目前的大多数内核中，如x86-64体系架构，gettimeofday只是一次vsyscall，仅仅对共享内存页中的数据做访问，并不是通常的系统调用，代价并不大，一般不必使用这个配置。而且，如果希望日志文件中每行打印的时间更准确，也可以使用它 Nginx worker进程优先级设置1worker_priority nice; #默认： worker_priority 0; 该配置项用于设置Nginx worker进程的nice优先级。 在Linux或其他类UNIX操作系统中，当许多进程都处于可执行状态时，将按照所有进程 的优先级来决定本次内核选择哪一个进程执行。进程所分配的CPU时间片大小也与进程优先 级相关，优先级越高，进程分配到的时间片也就越大（例如，在默认配置下，最小的时间片 只有5ms，最大的时间片则有800ms）。这样，优先级高的进程会占有更多的系统资源。 优先级由静态优先级和内核根据进程执行情况所做的动态调整（目前只有±5的调整）共 同决定。nice值是进程的静态优先级，它的取值范围是–20~+19，–20是最高优先级，+19是 最低优先级。因此，如果用户希望Nginx占有更多的系统资源，那么可以把nice值配置得更小 一些，但不建议比内核进程的nice值（通常为–5）还要小。 事件类配置项 是否打开accept锁1accept_mutex[on|off] #默认： accept_mutext on; accept_mutex是Nginx的负载均衡锁，本书会在第9章事件处理框架中详述Nginx是如何实 现负载均衡的。这里，读者仅需要知道accept_mutex这把锁可以让多个worker进程轮流地、 序列化地与新的客户端建立TCP连接。当某一个worker进程建立的连接数量达到 worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连 接的机会，以此实现所有worker进程之上处理的客户端请求数尽量接近。 accept锁默认是打开的，如果关闭它，那么建立TCP连接的耗时会更短，但worker进程 之间的负载会非常不均衡，因此不建议关闭它。 lock文件的路径1lock_file path/file; #默认： lock_file logs/nginx.lock; accept锁可能需要这个lock文件，如果accept锁关闭，lock_file配置完全不生效。如果打 开了accept锁，并且由于编译程序、操作系统架构等因素导致Nginx不支持原子锁，这时才会 用文件锁实现accept锁，这样lock_file指定的lock文件才 会生效。 使用accept锁后到真正建立连接之间的延迟时间1accept_mutex_delay Nms; #默认： accept_mutex_delay 500ms; 在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个accept锁不是 阻塞锁，如果取不到会立刻返回。如果有一个worker进程试图取accept锁而没有取到，它至 少要等accept_mutex_delay定义的时间间隔后才能再次试图取锁。 可以通过减少accept_mutex_delay这个参数让空闲的进程有更大的机会抢到accept锁，从而使任务更加平均的分配，至于对效率的影响 批量建立新连接1multi_accept[on|off]; #默认： multi_accept off; multi_accept可以让nginx worker进程尽可能多地接受请求。它的作用是让worker进程一次性地接受监听队列里的所有请求，然后处理 如果web服务器面对的是一个持续的请求流，那么启用multi_accept可能会造成worker进程一次接受的请求大于worker_connections指定可以接受的请求数。这就是overflow，这个overflow会造成性能损失，overflow这部分的请求不会受到处理。5. 选择事件模型 1use [kqueue|rtsig|epoll|/dev/poll|select|poll|eventport]; #默认： Nginx会自动使用最适合的事件模型。 对于Linux操作系统来说，可供选择的事件驱动模型有poll、select、epoll三种。epoll当 然是性能最高的一种 select: 这是一种标准的请求处理方法。如果一个平台上缺少相应的更加有效的方法，那么Nginx会自动使用select方法。 poll: 这是一种标准的请求处理方法。如果一个平台上缺少相应的更加有效的方法，那么Nginx会自动使用poll方法。 kqueue: 这是BSD家族操作系统上可用的一种高效的请求处理方法。可用于FreeBSD, OpenBSD, NetBSD和OS X。kqueue方法会忽略multi_accept。 epoll: 这是Linux系统上可用的一种高效的请求处理方法，类似于kqueue。它有一个额外的directive，那就是epoll_events。epoll_events指定了Nginx可以向内核传递的事件数量。默认的值是512。 每个worker的最大连接数1worker_connections number; 定义每个worker进程可以同时处理的最大连接数。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"66、mysql 之强制索引","slug":"Mysql/66、mysql 之强制索引","date":"2016-06-04T16:17:29.000Z","updated":"2020-08-07T14:10:11.857Z","comments":true,"path":"2016/06/05/Mysql/66、mysql 之强制索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/05/Mysql/66、mysql 之强制索引/","excerpt":"","text":"mysql 之强制索引用途查询可能会请求价格在10到80之间的产品。如果统计数据显示80％的产品具有这些价​​格范围，那么它可能会认为全表扫描效率最高。但是，如果统计数据显示很少有产品具有这些价​​格范围，那么读取索引后的表访问可能比全表扫描更快，更有效 语法1234SELECT * FROM table_name FORCE INDEX (index_list)WHERE condition;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"4、nginx 之配置文件通用语法","slug":"Nginx/4、nginx 之配置文件通用语法","date":"2016-06-04T01:14:43.000Z","updated":"2020-08-07T14:10:11.867Z","comments":true,"path":"2016/06/04/Nginx/4、nginx 之配置文件通用语法/","link":"","permalink":"https://www.zackaddy.xin/2016/06/04/Nginx/4、nginx 之配置文件通用语法/","excerpt":"","text":"nginx 之配置文件通用语法配置文件一般是一个文本文件，可以由程序解析，通过为一组指令指定值便定义了程序的行为，配置nginx只需要掌握一些机制：指令、区段(block)和整体逻辑结构,实际配置过程中，大多为指令填写值。 语法 配置文件由指令与指令块构成 每条指令以；分号结尾，指令与参数之间以空格符号隔离 指令块以{}大括号将多条指令组织在一起 include语句允许组合多个配置文件以提升可维护性 使用#符号添加注释，提高可读性 使用$符号使用变量 部分指令的参数支持正则表达式 示例12345678910111213141516171819202122232425262728293031#定义Nginx运行的用户和用户组user nobody; #nginx进程数，建议设置为等于CPU总核心数。worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#进程文件#pid logs/nginx.pid; events &#123; use epoll; worker_connections 50000; &#125;#ngx_http_module模块配置http &#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; log_format main '$remote_addr [$time_local] \"$request\" ' '$status $bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main buffer=32k; … ｝ 指令值单位 单位 描述 k/K 千字节 m/M 兆字节 ms Milliseconds–毫秒 s Seconds–秒(默认时间单位) m Minutes–分钟 h Hours–小时 d Days–天 w Weeks–星期 m Months–月(30天) y Years–年(365天)","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"65、mysql 之复合索引","slug":"Mysql/65、mysql 之复合索引","date":"2016-06-04T00:31:36.000Z","updated":"2020-08-07T14:10:11.857Z","comments":true,"path":"2016/06/04/Mysql/65、mysql 之复合索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/04/Mysql/65、mysql 之复合索引/","excerpt":"","text":"mysql 之复合索引 两个或更多个列上的索引被称作复合索引 复合索引是多列的索引。MySQL允许您创建一个最多包含16列的复合索引。 复合索引也称为多列索引。创建12345678910CREATE TABLE table_name ( c1 data_type PRIMARY KEY, c2 data_type, c3 data_type, c4 data_type, INDEX index_name (c2,c3,c4)); CREATE INDEX index_name ON table_name(c2,c3,c4); 以下组合可以建立以上索引功能 123(c1)(c1,c2)(c1,c2,c3)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"64、mysql8.0 之降序索引","slug":"Mysql/64、mysql8.0 之降序索引","date":"2016-06-03T03:33:28.000Z","updated":"2020-08-07T14:10:11.857Z","comments":true,"path":"2016/06/03/Mysql/64、mysql8.0 之降序索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/03/Mysql/64、mysql8.0 之降序索引/","excerpt":"","text":"mysql8.0 之降序索引如果一个查询，需要对多个列进行排序，且顺序要求不一致。在这种场景下，要想避免数据库额外的排序-“filesort”，只能使用降序索引。 建表1create table slowtech.t1(c1 int,c2 int,index idx_c1_c2(c1,c2 desc)); mysql 5.7123456789mysql&gt; show create table slowtech.t1\\G*************************** 1. row *************************** Table: t1Create Table: CREATE TABLE `t1` ( `c1` int(11) DEFAULT NULL, `c2` int(11) DEFAULT NULL, KEY `idx_c1_c2` (`c1`,`c2`)) ENGINE=InnoDB DEFAULT CHARSET=latin1row in set (0.00 sec) mysql 8.0123456789mysql&gt; show create table slowtech.t1\\G*************************** 1. row *************************** Table: t1Create Table: CREATE TABLE `t1` ( `c1` int(11) DEFAULT NULL, `c2` int(11) DEFAULT NULL, KEY `idx_c1_c2` (`c1`,`c2` DESC)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_cirow in set (0.00 sec) 区别 MySQL 8.0因为降序索引的存在，避免了“filesort”。这其实是降序索引的主要应用场景。 如果只对单个列进行排序，降序索引的意义不是太大，无论是升序还是降序，升序索引完全可以应付mysql 5.71234567mysql&gt; explain select * from slowtech.t1 order by c1,c2 desc;+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------+| 1 | SIMPLE | t1 | NULL | index | NULL | idx_c1_c2 | 10 | NULL | 1 | 100.00 | Using index; Using filesort |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-----------------------------+row in set, 1 warning (0.00 sec) mysql 8.01234567mysql&gt; explain select * from slowtech.t1 order by c1,c2 desc;+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+| 1 | SIMPLE | t1 | NULL | index | NULL | idx_c1_c2 | 10 | NULL | 1 | 100.00 | Using index |+----+-------------+-------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+row in set, 1 warning (0.00 sec)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"3、nginx 之添加新的模块","slug":"Nginx/3、nginx 之添加新的模块","date":"2016-06-02T22:04:54.000Z","updated":"2020-08-07T14:10:11.867Z","comments":true,"path":"2016/06/03/Nginx/3、nginx 之添加新的模块/","link":"","permalink":"https://www.zackaddy.xin/2016/06/03/Nginx/3、nginx 之添加新的模块/","excerpt":"","text":"nginx 之添加新的模块 查看当前nginx版本与configure编译配置信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748nginx -V--prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx--modules-path=/usr/lib64/nginx/modules--conf-path=/etc/nginx/nginx.conf--error-log-path=/var/log/nginx/error.log--http-log-path=/var/log/nginx/access.log--http-client-body-temp-path=/var/lib/nginx/tmp/client_body--http-proxy-temp-path=/var/lib/nginx/tmp/proxy--http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi--http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi--http-scgi-temp-path=/var/lib/nginx/tmp/scgi--pid-path=/run/nginx.pid--lock-path=/run/lock/subsys/nginx--user=nginx--group=nginx--with-file-aio--with-ipv6--with-http_ssl_module--with-http_v2_module--with-http_realip_module--with-stream_ssl_preread_module--with-http_addition_module--with-http_xslt_module=dynamic--with-http_image_filter_module=dynamic--with-http_sub_module--with-http_dav_module--with-http_flv_module--with-http_mp4_module--with-http_gunzip_module--with-http_gzip_static_module--with-http_random_index_module--with-http_secure_link_module--with-http_degradation_module--with-http_slice_module--with-http_stub_status_module--with-http_perl_module=dynamic--with-http_auth_request_module--with-mail=dynamic--with-mail_ssl_module--with-pcre--with-pcre-jit--with-stream=dynamic--with-stream_ssl_module--with-google_perftools_module--with-debug--with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic'--with-ld-opt='-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E' 下载相同版本号的源码 1http://nginx.org/en/download.html 解压，cd到源码目录 1cd ./nginx-1.x.x 执行configure命令附加你之前nginx -V查看到的configure参数 nginx-rtmp-module-1.2.1为要添加的模块 1./configure [configure arguments] --add-module=../nginx-rtmp-module-1.2.1 编译 1make 进入objs文件夹 1cd ./objs 生成的二进制nginx拷贝覆盖到之前的目录 1cp ./nginx /usr/local/nginx 重启nginx就可以看到安装的模块了 1nginx -V","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"2、nginx 之编译安装","slug":"Nginx/2、nginx 之编译安装","date":"2016-06-02T00:22:23.000Z","updated":"2020-08-07T14:10:11.867Z","comments":true,"path":"2016/06/02/Nginx/2、nginx 之编译安装/","link":"","permalink":"https://www.zackaddy.xin/2016/06/02/Nginx/2、nginx 之编译安装/","excerpt":"","text":"nginx 之编译安装安装步骤 下载 1http://nginx.org/en/download.html 解压 1tar -zxvf nginx-1.x.xx.tar.gz 进入解压目录 1cd nginx-1.x.xx 配置 1./configure 编译 1make 安装 1sudo make install configure支持选项参数 | 说明 –prefix= | row 1 col 2–sbin-path= | row 2 col 2–conf-path= |–pid-path=","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"63、mysql8.0 之不可见索引","slug":"Mysql/63、mysql8.0 之不可见索引","date":"2016-06-01T23:24:35.000Z","updated":"2020-08-07T14:10:11.856Z","comments":true,"path":"2016/06/02/Mysql/63、mysql8.0 之不可见索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/02/Mysql/63、mysql8.0 之不可见索引/","excerpt":"","text":"mysql8.0 之不可见索引简介INVISIBLE INDEX，不可见索引或者叫隐藏索引。就是对优化器不可见，查询的时候优化器不会把她作为备选。 其实以前要想彻底不可见，只能用开销较大的drop index；现在有了新的方式，可以改变索引的属性，让其不可见，这一操作只更改metadata，开销非常小。 使用场景 比如，我有张表t1，本来已经有索引idxf1，idxf2，idxf3。我通过数据字典检索到idxf3基本没有使用过，那我是不是可以判断这个索引直接删掉就好了？那如果删掉后突然有新上的业务要大量使用呢？难道我要频繁的drop index/add index吗？这个时候选择开销比较小的隐藏索引就好了。 我的业务只有一个可能每个月固定执行一次的SQL用到这个索引，那选择隐藏索引太合适不过了。 又或者是我想要测试下新建索引对我整个业务的影响程度。如果我直接建新索引，那我既有业务涉及到这个字段的有可能会收到很大影响。那这个时候隐藏索引也是非常合适的。 语法123CREATE INDEX index_name ON table_name( c1, c2, ...) INVISIBLE; CREATE INDEX extension ON employees(extension) INVISIBLE; 修改123ALTER TABLE table_name ALTER INDEX index_name [VISIBLE | INVISIBLE]; ALTER TABLE employees ALTER INDEX extension VISIBLE; 显示表的所有索引1SHOW INDEXES FROM tablename; 不可见索引和主键 主键列上的索引不能是不可见的 UNIQUE在NOT NULL没有主键的表的列上定义索引时，MySQL会隐式地理解列是主键列，并且不允许您使索引不可见 不可见索引系统变量1SELECT @@optimizer_switch;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"1、nginx 之概述","slug":"Nginx/1、nginx 之概述","date":"2016-06-01T04:03:12.000Z","updated":"2020-08-07T14:10:11.866Z","comments":true,"path":"2016/06/01/Nginx/1、nginx 之概述/","link":"","permalink":"https://www.zackaddy.xin/2016/06/01/Nginx/1、nginx 之概述/","excerpt":"","text":"nginx 之概述简介Nginx 是异步框架的 Web 服务器，也可以用作反向代理，负载平衡器 和 HTTP 缓存，Nginx 的编写有一个明确目标就是超越 Apache Web 服务器的性能。 Nginx 提供开箱即用的静态文件，使用的内存比 Apache 少得多，每秒可以处理大约四倍于 Apache 的请求。在高并发下 Nginx 能保持低资源低消耗高性能。还有高度模块化的设计，模块编写简单。配置文件简洁。 反向代理是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器(如 Web 服务器)上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的 IP 地址，而不知道在代理服务器后面的服务器簇的存在。 12345678910111213141516graph LR电脑--&gt;负载均衡,如LVS手机--&gt;负载均衡,如LVS平板--&gt;负载均衡,如LVS负载均衡,如LVS--&gt;nginx入口nginx入口--&gt;静态资源nginx入口--&gt;API服务nginx入口--&gt;反向代理nginx入口--&gt;缓存加速nginx入口--&gt;负载均衡静态资源--&gt;nginx出口API服务--&gt;nginx出口反向代理--&gt;nginx出口缓存加速--&gt;nginx出口负载均衡--&gt;nginx出口nginx出口--&gt;http服务 上图的Nginx有点入口网关的味道 优点 nginx由C编写，同样的web服务器，占用的资源和内存低性能高 nginx支持高并发，每个worker子进程是独立平等的，当有客户端请求时，worker进程公平竞争，抢到的worker进程会把请求提交给后端服务器，当后端服务器没有及时响应时，此worker进程会继续接收下一个request,当上一个请求有响应后会触发事件，此worker进程继续之前的执行，知道响应结束。 一个request不会被两个worker进程执行。 nginx支持反向代理（用户有感知的访问叫正向代理如使用vpn访问youtube，用户无感知访问叫反向代理如负载均衡），支持7层负载均衡（拓展负载均衡的好处）。 nginx是异步非阻塞型处理请求（第二点印证），采用的epollandqueue模式，apache是阻塞型处理请求。 nginx处理静态文件速度快 nginx高度模块化，配置简单 热部署 BSD许可证 缺点没有缺点 发行版本 nginx开源版 1http://nginx.org/ nginx商业版 1https://www.nginx.com/ 淘宝的tengine 1http://tengine.taobao.org/ openresty免费版 1https://openresty.org/cn/ openresty商业版 1https://openresty.com/","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/tags/Nginx/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zackaddy.xin/categories/Nginx/"}]},{"title":"62、mysql 之前缀索引","slug":"Mysql/62、mysql 之前缀索引","date":"2016-06-01T00:56:15.000Z","updated":"2020-08-07T14:10:11.856Z","comments":true,"path":"2016/06/01/Mysql/62、mysql 之前缀索引/","link":"","permalink":"https://www.zackaddy.xin/2016/06/01/Mysql/62、mysql 之前缀索引/","excerpt":"","text":"mysql 之前缀索引MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。 建立前缀索引的语法为： 1ALTER TABLE table_name ADD KEY(column_name(prefix_length)); 这里最关键的参数就是prefix_length，这个值需要根据实际表的内容，得到合适的索引选择性（Index Selectivity）。索引选择性就是不重复的个数与总个数的比值。 12select 1.0*count(distinct column_name)/count(*)from table_name 比如我们现在有个Employee表，其中有个FirstName字段，是varchar(50)的，我们查询该字段的索引选择性： 12select 1.0*count(distinct FirstName)/count(*)from Employee 得到结果0.7500，然后我们希望对FirstName建立前缀索引，希望前缀索引的选择性能够尽量贴近于对整个字段建立索引时的选择性。我们先看看3个字符，如何： 12select 1.0*count(distinct left(FirstName,3))/count(*)from Employee 得到的结果是0.58784，好像差距有点大，我们再试一试4个字符呢： 12select 1.0*count(distinct left(FirstName,4))/count(*)from Employee 得到0.68919，已经提升了很多，再试一试5个字符，得到的结果是0.72297，这个结果与0.75已经很接近了，所以我们这里认为前缀长度5是一个合适的取值。所以我们可以为FirstName建立前缀索引： 1alter table test.Employee add key(FirstName(5)) 建立前缀索引后查询语句并不需要更改，如果我们要查询所有FirstName为Devin的Employee，那么SQL仍然写成： 123select *from Employee ewhere e.FirstName='Devin'; 下面总结一下什么情况下使用前缀索引： 字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’ 字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。 前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"61、mysql 之 创建 删除 显示 索引","slug":"Mysql/61、mysql 之 创建 删除 显示 索引","date":"2016-05-31T01:26:18.000Z","updated":"2020-08-07T14:10:11.856Z","comments":true,"path":"2016/05/31/Mysql/61、mysql 之 创建 删除 显示 索引/","link":"","permalink":"https://www.zackaddy.xin/2016/05/31/Mysql/61、mysql 之 创建 删除 显示 索引/","excerpt":"","text":"mysql 之 创建 删除 显示 索引创建索引在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。 1．ALTER TABLEALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。 12345ALTER TABLE table_name ADD INDEX index_name (column_list)ALTER TABLE table_name ADD UNIQUE (column_list)ALTER TABLE table_name ADD PRIMARY KEY (column_list) 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。 2．CREATE INDEXCREATE INDEX可对表增加普通索引或UNIQUE索引。 123CREATE INDEX index_name ON table_name (column_list)CREATE UNIQUE INDEX index_name ON table_name (column_list) table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。 索引类型在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为PRIMARY KEY或UNIQUE索引。对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。 PRIMARY KEY索引和UNIQUE索引非常类似。事实上，PRIMARY KEY索引仅是一个具有名称PRIMARY的UNIQUE索引。这表示一个表只能包含一个PRIMARY KEY，因为一个表中不可能具有两个同名的索引。 下面的SQL语句对students表在sid上添加PRIMARY KEY索引。 1ALTER TABLE students ADD PRIMARY KEY (sid) 删除索引可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。 12345DROP INDEX index_name ON talbe_nameALTER TABLE table_name DROP INDEX index_nameALTER TABLE table_name DROP PRIMARY KEY 其中，前两条语句是等价的，删除掉table_name中的索引index_name。 第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。 如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 查看索引123mysql&gt; show index from tblname;mysql&gt; show keys from tblname; Table 表的名称。 Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 Key_name 索引的名称。 Seq_in_index 索引中的列序列号，从1开始。 Column_name 列名称。 Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。 Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。 Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。 Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。 Index_type用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。 Comment","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"60、mysql 之 R-Tree 索引结构","slug":"Mysql/60、mysql 之 R-Tree 索引结构","date":"2016-05-29T21:50:44.000Z","updated":"2020-08-07T14:10:11.856Z","comments":true,"path":"2016/05/30/Mysql/60、mysql 之 R-Tree 索引结构/","link":"","permalink":"https://www.zackaddy.xin/2016/05/30/Mysql/60、mysql 之 R-Tree 索引结构/","excerpt":"","text":"mysql 之 R-Tree 索引结构","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"59、mysql 之 FullText 索引结构","slug":"Mysql/59、mysql 之 FullText 索引结构","date":"2016-05-29T00:39:10.000Z","updated":"2020-08-07T14:10:11.855Z","comments":true,"path":"2016/05/29/Mysql/59、mysql 之 FullText 索引结构/","link":"","permalink":"https://www.zackaddy.xin/2016/05/29/Mysql/59、mysql 之 FullText 索引结构/","excerpt":"","text":"","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"58、mysql 之 Hash 索引结构","slug":"Mysql/58、mysql 之 Hash 索引结构","date":"2016-05-27T23:13:13.000Z","updated":"2020-08-07T14:10:11.855Z","comments":true,"path":"2016/05/28/Mysql/58、mysql 之 Hash 索引结构/","link":"","permalink":"https://www.zackaddy.xin/2016/05/28/Mysql/58、mysql 之 Hash 索引结构/","excerpt":"","text":"","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"57、mysql 之 BTree 索引结构","slug":"Mysql/57、mysql 之 BTree 索引结构","date":"2016-05-27T04:56:10.000Z","updated":"2020-08-07T14:10:11.855Z","comments":true,"path":"2016/05/27/Mysql/57、mysql 之 BTree 索引结构/","link":"","permalink":"https://www.zackaddy.xin/2016/05/27/Mysql/57、mysql 之 BTree 索引结构/","excerpt":"","text":"mysql 之 BTree 索引结构","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"26、redis 之性能监控及优化","slug":"Redis/26、redis 之性能监控及优化","date":"2016-05-25T22:09:33.000Z","updated":"2020-08-07T14:10:11.884Z","comments":true,"path":"2016/05/26/Redis/26、redis 之性能监控及优化/","link":"","permalink":"https://www.zackaddy.xin/2016/05/26/Redis/26、redis 之性能监控及优化/","excerpt":"","text":"redis 之性能监控及优化性能指标：PerformanceName | Description latency | Redis响应一个请求的时间instantaneous_ops_per_sec | 平均每秒处理请求总数hit rate（calculated） | 缓存命中率（计算出来的） 内存指标：Memory Name Description used_memory 已使用内存 mem_fragmentation_ratio 内存碎片率 evicted_keys 由于最大内存限制被移除的key的数量 blocked_clients 由于BLPOP,BRPOP,or BRPOPLPUSH而备阻塞的客户端 基本活动指标：Basic activity Name Description connected_clients 客户端连接数 connected_slaves Slave数量 master_last_io_seconds_ago 最近一次主从交互之后的秒数 keyspace 数据库中的key值总数 持久性指标：Persistence Name Description rdb_last_save_time 最后一次持久化保存到磁盘的时间戳 rdb_changes_since_last_save 自最后一次持久化以来数据库的更改数 错误指标：Error Name Description rejected_connections 由于达到maxclient限制而被拒绝的连接数 keyspace_misses Key值查找失败（没有命中）次数 master_link_down_since_seconds 主从断开的持续时间（以秒为单位） 监控方式 工具 Cloud Insight Redis Prometheus Redis-stat Redis-faina RedisLive zabbix 命令 benchmark redis cli monitor showlog benchmark 命令1redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ] 序号 选项 描述 默认值 1 -h 指定服务器主机名 127.0.0.1 2 -p 指定服务器端口 6379 3 -s 指定服务器 socket 4 -c 指定并发连接数 50 5 -n 指定请求数 10000 6 -d 以字节的形式指定 SET/GET 值的数据大小 2 7 -k 1=keep alive 0=reconnect 1 8 -r SET/GET/INCR 使用随机 key,SADD 使用随机值 9 -P 通过管道传输 请求 1 10 -q 强制退出 redis。仅显示 query/sec 值 11 –csv 以csv格式输出 12 -l 生成循环，永久执行测试 13 -t 仅运行以逗号分隔的测试命令列表 14 -i idle模式。仅打开n的idle连接并等待 范例1 说明：50个连接，10000次请求对应的性能 1redis-benchmark 范例2 说明：100个连接，5000次请求对应的性能 1redis-benchmark -c 100 -n 5000 monitor 命令 打印服务器调试信息1monitor showlong 命令 get ：获取慢查询日志 len ：获取慢查询日志条目数 reset ：重置慢查询日志1showlong [operator] 相关配置 12slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：微妙slowlog-max-len 100 #设置慢查询命令对应的日志显示长度，单位：命令数","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"56、mysql 之聚簇索引与非聚簇索引概念","slug":"Mysql/56、mysql 之聚簇索引与非聚簇索引概念","date":"2016-05-25T18:33:47.000Z","updated":"2020-08-07T14:10:11.855Z","comments":true,"path":"2016/05/26/Mysql/56、mysql 之聚簇索引与非聚簇索引概念/","link":"","permalink":"https://www.zackaddy.xin/2016/05/26/Mysql/56、mysql 之聚簇索引与非聚簇索引概念/","excerpt":"","text":"mysql 之聚簇索引与非聚簇索引概念在mysql数据库中，myisam引擎和innodb引擎使用的索引类型不同，myisam对应的是非聚簇索引，而innodb对应的是聚簇索引。聚簇索引也叫复合索引、聚集索引等等。 聚簇索引以innodb为例，在一个数据table中，它的数据文件和索引文件是同一个文件。即在查询过程中，找到了索引，便找到了数据文件。在innodb中，即存储主键索引值，又存储行数据，称之为聚簇索引。 innodb索引，指向主键对数据的引用。非主键索引则指向对主键的引用。innodb中，没有主见索引，则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的id来当作主键索引。 在聚簇索引中，数据会被按照顺序整理排列，当使用where进行顺序、范围、大小检索时，会大大加速检索效率。非聚簇索引在存储时不会对数据进行排序，相对产生的数据文件体积也比较大。 具有短主键是有利的，否则二级索引将使用更多空间。通常，自动增量整数列用于主键列。 非聚簇索引以myisam为例，一个数据表table中，它是有table.frm、table.myd以及table.myi组成。table.myd记录了数据，table.myi记录了索引的数据。在用到索引时，先到table.myi（索引树）中进行查找，取到数据所在table.myd的行位置，拿到数据。所以myisam引擎的索引文件和数据文件是独立分开的，则称之为非聚簇索引。 myisam类型的索引，指向数据在行的位置。即每个索引相对独立，查询用到索引时，索引指向数据的位置。 何时使用聚簇索引或非聚簇索引\\ | 聚簇索引 | 非聚簇索引 列经常被分组排序 | √ | √返回某范围内的数据 | √ | ×一个或极少不同值 | × | ×小数目的不同值 | √ | ×大数目的不同值 | × | √频繁更新的列 | × | √外键列 | √ | √主键列 | √ | √频繁修改索引列 | × | √ 索引使用场景 不要索引数据量不大的表，对于小表来讲，表扫描的成本并不高。 不要设置过多的索引，在没有聚集索引的表中，最大可以设置249个非聚集索引，过多的索引首先会带来更大的磁盘空间，而且在数据发生修改时，对索引的维护是特别消耗性能的。 合理应用复合索引，有某些情况下可以考虑创建包含所有输出列的覆盖索引。 对经常使用范围查询的字段，可能考虑聚集索引。 避免对不常用的列，逻辑性列，大字段列创建索引。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"55、mysql 之为什么使用索引","slug":"Mysql/55、mysql 之为什么使用索引","date":"2016-05-24T20:00:02.000Z","updated":"2020-08-07T14:10:11.854Z","comments":true,"path":"2016/05/25/Mysql/55、mysql 之为什么使用索引/","link":"","permalink":"https://www.zackaddy.xin/2016/05/25/Mysql/55、mysql 之为什么使用索引/","excerpt":"","text":"mysql 之为什么使用索引什么是索引MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。可以得到索引的本质：索引是数据结构 排好序的快速查找数据结构 数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上 我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。 电话簿比喻假设您有一本电话簿，其中包含城市中所有人的姓名和电话号码。假设你想找到Bob Cat的电话号码。知道这些名称是按字母顺序排列的，首先要查找姓氏为Cat的页面，然后查找Bob和他的电话号码。 现在，如果电话簿中的姓名没有按字母顺序排序，则需要浏览所有页面，阅读其中的每个名称，直到找到Bob Cat。这称为顺序搜索。您将查看所有条目，直到找到具有您要查找的电话号码的人员为止。 将电话簿与数据库表相关联，如果您有电话簿表并且必须找到Bob Cat的电话号码，则可以执行以下查询： 1234567SELECT phone_numberFROM phone_bookWHERE first_name = 'Bob' AND last_name = 'Cat'; 这很容易。虽然查询速度很快，但数据库必须扫描表的所有行，直到找到行为止。如果表有数百万行而没有索引，则数据检索将花费大量时间来返回结果。 优缺点优点 索引大大减小了服务器需要扫描的数据量 索引可以帮助服务器避免排序和临时表 索引可以将随机IO变成顺序IO 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效； 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 因此应该只为最经常查询和最经常排序的数据列建立索引。 MySQL里同一个数据表里的索引总数限制为16个。 什么时候需要建立索引 主键自动建立唯一索引 频繁作为查询条件的字段应该建立索引 查询中与其它表关联的字段，外键关系建立索引 频繁更新的字段不适合创建索引 - 因为每次不单单更新了记录还会更新索引 where条件里用不到的字段不创建索引 单键/组合索引的选择（在高并发下倾向创建组合索引） 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 什么时候不需要建立索引 表记录太少 经常增删改的表 数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。 假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分，布概率大约为50％，那么对这种表A字段建索引一般不会提高数据库的查询速度。 索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99.一个索引的选择性越接近1，这个索引的效率就越高。 注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"25、redis 之缓存穿透","slug":"Redis/25、redis 之缓存穿透","date":"2016-05-24T16:54:22.000Z","updated":"2020-08-07T14:10:11.884Z","comments":true,"path":"2016/05/25/Redis/25、redis 之缓存穿透/","link":"","permalink":"https://www.zackaddy.xin/2016/05/25/Redis/25、redis 之缓存穿透/","excerpt":"","text":"redis 之缓存穿透简介缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类 数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。 出现情况 系统平稳运行过程中 应用服务器流量随时间增量较大 Redis服务器命中率随时间逐步降低 Redis内存平稳，内存无压力 Redis服务器CPU占用激增 数据库服务器压力激增 数据库崩溃 问题排查 Redis中大面积出现未命中 出现非正常URL访问 问题分析 获取的数据在数据库中也不存在，数据库查询未得到对应数据 Redis获取到null数据未进行持久化，直接返回 下次此类数据到达重复上述过程 出现黑客攻击服务器 解决方案 缓存null 对查询结果为null的数据进行缓存(长期使用，定期清理)，设定短时限，例如30-60秒，最高5分钟 白名单策略 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截(效率偏低) 使用布隆过滤器(有关布隆过滤器的命中问题对当前状况可以忽略) 实施监控 实时监控redis命中率(业务正常范围时，通常会有一个波动值)与null数据的占比 非活动时段波动:通常检测3-5倍，超过5倍纳入重点排查对象 活动时段波动:通常检测10-50倍，超过50倍纳入重点排查对象 根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控(运营) key加密 问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验 例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"54、mysql 之 SIGNAL RESIGNAL 抛出异常信息","slug":"Mysql/54、mysql 之 SIGNAL RESIGNAL 抛出异常信息","date":"2016-05-24T01:11:55.000Z","updated":"2020-08-07T14:10:11.854Z","comments":true,"path":"2016/05/24/Mysql/54、mysql 之 SIGNAL RESIGNAL 抛出异常信息/","link":"","permalink":"https://www.zackaddy.xin/2016/05/24/Mysql/54、mysql 之 SIGNAL RESIGNAL 抛出异常信息/","excerpt":"","text":"mysql 之 SIGNAL RESIGNAL 抛出异常信息 在存储过程，存储函数， 触发器或事件 向调用者返回错误或警告 SIGNAL语法123SIGNAL SQLSTATE | condition_name;SET condition_information_item_name_1 = value_1, condition_information_item_name_1 = value_2, etc; condition_name：参数表示异常的名称 SQLSTATE [VALUE] sqlstate_value为包含5个字符的字符串错误值 condition_information_item_name可选MESSAGE_TEXT，MYSQL_ERRORNO，CURSOR_NAME，等。SIGNAL示例1234567891011121314151617drop procedure if exists Divide;DELIMITER //CREATE PROCEDURE Divide(IN numerator INT, IN denominator INT, OUT result double)BEGIN DECLARE division_by_zero CONDITION FOR SQLSTATE '22012'; IF denominator = 0 THEN SIGNAL division_by_zero SET MESSAGE_TEXT = '6666'; ELSE SET result := numerator / denominator; END IF;END//DELIMITER ; CALL Divide(2,0,@result); &gt; 1644 - 6666&gt; 时间: 0s RESIGNAL语法123RESIGNAL SQLSTATE | condition_name;SET condition_information_item_name_1 = value_1, condition_information_item_name_1 = value_2, etc; 与SIGNAL功能和语法类似 必须在错误或警告处理程序中使用RESIGNAL语句 可以省略RESIGNAL语句的所有属性，甚至是SQLSTATE值RESIGNAL示例 在错误消息发送给调用方之前更改错误消息12345678910111213141516171819drop procedure if exists Divide;DELIMITER //CREATE PROCEDURE Divide(IN numerator INT, IN denominator INT, OUT result double)BEGIN DECLARE division_by_zero CONDITION FOR SQLSTATE '22012'; DECLARE CONTINUE HANDLER FOR division_by_zero RESIGNAL SET MESSAGE_TEXT = 'HAHAHA'; IF denominator = 0 THEN SIGNAL division_by_zero; ELSE SET result := numerator / denominator; END IF;END//DELIMITER ; CALL Divide(2,0,@result); &gt; 1644 - HAHAHA&gt; 时间: 0s","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"24、redis 之缓存击穿","slug":"Redis/24、redis 之缓存击穿","date":"2016-05-23T23:00:13.000Z","updated":"2020-08-07T14:10:11.884Z","comments":true,"path":"2016/05/24/Redis/24、redis 之缓存击穿/","link":"","permalink":"https://www.zackaddy.xin/2016/05/24/Redis/24、redis 之缓存击穿/","excerpt":"","text":"redis 之缓存击穿简介缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服 务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度 较高，配合雪崩处理策略即可。 出现情况 系统平稳运行过程中 数据库连接量瞬间激增 Redis服务器无大量key过期 Redis内存平稳，无波动 Redis服务器CPU正常 数据库崩溃 问题排查 Redis中某个key过期，该key访问量巨大 多个数据请求从服务器直接压到Redis后，均未命中 Redis在短时间内发起了大量对数据库中同一数据的访问 问题分析 单个key高热数据 key过期 解决方案 预先设定 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长 注意:购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势 现场调整 监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key 后台刷新数据 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 二级缓存 设置不同的失效时间，保障不会被同时淘汰就行 加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重!","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"23、redis 之缓存雪崩","slug":"Redis/23、redis 之缓存雪崩","date":"2016-05-23T04:05:34.000Z","updated":"2020-08-07T14:10:11.884Z","comments":true,"path":"2016/05/23/Redis/23、redis 之缓存雪崩/","link":"","permalink":"https://www.zackaddy.xin/2016/05/23/Redis/23、redis 之缓存雪崩/","excerpt":"","text":"redis 之缓存雪崩简介缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现 (约40%)，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 出现情况 系统平稳运行过程中，忽然数据库连接量激增 应用服务器无法及时处理请求 大量408，500错误页面出现 客户反复刷新页面获取数据 数据库崩溃 应用服务器崩溃 重启应用服务器无效 Redis服务器崩溃 Redis集群崩溃 重启数据库后再次被瞬间流量放倒 问题排查 在一个较短的时间内，缓存中较多的key集中过期 此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 数据库同时接收到大量的请求无法及时处理 Redis大量请求被积压，开始出现超时现象 数据库流量激增，数据库崩溃 重启后仍然面对缓存中无数据可用 Redis服务器资源被严重占用，Redis服务器崩溃 Redis集群呈现崩塌，集群瓦解 应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃 10. 应用服务器，redis，数据库全部重启，效果不理想 问题分析 短时间范围内 大量key集中过期 解决方案 更多的页面静态化处理 构建多级缓存架构 Nginx缓存+redis缓存+ehcache缓存 检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查:例如超时查询、耗时较高事务等 灾难预警机制 监控redis服务器性能指标 CPU占用、CPU使用率 内存容量 查询平均响应时间 线程数 限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 LRU与LFU切换 数据有效期策略调整 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟 过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量 超热数据使用永久key 定期维护(自动+人工) 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 加锁 慎用!","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"53、mysql 之事件调度器","slug":"Mysql/53、mysql 之事件调度器","date":"2016-05-22T22:10:26.000Z","updated":"2020-08-07T14:10:11.854Z","comments":true,"path":"2016/05/23/Mysql/53、mysql 之事件调度器/","link":"","permalink":"https://www.zackaddy.xin/2016/05/23/Mysql/53、mysql 之事件调度器/","excerpt":"","text":"mysql 之事件调度器它相当于一个定时器，可以在指定的时间点执行一条SQL语句或一个语句块，也可以用于在固定间隔重复执行。事件调度器相当于操作系统中的定时任务(如：Linux中的cron、Window中的计划任务)，但MySql的事件调度器可以精确到秒，对于一些实时性要求较高的数据处理非常有用。 语法123456789101112131415161718192021CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] EVENT [IF NOT EXISTS] event_name ON SCHEDULE schedule [ON COMPLETION [NOT] PRESERVE] [ENABLE | DISABLE | DISABLE ON SLAVE] [COMMENT 'comment'] DO event_body; schedule: AT timestamp [+ INTERVAL interval] ... | EVERY interval [STARTS timestamp [+ INTERVAL interval] ...] [ENDS timestamp [+ INTERVAL interval] ...] interval: quantity &#123;YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE | DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND&#125; event_name ：创建的event名字（唯一确定的）。 ON SCHEDULE：计划任务。 schedule: 决定event的执行时间和频率（注意时间一定要是将来的时间，过去的时间会出错），有两种形式 AT和EVERY。 [ON COMPLETION [NOT] PRESERVE]： 可选项，默认是ON COMPLETION NOT PRESERVE 即计划任务执行完毕后自动drop该事件；ON COMPLETION PRESERVE则不会drop掉。 [COMMENT &#39;comment&#39;] ：可选项，comment 用来描述event；相当注释，最大长度64个字节。 [ENABLE | DISABLE] ：设定event的状态，默认ENABLE：表示系统尝试执行这个事件， DISABLE：关闭该事情，可以用alter修改 DO event_body: 需要执行的sql语句（可以是复合语句）。CREATE EVENT在存储过程中使用时合法的。 interval 表 单位 说明 YEAR 年 QUARTER 季度 MONTH 月 DAY 天 HOUR 时 MINUTE 分 WEEK 周 SECOND 秒 YEAR_MONTH 年:月 DAY_HOUR 日:时 DAY_MINUTE 日:分 DAY_SECOND 日:秒 HOUR_MINUTE 时:分 HOUR_SECOND 时:秒 MINUTE_SECOND 分:秒 #### Every interval 123- EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 1 WEEK 一周以后开始，每隔三个月- EVERY 2 WEEK STARTS CURRENT_TIMESTAMP + INTERVAL ‘6:15’ HOUR_MINUTE 六个小时15分钟以后，每隔两周- EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK 30分钟以后开始，4周后结束，每隔12个小时 查看123456SHOW EVENTS FROM mysqldemo; SHOW VARIABLES LIKE 'event_scheduler';SELECT @@event_scheduler;SHOW PROCESSLIST;SELECT * FROM information_schema.EVENTS;SELECT EVENT_NAME, LAST_EXECUTED FROM information_schema.EVENTS; 开启/关闭1234SET GLOBAL event_scheduler = 1;SET @@global.event_scheduler = 1;SET GLOBAL event_scheduler = ON;SET @@global.event_scheduler = ON; 删除1DROP EVENT [IF EXIST] event_name; 示例 事件创建后每小时执行一次 12345CREATE EVENT myevent ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR DO UPDATE myschema.mytable SET mycol = mycol + 1; 从2013-07-30 17:33:43起每一天执行一次p_del_count这个存储过程，并带上参数 123CREATE EVENT `e_del_tbl_base_count` ON SCHEDULE EVERY 1 DAY STARTS '2013-06-23 17:33:43' ON COMPLETION NOT PRESERVE ENABLE DO CALL p_del_count (90); 1小时后执行该事件： 1234CREATE EVENT myevent ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR DO UPDATE myschema.mytable SET mycol = mycol + 1; 修改事件调度器语法1234567ALTER EVENT event_nameON SCHEDULE scheduleON COMPLETION [NOT] PRESERVERENAME TO new_event_nameENABLE | DISABLEDO event_body 示例以下语句创建一个事件，每分钟将新记录插入messages表中。 12345CREATE EVENT test_event_04ON SCHEDULE EVERY 1 MINUTEDO INSERT INTO messages(message,created_at) VALUES('Test ALTER EVENT statement',NOW()); 改变时间表要使事件每2分钟运行一次，请使用以下语句： 12ALTER EVENT test_event_04ON SCHEDULE EVERY 2 MINUTE; 改变活动体您还可以通过指定新逻辑来更改事件的主体，如下所示： 1234ALTER EVENT test_event_04DO INSERT INTO messages(message,created_at) VALUES('Message from event',NOW()); 您可以等待2分钟并messages再次检查表格： 1SELECT * FROM messages; 禁用事件要禁用事件，请使用以下语句： 12ALTER EVENT test_event_04DISABLE; 您可以使用以下SHOW EVENTS语句检查事件的状态 ： 1SHOW EVENTS FROM mysqldemo; 启用事件要启用已禁用的事件，请ENABLE在ALTER EVENT语句后使用关键字 ，如下所示： 12ALTER EVENT test_event_04ENABLE; 重命名事件MySQL没有为您提供 RENAME EVENT语句。幸运的是，您可以使用 ALTER EVENT重命名现有事件，如下所示： 12ALTER EVENT test_event_04RENAME TO test_event_05; 将事件移动到另一个数据库您可以使用以下RENAME TO子句将事件从数据库移动到另一个数据库 ： 12ALTER EVENT mysqldemo.test_event_05RENAME TO newdb.test_event_05","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"52、mysql 之触发器","slug":"Mysql/52、mysql 之触发器","date":"2016-05-22T00:27:19.000Z","updated":"2020-08-07T14:10:11.854Z","comments":true,"path":"2016/05/22/Mysql/52、mysql 之触发器/","link":"","permalink":"https://www.zackaddy.xin/2016/05/22/Mysql/52、mysql 之触发器/","excerpt":"","text":"mysql 之触发器触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。 尽量少使用触发器，不建议使用。 假设触发器触发每次执行1s，insert table 500条数据，那么就需要触发500次触发器，光是触发器执行的时间就花费了500s，而insert 500条数据一共是1s，那么这个insert的效率就非常低了。因此我们特别需要注意的一点是触发器的begin end;之间的语句的执行效率一定要高，资源消耗要小。 触发器尽量少的使用，因为不管如何，它还是很消耗资源，如果使用的话要谨慎的使用，确定它是非常高效的：触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。 为什么不推荐使用触发器而是存储过程 存储过程和触发器二者是有很大的联系的，我的一般理解就是触发器是一个隐藏的存储过程，因为它不需要参数，不需要显示调用，往往在你不知情的情况下已经做了很多操作。从这个角度来说，由于是隐藏的，无形中增加了系统的复杂性，非DBA人员理解起来数据库就会有困难，因为它不执行根本感觉不到它的存在。 再有，涉及到复杂的逻辑的时候，触发器的嵌套是避免不了的，如果再涉及几个存储过程，再加上事务等等，很容易出现死锁现象，再调试的时候也会经常性的从一个触发器转到另外一个，级联关系的不断追溯，很容易使人头大。其实，从性能上，触发器并没有提升多少性能，只是从代码上来说，可能在coding的时候很容易实现业务，所以我的观点是：摒弃触发器！触发器的功能基本都可以用存储过程来实现。 在编码中存储过程显示调用很容易阅读代码，触发器隐式调用容易被忽略。存储过程也有他的致命伤↓ 存储过程的致命伤在于移植性，存储过程不能跨库移植，比如事先是在mysql数据库的存储过程，考虑性能要移植到oracle上面那么所有的存储过程都需要被重写一遍。 语法123456CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW BEGIN ... END; trigger_name : 触发器名称，用户自行指定 trigger_time： 触发时机，取值BEFORE（之前）、AFTER（之后） trigger_event : 出发事件，INSERT、UPDATE、DELETE。（插入、更新、删除） tbl_name : 需要建立触发器的表名。 trigger_stmt : 触发程序体，可以是一条SQL语句或是BEGIN和END包含的索条语句 由上面，可以知道MYSQL可以创建6种类型的触发器。（BEFORE INSERT、BEFORE UPDATE、BEFORE DELETE）（AFTER INSERT、AFTER UPDATE、AFTER DELETE）并且一张表上不能创建两个相同类型的触发器，因此一张表上面最多能创建6种类型的触发器。 使用 NEW、OLD关键字12345678910111213DELIMITER //CREATE TRIGGER before_employee_update BEFORE UPDATE ON employees FOR EACH ROW BEGIN INSERT INTO employees_audit SET action = 'update', employeeNumber = OLD.employeeNumber, lastname = OLD.lastname, changedat = NOW(); END//DELIMITER ; 查看123SHOW TRIGGERS\\G;SELECT * FROM information_schema.triggers\\Gselect * from information_schema.triggers where trigger_name='upd_check'\\G; 删除1DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"22、redis 之缓存预热","slug":"Redis/22、redis 之缓存预热","date":"2016-05-21T17:20:48.000Z","updated":"2020-08-07T14:10:11.883Z","comments":true,"path":"2016/05/22/Redis/22、redis 之缓存预热/","link":"","permalink":"https://www.zackaddy.xin/2016/05/22/Redis/22、redis 之缓存预热/","excerpt":"","text":"redis 之缓存预热简介系统上线时，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 哪些数据需要预热 可以将已知的热门数据加载到Redis，这种方法适合于基本不变化的数据； 使用redis-faina（https://github.com/facebookarchive/redis-faina.git）实时监控Redis热key，但是因为redis-faina是通过调用Redis的monitor命令来实现的，可能降低Redis50%左右的性能，所以需要根据实际情况评估； 在proxy层，对每个请求进行收集上报，弊端就是需要修改proxy的代码，需要考虑开发成本和稳定性问题； Redis-cli –hotkyes 查询热点key，只适用于缓存淘汰策略是lfu的时候（https://yq.aliyun.com/articles/278922）； TCP消息抓包，例如ELK体系下的packetbeat插件(https://www.elastic.co/guide/en/beats/packetbeat/current/index.html)，可以实现对Redis、MySQL等众多主流服务的数据包抓取、分析、报表展示； 客户端上报，例如nginx+lua将访问量上报到kafka中，然后进行统计 解决方案 直接写个缓存刷新页面，上线时手工操作 数据量不大，可以在项目启动的时候自动进行加载目的就是在系统上线前，将数据加载到缓存中。 定时刷新缓存","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"51、mysql 之内存表和临时表","slug":"Mysql/51、mysql 之内存表和临时表","date":"2016-05-21T04:42:09.000Z","updated":"2020-08-07T14:10:11.853Z","comments":true,"path":"2016/05/21/Mysql/51、mysql 之内存表和临时表/","link":"","permalink":"https://www.zackaddy.xin/2016/05/21/Mysql/51、mysql 之内存表和临时表/","excerpt":"","text":"mysql 之内存表和临时表区别 \\ 临时表 内存表 存储 表结构和数据都存在内存中 表结构存储在磁盘，表数据存储在内存中 会话 单个会话 多个会话 引擎 默认myisam 默认memory 断开连接 表结构和数据都没了 表结构和数据都存在 服务重启 表结构和数据都没了 表结构存在，表数据不存在 性能 由于表数据放在内存中，相对来说，查询速度较快，数据维护较为困难 由于表数据放在内存中，相对来说，查询速度较快，数据维护较为困难 - 存储 - 内存表 表结构存储在磁盘中，数据存储在内存中 - 临时表 表结构和数据都存储在内存中 - 会话 - 内存表 是可以多个会话共享的 - 临时表 是单个会话独享的，是会话级别的 - 引擎 - 内存表默认，memory - 临时表默认，myisam - 断开连接 - 临时表 啥都不剩 - 内存表 只剩下表结构 - 性能 - 内存表由于所有的内容都是放在内存中，所以相对来说，速度较快但是同时数据的维护较为困难 临时表为了保存临时数据而存在的(MySQL 3.23版本以后才有)，临时表只在当前连接可见，当关闭连接时，Mysql会自动删表并释放所有空间。如果你使用Navicat等客户端程工具连接MySQL创建临时表，那么只有在关闭客户端关闭时才会销毁临时表(也可手动销毁)。 临时表只在当前连接可见，连接关闭的时候，会自动drop。 临时表的存储引擎：memory、myisam、merge或innodb，临时表不支持mysql cluster簇。 临时表超容会转换成磁盘表。 show tables语句不会列出临时表，在information_schema中也不存在临时表信息 创建12345678910111213//创建临时表 TEMPORARY是关键字CREATE TEMPORARY TABLE IF NOT EXISTS gu( id INT NOT NULL DEFAULT 0, name VARCHAR(10) NOT NULL); //复制的方式创建临时表CREATE TEMPORARY TABLE guAS SELECT * FROM tb_gu; //手动销毁临时表DROP TABLE IF EXISTS gu; 查看1show create table 重命名1ALTER TABLE old_name RENAME new_name; 内存表数据放在内存里面的表(内存表的表结构建立在磁盘中)，当MySQL断开当前连接后，临时表的表结构和表数据都drop，但内存表的表结构和表数据都存在。当MySQL服务重启之后，内存表的数据会丢失，但表结构依旧存在。 当MySQL服务重启，内存表的数据丢失，结构存在。 当前session创建的内存表，对其他session可见，所以不同session，创建内存表的名字不能一样。 Mysql安装目录data下只有table名.frm，因为内存表的表结构放在磁盘上，数据放在内存中。 可以创建索引，删除索引，支持唯一索引(索引和数据一样保存在内存中)。 内存表不能包含BLOB或者TEXT等字段，但是支持AUTO_INCREMENT列。 可以通过参数max_heap_table_size来设定内存表大小，到达max_heap_table_size设定的内存上限后将报错。创建123456789创建内存表与创建普通表语法一样，但需要将存储引擎设置为：ENGINE = MEMORY CREATE TABLE IF NOT EXISTS gu ( id INT NOT NULL DEFAULT 0, name VARCHAR(10) NOT NULL) ENGINE = MEMORY; // 删除内存表DROP TABLE IF EXISTS gu;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"21、redis 之集群","slug":"Redis/21、redis 之集群","date":"2016-05-21T04:32:31.000Z","updated":"2020-08-07T14:10:11.883Z","comments":true,"path":"2016/05/21/Redis/21、redis 之集群/","link":"","permalink":"https://www.zackaddy.xin/2016/05/21/Redis/21、redis 之集群/","excerpt":"","text":"redis 之集群简介集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果 Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的错误。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 作用 分散单台服务器的访问压力，实现负载均衡 分散单台服务器的存储压力，实现可扩展性 降低单台服务器宕机带来的业务灾难 1234567graph LRmaster1--&gt;slave1master2--&gt;slave2master3--&gt;slave3访问流量--&gt;master1访问流量--&gt;master2访问流量--&gt;master3 数据存储设计Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中： 节点 A 负责处理 0 号至 5500 号哈希槽。 节点 B 负责处理 5501 号至 11000 号哈希槽。 节点 C 负责处理 11001 号至 16384 号哈希槽。这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：我现在想设置一个key,叫my_name:1set my_name zhangguoji 按照Redis Cluster的哈希槽算法，CRC16(‘my_name’)%16384 = 2412 那么这个key就被分配到了节点A上同样的，当我连接(A,B,C)的任意一个节点想获取my_name这个key,都会转到节点A上再比如如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。增加一个D节点的结果可能如下： 节点A覆盖1365-5460 节点B覆盖6827-10922 节点C覆盖12288-16383 节点D覆盖0-1364,5461-6826,10923-1228 与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。 主从复制模型为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。 在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000号的哈希槽。 另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。 不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。 一致性保证Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作：第一个原因是因为集群是用了异步复制. 写操作过程: 客户端向主节点B写入一条命令. 主节点B向客户端回复命令状态. 主节点将写操作复制给他得从节点 B1, B2 和 B3 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 注意：Redis 集群可能会在将来提供同步写的方法。 Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。举个例子 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， A1 、B1 、C1 为A，B，C的从节点， 还有一个客户端 Z1 假设集群中发生网络分区，那么集群可能会分为两方，大部分的一方包含节点 A 、C 、A1 、B1 和 C1 ，小部分的一方则包含节点 B 和客户端 Z1 .Z1仍然能够向主节点B中写入, 如果网络分区发生时间较短,那么集群将会继续正常运作,如果分区的时间足够让大部分的一方将B1选举为新的master，那么Z1写入B中得数据便丢失了.注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项 搭建redis集群要让集群正常工作至少需要3个主节点，在这里我们要创建6个redis节点，其中三个为主节点，三个为从节点，对应的redis节点的ip和端口对应关系如下（为了简单演示都在同一台机器上面） 1234567127.0.0.1:7000127.0.0.1:7001127.0.0.1:7002127.0.0.1:7003127.0.0.1:7004127.0.0.1:7005 创建目录 12mkdir clustercd cluster 创建6个配置文件 redis-7000.conf redis-7001.conf redis-7002.conf redis-7003.conf redis-7004.conf redis-7005.conf 6个配置文件基本相同 123456789101112131415161718# 端口号port 7000# 后台启动daemonize yes# 开启集群cluster-enabled yes#集群节点配置文件cluster-config-file nodes-7000.conf# 集群连接超时时间cluster-node-timeout 5000# 进程pid的文件位置pidfile /var/run/redis-7000.pid# 开启aofappendonly yes# aof文件路径appendfilename \"appendonly-7000.aof\"# rdb文件路径dbfilename dump-7000.rdb 启动配置好的redis 123456redis-server cluster/redis-7000.confredis-server cluster/redis-7001.confredis-server cluster/redis-7002.confredis-server cluster/redis-7003.confredis-server cluster/redis-7004.confredis-server cluster/redis-7005.conf 安装集群所需软件 123yum install rubyyum install rubygemsgem install redis gem install redis 安装失败参考如下设置 12345~]# yum install centos-release-scl-rh //会在/etc/yum.repos.d/目录下多出一个CentOS-SCLo-scl-rh.repo源~]# yum install rh-ruby23 -y //直接yum安装即可 ~]# scl enable rh-ruby23 bash //必要一步~]# ruby -v //查看安装版本~]# gem install redis 下载redis源码取得redis-trib.rb文件执行如下命令 123456redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005#redis 5 使用下方命令创建集群redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\--cluster-replicas 1 命令的意义如下： 给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。 选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。简单来说，以上的命令的意思就是让redis-trib程序帮我们创建三个主节点和三个从节点的集群接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中： 集群创建完毕，查看redis进程可以看到相应信息 1ps -ef | grep redis 连接集群中的一个节点 1redis-cli -c -h 127.0.0.1 -p 7000 Cluster节点操作命令 查看集群节点信息 1cluster nodes 进入一个从节点 redis，切换其主节点 1cluster replicate &lt;master-id&gt; 发现一个新节点，新增主节点 1cluster meet ip:port 忽略一个没有solt的节点 1cluster forget &lt;id&gt; 手动故障转移 1cluster failover","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"20、redis 之哨兵工作原理","slug":"Redis/20、redis 之哨兵工作原理","date":"2016-05-20T01:57:38.000Z","updated":"2020-08-07T14:10:11.883Z","comments":true,"path":"2016/05/20/Redis/20、redis 之哨兵工作原理/","link":"","permalink":"https://www.zackaddy.xin/2016/05/20/Redis/20、redis 之哨兵工作原理/","excerpt":"","text":"redis 之哨兵工作原理简介哨兵在进行主从切换过程中经历三个阶段 监控 通知 故障转移 阶段一：监控阶段 定时任务：每个哨兵节点维护了3个定时任务。 定时任务的功能分别如下： 通过向主从节点发送info命令获取最新的主从结构； 通过发布订阅功能获取其他哨兵节点的信息； 通过向其他节点发送ping命令进行心跳检测，判断是否下线。 主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。 阶段二：通知阶段 客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。 需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。 选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。 监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。 阶段三：故障转移故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤： 在从节点中选择新的主节点： 选择的原则： 首先过滤掉不健康的从节点； 然后选择优先级最高的从节点(由slave-priority指定)； 如果优先级无法区分，则选择复制偏移量最大的从节点； 如果仍无法区分，则选择runid最小的从节点。 更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。 将已经下线的主节点设置为新的主节点的从节点，重新上线后，它会成为新的主节点的从节点。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"50、mysql 之游标","slug":"Mysql/50、mysql 之游标","date":"2016-05-19T19:07:38.000Z","updated":"2020-08-07T14:10:11.853Z","comments":true,"path":"2016/05/20/Mysql/50、mysql 之游标/","link":"","permalink":"https://www.zackaddy.xin/2016/05/20/Mysql/50、mysql 之游标/","excerpt":"","text":"mysql 之游标简介要处理存储过程中的结果集，请使用游标。游标允许您迭代查询返回的一组行，并相应地处理每行。MySQL游标为只读，不可滚动和敏感。 只读：无法通过光标更新基础表中的数据。 不可滚动：只能按照SELECT语句确定的顺序获取行。不能以相反的顺序获取行。 此外，不能跳过行或跳转到结果集中的特定行。 敏感：有两种游标：敏感游标和不敏感游标。敏感游标指向实际数据，不敏感游标使用数据的临时副本。敏感游标比一个不敏感的游标执行得更快，因为它不需要临时拷贝数据。但是，对其他连接的数据所做的任何更改都将影响由敏感游标使用的数据，因此，如果不更新敏感游标所使用的数据，则更安全。 MySQL游标是敏感的。 可以在存储过程，存储函数和触发器中使用MySQL游标。 声明游标 游标声明必须在变量声明之后。 如果在变量声明之前声明游标，MySQL将会发出一个错误。游标必须始终与SELECT语句相关联。1DECLARE cursor_name CURSOR FOR SELECT_statement; 打开游标 初始化游标的结果集1OPEN cursor_name; 检索游标 将游标移动到结果集中的下一行1FETCH cursor_name INTO variables 释放游标 停用游标并释放与之关联的内存1CLOSE cursor_name; 示例12345678910111213141516171819202122232425262728BEGIN--定义变量declare testrangeid BIGINT;declare versionid BIGINT; declare done int;--创建游标，并存储数据declare cur_test CURSOR for select id as testrangeid,version_id as versionid from tp_testrange;--游标中的内容执行完后将done设置为1 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done=1; --打开游标open cur_test;--执行循环 posLoop:LOOP--判断是否结束循环 IF done=1 THEN LEAVE posLoop; END IF; --取游标中的值 FETCH cur_test into testrangeid,versionid;--执行更新操作 update tp_data_execute set version_id=versionid where testrange_id = testrangeid; END LOOP posLoop;--释放游标CLOSE cur_test; END","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"19、redis 之哨兵模式","slug":"Redis/19、redis 之哨兵模式","date":"2016-05-19T02:38:44.000Z","updated":"2020-08-07T14:10:11.882Z","comments":true,"path":"2016/05/19/Redis/19、redis 之哨兵模式/","link":"","permalink":"https://www.zackaddy.xin/2016/05/19/Redis/19、redis 之哨兵模式/","excerpt":"","text":"redis 之哨兵模式简介哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的 master并将所有slave连接到新的master。 123456graph LRsentinel1--&gt;mastersentinel2--&gt;mastersentinel3--&gt;mastermaster--&gt;slave1master--&gt;slave2 作用 监控 不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测 通知（提醒） 当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 自动故障转移 断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服 务器地址 ==注意： 哨兵也是一台redis服务器，只是不提供数据服务 通常哨兵配置数量为单数== 配置哨兵1、部署主从节点12345678910111213141516171819#redis-6379.confport 6379daemonize yeslogfile \"6379.log\"dbfilename \"dump-6379.rdb\" #redis-6380.confport 6380daemonize yeslogfile \"6380.log\"dbfilename \"dump-6380.rdb\"slaveof 192.168.92.128 6379 #redis-6381.confport 6381daemonize yeslogfile \"6381.log\"dbfilename \"dump-6381.rdb\"slaveof 192.168.92.128 6379 配置完成后，依次启动主节点和从节点： 123redis-server redis-6379.confredis-server redis-6380.confredis-server redis-6381.conf 2、部署哨兵1234567891011121314151617#sentinel-26379.confport 26379daemonize yeslogfile \"26379.log\"sentinel monitor mymaster 192.168.92.128 6379 2#sentinel-26380.confport 26380daemonize yeslogfile \"26380.log\"sentinel monitor mymaster 192.168.92.128 6379 2#sentinel-26381.confport 26381daemonize yeslogfile \"26381.log\"sentinel monitor mymaster 192.168.92.128 6379 2 配置完成后启动哨兵 123redis-sentinel sentinel-26379.confredis-sentinel sentinel-26380.confredis-sentinel sentinel-26381.conf 配置项 范例 说明 sentinel auth-pass &lt;服务器名称&gt; sentinel auth-pass mymaster 123456 连接服务器口令 sentinel monitor &lt;自定义服务名称&gt; &lt;主机地址&gt; &lt;端口&gt; &lt;哨兵投票通过数&gt; sentinel monitor mymaster 192.168.194.131 6381 2 设置哨兵监听的主服务器信息，最后的参数决定了最终参与选举的服务器 数量 sentinel down-after-milliseconds &lt;服务名称&gt;&lt;毫秒数（整数）&gt; sentinel down-aftermilliseconds mymaster 3000 指定哨兵在监控Redis服务时，判定服务器挂掉的时间周期，默认30秒 （30000），也是主从切换的启动条件之一 sentinel parallel-syncs &lt;服务名称&gt;&lt;服务器数（整数）&gt; sentinel parallel-syncs mymaster 1 指定同时进行主从的slave数量，数值越大，要求网络资源越高，要求约 小，同步时间约长 sentinel failover-timeout &lt;服务名称&gt;&lt;毫秒数（整数）&gt; sentinel failover-timeout mymaster 9000 指定出现故障后，故障切换的最大超时时间，超过该值，认定切换失败， 默认3分钟 sentinel notification-script &lt;服务名称&gt;&lt;脚本路径&gt; * 服务器无法正常联通时，设定的执行脚本，通常调试使用。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"49、mysql 之存储过程的异常处理","slug":"Mysql/49、mysql 之存储过程的异常处理","date":"2016-05-18T22:38:49.000Z","updated":"2020-08-07T14:10:11.853Z","comments":true,"path":"2016/05/19/Mysql/49、mysql 之存储过程的异常处理/","link":"","permalink":"https://www.zackaddy.xin/2016/05/19/Mysql/49、mysql 之存储过程的异常处理/","excerpt":"","text":"mysql 之存储过程的异常处理当存储过程内发生错误时，必须正确处理它，例如继续或退出当前代码块的执行，以及发出有意义的错误消息。 异常定义语法1DECLARE condition_name CONDITION FOR [condition_type]; condition_name：参数表示异常的名称 condition_type：参数表示条件的类型，由SQLSTATE [VALUE] sqlstate_value | mysql_error_code组成示例定义“ERROR 1148(42000)”错误，名称为command_not_allowed。可以有以下两种方法： 方法一：使用sqlstate_value 1DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000'; 方法二：使用mysql_error_code 1DECLARE command_not_allowed CONDITION FOR 1148; 异常处理语法1DECLARE handler_type HANDLER FOR condition_value [,...] sp_statement handler_type：CONTINUE | EXIT | UNDO handler_type为错误处理方式，参数为 3个值之一 CONTINUE表示遇到错误不处理，继续执行 EXIT表示遇到错误时马上退出 UNDO表示遇到错误后撤回之前的操作 MySQL暂不支持回滚操作 condition_value： SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION | mysql_error_code condition_value表示错误类型 SQLSTATE [VALUE] sqlstate_value为包含5个字符的字符串错误值 condition_name表示DECLARE CONDITION定义的错误条件名称 SQLWARNING匹配所有以01开头的SQLSTATE错误代码 NOT FOUND匹配所有以02开头的SQLSTATE错误代码 SQLEXCEPTION匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码 mysql_error_code匹配数值类型错误代码 sp_statement会是一个简单的语句或由一个复合语句在BEGIN和END关键字内。示例 定义duplicate_key异常并处理 12345DECLARE duplicate_key CONDITION FOR 1062; DECLARE CONTINUE HANDLER FOR duplicate_key BEGIN SELECT 'Duplicate key error!'; END; 异常回滚 12345DECLARE EXIT HANDLER FOR SQLEXCEPTIONBEGINROLLBACK;SELECT 'An error has occurred, operation rollbacked and the stored procedure was terminated';END;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"48、mysql 之自定义函数","slug":"Mysql/48、mysql 之自定义函数","date":"2016-05-18T03:48:02.000Z","updated":"2020-08-07T14:10:11.852Z","comments":true,"path":"2016/05/18/Mysql/48、mysql 之自定义函数/","link":"","permalink":"https://www.zackaddy.xin/2016/05/18/Mysql/48、mysql 之自定义函数/","excerpt":"","text":"mysql 之自定义函数 自定义函数不能跨库使用 如果做数据迁移，或许需要将函数改变成存储过程 不支持create、drop等DDL命令 insert、delete、update只能用在临时表上 不支持动态SQL 不支持“不确定”的函数，比如常用的getdate。不确定函数是指输入参数相同，返回结果可能不同的函数 有且仅有1 个返回，适合做处理数据后返回一个结果 函数只有输入参数类型，而且不能带in 函数的单一功能性（针对性）更强 函数可以作为其它sql语句的组成部分来出现 函数不能调用存储过程 自定义函数与存储过程区别 存储过程可以有多个in,out,inout参数，而函数只有输入参数类型，而且不能带in. 存储过程实现的功能要复杂一些；而函数的单一功能性（针对性）更强。 存储过程可以返回多个值；存储函数只能有一个返回值。 存储过程一般独立的来执行；而存储函数可以作为其它sql语句的组成部分来出现。 存储过程可以调用存储函数。函数不能调用存储过程。 语法1234CREATE FUNCTION 函数名(参数 类型,[参数 类型,...])RETURNS 返回类型 RETURN 表达式值-- 注意-- 这种方式不能使用任何SQL语句 12345CREATE FUNCTION 函数(参数 类型,[参数 类型,...])RETURNS 返回类型BEGINEND;-- 如果要在函数体中可以使用更为复杂的语法，比如复合结构/流程控制/任何SQL语句/定义变量等。带复合结构的函数体的自定义函数的 开启写自定义函数功能1set global log_bin_trust_function_creators=1; 创建自定义函数123456789101112DROP FUNCTION IF EXISTS test_fun;DELIMITER //CREATE FUNCTION test_fun(num1 FLOAT,num2 FLOAT) RETURNS floatBEGIN DECLARE SUM FLOAT DEFAULT 0; SET SUM=num1+num2; RETURN SUM;END//DELIMITER ;SELECT test_fun(1,4); 函数的查看12查看函数创建语句：show create function 函数名;查看所有函数：show function status [like 'pattern']; 函数的删除1drop function 函数名; 示例实现两个数相加12345-- 1. 创建函数create function fun_add(a int,b int)returns int return a + b;-- 2. 执行函数select fun_add(1,1); 生成uuid1234CREATE FUNCTION uuid_32() RETURNS CHAR(32)BEGIN RETURN replace(uuid(), '-', '');END; 随机生成字符串123456789101112131415161718192021222324252627# 1. 如果函数存在则先删除函数DROP FUNCTION IF EXISTS rand_str;-- 2. 创建函数CREATE FUNCTION rand_str(str_len SMALLINT) RETURNS VARCHAR(255)BEGIN -- 相当于&#123;' -- 3. 定义一个函数,名称'rand_str' ,参数名 str_len 参数类型 smallint , -- 返回值类型 varchar(255) ，特别 注意下 这里的 是returns 下面的是 return DECLARE rand_str VARCHAR(255) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'; -- 4. 定义循环条件 DECLARE i SMALLINT DEFAULT 0; -- 5. 定义 返回的的变量 DECLARE result_str VARCHAR(255) DEFAULT ''; -- 6. 循环 WHILE i &lt; str_len DO -- 7. 内置函数说明 -- 7.1 rand() : 产生 0-1之间的小数 -- 7.2 rand() :产生 0-1之间的小数,简称种子.rand()*10 产生的数 在 0- 10 之间,不包括10 -- 7.3 substring(str,pos,len): 截取字符串， -- 第一个参数:待截取的字符串，第二个参数:开始的位置(这里有些不同，下标开始位置为1，可以试试下),第三个参数:截取的长度. -- 7.4 floor(val): 生成最近接val的最大整数 -- 7.5 CONCAT 生成连接的字符串 SET result_str = CONCAT(SUBSTR(rand_str, FLOOR(RAND() * LENGTH(rand_str)) + 1, 1), result_str); SET i = i + 1; END WHILE; -- 8.结束语句 -- 9. 返回 结果对象 这里的是 return RETURN result_str;END -- 相当于'&#125;' 随机生成三位名字1234567891011121314151617181920212223DROP FUNCTION IF EXISTS create_name;CREATE FUNCTION create_name() RETURNS varchar(3)BEGIN DECLARE ln VARCHAR(300); DECLARE mn VARCHAR(500); DECLARE fn VARCHAR(500); DECLARE ln_n INT; DECLARE mn_n INT; DECLARE fn_n INT; SET ln = '郑罗宋谢唐韩曹许邓萧冯曾程蔡彭潘袁李王张刘陈杨黄赵周吴徐孙朱马胡郭林何高梁于董余苏叶吕魏蒋田杜丁沈姜范江傅钟卢汪戴崔任陆廖姚方金邱夏谭韦贾邹石熊孟秦阎薛侯雷白龙段郝孔邵史毛常万顾赖武康贺严尹钱施牛洪龚'; SET mn = '庆磊民友玉萍红娥玲芬芳燕彩兰凤洁梅伟刚勇毅俊云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞莉桂娣叶璧才发武丽琳轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德河哲江超浩璐娅琦晶裕华慧巧美婕馨影荔枝思心邦承乐绍功松善厚庆磊民友玉萍红娥玲芬芳燕彩兰凤洁梅秀娟英行时泰盛雄琛钧冠策腾楠榕风航弘峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘'; SET fn = '莉桂娣叶璧才发武丽琳轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德河哲江超浩璐娅琦晶裕华慧巧美婕馨影荔枝思心邦承乐绍功松善厚秀娟伟刚勇毅俊云莲真环雪荣爱妹霞香月莺媛艳瑞凡佳嘉琼勤珍贞英行时泰盛雄琛钧冠策腾楠榕风航弘峰强军平保东文辉力明永健世广志义兴良海山仁波宁贵福生龙元全国胜学祥才发武新利清飞彬富顺信子杰涛昌成康星光天达安岩中茂进林有坚和彪博诚先敬震振壮会思群豪心邦承乐绍功松善厚庆磊民友裕河哲江超浩亮政谦亨奇固之轮翰朗伯宏言若鸣朋斌梁栋维启克伦翔旭鹏泽晨辰士以建家致树炎德行时泰盛雄琛钧冠策腾楠榕风航弘'; SET ln_n = CHAR_LENGTH(ln); SET mn_n = CHAR_LENGTH(mn); SET fn_n = CHAR_LENGTH(fn); RETURN CONCAT(substring(ln, ceil(rand() * ln_n), 1), substring(MN, ceil(rand() * mn_n), 1), substring(fn, ceil(rand() * fn_n), 1));END-- 调用函数SELECT create_name()","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"18、redis 之主从复制常见问题","slug":"Redis/18、redis 之主从复制常见问题","date":"2016-05-17T22:06:26.000Z","updated":"2020-08-07T14:10:11.882Z","comments":true,"path":"2016/05/18/Redis/18、redis 之主从复制常见问题/","link":"","permalink":"https://www.zackaddy.xin/2016/05/18/Redis/18、redis 之主从复制常见问题/","excerpt":"","text":"redis 之主从复制常见问题频繁的全量复制（1） 伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的 全量复制操作 内部优化调整方案： master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave 在master关闭时执行命令 shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中 repl-id repl-offset 通过redis-check-rdb命令可以查看该信息 master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中 master_repl_id = repl master_repl_offset = repl-offset 通过info命令可以查看该信息 作用： 本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master 频繁的全量复制（2） 网络环境不佳，出现网络中断，slave不提供服务 问题原因 复制缓冲区过小，断网后slave的offset越界，触发全量复制 最终结果 slave反复进行全量复制 解决方案 修改复制缓冲区大小 repl-backlog-size 建议设置如下： 测算从master到slave的重连平均时长second 获取master平均每秒产生写命令数据总量write_size_per_second 最优复制缓冲区空间 = 2 * second * write_size_per_second 频繁的网络中断（1） master的CPU占用过高 或 slave频繁断开连接 问题原因 slave每1秒发送REPLCONF ACK命令到master 当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能 master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应 最终结果 master各种资源（输出缓冲区、带宽、连接等）被严重占用 解决方案 通过设置合理的超时时间，确认是否释放slave repl-timeout 该参数定义了超时时间的阈值（默认60秒），超过该值，释放slave 频繁的网络中断（2） slave与master连接断开 问题原因 master发送ping指令频度较低 master设定超时时间较短 ping指令在网络中存在丢包 解决方案 提高ping指令发送的频度 repl-ping-slave-period 超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时 数据不一致 多个slave获取相同数据不同步 问题原因 网络信息不同步，数据发送有延迟 解决方案 优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象 监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问 slave-serve-stale-data yes|no 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"47、mysql 之 Prepare execute deallocate 预处理语句","slug":"Mysql/47、mysql 之 Prepare execute deallocate 预处理语句","date":"2016-05-17T02:17:33.000Z","updated":"2020-08-07T14:10:11.852Z","comments":true,"path":"2016/05/17/Mysql/47、mysql 之 Prepare execute deallocate 预处理语句/","link":"","permalink":"https://www.zackaddy.xin/2016/05/17/Mysql/47、mysql 之 Prepare execute deallocate 预处理语句/","excerpt":"","text":"mysql 之 Prepare execute deallocate 预处理语句简介预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 sql执行大致过程 词法和语义解析； 优化 SQL 语句，制定执行计划； 执行并返回结果； 一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）。 sql预处理绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。 所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 语法123456# 定义预处理语句PREPARE stmt_name FROM preparable_stmt;# 执行预处理语句EXECUTE stmt_name [USING @var_name [, @var_name] ...];# 删除(释放)定义&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name; 注意虽然可能是通过预处理 SQL 的方式一定程度的提高了效率，但是对于优化而言，最优的执行计划不是光靠 SQL 语句的模板化来实现的，往往还是需要通过具体值来预估出成本代价。 stmt_name 作为 preparable_stmt 的接收者，唯一标识，不区分大小写。 preparable_stmt 语句中的 ? 是个占位符，所代表的是一个字符串，不需要将 ? 用引号包含起来。 定义一个已存在的 stmt_name ，原有的将被立即释放，类似于变量的重新赋值。 PREPARE stmt_name 的作用域是session级 通过 max_prepared_stmt_count变量来控制全局最大的存储的预处理语句。show variables like &#39;max_prepared%&#39;; 预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源 利用字符串定义预处理 SQL1234567891011121314151617181920mysql&gt; PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';Query OK, 0 rows affected (0.00 sec)Statement preparedmysql&gt; SET @a = 3;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET @b = 4; Query OK, 0 rows affected (0.00 sec)mysql&gt; EXECUTE stmt1 USING @a, @b;+------------+| hypotenuse |+------------+| 5 |+------------+1 row in set (0.00 sec)mysql&gt; DEALLOCATE PREPARE stmt1; Query OK, 0 rows affected (0.00 sec) 利用变量定义预处理 SQL1234567891011121314151617181920212223mysql&gt; SET @s = 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';Query OK, 0 rows affected (0.00 sec)mysql&gt; PREPARE stmt2 FROM @s;Query OK, 0 rows affected (0.00 sec)Statement preparedmysql&gt; SET @c = 6;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET @d = 8;Query OK, 0 rows affected (0.00 sec)mysql&gt; EXECUTE stmt2 USING @c, @d;+------------+| hypotenuse |+------------+| 10 |+------------+1 row in set (0.00 sec)mysql&gt; DEALLOCATE PREPARE stmt2;Query OK, 0 rows affected (0.00 sec) 解决无法传参问题123456789101112131415161718192021222324mysql&gt; SET @skip = 100; SET @numrows = 3;Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM t1 LIMIT @skip, @numrows;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@skip, @numrows' at line 1mysql&gt; PREPARE stmt3 FROM \"SELECT * FROM t1 LIMIT ?, ?\";Query OK, 0 rows affected (0.00 sec)Statement preparedmysql&gt; EXECUTE stmt3 USING @skip, @numrows;+-----+--------+| a | filler |+-----+--------+| 100 | filler || 101 | filler || 102 | filler |+-----+--------+3 rows in set (0.00 sec)mysql&gt; DEALLOCATE PREPARE stmt3;Query OK, 0 rows affected (0.00 sec) 字符串拼接1234567891011121314151617181920212223mysql&gt; SET @table = 't2';Query OK, 0 rows affected (0.00 sec)mysql&gt; SET @s = CONCAT('SELECT * FROM ', @table);Query OK, 0 rows affected (0.00 sec)mysql&gt; PREPARE stmt4 FROM @s;Query OK, 0 rows affected (0.00 sec)Statement preparedmysql&gt; EXECUTE stmt4;+------+-------+-------+| id | score | grade |+------+-------+-------+| 1 | 99 | A || 2 | 81 | B || 3 | 55 | D || 4 | 69 | C |+------+-------+-------+4 rows in set (0.00 sec)mysql&gt; DROP PREPARE stmt4;Query OK, 0 rows affected (0.00 sec)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"17、redis 之主从复制","slug":"Redis/17、redis 之主从复制","date":"2016-05-16T23:51:39.000Z","updated":"2020-08-07T14:10:11.882Z","comments":true,"path":"2016/05/17/Redis/17、redis 之主从复制/","link":"","permalink":"https://www.zackaddy.xin/2016/05/17/Redis/17、redis 之主从复制/","excerpt":"","text":"redis 之主从复制简介 主从复制即将master中的数据即时、有效的复制到slave中 Master可以拥有多个slave 多个slave可以连接同一个Master外，还可以连接到其他的slave 主从复制不会阻塞Master，在主从复制时，Master可以处理client请求。 提供系统的伸缩性。 123graph LRslave1--&gt;Masterslave2--&gt;Master 单机redis的风险与问题 问题1.机器故障 现象：硬盘故障、系统崩溃 本质：数据丢失，很可能对业务造成灾难性打击 结论：基本上会放弃使用redis 问题2.容量瓶颈 现象：内存不足，从16G升级到64G，从64G升级到128G，无限升级内存 本质：穷，硬件条件跟不上 结论：放弃使用redis 结论 为了避免单点Redis服务器故障，准备多台服务器，互相连通。将数据复制多个副本保存在不同的服 务器上，连接在一起，并保证数据是同步的。即使有其中一台服务器宕机，其他服务器依然可以继续 提供服务，实现Redis的高可用，同时实现数据冗余备份。 主从复制的作用 读写分离：master写、slave读，提高服务器的读写负载能力 负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量 故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 阶段一：主从连接（slave连接master） slave发送指令：slaveof ip port master接收到指令，响应对方 slave保存master的IP与端口 slave根据保存的信息创建连接master的socket slave周期性发送命令：ping master响应pong slave发送指令：auth password master验证授权 slave发送指令：replconf listening-port master保存slave的端口号 方式一：客户端发送命令 1slaveof &lt;masterip&gt; &lt;masterport&gt; 方式二：启动服务器参数 1redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt; 方式三：服务器配置 1slaveof &lt;masterip&gt; &lt;masterport&gt; 主从断开连接 客户端发送命令 slave断开连接后，不会删除已有数据，只是不再接受master发送的数据 1slaveof no one master客户端发送命令设置密码 1requirepass &lt;password&gt; master配置文件设置密码 12config set requirepass &lt;password&gt; config get requirepass slave客户端发送命令设置密码 1auth &lt;password&gt; slave配置文件设置密码 1masterauth &lt;password&gt; slave启动服务器设置密码 1redis-server –a &lt;password&gt; 阶段二：数据同步阶段数据同步阶段master说明 如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行 复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态 1repl-backlog-size 1mb master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区 数据同步阶段slave说明 为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务 1slave-serve-stale-data yes|no 数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送 命令 多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰 slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟 较大，数据一致性变差，应谨慎选择 阶段三：命令传播阶段 当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的 状态，同步的动作称为命令传播 master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 命令传播阶段的部分复制 命令传播阶段出现了断网现象 网络闪断闪连 忽略 短时间网络中断 部分复制 长时间网络中断 全量复制 部分复制的三个核心要素 服务器的运行 id（run id） 主服务器的复制积压缓冲区 主从服务器的复制偏移量 服务器运行ID（runid） 概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id 组成：运行id由40位字符组成，是一个随机的十六进制字符 例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce 作用：运行id被用于在服务器间进行传输，识别身份 如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发 送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid 复制缓冲区内部工作原理 组成 偏移量 字节值 工作原理 通过offset区分不同的slave当前数据传播的差异 master记录已发送的信息对应的offset slave记录已接收的信息对应的offset 复制缓冲区 概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列 由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） 数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 复制偏移量（offset） 概念：一个数字，描述复制缓冲区中的指令字节位置 分类： master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） 数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用 数据同步+命令传播阶段工作流程 如果从服务器以前没有复制过任何主服务器，或者之前执行过SLAVEOF no one命令，那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步； 相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 PSYNC 命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作。 根据情况，接收到PSYNC命令的主服务器会向从服务器返回以下三种回复的其中一种： 如果主服务器返回+FULLRESYNC 回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用；而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量； 如果主服务器返回+CONTINUE回复，那么表示主服务器将与从服务器执行部分重同步操作，主服务器将自己的offset与从服务器的offset相差部分传送给从服务器 如果主服务器返回-ERR回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作。 心跳机制 进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 master心跳： 指令：PING 周期：由repl-ping-slave-period决定，默认10秒 作用：判断slave是否在线 查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 slave心跳： 指令：REPLCONF ACK {offset} 周期：1秒 作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 作用2：判断master是否在线 心跳阶段注意事项 当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 通过向主服务器发送INFO replication命令，在列出的从服务器列表的lag一栏中，我们可以看到相应从服务器最后一次向主服务器发送REPLCONF ACK命令距离现在过了多少秒：1234min-slaves-to-write 2 min-slaves-max-lag 8 slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"16、redis 之 GEO 类型","slug":"Redis/16、redis 之 GEO 类型","date":"2016-05-16T03:15:32.000Z","updated":"2020-08-07T14:10:11.881Z","comments":true,"path":"2016/05/16/Redis/16、redis 之 GEO 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/16/Redis/16、redis 之 GEO 类型/","excerpt":"","text":"redis 之 GEO 类型简介GEO功能在Redis3.2版本提供，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能.geo的数据类型为zset. 基本操作 添加经纬度信息 1234geoadd key longitude latitude member [longitude latitude member ...] geoadd cityGeo 116.405285 39.904989 \"北京\"geoadd cityGeo 121.472644 31.231706 \"上海\" 查找指定key的经纬度信息，可以指定多个key，批量返回 12345geopos key member [member ...] 127.0.0.1:6379&gt; geopos cityGeo 北京1) 1) \"116.40528291463851929\" 2) \"39.9049884229125027\" 计算坐标点距离 可以指定单位，比如米m，千米km，英里mi，英尺ft 123456geodist key member1 member2 [unit]127.0.0.1:6379&gt; geodist cityGeo 北京 上海\"1067597.9668\"127.0.0.1:6379&gt; geodist cityGeo 北京 上海 km\"1067.5980\" 以给定的经纬度为中心，返回键包含的位置元素当中，与中心的距离不超过给定最大距离的而所有位置元素。 WITHDIST：在返回位置元素的同时，将位置元素与中心之间的距离也一并返回。 WITHCOORD：将位置元素的经度和纬度也一并返回。 WITHHASH：以52位有符号整数的形式，返回位置元素经过原始geohash编码的有序集合分值。这个选项主要用于底层应用或者调试，实际中的作用并不大。 ASC：根据中心的位置，按照从近到远的方式返回位置元素 DESC:根据中心的位置，按照从远到近的方式返回位置元素1234567891011121314151617181920212223242526georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"(integer) 2redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST1) 1) \"Palermo\" 2) \"190.4424\"2) 1) \"Catania\" 2) \"56.4413\"redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD1) 1) \"Palermo\" 2) 1) \"13.361389338970184\" 2) \"38.115556395496299\"2) 1) \"Catania\" 2) 1) \"15.087267458438873\" 2) \"37.50266842333162\"redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD1) 1) \"Palermo\" 2) \"190.4424\" 3) 1) \"13.361389338970184\" 2) \"38.115556395496299\"2) 1) \"Catania\" 2) \"56.4413\" 3) 1) \"15.087267458438873\" 2) \"37.50266842333162\"redis&gt; 返回一个或多个位置元素的geohash表示 1234geohash key member [member……]127.0.0.1:6379&gt; geohash cityGeo 北京1) \"wx4g0b7xrt0\" 这个命令和georadius命令一样。 不同的是中心点是由给定的位置元素决定的。 1georadiusbymemeber key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"46、mysql 之存储过程插入100w条测试数据","slug":"Mysql/46、mysql 之存储过程插入100w条测试数据","date":"2016-05-15T19:34:42.000Z","updated":"2020-08-07T14:10:11.852Z","comments":true,"path":"2016/05/16/Mysql/46、mysql 之存储过程插入100w条测试数据/","link":"","permalink":"https://www.zackaddy.xin/2016/05/16/Mysql/46、mysql 之存储过程插入100w条测试数据/","excerpt":"","text":"mysql 之存储过程插入100w条测试数据创建用户表123456789CREATE TABLE user100w_optimizition( id INT NOT NULL AUTO_INCREMENT, first_name VARCHAR(10) NOT NULL, last_name VARCHAR(10) NOT NULL, sex VARCHAR(5) NOT NULL, score INT NOT NULL, copy_id INT NOT NULL, PRIMARY KEY (`id`)); 创建存储过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647DROP PROCEDURE IF EXISTS add_user_optimizition; DELIMITER // create PROCEDURE add_user_optimizition(in num INT) BEGIN DECLARE rowid INT DEFAULT 0; DECLARE firstname CHAR(1); DECLARE name1 CHAR(1); DECLARE name2 CHAR(1); DECLARE lastname VARCHAR(3) DEFAULT ''; DECLARE sex CHAR(1); DECLARE score CHAR(2); SET @exedata = \"\"; WHILE rowid &lt; num DO SET firstname = SUBSTRING('赵钱孙李周吴郑王林杨柳刘孙陈江阮侯邹高彭徐',FLOOR(1+21*RAND()),1); SET name1 = SUBSTRING('一二三四五六七八九十甲乙丙丁静景京晶名明铭敏闵民军君俊骏天田甜兲恬益依成城诚立莉力黎励',ROUND(1+43*RAND()),1); SET name2 = SUBSTRING('一二三四五六七八九十甲乙丙丁静景京晶名明铭敏闵民军君俊骏天田甜兲恬益依成城诚立莉力黎励',ROUND(1+43*RAND()),1); SET sex=FLOOR(0 + (RAND() * 2)); SET score= FLOOR(40 + (RAND() *60)); SET rowid = rowid + 1; IF ROUND(RAND())=0 THEN SET lastname =name1; END IF; IF ROUND(RAND())=1 THEN SET lastname = CONCAT(name1,name2); END IF; IF length(@exedata)&gt;0 THEN SET @exedata = CONCAT(@exedata,','); END IF; SET @exedata=concat(@exedata,\"('\",firstname,\"','\",lastname,\"','\",sex,\"','\",score,\"','\",rowid,\"')\"); IF rowid%1000=0 THEN SET @exesql =concat(\"insert into user100w_optimizition(first_name,last_name,sex,score,copy_id) values \", @exedata); prepare stmt from @exesql; execute stmt; DEALLOCATE prepare stmt; SET @exedata = \"\"; END IF; END WHILE; IF length(@exedata)&gt;0 THEN SET @exesql =concat(\"insert into user100w_optimizition(first_name,last_name,sex,score,copy_id) values \", @exedata); prepare stmt from @exesql; execute stmt; DEALLOCATE prepare stmt; END IF; END //DELIMITER ; 调用存储过程1call add_user_optimizition(1000001);","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"45、mysql 之存储过程","slug":"Mysql/45、mysql 之存储过程","date":"2016-05-15T02:13:26.000Z","updated":"2020-08-07T14:10:11.852Z","comments":true,"path":"2016/05/15/Mysql/45、mysql 之存储过程/","link":"","permalink":"https://www.zackaddy.xin/2016/05/15/Mysql/45、mysql 之存储过程/","excerpt":"","text":"mysql 之存储过程简介SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。 语法1CREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体 优点 增强SQL语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。 作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 参数声明 in：事先set用户变量并设置某个值，存储过程中可以修改，但修改仅作用于存储过程内部。存储过程结束后，返回的还是原来的值。 out：变量传入存储过程为null（可理解为变量原来的值是不能传入存储过程的），但存储过程修改后，变量的修改于存储过程结束后同样有效 inout：可以传入，存储过程中可以修改，修改结果对于存储过程结束后同样有效。 创建存储过程1234567DELIMITER // CREATE PROCEDURE myproc(OUT s int) BEGIN SELECT COUNT(*) INTO s FROM students; END //DELIMITER ; 调用存储过程123#如果传入变量@aSET @a = 0;call procedure_name(@a) 查看存储过程123show procedure status;#查看创建procedure_name存储过程的内容。show create procedure procedure_name; 删除存储过程1drop procedure if exists procedure_name 存储过程为什么用delimiter 默认情况下，mysql的结束标志符delimiter是分号‘;’，输入分号后回车，mysql将会提交命令。在存储过程使用中，默认的结束标志符会与存储过程语句中的分号冲突，导致存储过程语句未执行完就提交，进而就报错了。所以在创建存储过程前，我们一般会声明标志符为其他符号。比如‘$’，当然其他符号也可以。 注意delimiter声明语句后面没有分号‘;’1delimiter // if的使用1234567891011121314151617set @num = 75;delimiter //create procedure p1(in num int)begin declare score char(3); if num &gt;80 then set score = \"优秀\"; elseif num &gt;= 60 then set score = \"及格\"; else set score = \"不及格\"; end if; select score;end//delimiter ;call p1(@num); case when的使用123456789101112131415161718set @num = 75;delimiter //create procedure p2(in num int)begin declare score char(3); case num when \"&gt;80\" then set score = \"优秀\"; when \"&gt;= 60\" then set score = \"及格\"; else set score = \"不及格\"; end case;select score;end//delimiter ;call p2(@num); while循环的使用1234567891011121314151617set @num = 10;delimiter //create procedure p3(n smallint)begin declare i int; declare s float; set s = 0; set i = 0; while i &lt; n do set i = i + 1; set s = s + i; end while; select s;end//delimiter ;call p3(@num); repeat循环的使用 until+条件：结束循环123456789101112131415161718set @n = 10$delimiter //create procedure p4(n smallint)begin declare i int; declare s int; set s = 0; set i = 0; repeat set i = i + 1; set s = s + i; until i = 10 end repeat; select s;end//delimiter ;call p4(@n); loop循环的使用 这里的循环名称‘myloop’可以自定义，leave表示结束循环。1234567891011121314151617181920set @n = 10;delimiter //create procedure p5(n smallint)begin declare i int; declare s int; set s = 0; set i = 0; myloop : loop set i = i + 1; set s = s + i; if i = 10 then leave myloop; end if; end loop myloop; select s;end//delimiter ;call p5(@num);","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"15、redis 之 HyperLogLog 类型","slug":"Redis/15、redis 之 HyperLogLog 类型","date":"2016-05-15T01:28:01.000Z","updated":"2020-08-07T14:10:11.881Z","comments":true,"path":"2016/05/15/Redis/15、redis 之 HyperLogLog 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/15/Redis/15、redis 之 HyperLogLog 类型/","excerpt":"","text":"redis 之 HyperLogLog 类型简介 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据 核心是基数估算算法，最终数值存在一定误差 误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值 耗空间极小，每个hyperloglog key占用了12K的内存用于标记基数 pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大 Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少 基数 基数是数据集去重后元素个数 HyperLogLog 是用来做基数统计的，运用了LogLog的算法 12&#123;1, 3, 5, 7, 5, 7, 8&#125; 基数集： &#123;1, 3, 5 ,7, 8&#125; 基数：5 &#123;1, 1, 1, 1, 1, 7, 1&#125; 基数集： &#123;1,7&#125; 基数：2 基本操作 添加数据 1pfadd key element [element ...] 统计数据 1pfcount key [key ...] 合并数据 1pfmerge destkey sourcekey [sourcekey...]","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"14、redis 之 bitmaps 类型","slug":"Redis/14、redis 之 bitmaps 类型","date":"2016-05-14T02:53:54.000Z","updated":"2020-08-07T14:10:11.881Z","comments":true,"path":"2016/05/14/Redis/14、redis 之 bitmaps 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/14/Redis/14、redis 之 bitmaps 类型/","excerpt":"","text":"redis 之 bitmaps 类型简介 Bitmaps本身不是一种数据结构， 实际上它就是字符串，但是它可以对字符串的位进行操作 Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。 基础操作 获取指定key对应偏移量上的bit值 1getbit key offset 设置指定key对应偏移量上的bit值，value只能是1或0 1setbit key offset value 扩展操作 对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中 and：交 or：并 not：非 xor：异或 1bitop op destKey key1 [key2...] 统计指定key中1的数量 1bitcount key [start end] #start end 为字节","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"44、mysql 之 全局、会话、用户、局部变量","slug":"Mysql/44、mysql 之 全局、会话、用户、局部变量","date":"2016-05-13T19:10:38.000Z","updated":"2020-08-07T14:10:11.851Z","comments":true,"path":"2016/05/14/Mysql/44、mysql 之 全局、会话、用户、局部变量/","link":"","permalink":"https://www.zackaddy.xin/2016/05/14/Mysql/44、mysql 之 全局、会话、用户、局部变量/","excerpt":"","text":"mysql 之 全局、会话、用户、局部变量变量分类 全局变量 作用域为server的整个生命周期。 服务启动时，它将所有全局变量初始化为默认值。 会话变量 作用域仅限于当前连接，即每个连接中的会话变量是独立的。 用户变量 作用域是当前连接 局部变量 只能用在begin/end语句块中，比如存储过程中的begin/end语句块。其作用域仅限于该语句块。 全局变量123456789101112#显示所有的全局变量show global variables;#查询全局变量的值的两种方式show variables like '%sql_warnings%'; #查询变量值的通用方式select @@global.sql_warnings; #使用@@global.的方式#设置全局变量的值的两种方式set sql_warnings=FALSE; #直接设置set global sql_warnings=FALSE; #使用global关键字，设置选定的范围，最好加上globalset @@global.sql_warnings=OFF; #使用@@global.的方式 会话变量1234567891011121314#显示所有的会话变量show session variables; #查询会话变量的值，方式有以下三种。show variables like '%auto_increment_increment%'; #查询变量值的通用方式select @@auto_increment_increment; #使用@@方式查询select @@session.auto_increment_increment; #使用@@session.的方式，类似于java中对象名.变量名 select @@local.auto_increment_increment; #使用@@local.的方式，类似于java中对象名.变量名 #设置会话变量的值,方式有以下三种。set auto_increment_increment=1; #直接设置set session auto_increment_increment=1; #使用session关键字，设置选定的范围set @@session.auto_increment_increment=1; #使用@@session.的方式，类似于java中对象名.变量名set @@local.auto_increment_increment=1; #使用@@local.的方式，类似于java中对象名.变量名 用户变量1234567#变量的赋值方式一：直接赋值，方式有以下两种。set @var1 = 2;set @var2 := 3;#变量的赋值方式二：将查询结果赋值给变量select u_id into @var3 from users where u_name = 'zhangsan';select @var3:=u_id from users where u_name = 'zhangsan'; 局部变量1234567891011BEGIN #Routine body goes here... #变量的定义 declare var2 int(4) default 0; #变量的赋值方式一：直接赋值 set var2 = 2; #变量的赋值方式二：将查询结果赋值给变量 select u_id into var2 from users where u_name = 'zhangsan';END","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"13、redis 之删除策略","slug":"Redis/13、redis 之删除策略","date":"2016-05-12T21:06:44.000Z","updated":"2020-08-07T14:10:11.881Z","comments":true,"path":"2016/05/13/Redis/13、redis 之删除策略/","link":"","permalink":"https://www.zackaddy.xin/2016/05/13/Redis/13、redis 之删除策略/","excerpt":"","text":"redis 之删除策略数据特征 Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态 XX ：具有时效性的数据 -1 ：永久有效的数据 -2 ：已经过期的数据 或 被删除的数据 或 未定义的数据 数据删除策略 定时删除 惰性删除 定期删除 数据删除策略的目标 在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用。 定时删除 创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作 优点：节约内存，到时就删除，快速释放掉不必要的内存占用 缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 总结：用处理器性能换取存储空间 （拿时间换空间） 惰性删除 数据到达过期时间，不做处理。等下次访问该数据时 如果未过期，返回数据 发现已过期，删除，返回不存在 优点：节约CPU性能，发现必须删除的时候才删除 缺点：内存压力很大，出现长期占用内存的数据 总结：用存储空间换取处理器性能（拿时间换空间） 定期删除 Redis启动服务器初始化时，读取配置server.hz的值，默认为10 每秒钟执行server.hz次serverCron()-&gt;databasesCron()-&gt;activeExpireCycle() activeExpireCycle()对每个expires[*]逐一进行检测，每次执行250ms/server.hz 对某个expires[*]检测时，随机挑选W个key检测 如果key超时，删除key 如果一轮中删除的key的数量&gt;W*25%，循环该过程 如果一轮中删除的key的数量≤W25%，检查下一个expires[]，0-15循环 W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值 参数current_db用于记录activeExpireCycle() 进入哪个expires[*] 执行 如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行 周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度 特点1：CPU性能占用设置有峰值，检测频度可自定义设置 特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 总结：周期性抽查存储空间 （随机抽查，重点抽查） 删除策略比对 策略 内存 CPU 方式 定时删除 节约内存，无占用 不分时段占用CPU资源，频度高 拿时间换空间 惰性删除 内存占用严重 延时执行，CPU利用率高 拿空间换时间 定期删除 内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查 逐出算法 Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如 果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据 的策略称为逐出算法。 注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 配置 最大可使用内存 占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。 1maxmemory 每次选取待删除数据的个数 选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 1maxmemory-samples 删除策略 达到最大内存后的，对被挑选出来的数据进行删除的策略 1maxmemory-policy 检测易失数据（可能会过期的数据集server.db[i].expires ） volatile-lru：挑选最近最少使用的数据淘汰 volatile-lfu：挑选最近使用次数最少的数据淘汰 volatile-ttl：挑选将要过期的数据淘汰 volatile-random：任意选择数据淘汰 检测全库数据（所有数据集server.db[i].dict ） allkeys-lru：挑选最近最少使用的数据淘汰 allkeys-lfu：挑选最近使用次数最少的数据淘汰 allkeys-random：任意选择数据淘汰 放弃数据驱逐 no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"43、mysql 之视图","slug":"Mysql/43、mysql 之视图","date":"2016-05-12T18:03:28.000Z","updated":"2020-08-07T14:10:11.851Z","comments":true,"path":"2016/05/13/Mysql/43、mysql 之视图/","link":"","permalink":"https://www.zackaddy.xin/2016/05/13/Mysql/43、mysql 之视图/","excerpt":"","text":"mysql 之视图视图view是基于 SQL 语句的结果集的可视化的表，视图是由查询结果形成的一张虚拟表，视图也包含行和列，就像一个真实的表。使用视图查询可以使查询数据相对安全，通过视图可以隐藏一些敏感字段和数据，从而只对用户暴露安全数据。视图查询也更简单高效，如果某个查询结果出现的非常频繁或经常拿这个查询结果来做子查询，将查询定义成视图可以使查询更加便捷。 视图和表的区别使用方式 | 占用物理空间 视图 | 不占用，仅仅保存的是sql逻辑表 | 占用 视图的好处 sql语句提高重用性，效率高 和表实现了分离，提高了安全性 视图的创建1CREATE VIEW 视图名 AS 查询语句; 视图的增删改查1、查看视图的数据 ★ 12SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name='Partners'; 插入视图的数据 1INSERT INTO my_v4(last_name,department_id) VALUES('虚竹',90); 修改视图的数据 1UPDATE my_v4 SET last_name ='梦姑' WHERE last_name='虚竹'; 删除视图的数据 1DELETE FROM my_v4; 某些视图不能更新包含以下关键字的sql语句： 分组函数 distinct group by having union或者union all 常量视图 Select中包含子查询 join from一个不能更新的视图 where子句的子查询引用了from子句中的表视图逻辑的更新123456789101112#方式一：CREATE OR REPLACE VIEW test_v7ASSELECT last_name FROM employeesWHERE employee_id&gt;100;#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7; 视图的删除1DROP VIEW test_v1,test_v2,test_v3; 视图结构的查看12DESC test_v7;SHOW CREATE VIEW test_v7;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"42、mysql 之事务","slug":"Mysql/42、mysql 之事务","date":"2016-05-12T03:25:03.000Z","updated":"2020-08-07T14:10:11.851Z","comments":true,"path":"2016/05/12/Mysql/42、mysql 之事务/","link":"","permalink":"https://www.zackaddy.xin/2016/05/12/Mysql/42、mysql 之事务/","excerpt":"","text":"mysql 之事务简介 一个”最小的”不可再分的”工作单元”。 一个事务通常对应了一个完整的业务。如：银行的转账功能，a转账给b，a扣钱，b加钱。 一个事务包含一条或多条DML语句(insert,update,delete)。 在一个事务中要么所有的语句都成功执行，要么都失败，即所有的DML语句都成功执行才会修改硬盘数据。 在mysql命令行模式下，事务是自动提交的，每执行一条DML语句都会开启一个事务，执行成功后立即执行commit操作。可以通过”show variables like ‘%commit%’;” 查看事务的是否自动开启。 事务的四个属性 原子性(Atomicity)：指处于同一个事务中的多条语句是不可分割的。 一致性(Consistent)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。比如转账，转账前两个账户余额之和为2k，转账之后也应该是2K。 隔离性(Isolation)：指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰 持久性(Durable)：事务一旦提交，就应该被永久保存起来。可能出现的问题 脏读：指一个线程中的A事务读取到了另外一个线程中B事务未commit的数据， 这时B事务回滚会导致A事务脏读。 不可重复读：A事务在耗时执行过程中，B事务commit了update和delete操作数据，导致A两次读取的数据不一致； 幻读：A事务在耗时执行过程中，B事务commit了insert操作数据，导致A两次读取的数据不一致； 隔离级别 隔离级别 脏读（Dirty Read） 不可重复读（NonRepeatable Read） 幻读（Phantom Read） 未提交读（Read uncommitted） 可能 可能 可能 已提交读（Read committed） 不可能 可能 可能 可重复读（Repeatable read） 不可能 不可能 可能 可串行化（Serializable ） 不可能 不可能 不可能 Read uncommitted：事务A可以读取到事务B未提交的数据，这种隔离级别最低。这种事务会导致”dirty read(脏读)”。因为事务B的数据还没有提交，事务A就可以读取到，那如果事务B在事务A读取后回滚了呢，就导致了事务A读取到的数据是”脏数据”。 Read committed：事务A读取不到事务B未提交的数据，事务B提交后的数据事务A才能读取到。这个事务级别不会导致”dirty read”，但会导致”不可重复读”。假设事务A需要半天，在这期间有很多的其它事务都在修改数据，那么就导致了一个问题，事务A在开启时读到的数据与半天后读到的数据差别很大，那么事务A需要在这半天内读到的数据都是一样的该怎么办，比如每个月底网络运营商系统出账的时候，那肯定得在出账期间读到的数据都必须一样才行。 Repeatable read：事务A读取不到事务B提交后的数据，事务A读取的数据依旧是事务A刚开始时的数据。MySQL的事务默认是这个级别。 Serializable：当多个事务需要执行时，只能排队一个个的来，就是串行化的字面意思了。这种隔离级别最高，但会导致数据库的吞吐量很低一般不用。 设置事务隔离级别123select @@tx_isolationset session transaction isolation level read uncommittedset global transaction isolation level read uncommitted savepoint 搭配ROLLBACK TO使用123456SET autocommit = 0;START TRANSACTION;DELETE FROM account WHERE id = 25; // 被删除了SAVEPOINT a;DELETE FROM account WHERE id = 28; // 没被删除，被回滚了ROLLBACK TO a;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"12、redis 之事务","slug":"Redis/12、redis 之事务","date":"2016-05-12T03:06:49.000Z","updated":"2020-08-07T14:10:11.880Z","comments":true,"path":"2016/05/12/Redis/12、redis 之事务/","link":"","permalink":"https://www.zackaddy.xin/2016/05/12/Redis/12、redis 之事务/","excerpt":"","text":"redis 之事务简介redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性 按照添加顺序依次执行，中间不会被打断或者干扰。 一个队列中，一次性、顺序性、排他性的执行一系列命令 事务基本操作 开启事务 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 1multi 执行事务 设定事务的结束位置，同时执行事务。与multi成对出现，成对使用 1exec 取消事务 终止当前事务的定义，发生在multi之后，exec之前 1discard ==加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行== ==事务中出现错误，已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚== 监视锁场景 用于多个连续操作，保障不会重复操作。 …… 对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行 1watch key1 [key2……] 取消对所有 key 的监视 1unwatch 分布式锁场景 避免最后一件商品超卖 …… 使用 setnx 设置一个公共锁 利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功 1setnx lock-key value 操作完毕通过del操作释放锁 1del lock-key 使用 expire 为锁key添加时间限定，到时不释放，放弃锁 12expire lock-key second pexpire lock-key milliseconds 由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 锁时间设定推荐：最大耗时120%+平均网络延迟110% 如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"41、mysql 之标识列","slug":"Mysql/41、mysql 之标识列","date":"2016-05-11T04:08:33.000Z","updated":"2020-08-07T14:10:11.851Z","comments":true,"path":"2016/05/11/Mysql/41、mysql 之标识列/","link":"","permalink":"https://www.zackaddy.xin/2016/05/11/Mysql/41、mysql 之标识列/","excerpt":"","text":"mysql 之标识列自增长列，可以不用手动的插入值，系统提供默认的序列值 特点 标识列必须和一个Key搭配（Key指主键、唯一、外键….） 一个表最多有一个标识列 标识列的类型只能是数值型 标识列可以通过SET auto_increment_increment = 3;设置步长（全局），可以通过插入行时手动插入标识列值设置起始值。 添加标识列 创建表时设置标识列 1234create table user( id int primary key auto_increment, name varchar(20)); 修改表时设置标识列 1alter table 表名称 modify column id int primary key auto_increment; 修改表时删除标识列 1alter table 表名称 modify column id int primary key;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"11、redis 之持久化","slug":"Redis/11、redis 之持久化","date":"2016-05-11T02:52:49.000Z","updated":"2020-08-07T14:10:11.880Z","comments":true,"path":"2016/05/11/Redis/11、redis 之持久化/","link":"","permalink":"https://www.zackaddy.xin/2016/05/11/Redis/11、redis 之持久化/","excerpt":"","text":"redis 之持久化简介 利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。 防止数据的意外丢失，确保数据安全性 持久化过程保存什么 RDB将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据 AOF将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程 应用场景 场景 是否做持久化 redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 ❌ redis 应用于各种结构型和非结构型高热度数据访问加速 ❌ redis 应用于购物车数据存储设计 ❌ redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 ✔ redis 应用于具有操作先后顺序的数据控制 ✔ redis 应用于最新消息展示 ✔ redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 ❌ redis 应用于基于黑名单与白名单设定的服务控制 ✔ redis 应用于计数器组合排序功能对应的排名 ✔ redis 应用于即时任务/消息队列执行管理 ❌ redis 应用于按次结算的服务控制 ❌ ### RDB #### RDB之save指令 - 手动执行一次保存操作 1save save指令相关配置 dbfilename dump.rdb 说明：设置本地数据库文件名，默认值为 dump.rdb 经验：通常设置为dump-端口号.rdb dir 说明：设置存储.rdb文件的路径 经验：通常设置成存储空间较大的目录中，目录名称data rdbcompression yes 说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 - 经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） rdbchecksum yes 说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 save指令自定执行配置 满足限定时间范围内key的变化数量达到指定数量即进行持久化 在conf文件中进行配置 123save second changessecond：监控时间范围 changes：监控key的变化量 范例 123save 900 1 save 300 10 save 60 10000 RDB之bgsave指令 手动启动后台保存操作，但不是立即执行 1bgsave bgsave指令相关配置 dbfilename dump.rdb dir rdbcompression yes rdbchecksum yes stop-writes-on-bgsave-error yes 说明：后台存储过程中如果出现错误现象，是否停止保存操作 经验：通常默认为开启状态 RDB启动方式对比 方式 save指令 bgsave指令 读写 同步 异步 阻塞客户端指令 是 否 额外内存消耗 否 是 启动新进程 否 是 RDB优点 RDB是一个紧凑压缩的二进制文件，存储效率较高 RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景 RDB恢复数据的速度要比AOF快很多 应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。 RDB缺点 RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据 bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能 Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象 RDB存储的弊端 存储数据量较大，效率较低 基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低 大数据量下的IO性能较低 基于fork创建子进程，内存产生额外消耗 宕机带来的数据丢失风险 解决思路 不写全数据，仅记录部分数据 降低区分数据是否改变的难度，改记录数据为记录操作过程 对所有操作均进行记录，排除丢失数据的风险 AOF AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令 达到恢复数据的目的 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式 AOF写数据三种策略(appendfsync) always(每次） 每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。 everysec（每秒） 每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，建议使用，也是默认配置 在系统突然宕机的情况下丢失1秒内的数据 no（系统控制） 由操作系统控制每次同步到AOF文件的周期，整体过程不可控 AOF功能开启 appendfilename filename AOF持久化文件名，默认文件名未appendonly.aof，建议配置为appendonly-端口号.aof dir AOF持久化文件保存路径，与RDB持久化文件保持一致即可 AOF重写随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重 写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结 果转化成最终结果数据对应的指令进行记录 降低磁盘占用量，提高磁盘利用率 提高持久化效率，降低持久化写时间，提高IO性能 降低数据恢复用时，提高数据恢复效率 AOF重写方式 手动重写 1bgrewriteaof 自动重写 1234567891011自动重写触发条件设置 auto-aof-rewrite-min-size size auto-aof-rewrite-percentage percent 自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） aof_current_size aof_base_size 自动重写触发条件 aof_current_size&gt;auto-aof-rewrite-min-size(aof_current_size-aof_base_size)/aof_base_size&gt;=auto-aof-rewrite-percentage RDB与AOF区别 对数据非常敏感，建议使用默认的AOF持久化方案 AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出 现问题时，最多丢失0-1秒内的数据。 注意：由于AOF文件存储体积较大，且恢复速度较慢 数据呈现阶段有效性，建议使用RDB持久化方案 数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段 点数据恢复通常采用RDB方案 注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重总结： 综合比对 RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF 如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB 灾难恢复选用RDB 双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"40、（重点）mysql 之常见约束","slug":"Mysql/40、（重点）mysql 之常见约束","date":"2016-05-09T22:14:03.000Z","updated":"2020-08-07T14:10:11.850Z","comments":true,"path":"2016/05/10/Mysql/40、（重点）mysql 之常见约束/","link":"","permalink":"https://www.zackaddy.xin/2016/05/10/Mysql/40、（重点）mysql 之常见约束/","excerpt":"","text":"mysql 之常见约束 一种限制，用于限制表中的数据，为了保证表中数据的准确性和可靠性。 六大约束 NOT NULL ：非空，用于保证该字段的值不能为空。例如学生表的学生姓名及学号等等。 DEFAULT：默认值，用于保证该字段有默认值。例如学生表的学生性别 PRIMARY KEY：主键，用于保证该字段的值具有唯一性并且非空。例如学生表的学生学号等。 UNIQUE：唯一，用于保证该字段的值具有唯一性，可以为空。例如注册用户的手机号，身份证号等。 CHECK：检查约束（MySql不支持），检查字段的值是否为指定的值。 FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值，在从表添加外键约束，用于引用主表中某些的值。例如学生表的专业编号 添加约束的时机 创建表时 修改表时 约束的添加分类 约束 位置 支持的约束类型 是否可以起约束名 列级约束 列的后面 六大约束语法上都支持，但外键约束没有效果 不可以 表级约束 所有列的下面 除了非空、默认、其它的都支持 可以（主键没效果） 添加列级约束12345678CREATE TABLE IF NOT EXISTS stuinfo &#123; id INT PRIMARY KEY, #主键 stuName VARCHAR(20) NOT NULL, #非空 gender CHAR(1) CHECK(gender = '男' or name = '女'), #检查 seat INT UNIQUE, #唯一 age INT DEFAULT 18, #默认约束 majorId INT REFERENCES major(id) #列级外键没有效果，但不报错&#125; 添加表级约束12345678910111213CREATE TABLE IF NOT EXISTS stuinfo &#123; id INT, stuName VARCHAR(20), gender CHAR(1), seat INT, age INT, majorId INT, CONSTRAINT pk PRIMARY KEY(id), CONSTRAINT uq UNIQUE(seat), CONSTRAINT ck CHECK(gender = '男' or name = '女'), CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)&#125; 主键和唯一的区别 约束名称 保证唯一性 是否允许为空 一个表中可以有多少个 是否允许组合 主键 √ × 最多有1个，可以没有 √（不推荐） 唯一 √ √ 可以有多个 √（不推荐） 外键 要求在从表中设置外键关系 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求。 主表的关联列必须时一个Key（一般为主键或唯一，外键也可以但无意义） 插入数据时，先插入主表，再插入从表 删除数据时，先删除从表，再删除主表 查看表中的约束12SHOW CREATE TABLE &lt;数据表名&gt;;DESC TABLE 查看表中的外键1SHOW INDEX FROM stuinfo 修改表时添加约束 添加非空约束 1alter table 表名称 modify column 列名 列类型 not null; 添加默认约束 1alter table 表名称 modify column 列名 列类型 default 默认值; 添加主键列级约束方式 1alter table 表名称 modify column 列名 列类型 primary key; 添加主键表级约束方式 1alter table 表名称 add primary key(id); 添加唯一列级约束 1alter table 表名称 modify column 列名 列类型 unique; 添加唯一表级约束 1alter table 表名称 add unique(列名称); 添加外键（列级写法可行，但无效果） 添加外键表级约束 1alter table 表名称 add constraint fk_stuinfo_magor foreign key(magorId) references major(id); 添加列级约束通用写法 1alter table 表名称 modify column 列名 列类型 新约束; 添加表级约束通用写法 1alter table 表名称 add constraint 约束名 约束类型(列名称) [外键的引用]; 修改表时删除约束 删除非空约束 1alter table 表名称 modify column 列名 列类型 [null]; 删除默认约束 1alter table 表名称 modify column 列名 列类型; 删除主键 12alter table 表名称 modify column id int;alter table 表名称 drop primary key; 删除唯一 1alter table 表名称 drop index(索引名) 设置唯一时的名称; 删除外键 1alter table 表名称 drop foreign key(索引名) 设置外键时的名称;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"10、redis 之 sort 排序","slug":"Redis/10、redis 之 sort 排序","date":"2016-05-09T17:51:09.000Z","updated":"2020-08-07T14:10:11.880Z","comments":true,"path":"2016/05/10/Redis/10、redis 之 sort 排序/","link":"","permalink":"https://www.zackaddy.xin/2016/05/10/Redis/10、redis 之 sort 排序/","excerpt":"","text":"redis 之 sort 排序","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"9、redis 之通用指令","slug":"Redis/9、redis 之通用指令","date":"2016-05-09T03:18:58.000Z","updated":"2020-08-07T14:10:11.886Z","comments":true,"path":"2016/05/09/Redis/9、redis 之通用指令/","link":"","permalink":"https://www.zackaddy.xin/2016/05/09/Redis/9、redis 之通用指令/","excerpt":"","text":"redis 之通用指令key通用操作 key是一个字符串，通过key获取redis中保存的数据 key 基本操作 删除指定key 1del key 获取key是否存在 1exists key 获取key的类型 1type key key 扩展操作（时效性控制） 为指定key设置有效期 1234expire key seconds pexpire key milliseconds expireat key timestamp pexpireat key milliseconds-timestamp 获取key的有效时间 12ttl key pttl key 切换key从时效性转换为永久性 1persist key key 扩展操作（查询模式） 查询key 1keys pattern 查询模式规则 123456keys * 查询所有 keys it* 查询所有以it开头 keys *heima 查询所有以heima结尾 keys ??heima 查询所有前面两个字符任意，后面以heima结尾 keys user:? 查询所有以user:开头，最后一个字符任意 keys u[st]er:1 查询所有以u开头，以er:1结尾，中间包含一个字母，s或t key 其他操作 为key改名 12rename key newkey renamenx key newkey 对所有key排序 1sort 其他key通用操作 1help @generic 切换数据库 1select index 其他操作 123quit ping echo message 数据移动 1move key db 数据清除 123dbsize flushdb flushall","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"39、mysql 之日期和时间类型","slug":"Mysql/39、mysql 之日期和时间类型","date":"2016-05-09T01:51:06.000Z","updated":"2020-08-07T14:10:11.850Z","comments":true,"path":"2016/05/09/Mysql/39、mysql 之日期和时间类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/09/Mysql/39、mysql 之日期和时间类型/","excerpt":"","text":"mysql 之日期和时间类型 timestamp 记录经常变化的更新 / 创建 / 发布 / 日志时间 / 购买时间 / 登录时间 / 注册时间等，并且是近来的时间，够用，时区自动处理，比如说做海外购或者业务可能拓展到海外 datetime 记录固定时间如服务器执行计划任务时间 / 健身锻炼计划时间等，在任何时区都是需要一个固定的时间要做某个事情。超出 timestamp 的时间，如果需要时区必须记得时区处理 类型 数据类型 零值 DATE ‘0000-00-00’ TIME ‘00:00:00’ DATETIME ‘0000-00-00 00:00:00’ TIMESTAMP ‘0000-00-00 00:00:00’ YEAR 0000 范围 日期和时间类型 字节 最小值 最大值 date 4 1000-01-01 9999-12-21 datetime 8 1000-01-01 00:00:00 9999-12-31 23:59:59 timestamp 4 19700101080001 2038年的某个时刻 time 3 -838:59:59 838:59:59 year 1 1901 2155 效率 插入一千万行数据 字段 未加索引 有索引 t_timestamp 12.689s 5.909s t_varchar 2.706s 2.042s t_char 3.847s 1.888s t_datetime 3.853s 0.956s t_int 2.073s 0.673s DATE1234567INSERT INTO myset (d1) VALUES (NULL) // NULLINSERT INTO myset (d1) VALUES ('00') // 0000-00-00INSERT INTO myset (d1) VALUES ('0') // 0000-00-00INSERT INTO myset (d1) VALUES (0) // 0000-00-00INSERT INTO myset (d1) VALUES ('') // 0000-00-00INSERT INTO myset (d1) VALUES ('11') // 0000-00-00INSERT INTO myset (d1) VALUES ('11-20') // 0000-00-00 TIME12345678INSERT INTO myset (d2) VALUES ('23:59:59') // 23:59:59INSERT INTO myset (d2) VALUES (NULL) // NULLINSERT INTO myset (d2) VALUES ('00') // 00:00:00INSERT INTO myset (d2) VALUES ('0') // 00:00:00INSERT INTO myset (d2) VALUES (0) // 00:00:00INSERT INTO myset (d2) VALUES ('') // 00:00:00INSERT INTO myset (d2) VALUES (13) // 00:00:13INSERT INTO myset (d2) VALUES ('13') // 00:00:13 存储时间日期类型的选择问题int（对应javaBean中的Integer或int） 占用4个字节 建立索引之后，查询速度快 条件范围搜索可以使用使用between 不能使用mysql提供的时间函数结论：适合需要进行大量时间范围查询的数据表 datetime（javaBean中用Date类型） 占用8个字节 允许为空值，可以自定义值，系统不会自动修改其值。 实际格式储存（Just stores what you have stored and retrieves the same thing which you have stored.） 与时区无关（It has nothing to deal with the TIMEZONE and Conversion.） 不可以设定默认值，所以在不允许为空值的情况下，必须手动指定datetime字段的值才可以成功插入数据。 可以在指定datetime字段的值的时候使用now()变量来自动插入系统的当前时间。结论：datetime类型适合用来记录数据的原始的创建时间，因为无论你怎么更改记录中其他字段的值，datetime字段的值都不会改变，除非你手动更改它。 timestamp（javaBean中用Date或Timestamp类型） 占用4个字节 允许为空值，但是不可以自定义值，所以为空值时没有任何意义。 TIMESTAMP值不能早于1970或晚于2037。这说明一个日期，例如’1968-01-01’，虽然对于DATETIME或DATE值是有效的，但对于TIMESTAMP值却无效，如果分配给这样一个对象将被转换为0。 值以UTC格式保存（ it stores the number of milliseconds） 时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区。 默认值为CURRENT_TIMESTAMP()，其实也就是当前的系统时间。 数据库会自动修改其值，所以在插入记录时不需要指定timestamp字段的名称和timestamp字段的值，你只需要在设计表的时候添加一个timestamp字段即可，插入后该字段的值会自动变为当前系统时间。 以后任何时间修改表中的记录时，对应记录的timestamp值会自动被更新为当前的系统时间。结论：timestamp类型适合用来记录数据的最后修改时间，因为只要你更改了记录中其他字段的值，timestamp字段的值都会被自动更新。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"38、mysql 之 SET 类型","slug":"Mysql/38、mysql 之 SET 类型","date":"2016-05-07T23:48:18.000Z","updated":"2020-08-07T14:10:11.850Z","comments":true,"path":"2016/05/08/Mysql/38、mysql 之 SET 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/08/Mysql/38、mysql 之 SET 类型/","excerpt":"","text":"mysql 之 SET 类型 SET列最多可以有64个不同的成员 一个表在其列ENUM和 SET列中可以有不超过255个独特的元素列表定义 定义中的重复值将导致警告，或者如果启用严格SQL模式，则会发生错误。 SET列为NULL用IS NULL查询 SET列为空字符串用列名 = 0查询 多选字符串数据类型，适合存储表单界面的“多选值”。 1234567891011121314151617mysql&gt; CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));mysql&gt; INSERT INTO myset (col) VALUES -&gt; ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');Query OK, 5 rows affected (0.01 sec)Records: 5 Duplicates: 0 Warnings: 0mysql&gt; SELECT col FROM myset;+------+| col |+------+| a,d || a,d || a,d || a,d || a,d |+------+5 rows in set (0.04 sec) 存取方式 SET成员 十进制值 二进制值 ‘a’ 1 0001 ‘b’ 2 0010 ‘c’ 4 0100 ‘d’ 8 1000 12mysql&gt; SELECT * FROM tbl_name WHERE set_col &amp; 1; // 查询set中存在a的项mysql&gt; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"8、redis 之解决方案","slug":"Redis/8、redis 之解决方案","date":"2016-05-07T22:11:54.000Z","updated":"2020-08-07T14:10:11.886Z","comments":true,"path":"2016/05/08/Redis/8、redis 之解决方案/","link":"","permalink":"https://www.zackaddy.xin/2016/05/08/Redis/8、redis 之解决方案/","excerpt":"","text":"redis 之解决方案 redis 用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 redis 应用于各种结构型和非结构型高热度数据访问加速 redis 应用于购物车数据存储设计 redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计 redis 应用于具有操作先后顺序的数据控制 redis 应用于最新消息展示 redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等 redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索 redis 应用于同类型不重复数据的合并、取交集操作 redis 应用于同类型数据的快速去重 redis 应用于基于黑名单与白名单设定的服务控制 redis 应用于计数器组合排序功能对应的排名 redis 应用于定时任务执行顺序管理或任务过期管理 redis 应用于及时任务/消息队列执行管理 redis 应用于按次结算的服务控制 redis 应用于基于时间顺序的数据操作，而不关注具体时间","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"37、mysql 之 ENUM 类型","slug":"Mysql/37、mysql 之 ENUM 类型","date":"2016-05-07T00:38:53.000Z","updated":"2020-08-07T14:10:11.849Z","comments":true,"path":"2016/05/07/Mysql/37、mysql 之 ENUM 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/07/Mysql/37、mysql 之 ENUM 类型/","excerpt":"","text":"mysql 之 ENUM 类型创建和使用ENUM列 枚举值必须是带引号的字符串 插入非限定字符串视为空字符串 最多可以有65535个不同的元素值（实际限制小于3000）。 枚举值不能是0或空字符串（虽然存在特殊情况） 12345678910111213141516CREATE TABLE shirts ( name VARCHAR(40), size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'), ('polo shirt','small'); SELECT name, size FROM shirts WHERE size = 'medium';SELECT name, size FROM shirts WHERE size = 3+---------+--------+| name | size |+---------+--------+| t-shirt | medium |+---------+--------+UPDATE shirts SET size = 'small' WHERE size = 'large';COMMIT; 如果将一百万行插入到此表中，则值 ‘medium’需要100万字节的存储空间，而如果将实际字符串存储’medium’在 VARCHAR列中，则需要600万字节。 索引查询 列出的元素被分配索引号，从1开始。 指定的列ENUM(‘Mercury’, ‘Venus’, ‘Earth’)，则索引值如下值| 指数–|–NULL| NULL‘’| 0‘Mercury’| 1‘Venus’| 2‘Earth’| 3 创建表时定义枚举列的限制==以下都是不被允许的== 123CREATE TABLE sizes ( size ENUM('small', CONCAT('med','ium'), 'large')); 12345SET @mysize = 'medium';CREATE TABLE sizes ( size ENUM('small', @mysize, 'large'));","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"7、redis 之 sorted_set 类型","slug":"Redis/7、redis 之 sorted_set 类型","date":"2016-05-06T16:29:00.000Z","updated":"2020-08-07T14:10:11.886Z","comments":true,"path":"2016/05/07/Redis/7、redis 之 sorted_set 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/07/Redis/7、redis 之 sorted_set 类型/","excerpt":"","text":"redis 之 sorted_set 类型 新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式 需要的存储结构：新的存储模型，可以保存可排序的数据 sorted_set类型：在set的存储结构基础上添加可排序字段 score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时 候要慎重 sorted_set 底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反 复覆盖，保留最后一次修改的结果 sorted_set 类型数据的基本操作 添加数据 1zadd key score1 member1 [score2 member2] 获取全部数据 12zrange key start stop [WITHSCORES] zrevrange key start stop [WITHSCORES] 删除数据 1zrem key member [member ...] 按条件获取数据 12zrangebyscore key min max [WITHSCORES] [LIMIT] zrevrangebyscore key max min [WITHSCORES] 条件删除数据 12zremrangebyrank key start stop zremrangebyscore key min max 获取集合数据总量 12zcard key zcount key min max 集合交、并操作 12zinterstore destination numkeys key [key ...] zunionstore destination numkeys key [key ...] sorted_set 类型数据的扩展操作 获取数据对应的索引（排名） 12zrank key member zrevrank key member score值获取与修改 12zscore key member zincrby key increment member","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"6、redis 之 set 类型","slug":"Redis/6、redis 之 set 类型","date":"2016-05-05T19:52:27.000Z","updated":"2020-08-07T14:10:11.886Z","comments":true,"path":"2016/05/06/Redis/6、redis 之 set 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/06/Redis/6、redis 之 set 类型/","excerpt":"","text":"redis 之 set 类型 新的存储需求：存储大量的数据，在查询方面提供更高的效率 需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询 set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的 应用场景 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐， 大V推荐等 基于经营战略设定问题用户发现、鉴别规则 周期性更新满足规则的用户黑名单，加入set集合 用户行为信息达到后与黑名单进行比对，确认行为去向 黑名单过滤IP地址：应用于开放游客访问权限的信息源 黑名单过滤设备信息：应用于限定访问设备的信息源 黑名单过滤用户：应用于基于访问权限的信息源 建立set模型，记录不同IP数量（IP） 建立set模型，记录不同cookie数量（UV） set 类型数据的基本操作 添加数据 1sadd key member1 [member2] 获取全部数据 1smembers key 删除数据 1srem key member1 [member2] 获取集合数据总量 1scard key 判断集合中是否包含指定数据 1sismember key member set 类型数据的扩展操作 随机获取集合中指定数量的数据 1srandmember key [count] 移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素 1spop key [count] 求两个集合的交、并、差集 123sinter key1 [key2] sunion key1 [key2] sdiff key1 [key2] 求两个集合的交、并、差集并存储到指定集合中 123sinterstore destination key1 [key2] sunionstore destination key1 [key2] sdiffstore destination key1 [key2] 将指定数据从原始集合中移动到目标集合中 1smove source destination member","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"36、mysql 之 TEXT 类型","slug":"Mysql/36、mysql 之 TEXT 类型","date":"2016-05-05T19:42:52.000Z","updated":"2020-08-07T14:10:11.849Z","comments":true,"path":"2016/05/06/Mysql/36、mysql 之 TEXT 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/06/Mysql/36、mysql 之 TEXT 类型/","excerpt":"","text":"mysql 之 TEXT 类型 MySQL TEXT数据类型是除了CHAR和VARCHAR字符类型，MySQL为我们提供了具有CHAR和VARCHAR无法实现的更多功能的TEXT类型。 TEXT可用于存储可以从1字节到4GB长度的文本字符串。 我们经常在电子商务网站中找到用于在新闻站点存储物品的TEXT数据类型，如：产品详细描述。 与CHAR和VARCHAR不同，您不必在列使用TEXT类型时指定存储长度 当检索或插入文本数据(如CHAR和VARCHAR)时，MySQL不会删除或填充空格。 请注意，TEXT数据不存储在数据库服务器的内存中，因此，每当查询TEXT数据时，MySQL都必须从磁盘读取它，这与CHAR和VARCHAR相比要慢得多。 MySQL提供四种TEXT类型：TINYTEXT，TEXT，MEDIUMTEXT和LONGTEXT。 VARCHAR与TEXT 根据存储的实现： 可以考虑用varchar替代tinytext 如果需要非空的默认值，就必须使用varchar 如果存储的数据大于64K，就必须使用到mediumtext , longtextvarchar(255+)和text在存储机制是一样的 需要特别注意varchar(255)不只是255byte ,实质上有可能占用的更多。 特别注意，varchar大字段一样的会降低性能，所以在设计中还是一个原则大字段要拆出去，主表还是要尽量的瘦小TINYTEXT TINYTEXT可以存储255个字节。 需要少于255个字节的列应该使用TINYTEXT类型，长度不一致，不需要排序 适用博文摘录，文章摘要等。12345CREATE TABLE articles ( id INT AUTO_INCREMENT PRIMARY KEY, title VARCHAR(255), summary TINYTEXT); TEXT TEXT - 64KB(65,535个字符)TEXT数据类型最多可容纳64KB，相当于65535(2 ^ 16 - 1)个字节。 TEXT还需要2字节开销。 适用文章的正文123ALTER TABLE articles ADD COLUMN body TEXT NOT NULLAFTER summary; MEDIUMTEXT MEDIUMTEXT - 16MB(16,777,215个字节)MEDIUMTEXT最多可容纳16MB的文本数据，相当于16,777,215个字字节。 需要3字节开销。MEDIUMTEXT可用于存储相当大的文本数据， 适用书籍文本，白皮书等1234567USE testdb;CREATE TABLE whitepapers ( id INT AUTO_INCREMENT PRIMARY KEY, body MEDIUMTEXT NOT NULL, published_on DATE NOT NULL); LONGTEXT LONGTEXT - 4GB(4,294,967,295个字节)LONGTEXT可以存储高达4GB的文本数据，这是非常巨大的。 它需要4字节开销。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"35、mysql 之二进制类型","slug":"Mysql/35、mysql 之二进制类型","date":"2016-05-04T18:42:29.000Z","updated":"2020-08-07T14:10:11.849Z","comments":true,"path":"2016/05/05/Mysql/35、mysql 之二进制类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/05/Mysql/35、mysql 之二进制类型/","excerpt":"","text":"mysql 之二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 BIT 类型 位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型 BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 1列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节 BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"5、redis 之 list 类型","slug":"Redis/5、redis 之 list 类型","date":"2016-05-04T16:24:36.000Z","updated":"2020-08-07T14:10:11.885Z","comments":true,"path":"2016/05/05/Redis/5、redis 之 list 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/05/Redis/5、redis 之 list 类型/","excerpt":"","text":"redis 之 list 类型 数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 list类型：保存多个数据，底层使用双向链表存储结构实现 list 类型数据基本操作 添加/修改数据 12lpush key value1 [value2] ……rpush key value1 [value2] …… 获取数据 123lrange key start stop lindex key index llen key 获取并移除数据 12lpop keyrpop key list 类型数据扩展操作 规定时间内获取并移除数据 123blpop key1 [key2] timeout brpop key1 [key2] timeout brpoplpush source destination timeout #Redis Brpoplpush 命令从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 移除指定数据 1lrem key count value","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"4、redis 之 hash 类型","slug":"Redis/4、redis 之 hash 类型","date":"2016-05-04T04:44:58.000Z","updated":"2020-08-07T14:10:11.885Z","comments":true,"path":"2016/05/04/Redis/4、redis 之 hash 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/04/Redis/4、redis 之 hash 类型/","excerpt":"","text":"redis 之 hash 类型 新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信 需要的存储结构：一个存储空间保存多个键值对数据 hash类型：底层使用哈希表结构实现数据存储 hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到， 对应的值为（nil） 每个 hash 可以存储 232 - 1 个键值对 hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存 储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用 hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问 瓶颈 hash 类型数据的基本操作 添加/修改数据 1hset key field value 获取数据 12hget key field hgetall key 删除数据 1hdel key field1 [field2] 添加/修改多个数据 1hmset key field1 value1 field2 value2 … 获取多个数据 1hmget key field1 field2 … 获取哈希表中字段的数量 1hlen key 获取哈希表中是否存在指定的字段 1hexists key field hash 类型数据扩展操作 获取哈希表中所有的字段名或字段值 12hkeys key hvals key 设置指定字段的数值数据增加指定范围的值 12hincrby key field increment hincrbyfloat key field increment","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"34、mysql 之 CHAR 和 VARCHAR 类型","slug":"Mysql/34、mysql 之 CHAR 和 VARCHAR 类型","date":"2016-05-04T03:12:27.000Z","updated":"2020-08-07T14:10:11.848Z","comments":true,"path":"2016/05/04/Mysql/34、mysql 之 CHAR 和 VARCHAR 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/04/Mysql/34、mysql 之 CHAR 和 VARCHAR 类型/","excerpt":"","text":"mysql 之 CHAR 和 VARCHAR 类型char类型 char类型：定长，简单粗暴，浪费空间，存取速度快 字符长度范围：0-255（一个中文是一个字符，是utf8编码的3个字节） 存储： 存储char类型的值时，会往右填充空格来满足长度 例如：指定长度为10，存&gt;10个字符则报错，存&lt;10个字符则用空格填充直到凑够10个字符存储 检索： 在检索或者说查询时，查出的结果会自动删除尾部的空格，除非我们打开pad_char_to_full_length SQL模式（SET sql_mode = ‘PAD_CHAR_TO_FULL_LENGTH’;） varchar类型 varchar类型：变长，精准，节省空间，存取速度慢 字符长度范围：0-65535（如果大于21845会提示用其他类型 。mysql行最大限制为65535字节，字符编码为utf-8：https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html） 在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作 存储： varchar类型存储数据的真实内容，不会用空格填充，如果’ab ‘,尾部的空格也会被存起来 强调：varchar类型会在真实数据前加1-2Bytes的前缀，该前缀用来表示真实数据的bytes字节数（1-2Bytes最大表示65535个数字，正好符合mysql对row的最大字节限制，即已经足够使用） 如果真实的数据&lt;255bytes则需要1Bytes的前缀（1Bytes=8bit 2**8最大表示的数字为255） 如果真实的数据&gt;255bytes则需要2Bytes的前缀（2Bytes=16bit 2**16最大表示的数字为65535） 检索： 尾部有空格会保存下来，在检索或者说查询时，也会正常显示包含空格在内的内容 存储表 值 CHAR(4) 需要存储 VARCHAR(4) 需要存储 ‘’ ‘&nbsp;&nbsp;&nbsp;&nbsp;’ 4字节 ‘’ 1个字节 ‘ab’ ‘ab&nbsp;&nbsp;’ 4字节 ‘ab’ 3个字节 ‘abcd’ ‘abcd’ 4字节 ‘abcd’ 5个字节 ‘abcdefgh’ ‘abcd’ 4字节 ‘abcd’ 5个字节 varchar类型适用场景 字符串列的最大长度比平均长度大很多 列的更新很少，所以碎片不是问题 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储char类型适用场景 CHAR适合存储很短的字符串，或者所有值都接近同一个长度 选varchar还是char 该字段数据集的平均长度与最大长度是否相差很小，若相差很小优先考虑CHAR类型，反之，考虑VARCHAR类型。 若字段存储的是MD5后的哈希值，或一些定长的值，优先选取CHAR类型。 若字段经常需要更新，则优先考虑CHAR类型，由于CHAR类型为定长，因此不容易产生碎片。 对于字段值存储很小的信息，如性别等，优先选取CHAR类型，因为VARCHAR类型会占用额外的字节保存字符串长度信息。 当我们能够选取CHAR类型的时候，或者说空间消耗相对并不是影响因素的重点时，尽量选取CHAR类型，因为在其他方面，CHAR类型都有着或多或少的优势。而当空间消耗成为了很大的影响因素以后，我们则考虑使用VARCHAR类型。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"33、mysql 之常见数据类型","slug":"Mysql/33、mysql 之常见数据类型","date":"2016-05-02T21:28:32.000Z","updated":"2020-08-07T14:10:11.848Z","comments":true,"path":"2016/05/03/Mysql/33、mysql 之常见数据类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/03/Mysql/33、mysql 之常见数据类型/","excerpt":"","text":"mysql 之常见数据类型 数值型 整型 小数 定点数 浮点数 字符型 较短的文本：char、varchar 较长的文本：text、blob（较长的二进制数据） 日期型 数据类型文章1234567898、mysql 之整型9、mysql 之 DECIMAL 数字类型10、mysql 之 float double 浮点型34、mysql 之 CHAR 和 VARCHAR 类型35、mysql 之二进制类型36、mysql 之 TEXT 类型37、mysql 之 ENUM 类型38、mysql 之 SET 类型39、mysql 之日期和时间类型","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"3、redis 之 key 的命名规范","slug":"Redis/3、redis 之 key 的命名规范","date":"2016-05-02T16:37:30.000Z","updated":"2020-08-07T14:10:11.885Z","comments":true,"path":"2016/05/03/Redis/3、redis 之 key 的命名规范/","link":"","permalink":"https://www.zackaddy.xin/2016/05/03/Redis/3、redis 之 key 的命名规范/","excerpt":"","text":"redis 之 key 的命名规范 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id 不要包含特殊字符 反例：包含空格、换行、单双引号以及其他转义字符 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视123user:&#123;uid&#125;:friends:message:&#123;mid&#125; 简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125; key 的设置约定 表名 主键名 主键值 字段名 user id 29437753 login_count 1set user:id:29437753:login_count 666","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"2、redis 之 string 类型","slug":"Redis/2、redis 之 string 类型","date":"2016-05-02T00:48:13.000Z","updated":"2020-08-07T14:10:11.885Z","comments":true,"path":"2016/05/02/Redis/2、redis 之 string 类型/","link":"","permalink":"https://www.zackaddy.xin/2016/05/02/Redis/2、redis 之 string 类型/","excerpt":"","text":"redis 之 string 类型 redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储 数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型 存储数据的格式：一个存储空间保存一个数据 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用 string命令 命令 行为 GET 获取存储在给定键中的值 SET 设置存储在给定键中的值 DEL 删除存储在给定键中的值（这个命令可以用于所有类型） 添加/修改数据 1set key value 获取数据 1get key 删除数据 1del key 添加/修改多个数据 1mset key1 value1 key2 value2 … 获取多个数据 1mget key1 key2 … 获取数据字符个数（字符串长度） 1strlen key 追加信息到原始信息后部（如果原始信息存在就追加，否则新建） 1append key value string 作为数值操作 string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。 redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发 带来的数据影响。 注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。9223372036854775807（java中long型数据最大值，Long.MAX_VALUE） redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性 此方案适用于所有数据库，且支持数据库集群 数值操作 设置数值数据增加指定范围的值 123incr key incrby key increment incrbyfloat key increment 设置数值数据减少指定范围的值 12decr key decrby key increment string 类型数据的扩展操作 设置数据具有指定的生命周期12setex key seconds value psetex key milliseconds value","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"32、mysql 之表复制","slug":"Mysql/32、mysql 之表复制","date":"2016-05-01T23:35:58.000Z","updated":"2020-08-07T14:10:11.848Z","comments":true,"path":"2016/05/02/Mysql/32、mysql 之表复制/","link":"","permalink":"https://www.zackaddy.xin/2016/05/02/Mysql/32、mysql 之表复制/","excerpt":"","text":"mysql 之表复制第一种复制表结构1CREATE TABLE newuser LIKE user; 导入数据1INSERT INTO newauser SELECT * FROM user; 第二种1RENAME TABLE `db1`.`user` TO `db1`.`newauser` ; 第三种12CREATE TABLE copy3SELECT * FROM user;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"31、mysql 之表删除","slug":"Mysql/31、mysql 之表删除","date":"2016-04-30T20:03:38.000Z","updated":"2020-08-07T14:10:11.848Z","comments":true,"path":"2016/05/01/Mysql/31、mysql 之表删除/","link":"","permalink":"https://www.zackaddy.xin/2016/05/01/Mysql/31、mysql 之表删除/","excerpt":"","text":"语法1DROP TABLE [IF EXISTS] &lt;表名&gt; [ , &lt;表名1&gt; , &lt;表名2&gt;] … 语法说明如下： &lt;表名&gt;：被删除的表名。DROP TABLE 语句可以同时删除多个表，用户必须拥有该命令的权限。 表被删除时，所有的表数据和表定义会被取消，所以使用本语句要小心。 表被删除时，用户在该表上的权限并不会自动被删除。 参数IF EXISTS用于在删除前判断删除的表是否存在，加上该参数后，在删除表的时候，如果表不存在，SQL 语句可以顺利执行，但会发出警告（warning）。 1DROP TABLE IF EXISTS tb_emp3;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"1、redis 之概述","slug":"Redis/1、redis 之概述","date":"2016-04-30T18:49:23.000Z","updated":"2020-08-07T14:10:11.883Z","comments":true,"path":"2016/05/01/Redis/1、redis 之概述/","link":"","permalink":"https://www.zackaddy.xin/2016/05/01/Redis/1、redis 之概述/","excerpt":"","text":"redis 之概述简介概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。 数据间没有必然的关联关系 内部采用单线程机制进行工作 高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。 多数据类型支持 字符串类型 string 列表类型 list 散列类型 hash 集合类型 set 有序集合类型 sorted_set 持久化支持。可以进行数据灾难恢复 纯内存操作 单线程操作，避免了频繁的上下文切换 采用了非阻塞 I/O 多路复用机制NoSQL即 Not-Only SQL（ 泛指非关系型的数据库），作为关系型数据库的补充。 常见 Nosql 数据库 Redis memcache HBase MongoDB 对比 名称 类型 数据存储选项 查询类型 附加功能 Redis 使用内存存储（in-memory）的非关系数据库 字符串、列表、集合、散列表、有序集合 每种数据类型都有自己的专属命令，另外还有批量操作（ bulkoperation ）和不完全（partial）的事务支持 发布与订阅，主从复制（master/slave replication），持久化，脚本（存储过程，stored procedure） memcached 使用内存存储的键值缓存 键值之间的映射 创建命令、读取命令、更新命令、删除命令以及其他几个命令 为提升性能而设的多线程服务器 MySQL 关系数据库 每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图（view）；支持空间（spatial）和第三方扩展 SELECT 、 INSERT 、UPDATE、DELETE、函数、存储过程 支持 ACID 性质（需要使用 InnoDB），主从复制和主主复制（ master/masterreplication） PostgreSQL 关系数据库 每个数据库可以包含多个表，每个表可以包含多个行；可以处理多个表的视图；支持空间和第三方扩展；支持可定制类型 SELECT、INSERT 、UPDATE、DELETE、内置函数、自定义的存储过程 支持ACID性质，主从复制，由第三方支持的多主复制（multi-master replication） MongoDB 使用硬盘存储（on-disk）的非关系文档存储 每个数据库可以包含多个表，每个表可以包含多个无schema （ schema-less ） 的BSON 文档 创建命令、读取命令、更新命令、删除命令、条件查询命令等 支持map-reduce 操作，主从复制，分片，空间索引（spatial index） 应用 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等 任务队列，如秒杀、抢购、购票排队等 即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等 时效性信息控制，如验证码控制、投票控制等 分布式数据共享，如分布式集群架构中的 session 分离 消息队列 分布式锁 特征 可扩容 可伸缩 大数据量下高性能 灵活的数据模型 高可用 解决方案（电商场景）12345678910111213141516171819graph LRMysql1--&gt;基本数据层Mysql2--&gt;基本数据层Mysql3--&gt;基本数据层Mysql4--&gt;基本数据层Mysql5--&gt;基本数据层Mysql6--&gt;基本数据层基本数据层--&gt;MongoDB集群-文档基本数据层--&gt;Redis集群-缓存基本数据层--&gt;Slor集群-全文检索基本数据层--&gt;FastDFS集群-图片MongoDB集群-文档--&gt;商品评价信息Redis集群-缓存--&gt;热点信息存储Slor集群-全文检索--&gt;搜索关键字及全文检索 FastDFS集群-图片--&gt;商品图片商品评价信息--&gt;对外数据服务热点信息存储--&gt;对外数据服务搜索关键字及全文检索--&gt;对外数据服务商品图片--&gt;对外数据服务 1. 商品基本信息1234graph LR名称--&gt;MySQL等价格--&gt;MySQL等厂商--&gt;MySQL等 2. 商品附加信息1234graph LR描述--&gt;MongoDB等详情--&gt;MongoDB等评论--&gt;MongoDB等 3. 图片信息 分布式文件系统 4. 搜索关键字 ES Lucene solr 5. 热点信息123graph LR高频--&gt;Redis\\memcache\\tair等波段性--&gt;Redis\\memcache\\tair等","categories":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/tags/Redis/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://www.zackaddy.xin/categories/Redis/"}]},{"title":"30、mysql 之表修改","slug":"Mysql/30、mysql 之表修改","date":"2016-04-30T01:26:08.000Z","updated":"2020-08-07T14:10:11.848Z","comments":true,"path":"2016/04/30/Mysql/30、mysql 之表修改/","link":"","permalink":"https://www.zackaddy.xin/2016/04/30/Mysql/30、mysql 之表修改/","excerpt":"","text":"mysql 之表修改语法1ALTER TABLE &lt;表名&gt; [修改选项] 修改选项的语法格式如下： 123456&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;| ALTER COLUMN &lt;列名&gt; &#123; SET DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;| DROP COLUMN &lt;列名&gt;| RENAME TO &lt;新表名&gt; &#125; 添加字段语法1ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]； 新字段名为需要添加的字段的名称； FIRST 为可选参数，其作用是将新添加的字段设置为表的第一个字段； AFTER 为可选参数，其作用是将新添加的字段添加到指定的已存在的字段名的后面。123456789101112131415mysql&gt; ALTER TABLE tb_emp1 -&gt; ADD COLUMN col1 INT FIRST;Query OK, 0 rows affected (0.94 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.00 sec) 修改字段数据类型语法1ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt; 表名指要修改数据类型的字段所在表的名称 字段名指需要修改的字段 数据类型指修改后字段的新数据类型。12345678910111213141516mysql&gt; ALTER TABLE tb_emp1 -&gt; MODIFY name VARCHAR(30);Query OK, 0 rows affected (0.15 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || col2 | int(11) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+6 rows in set (0.00 sec) 删除字段语法1ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;； 字段名指需要从表中删除的字段的名称。12345678910111213141516mysql&gt; ALTER TABLE tb_emp1 -&gt; DROP col2;Query OK, 0 rows affected (0.53 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.00 sec) 修改字段名称语法1ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;； 旧字段名指修改前的字段名； 新字段名指修改后的字段名； 新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。123456789101112131415mysql&gt; ALTER TABLE tb_emp1 -&gt; CHANGE col1 col3 CHAR(30);Query OK, 0 rows affected (0.76 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp1;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| col3 | char(30) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+5 rows in set (0.01 sec) 修改表名语法1ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;； TO 为可选参数，使用与否均不影响结果。123456789mysql&gt; ALTER TABLE tb_emp1 -&gt; RENAME TO tb_emp2;mysql&gt; SHOW TABLES;+--------------------+| Tables_in_test_db |+--------------------+| tb_emp2 |+--------------------+1 rows in set (0.00 sec)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"29、mysql 之修改数据库","slug":"Mysql/29、mysql 之修改数据库","date":"2016-04-28T18:15:59.000Z","updated":"2020-08-07T14:10:11.847Z","comments":true,"path":"2016/04/29/Mysql/29、mysql 之修改数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/29/Mysql/29、mysql 之修改数据库/","excerpt":"","text":"mysql 之修改数据库修改数据库字符集1ALERT DATABASE books CHARACTER SET gbk 修改数据库名MyISAM版 如果所有表都是MyISAM类型的话，可以改文件夹的名字 关闭mysqld 把data目录中的db_name目录重命名为new_db_name 开启mysqld ==以下这些操作都是危险的，所以请在执行操作前，备份你的数据库！！== 手动版12345CREATE DATABASE `db2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;RENAME TABLE `db1`.`admin` TO `db2`.`admin` ;DROP DATABASE `db1` ; shell版12345678910#!/bin/bashmysqlconn=”mysql -u xxxx -pxxxx -S /var/lib/mysql/mysql.sock -h localhost”olddb=”db_name”newdb=”new_db_name”#$mysqlconn -e “CREATE DATABASE $newdb”params=$($mysqlconn -N -e “SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='$olddb'”)for name in $params; do$mysqlconn -e “RENAME TABLE $olddb.$name to $newdb.$name”;done;#$mysqlconn -e “DROP DATABASE $olddb”","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"28、mysql 之 delete 和 truncate 删除语句","slug":"Mysql/28、mysql 之 delete 和 truncate 删除语句","date":"2016-04-27T21:45:24.000Z","updated":"2020-08-07T14:10:11.847Z","comments":true,"path":"2016/04/28/Mysql/28、mysql 之 delete 和 truncate 删除语句/","link":"","permalink":"https://www.zackaddy.xin/2016/04/28/Mysql/28、mysql 之 delete 和 truncate 删除语句/","excerpt":"","text":"mysql 之 delete 和 truncate 删除语句清空表中的所有记录12delete from tablenametruncate table tablename // table是可选的 区别 如果delete不加WHERE子句，那么它和truncate table是一样的， delete可以返回被删除的记录数，而truncate table返回的是0。 如果一个表中有自增字段，使用truncate table和没有WHERE子句的delete删除所有记录后，这个自增字段将起始值恢复成1 自增字段将起始值保持不变只要在delete语句中加上永真的WHERE，如WHERE 1或WHERE true。delete FROM table1 WHERE 1 delete from是一行一行的删除,速度很慢. delete可以通过WHERE语句选择要删除的记录。但执行得速度不快。 truncate table无法删除指定的记录，而且不能返回被删除的记录。但它执行得非常快","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"27、mysql 之 delete 删除语句","slug":"Mysql/27、mysql 之 delete 删除语句","date":"2016-04-26T22:39:54.000Z","updated":"2020-08-07T14:10:11.846Z","comments":true,"path":"2016/04/27/Mysql/27、mysql 之 delete 删除语句/","link":"","permalink":"https://www.zackaddy.xin/2016/04/27/Mysql/27、mysql 之 delete 删除语句/","excerpt":"","text":"mysql 之 delete 删除语句语法使用 DELETE 语句从单个表中删除数据，语法格式为： 1DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句] 语法说明如下： &lt;表名&gt;：指定要删除数据的表名。 ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。 WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。 LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。用于删除表中的行1delete from table_name where some_column=some_value 删除表中所有的数据12delete from table_namedelete * from table_name; 删除整个表1drop table table_name; 删除数据库1drop database database_name; 删除表中的列1alter table table_name drop column column_name; 删除表中的索引1alter table table_name drop index index_name;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"26、mysql 之 update 修改数据","slug":"Mysql/26、mysql 之 update 修改数据","date":"2016-04-25T22:04:11.000Z","updated":"2020-08-07T14:10:11.846Z","comments":true,"path":"2016/04/26/Mysql/26、mysql 之 update 修改数据/","link":"","permalink":"https://www.zackaddy.xin/2016/04/26/Mysql/26、mysql 之 update 修改数据/","excerpt":"","text":"mysql 之 update 修改数据语法123456UPDATE &lt;表名&gt; [inner|left|right join 表2] SET 字段1=值1[,..字段n=值n][WHERE 子句][ORDER BY 子句][LIMIT 子句] 语法说明如下： &lt;表名&gt;：用于指定要更新的表名称。 SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。 WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。 ORDER BY 子句：可选项。用于限定表中的行被修改的次序。 LIMIT 子句：可选项。用于限定被修改的行数。 注意：修改一行数据的多个列值时，SET 子句的每个值用逗号分开即可。 单表更新 修改所有用户密码为666 1UPDATE user SET password = 666 修改id为1的用户密码为666 1UPDATE user SET password = 666 WHERE id = 1 多表更新 更新男孩名为herghost的女朋友号码为6661234UPDATE boys bINNER JOIN girls g ON b.id = g.boyfriend_idSET g.phone = '666'WHERE b.name = 'herghost'","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"25、mysql 之联合查询","slug":"Mysql/25、mysql 之联合查询","date":"2016-04-25T00:16:38.000Z","updated":"2020-08-07T14:10:11.846Z","comments":true,"path":"2016/04/25/Mysql/25、mysql 之联合查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/25/Mysql/25、mysql 之联合查询/","excerpt":"","text":"mysql 之联合查询 要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时 多条查询语句的查询列数是一致的！ 多条查询语句的查询的每一列的类型和顺序可以不一致，但是最好一致！ union关键字默认去重 union all 包含重复项 分离or查询12345SELECT * FROM table WHERE field = ? or field2 = ?SELECT * FROM table WHERE field = ?unionSELECT * FROM table WHERE field2 = ?;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"24、mysql 之分页","slug":"Mysql/24、mysql 之分页","date":"2016-04-24T01:35:44.000Z","updated":"2020-08-07T14:10:11.846Z","comments":true,"path":"2016/04/24/Mysql/24、mysql 之分页/","link":"","permalink":"https://www.zackaddy.xin/2016/04/24/Mysql/24、mysql 之分页/","excerpt":"","text":"mysql 之分页语法12SELECT * FROM table limit [offset,] size;SELECT * FROM table limit (第N行-1) size; // 第N行开始，大小为size limit分页公式 limit分页公式：curPage是当前第几页；pageSize是一页多少条记录 1limit (curPage-1)*pageSize,pageSize 用的地方：sql语句中select * from student limit (curPage-1)*pageSize,pageSize; 总页数公式 总页数公式：totalRecord是总记录数；pageSize是一页分多少条记录 1int totalPageNum = (totalRecord +pageSize - 1) / pageSize; 用的地方：前台UI分页插件显示分页码 查询总条数：totalRecord是总记录数 1SELECT COUNT(*) FROM tablename","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"23、（重点）mysql 之子查询","slug":"Mysql/23、（重点）mysql 之子查询","date":"2016-04-22T17:43:27.000Z","updated":"2020-08-07T14:10:11.845Z","comments":true,"path":"2016/04/23/Mysql/23、（重点）mysql 之子查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/23/Mysql/23、（重点）mysql 之子查询/","excerpt":"","text":"mysql 之子查询 出现在其它语句中的select语句称为子查询或内查询 内部嵌套其它select语句的查询，称为主查询或外查询 1SELECT field FROM table WHERE id in (SELECT field2 FROM table2) 子查询出现的位置 select后面 仅仅支持标量子查询 from后面 支持表子查询 where或having后面 标量子查询 列子查询 行子查询 exists后面 表子查询 标量子查询（结果集为一行一列） 列子查询（结果集为一列多行） 行子查询（结果集为一行多列） 表子查询（结果集为多行多列） 标量查询 结果集为一行一列123456SELECT last_name, job_id, salary FROM employeesWHERE job_id = ( SELECT job_id FROM employees WHERE employee_id = 141) AND salary &gt; ( SELECT salary FROM employees WHERE employee_id = 143) 123456SELECT MIN(salary), department_id FROM employeesGROUP BY department_idHAVING MIN(salary) &gt; ( SELECT MIN(salary) FROM employees WHERE department_id = 50) 列子查询 结果集为一列多行多行操作符操作符|含义 -|–IN/NOT IN|任意一个 IN(1,2,3)ANY|SOME|某一个 ANY(1,2,3) 或 MIN(1,2,3)ALL|所有 ALL(1,2,3) 或 MAX(1,2,3)123456SELECT last_name FROM employeesWHERE department_id IN( SELECT department_id FROM department WHERE location_id IN(1400, 1700)) 行子查询 结果集为一行多列12345SELECT * FROM employeesWHERE (employee_id, salary) = ( SELECT MIN(employee_id), MAX(salary) FROM employees) select后方子查询 仅支持标量子查询12345SELECT d.*, ( SELECT COUNT(*) FROM employees e WHERE e.department_id = d.department_id) FROM department d; from后方子查询 表子查询12345678SELECT ag_dep.*, g.grade_levelFROM ( SELECT AVG(salary) ag, department_id FROM employees GROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal; exists后方子查询1SELECT EXISTS(SELECT NULL)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"22、（重点）mysql 之连接查询","slug":"Mysql/22、（重点）mysql 之连接查询","date":"2016-04-21T16:45:29.000Z","updated":"2020-08-07T14:10:11.845Z","comments":true,"path":"2016/04/22/Mysql/22、（重点）mysql 之连接查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/22/Mysql/22、（重点）mysql 之连接查询/","excerpt":"","text":"mysql 之连接查询连接查询分类 内连接 等值连接 非等值连接 自连接 外连接 左外连接 右外连接 全外连接 交叉连接 mysql 支持内连接+外连接（左外和右外）+交叉连接 等值连接1SELECT field, field2 FROM table, table2 WHERE table.xxx_id = table2.id 非等值连接1SELECT field, field2 FROM table, table2 WHERE table.xxx_id != table2.id 自连接1SELECT t.field, t2.field2 FROM table t, table t2 WHERE t.xxx_id = t2.id inner 等值连接、非等值连接、自连接的另一种语法 article 文章表: aid title content uid 1 文章1 文章1正文内容… 1 2 文章2 文章2正文内容… 1 3 文章3 文章3正文内容… 2 4 文章4 文章4正文内容… 4 user 用户表: uid username email 1 admin admin@5idev.com 2 小明 xiao@163.com 3 Jack jack@gmail.com 查询结果 aid title username 1 文章1 admin 2 文章2 admin 3 文章3 小明 1SELECT article.aid,article.title,user.username FROM article INNER JOIN user ON article.uid = user.uid 外连接 查询一个表有，另一个表没有的记录 查询结果为主表中的所有记录 从表中有匹配的则显示匹配的值 从表中没有匹配的则显示null 左外连接，left join 左边是主表 右外连接，right join 右边是主表 左连接1SELECT article.aid,article.title,user.username FROM article LEFT JOIN user ON article.uid = user.uid aid title username 1 文章1 admin 2 文章2 admin 3 文章3 小明 4 文章4 NULL 右连接1SELECT article.aid,article.title,user.username FROM article RIGHT JOIN user ON article.uid = user.uid aid title username 1 文章1 admin 2 文章2 admin 3 文章3 小明 NULL NULL Jack 交叉连接 总行数为左表行数*右表行数123SELECT field, field2 FROM table, table2SELECT field, field2 FROM table CROSS JOIN table2;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"21、mysql 之 Group By Having分组查询","slug":"Mysql/21、mysql 之 Group By Having分组查询","date":"2016-04-20T18:58:22.000Z","updated":"2020-08-07T14:10:11.845Z","comments":true,"path":"2016/04/21/Mysql/21、mysql 之 Group By Having分组查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/21/Mysql/21、mysql 之 Group By Having分组查询/","excerpt":"","text":"mysql 之 Group By Having分组查询 group by的含义:将查询结果按照1个或多个字段进行分组，字段值相同的为一组 group by可用于单个字段分组，也可用于多个字段分组 12345678910111213141516171819202122select * from employee;+------+------+--------+------+------+-------------+| num | d_id | name | age | sex | homeaddr |+------+------+--------+------+------+-------------+| 1 | 1001 | 张三 | 26 | 男 | beijinghdq || 2 | 1002 | 李四 | 24 | 女 | beijingcpq || 3 | 1003 | 王五 | 25 | 男 | changshaylq || 4 | 1004 | Aric | 15 | 男 | England |+------+------+--------+------+------+-------------+select * from employee group by d_id,sex;select * from employee group by sex;+------+------+--------+------+------+------------+| num | d_id | name | age | sex | homeaddr |+------+------+--------+------+------+------------+| 2 | 1002 | 李四 | 24 | 女 | beijingcpq || 1 | 1001 | 张三 | 26 | 男 | beijinghdq |+------+------+--------+------+------+------------+根据sex字段来分组，sex字段的全部值只有两个('男'和'女')，所以分为了两组当group by单独使用时，只显示出每组的第一条记录所以group by单独使用时的实际意义不大 group by + group_concat() group_concat(字段名)可以作为一个输出字段来使用， 表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合 1234567891011121314151617181920212223select sex from employee group by sex;+------+| sex |+------+| 女 || 男 |+------+select sex,group_concat(name) from employee group by sex;+------+--------------------+| sex | group_concat(name) |+------+--------------------+| 女 | 李四 || 男 | 张三,王五,Aric |+------+--------------------+select sex,group_concat(d_id) from employee group by sex;+------+--------------------+| sex | group_concat(d_id) |+------+--------------------+| 女 | 1002 || 男 | 1001,1003,1004 |+------+--------------------+ group by + 集合函数 通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个”值的集合”做一些操作 12345678910111213141516171819202122232425select sex,group_concat(age) from employee group by sex;+------+-------------------+| sex | group_concat(age) |+------+-------------------+| 女 | 24 || 男 | 26,25,15 |+------+-------------------+分别统计性别为男/女的人年龄平均值select sex,avg(age) from employee group by sex;+------+----------+| sex | avg(age) |+------+----------+| 女 | 24.0000 || 男 | 22.0000 |+------+----------+分别统计性别为男/女的人的个数select sex,count(sex) from employee group by sex;+------+------------+| sex | count(sex) |+------+------------+| 女 | 1 || 男 | 3 |+------+------------+ group by + having having 条件表达式：用来分组查询后指定一些条件来输出查询结果 having作用和where一样，但having只能用于group by123456select sex,count(sex) from employee group by sex having count(sex)&gt;2;+------+------------+| sex | count(sex) |+------+------------+| 男 | 3 |+------+------------+ group by + with rollup with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和 1234567891011121314151617select sex,count(age) from employee group by sex with rollup;+------+------------+| sex | count(age) |+------+------------+| 女 | 1 || 男 | 3 || NULL | 4 |+------+------------+select sex,group_concat(age) from employee group by sex with rollup;+------+-------------------+| sex | group_concat(age) |+------+-------------------+| 女 | 24 || 男 | 26,25,15 || NULL | 24,26,25,15 |+------+-------------------+","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"20、mysql 之日期和时间函数","slug":"Mysql/20、mysql 之日期和时间函数","date":"2016-04-20T00:04:23.000Z","updated":"2020-08-07T14:10:11.845Z","comments":true,"path":"2016/04/20/Mysql/20、mysql 之日期和时间函数/","link":"","permalink":"https://www.zackaddy.xin/2016/04/20/Mysql/20、mysql 之日期和时间函数/","excerpt":"","text":"mysql 之日期和时间函数 名称 描述 ADDDATE() 将时间值（间隔）添加到日期值 ADDTIME() 添加时间 CONVERT_TZ() 从一个时区转换到另一个时区 CURDATE() 返回当前日期 CURRENT_DATE()， CURRENT_DATE 同义词CURDATE（） CURRENT_TIME()， CURRENT_TIME CURTIME（）的同义词 CURRENT_TIMESTAMP()， CURRENT_TIMESTAMP NOW（）的同义词 CURTIME() 返回当前时间 DATE() 提取日期或日期时间表达式的日期部分 DATE_ADD() 将时间值（间隔）添加到日期值 DATE_FORMAT() 格式化指定的日期 DATE_SUB() 从日期中减去一个时间值（间隔） DATEDIFF() 减去两个日期 DAY() DAYOFMONTH（）的同义词 DAYNAME() 返回星期几的名字 DAYOFMONTH() 返回月份的一天（0-31） DAYOFWEEK() 返回参数的周日指数 DAYOFYEAR() 返回今年的一天（1-366） EXTRACT() 提取日期的一部分 FROM_DAYS() 将日期编号转换为日期 FROM_UNIXTIME() 将Unix时间戳格式化为日期 GET_FORMAT() 返回日期格式字符串 HOUR() 提取小时 LAST_DAY 返回参数的月份的最后一天 LOCALTIME()， LOCALTIME NOW（）的同义词 LOCALTIMESTAMP， LOCALTIMESTAMP() NOW（）的同义词 MAKEDATE() 从年份和日期创建一个日期 MAKETIME() 从小时，分钟，秒创建时间 MICROSECOND() 从参数中返回微秒 MINUTE() 从参数中返回一分钟 MONTH() 从过去的日期中返回月份 MONTHNAME() 返回月份的名称 NOW() 返回当前日期和时间 PERIOD_ADD() 添加期间到一个年份 PERIOD_DIFF() 返回期间之间的月数 QUARTER() 从日期参数中返回季度 SEC_TO_TIME() 将秒转换为“HH：MM：SS”格式 SECOND() 返回第二个（0-59） STR_TO_DATE() 将字符串转换为日期 SUBDATE() 用三个参数调用DATE_SUB（）的同义词 SUBTIME() 减去时间 SYSDATE() 返回函数执行的时间 TIME() 提取传递的表达式的时间部分 TIME_FORMAT() 格式为时间 TIME_TO_SEC() 返回转换为秒的参数 TIMEDIFF() 减去时间 TIMESTAMP() 使用单个参数，该函数返回日期或日期时间表达式; 有两个论点，即论据的总和 TIMESTAMPADD() 将时间间隔添加到日期时间表达式中 TIMESTAMPDIFF() 从日期时间表达式中减去一个时间间隔 TO_DAYS() 返回转换为天的日期参数 TO_SECONDS() 返回自Year 0以来转换为秒数的日期或日期时间参数 UNIX_TIMESTAMP() 返回一个Unix时间戳 UTC_DATE() 返回当前的UTC日期 UTC_TIME() 返回当前UTC时间 UTC_TIMESTAMP() 返回当前的UTC日期和时间 WEEK() 返回周数 WEEKDAY() 返回周日指数 WEEKOFYEAR() 返回日期的日历周（1-53） YEAR() 归还年份 YEARWEEK() 返回一年和一周 FROM_UNIXTIME 时间戳转日期字符串12SELECT FROM_UNIXTIME('1579001518') // 2020-01-14 19:31:58select FROM_UNIXTIME(1545711900,'%Y-%m-%d %T') // 2018-12-25 12:25:00 DATE_FORMAT 符 描述 %a 简称周日名（Sun.. Sat） %b 简称月名（Jan.. Dec） %c 月，数字（0.. 12） %D 这个月的一天，英语后缀（0th， 1st，2nd， 3rd，…） %d 数字（00.. 31） %e 数字（0.. 31） %f 微秒（000000.. 999999） %H 小时（00.. 23） %h 小时（01.. 12） %I 小时（01.. 12） %i 分钟，数字（00.. 59） %j 一年中的某一天（001.. 366） %k 小时（0.. 23） %l 小时（1.. 12） %M 月份名称（January.. December） %m 月，数字（00.. 12） %p AM 要么 PM %r 时间，12小时（hh:mm:ss后面 AM还是PM） %S 秒（00.. 59） %s 秒（00.. 59） %T 时间，24小时（hh:mm:ss） %U 周（00.. 53），星期日是一周中的第一天; WEEK()模式0 %u 星期（00.. 53），星期一是星期的第一天; WEEK()模式1 %V 周（01.. 53），星期日是一周中的第一天; WEEK()模式2; 使用%X %v 星期（01.. 53），星期一是星期的第一天; WEEK()模式3; 使用%x %W 平日名称（Sunday.. Saturday） %w 星期几（0星期日.. 6=星期六） %X 星期日是一周中的第一天的星期几，数字，四位数; 使用%V %x 星期几，星期一是一周中的第一天，数字，四位数; 使用%v %Y 年份，数字，四位数字 %y 年份，数字（两位数字） %% 一个文字%字符 %x x，对于上面没有列出的任何 “ x” 1234567891011121314mysql&gt; SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y'); -&gt; 'Sunday October 2009'mysql&gt; SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s'); -&gt; '22:23:00'mysql&gt; SELECT DATE_FORMAT('1900-10-04 22:23:00', -&gt; '%D %y %a %d %m %b %j'); -&gt; '4th 00 Thu 04 10 Oct 277'mysql&gt; SELECT DATE_FORMAT('1997-10-04 22:23:00', -&gt; '%H %k %I %r %T %S %w'); -&gt; '22 22 10 10:23:00 PM 22:23:00 00 6'mysql&gt; SELECT DATE_FORMAT('1999-01-01', '%X %V'); -&gt; '1998 52'mysql&gt; SELECT DATE_FORMAT('2006-06-00', '%d'); -&gt; '00' NOW 当前日期时间1SELECT NOW(); // 2020-01-14 19:36:34 UNIX_TIMESTAMP 日期转时间戳1select UNIX_TIMESTAMP('2018-12-25 12:25:00'); // 1545711900","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"19、mysql 之数字函数和操作符","slug":"Mysql/19、mysql 之数字函数和操作符","date":"2016-04-18T23:01:20.000Z","updated":"2020-08-07T14:10:11.844Z","comments":true,"path":"2016/04/19/Mysql/19、mysql 之数字函数和操作符/","link":"","permalink":"https://www.zackaddy.xin/2016/04/19/Mysql/19、mysql 之数字函数和操作符/","excerpt":"","text":"mysql 之数字函数和操作符 名称 描述 ABS() 返回绝对值 ACOS() 返回反余弦 ASIN() 返回反正弦 ATAN() 返回反正切 ATAN2()， ATAN() 返回两个参数的反正切 CEIL() 返回不小于参数的最小整数值 CEILING() 返回不小于参数的最小整数值 CONV() 在不同的数字之间转换数字 COS() 返回余弦 COT() 返回余切 CRC32() 计算循环冗余校验值 DEGREES() 将弧度转换为度数 DIV 整数划分 / 司运营商 EXP() 提高到力量 FLOOR() 返回不大于参数的最大整数值 LN() 返回参数的自然对数 LOG() 返回第一个参数的自然对数 LOG10() 返回参数的基数为10的对数 LOG2() 返回参数的基数为2的对数 - 减号操作员 MOD() 返回剩余部分 %， MOD 模运算符 PI() 返回pi的值 + 加法运算符 POW() 将所提出的论点归还给指定的权力 POWER() 将所提出的论点归还给指定的权力 RADIANS() 返回参数转换为弧度 RAND() 返回一个随机的浮点值 ROUND() 围绕论点 SIGN() 返回参数的符号 SIN() 返回参数的正弦 SQRT() 返回参数的平方根 TAN() 返回参数的正切值 * 乘法运算符 TRUNCATE() 截断到指定的小数位数 - 改变参数的符号 加减乘除与取模12345678SELECT 3+5;SELECT 3-5;SELECT - 2;SELECT 3*5;SELECT 3/5;SELECT 5 DIV 2, -5 DIV 2, 5 DIV -2, -5 DIV -2;SELECT 5 MOD 2;SELECT 5 % 2; ABS(X) 返回x的绝对值12mysql&gt; SELECT ABS(-2); -&gt; 2","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"18、mysql 之字符串函数","slug":"Mysql/18、mysql 之字符串函数","date":"2016-04-17T19:17:47.000Z","updated":"2020-08-07T14:10:11.844Z","comments":true,"path":"2016/04/18/Mysql/18、mysql 之字符串函数/","link":"","permalink":"https://www.zackaddy.xin/2016/04/18/Mysql/18、mysql 之字符串函数/","excerpt":"","text":"mysql 之字符串函数 函数 功能 ASCII() 返回最左边字符的数值 BIN() 返回一个包含数字二进制表示的字符串 BIT_LENGTH() 以位为单位返回参数的长度 CHAR() 返回传递的每个整数的字符 CHAR_LENGTH() 返回字符串的字符个数 CHARACTER_LENGTH() CHAR_LENGTH（）的同义词 CONCAT() 将多个字符串首尾相连然后返回 CONCAT_WS() 将多个字符串与连接符首尾相连然后返回 ELT() 在索引号处返回字符串 EXPORT_SET() 返回一个字符串，使得对于值位中设置的每一位，您都会得到一个字符串，并且对于每个未设置的位，您都会得到一个字符串 FIELD() 第一个字符串与后面几个字符串比较，返回相等字符串的位置， 都不想等则返回0 FIND_IN_SET() 返回第二个参数中第一个参数的索引位置 FORMAT() 返回格式化为指定小数位数的数字 FROM_BASE64() 解码为一个基64字符串并返回结果 HEX() 十进制数字转化为十六进制字符串，如果为字符串则转化为ascii码再转化成十六进制 INSERT() 在指定位置插入一个子字符串，直到指定的字符数 INSTR() 返回子字符串在字符串中第一次出现的索引 LCASE() LOWER（）的同义词 LEFT() 返回最左边指定长度的字符 LENGTH() 返回字符串存储长度 LIKE 简单的模式匹配 LOAD_FILE() 加载指定的文件 LOCATE() 返回第一个出现的子串的位置 LOWER() 将字符串全部转换成小写 LPAD() 在字符串左边填充指定的字符串到指定的长度 LTRIM() 去掉字符串左侧的空格 MAKE_SET() 返回一组逗号分隔的字符串，它们具有相应的位设置 MATCH 执行全文搜索 MID() 从指定的位置开始返回一个子串 NOT LIKE 否定简单的模式匹配 NOT REGEXP 否定REGEXP OCT() 返回一个包含数字的八进制表示的字符串 OCTET_LENGTH() LENGTH（）的同义词 ORD() 返回参数最左边字符的字符代码 POSITION() Synonym for LOCATE() QUOTE() Escape the argument for use in an SQL statement REGEXP Whether string matches regular expression REPEAT() 将字符串重复N次后返回 REPLACE(str,from_str,to_str) 在字符串str中查找from_str并用to_str替换返回 REVERSE(str) 反转字符串中的字符 RIGHT() Return the specified rightmost number of characters RLIKE Synonym for REGEXP RPAD() Append string the specified number of times RTRIM() Remove trailing spaces SOUNDEX() Return a soundex string SOUNDS LIKE Compare sounds SPACE() 返回由N个空格构成的字符串 STRCMP() 如果两个字符串是一样的返回0，第一个小于第二个返回-1，否则返回1 SUBSTR(str, pos[,len]) 指定位置截取字符串 SUBSTRING(str,pos,len) 截取指定位置len长度的字符串 SUBSTRING_INDEX() Return a substring from a string before the specified number of occurrences of the delimiter TO_BASE64() 转成base64字符串 TRIM() 删除字符串前后空格 UCASE() UPPER（）的同义词 UNHEX() 十六进制转为字符 UPPER() 将字符串全部转换为大写 WEIGHT_STRING() 返回字符串的权重字符串 ASCII ASCII(str) 返回第一个字符的ascii码 空字符串则返回0 NULL返回NULL12345678910mysql&gt; SELECT ASCII('2'); -&gt; 50mysql&gt; SELECT ASCII(2); -&gt; 50mysql&gt; SELECT ASCII('dx'); -&gt; 100mysql&gt; SELECT ASCII(''); -&gt; 0mysql&gt; SELECT ASCII(NULL); -&gt; NULL BIN BIN(N) 返回数字的二进制 NULL返回NULL 字母返回0 空字符串返回NULL 输入字符串会被试图转换成整型12mysql&gt; SELECT BIN('3'); -&gt; '11' BIT_LENGTH BIT_LENGTH(str) 字符串有多少bit位 NULL返回NULL 空字符串返回0 输入整型会被试图转换成字符串12mysql&gt; SELECT BIT_LENGTH('text'); -&gt; 32 CHAR CHAR(N,... [USING charset_name]) 将ascii码转成字符 CHAR内如果为小数则按四舍五入， 如果是字符串小数则不按四舍五入123456mysql&gt; select char(77,121,83,81,'76'),char(77,77.3,'77.3');+-------------------------+----------------------+| char(77,121,83,81,'76') | char(77,77.3,'77.3') |+-------------------------+----------------------+| MySQL | MMM |+-------------------------+----------------------+ 默认情况下，函数返回二进制字符串，若想返回针对特定字符集的字符串，使用using选项 123456mysql&gt; SELECT charset(char(0x65)), charset(char(0x65 USING utf8));+---------------------+--------------------------------+| charset(char(0x65)) | charset(char(0x65 USING utf8)) |+---------------------+--------------------------------+| binary | utf8 |+---------------------+--------------------------------+","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"17、mysql 之 binary 区分大小写","slug":"Mysql/17、mysql 之 binary 区分大小写","date":"2016-04-17T00:59:17.000Z","updated":"2020-08-07T14:10:11.844Z","comments":true,"path":"2016/04/17/Mysql/17、mysql 之 binary 区分大小写/","link":"","permalink":"https://www.zackaddy.xin/2016/04/17/Mysql/17、mysql 之 binary 区分大小写/","excerpt":"","text":"mysql 之 binary 区分大小写sql语句中区分大小写1SELECT * FROM table WHERE binary name = 'zhangSan'; 更改my.ini区分大小写 mysqld节下加入下面一行 set-variable=lower_case_table_names=0 （0：大小写敏感；1：大小写不敏感）建表时加以标识123create table table_name( a varchar (20) binary)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"16、mysql 之控制流程函数","slug":"Mysql/16、mysql 之控制流程函数","date":"2016-04-15T16:30:29.000Z","updated":"2020-08-07T14:10:11.843Z","comments":true,"path":"2016/04/16/Mysql/16、mysql 之控制流程函数/","link":"","permalink":"https://www.zackaddy.xin/2016/04/16/Mysql/16、mysql 之控制流程函数/","excerpt":"","text":"mysql 之控制流程函数CASE CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END 选择id字段，当id为100显示yes，否则no123456SELECT id, CASE id WHEN 100 THEN 'yes' ELSE 'no'END AS result FROM table; IF IF(expr1,expr2,expr3) 如果expr1是TRUE,返回expr2,否则返回expr3123456mysql&gt; SELECT IF(1&gt;2,2,3); -&gt; 3mysql&gt; SELECT IF(1&lt;2,'yes','no'); -&gt; 'yes'mysql&gt; SELECT IF(STRCMP('test','test1'),'no','yes'); -&gt; 'no' IFNULL IFNULL(expr1,expr2) expr1不是 NULL,返回 expr1,否则返回 expr212345678mysql&gt; SELECT IFNULL(1,0); -&gt; 1mysql&gt; SELECT IFNULL(NULL,10); -&gt; 10mysql&gt; SELECT IFNULL(1/0,10); -&gt; 10mysql&gt; SELECT IFNULL(1/0,'yes'); -&gt; 'yes' NULLIF NULLIF(expr1,expr2) 如果expr1 = expr2 成立，那么返回值为NULL，否则返回值为expr11234mysql&gt; SELECT NULLIF(1,1); -&gt; NULLmysql&gt; SELECT NULLIF(1,2); -&gt; 1","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"15、mysql 之逻辑运算符","slug":"Mysql/15、mysql 之逻辑运算符","date":"2016-04-15T03:22:10.000Z","updated":"2020-08-07T14:10:11.843Z","comments":true,"path":"2016/04/15/Mysql/15、mysql 之逻辑运算符/","link":"","permalink":"https://www.zackaddy.xin/2016/04/15/Mysql/15、mysql 之逻辑运算符/","excerpt":"","text":"mysql 之逻辑运算符 名称 描述 AND， &amp;&amp; 逻辑与 NOT， ! 否定价值 ||， OR 逻辑或 XOR 逻辑XOR IS12345678910mysql&gt; SELECT 10 IS TRUE;-&gt; 1mysql&gt; SELECT -10 IS TRUE;-&gt; 1mysql&gt; SELECT 'string' IS NOT NULL;-&gt; 1mysql&gt; SELECT NULL IS NULL;-&gt; 1mysql&gt; SELECT NULL IS UNKNOWN;-&gt; 1 NOT， !12345678910mysql&gt; SELECT NOT 10; -&gt; 0mysql&gt; SELECT NOT 0; -&gt; 1mysql&gt; SELECT NOT NULL; -&gt; NULLmysql&gt; SELECT ! (1+1); -&gt; 0mysql&gt; SELECT ! 1+1; -&gt; 1 AND， &amp;&amp;12345678910mysql&gt; SELECT 1 AND 1; -&gt; 1mysql&gt; SELECT 1 AND 0; -&gt; 0mysql&gt; SELECT 1 AND NULL; -&gt; NULLmysql&gt; SELECT 0 AND NULL; -&gt; 0mysql&gt; SELECT NULL AND 0; -&gt; 0 OR， ||12345678910mysql&gt; SELECT 1 OR 1; -&gt; 1mysql&gt; SELECT 1 OR 0; -&gt; 1mysql&gt; SELECT 0 OR 0; -&gt; 0mysql&gt; SELECT 0 OR NULL; -&gt; NULLmysql&gt; SELECT 1 OR NULL; -&gt; 1 XOR12345678mysql&gt; SELECT 1 XOR 1; -&gt; 0mysql&gt; SELECT 1 XOR 0; -&gt; 1mysql&gt; SELECT 1 XOR NULL; -&gt; NULLmysql&gt; SELECT 1 XOR 1 XOR 1; -&gt; 1","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"14、mysql 之 order by 排序查询","slug":"Mysql/14、mysql 之 order by 排序查询","date":"2016-04-14T01:54:58.000Z","updated":"2020-08-07T14:10:11.843Z","comments":true,"path":"2016/04/14/Mysql/14、mysql 之 order by 排序查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/14/Mysql/14、mysql 之 order by 排序查询/","excerpt":"","text":"mysql 之 order by 排序查询order by SELECT field1, field2,...fieldN FROM table_name1, table_name2... ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 根据某个字段或多个字段从左往右依次排序 ASC 正序 从小到大 DESC 倒序 从大到小 order by 后面可以放单个字段、多个字段、表达式、函数、别名1SELECT * FROM table ORDER BY id DESC; 多列排序1SELECT ename,sal,deptno FROM emp ORDER BY sal,deptno DESC 使用多列进行排序时，左边的列的排序优先级高于右侧，如示例：先对sal进行升序，若sal相同，则按照deptno进行降序；若sal没有重复，不会对deptno排序。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"13、mysql 之比较函数和操作符","slug":"Mysql/13、mysql 之比较函数和操作符","date":"2016-04-12T22:35:10.000Z","updated":"2020-08-07T14:10:11.843Z","comments":true,"path":"2016/04/13/Mysql/13、mysql 之比较函数和操作符/","link":"","permalink":"https://www.zackaddy.xin/2016/04/13/Mysql/13、mysql 之比较函数和操作符/","excerpt":"","text":"mysql 之比较函数和操作符BETWEEN … AND … expr BETWEEN min AND max 检查一个值是否在一个范围内 选取 uid 在 2 到 5 之间的用户数据 1SELECT * FROM user WHERE uid BETWEEN 2 AND 5 选择出所有 username 介于 a 至 j 之间的用户（并包括单字母k/K）： 1SELECT * FROM user WHERE username BETWEEN 'a' AND 'k' BETWEEN AND 常用于检索时间或日期段内的内容 123456789101112// int 时间戳格式，查询 2008-08-08 20:00:00 到 2009-01-01 零点之前的数据SELECT * FROM table WHERE column_time BETWEEN 1218196800 AND 1230739199 // DATE 格式，查询 2008-08-08 到 2009-01-01 零点之前的数据SELECT * FROM table WHERE column_time BETWEEN '2008-08-08' AND '2009-01-01' // DATETIME 格式，查询 2008-08-08 20:00:00 到 2009-01-01 零点之前的数据SELECT * FROM table WHERE column_time BETWEEN '2008-08-08 20:00:00' AND '2008-12-31 23:59:59'但对于查询到当前时间的数据，建议使用 &gt;= 运算符：// DATETIME 格式，查询 2008-08-08 20:00:00 到当前时刻的数据SELECT * FROM table WHERE column_time &gt;= '2008-08-08 20:00:00' COALESCE COALESCE(value,...) 返回参数中的第一个非空表达式（从左向右依次类推）1234567select coalesce(null,2,3); // Return 2select coalesce(null,null,3); // Return 3select coalesce(null,null,null); // Return NULLselect coalesce(1,2,3); // Return 1 GREATEST GREATEST(value1,value2,...) 返回参数列表中最大值，如果参数列表中存在NULL，则返回NULL12345678mysql&gt; SELECT GREATEST(2,0); -&gt; 2mysql&gt; SELECT GREATEST(34.0,3.0,5.0,767.0); -&gt; 767.0mysql&gt; SELECT GREATEST('B','A','C'); -&gt; 'C'mysql&gt; SELECT GREATEST('B',NULL,'C'); -&gt; NULL LEAST LEAST(value1,value2,...) 参数中存在NULL则返回NULL 返回最小值参数12345678mysql&gt; SELECT LEAST(2,0); -&gt; 0mysql&gt; SELECT LEAST(34.0,3.0,5.0,767.0); -&gt; 3.0mysql&gt; SELECT LEAST('B','A','C'); -&gt; 'A'mysql&gt; SELECT LEAST('B','A',NULL); -&gt; NULL IN expr IN (value,...) 查询某个范围内的数据 查询到返回1 未查询到返回0 存在NULL且未查询到返回NULL12345678910111213select * from where field in (value1,value2,value3,…)SELECT * FROM article WHERE uid IN(SELECT uid FROM user WHERE status=0)SELECT 2 IN (1,22, 3); // Return 0SELECT 2 IN (1,2, 3); // Return 1SELECT 2 IN (1,NULL, 3); // Return NULLSELECT 2 NOT IN (1,2, NULL); // Return 0SELECT 2 NOT IN (1,3); // Return 1SELECT 2 NOT IN (1,3,NULL); // Return NULLSELECT 2 NOT IN (1,NULL,2); // Return 0SELECT 2 NOT IN (1,NULL,3); // Return NULL ISNULL ISNULL(expr) 如果expr是 NULL，则 ISNULL()返回 1，否则返回 0123456mysql&gt; SELECT ISNULL(1+1); -&gt; 0mysql&gt; SELECT ISNULL(1/0); -&gt; 1mysql&gt; SELECT ISNULL(NULL); -&gt; 1 INTERVAL INTERVAL(N,N1,N2,N3,……….) 返回比N大的参数位置123SELECT INTERVAL(6,NULL); // Return 1SELECT INTERVAL(6,NULL); // Return 1SELECT INTERVAL(6,1,2,3,4,5,NULL,6,85,8,9,NULL); // Return 7","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"104、Go语言 之定时任务","slug":"Golang/104、Go语言 之定时任务","date":"2016-04-12T19:06:08.000Z","updated":"2020-08-07T14:10:11.742Z","comments":true,"path":"2016/04/13/Golang/104、Go语言 之定时任务/","link":"","permalink":"https://www.zackaddy.xin/2016/04/13/Golang/104、Go语言 之定时任务/","excerpt":"","text":"定时任务格式 字段名 是否必须 允许的值 允许的特定字符 秒(Seconds) 是 0-59 * / , - 分(Minute) 是 0-59 * / , - 时(Hours) 是 0-23 * / , - 日(Day of month) 是 1-31 * / , - ? 月(Month) 是 1-12 或 JAN-DEC * / , - 星期(Day of week) 是 0-6 或 SUM-SAT * / , - ? 特殊字符说明星号（*）星号表示cron表达式将匹配该字段的所有值，比如，在上面表达式’月’中使用星号，就表示每个月 斜线（/）斜杠用于描述范围的增量，比如’3-59/15’这个表达式在表示从现在的第三分钟开始和往后的每15分钟，到第59分钟为止。表现形式为”* \\ / …”，等同于”N-MAX / m”，即在该字段范围内的增量。即从N开始，使用增量 m 直到 MAX 结束，它没有重复 逗号（,）逗号用于分隔列表中的项，比如，在上表的’星期几’中使用 “MON,WED,FRI” 表示星期一、星期三和星期五 连字符 (-)连字符用于定义范围。例如，9-17表示包括上午9点至下午5点在内的每小时 问好 (?)表示不指定值，可以来代替 “*” 预定义的表达式 输入 描述 等式 @yearly (or @annually) 每年1月1日午夜跑步一次 0 0 0 1 1 * @monthly 每个月第一天的午夜跑一次 0 0 0 1 * * @weekly 每周周六的午夜运行一次 0 0 0 * * 0 @daily (or @midnight) 每天午夜跑一次 0 0 0 * * * @hourly 每小时运行一次 0 0 * * * * 成员方法1234567891011121314151617181920212223// 将 job 加入 Cron 中// 如上所述，该方法只是简单的通过 FuncJob 类型强制转换 cmd，然后调用 AddJob 方法func (c *Cron) AddFunc(spec string, cmd func()) error// 将 job 加入 Cron 中// 通过 Parse 函数解析 cron 表达式 spec 的到调度器实例(Schedule)，之后调用 c.Schedule 方法func (c *Cron) AddJob(spec string, cmd Job) error// 获取当前 Cron 总所有 Entities 的快照func (c *Cron) Entries() []*Entry// 通过两个参数实例化一个 Entity，然后加入当前 Cron 中// 注意：如果当前 Cron 未运行，则直接将该 entity 加入 Cron 中；// 否则，通过 add 这个成员 channel 将 entity 加入正在运行的 Cron 中func (c *Cron) Schedule(schedule Schedule, cmd Job)// 新启动一个 goroutine 运行当前 Cronfunc (c *Cron) Start()// 通过给 stop 成员发送一个 struct&#123;&#125;&#123;&#125; 来停止当前 Cron，同时将 running 置为 false// 从这里知道，stop 只是通知 Cron 停止，因此往 channel 发一个值即可，而不关心值是多少// 所以，成员 stop 定义为空 structfunc (c *Cron) Stop() 示例示例一123456789101112131415161718192021222324package mainimport ( \"fmt\" \"time\" \"github.com/robfig/cron\")func main() &#123; c := cron.New() c.AddFunc(\"*/1 * * * * *\", func() &#123; fmt.Println(\"every 1 seconds executing\") &#125;) c.Start() defer c.Stop() select &#123; case &lt;-time.After(time.Second * 10): return &#125;&#125; 示例二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\" \"log\" \"github.com/robfig/cron\")type TestJob struct &#123;&#125;func (t TestJob) Run() &#123; fmt.Println(\"testJob1...\")&#125;type Test2Job struct &#123;&#125;func (t Test2Job) Run() &#123; fmt.Println(\"testJob2...\")&#125;//启动多个任务func main() &#123; i := 0 c := cron.New() //AddFunc spec := \"*/5 * * * * ?\" c.AddFunc(spec, func() &#123; i++ log.Println(\"cron running:\", i) &#125;) //AddJob方法 c.AddJob(spec, TestJob&#123;&#125;) c.AddJob(spec, Test2Job&#123;&#125;) //启动计划任务 c.Start() //关闭着计划任务, 但是不能关闭已经在执行中的任务. defer c.Stop() select &#123;&#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"12、mysql 之安全等于判断NULL","slug":"Mysql/12、mysql 之安全等于判断NULL","date":"2016-04-11T23:12:01.000Z","updated":"2020-08-07T14:10:11.842Z","comments":true,"path":"2016/04/12/Mysql/12、mysql 之安全等于判断NULL/","link":"","permalink":"https://www.zackaddy.xin/2016/04/12/Mysql/12、mysql 之安全等于判断NULL/","excerpt":"","text":"mysql 之安全等于 普通等号=不能判断null，这时可以使用is null、is not null判断null值，除此之外还可以用安全等于&lt;=&gt;判断null值 &lt;=&gt;还可以判断数值如：12345678910111213SELECT*FROMemployeesWHEREcommission_pct &lt;=&gt;NULL;SELECT*FROMemployeesWHEREcommission_pct &lt;=&gt; '8888';","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"103、Go语言 之GoWeb","slug":"Golang/103、Go语言 之GoWeb","date":"2016-04-11T19:06:08.000Z","updated":"2020-08-07T14:10:11.742Z","comments":true,"path":"2016/04/12/Golang/103、Go语言 之GoWeb/","link":"","permalink":"https://www.zackaddy.xin/2016/04/12/Golang/103、Go语言 之GoWeb/","excerpt":"","text":"Go语言 之GoWeb创建http服务器1234567891011121314151617package mainimport ( \"fmt\" \"net/http\")func handler(w http.ResponseWriter, r *http.Request) &#123; _, _ = fmt.Fprintln(w, r.URL.Path) _, _ = fmt.Fprintln(w, r.URL.RawQuery) _, _ = fmt.Fprintln(w, r.Header)&#125;func main() &#123; http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8080\", nil)&#125; 获取请求体内容123456789101112131415161718package mainimport ( \"fmt\" \"net/http\")func handler(w http.ResponseWriter, r *http.Request) &#123; l := r.ContentLength body := make([]byte, l) _, _ = r.Body.Read(body) _, _ = fmt.Fprintln(w, body)&#125;func main() &#123; http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8080\", nil)&#125; 获取请求参数12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"net/http\")func handler(w http.ResponseWriter, r *http.Request) &#123; queryForm, err := url.ParseQuery(r.URL.RawQuery) if err == nil &amp;&amp; len(queryForm[\"id\"]) &gt; 0 &#123; fmt.Fprintln(w, queryForm[\"id\"][0]) &#125; r.FormValue(\"user\") // url中的参数 r.PostFormValue(\"user\") // form表单中的请求参数值 r.ParseForm() fmt.Fprintln(w, r.Form) fmt.Fprintln(w, r.PostForm)&#125;func main() &#123; http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8080\", nil)&#125; 响应json12345678910111213141516171819202122package mainimport ( \"encoding/json\" \"net/http\")type student struct &#123; Name string Age int&#125;func handler(w http.ResponseWriter, r *http.Request) &#123; w.Header().Set(\"Content-Type\", \"application/json\") bContent, _ := json.Marshal(&amp;student&#123;\"herghost000\", 62&#125;) _, _ = w.Write(bContent)&#125;func main() &#123; http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8080\", nil)&#125; 响应模板1234567891011121314151617181920package mainimport ( \"fmt\" \"html/template\" \"net/http\")func handler(w http.ResponseWriter, r *http.Request) &#123; t, err := template.ParseFiles(\"tpl/index.html\") if err != nil &#123; fmt.Println(err) &#125; _ = t.Execute(w, \"hello world!\") // index.html内使用&#123;&#123;.&#125;&#125;显示hello world!&#125;func main() &#123; http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8082\", nil)&#125; 处理静态资源文件123456789101112131415package mainimport ( \"fmt\" \"net/http\")func handler(w http.ResponseWriter, r *http.Request) &#123; _, _ = fmt.Fprintln(w, \"hello world!\", r.URL.Path)&#125;func main() &#123; http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.Dir(\"static\")))) http.HandleFunc(\"/\", handler) _ = http.ListenAndServe(\":8080\", nil)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"102、Go语言 之操作Redis","slug":"Golang/102、Go语言 之操作Redis","date":"2016-04-10T19:06:08.000Z","updated":"2020-08-07T14:10:11.741Z","comments":true,"path":"2016/04/11/Golang/102、Go语言 之操作Redis/","link":"","permalink":"https://www.zackaddy.xin/2016/04/11/Golang/102、Go语言 之操作Redis/","excerpt":"","text":"Go语言 之操作Redis","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"11、mysql 之 SELECT 基本查询","slug":"Mysql/11、mysql 之 SELECT 基本查询","date":"2016-04-10T17:13:24.000Z","updated":"2020-08-07T14:10:11.842Z","comments":true,"path":"2016/04/11/Mysql/11、mysql 之 SELECT 基本查询/","link":"","permalink":"https://www.zackaddy.xin/2016/04/11/Mysql/11、mysql 之 SELECT 基本查询/","excerpt":"","text":"mysql 之 SELECT 基本查询查询123SELECT field FROM table; // 单列查询SELECT field,field2,field3 FROM table; // 多列查询SELECT * FROM table; // 全部查询 起别名1SELECT field AS a, field2 AS b FROM table; // 起别名查询 去除重复行去除重复行是个非常少实用的操作, 关键字是DISTINCT: 12SELECT DISTINCT field FROM table; SELECT DISTINCT field, field2 FROM table 需要注意的是: DISTINCT需要放在所有的列名之前, 也就是SELECT 之后. DISTINCT其实是对后面所有列名的组合进行去除, 并不是对某一列进行去重. 这也是为什么DISTINCT要放在所有的列名之前的原因. 排序检索数据12SELECT * FROM table ORDER BY field DESC ;SQL：SELECT *FROM table ORDER BY field, field2 DESC; SELECT的执行顺序123SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...FROM &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT 的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT 连接查询1SELECT CONCAT(field, field2) FROM table; 过滤查询12345678910111213141516select * from product where name is null;/* 表格中年龄为23的数据 */select * from t_students where age = 23 ;/* 表格中名字为杨敏豪的数据，字符串和日期要用单引号括起来 */select * from t_students where name = '杨敏豪' ;/* 列名的别名不能用于where子句 */select name as mingzi from t_students where name != 'Mh' ;/* AND */select * from product where saleprice&gt;=300 AND saleprice&lt;=400;/* OR */select * from product where saleprice=300 OR saleprice=400;/* NOT */select * from product where NOT saleprice=300 ; 范围查询1234/* 用between-and语句选择范围 */select * from product where saleprice between 300 and 400;select * from product where NOT saleprice between 300 and 400;/*取反*/ 集合查询123in，列的值是否存在于集合中，用于批量删除select * from product where id in (2,4); 模糊查询like，查询条件可包含文字或数字 【 % 】：可以表示零或任意多个字符 【 _ 】：可表示一个字符12345/* 值以罗技M结尾的 */select * from product where name like '%罗技M';/* 值以罗技M开头的 */select * from product where name like '罗技M%'; 分页查询123第一页：SELECT * FROM `test1`.`t_students` LIMIT 0,2第二页：SELECT * FROM `test1`.`t_students` LIMIT 2,2第三页：SELECT * FROM `test1`.`t_students` LIMIT 4,2","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"10、mysql 之 float double 浮点型","slug":"Mysql/10、mysql 之 float double 浮点型","date":"2016-04-09T22:53:53.000Z","updated":"2020-08-07T14:10:11.841Z","comments":true,"path":"2016/04/10/Mysql/10、mysql 之 float double 浮点型/","link":"","permalink":"https://www.zackaddy.xin/2016/04/10/Mysql/10、mysql 之 float double 浮点型/","excerpt":"","text":"mysql 之 float double 浮点型 FLOAT 和 DOUBLE 类型表示近似值。 MySQL 对单精度值使用四个字节，双精度值使用八个字节。 对于 FLOAT，SQL 规范允许在 FLOAT 后面通过括号中的关键字来指定精度（不是指数的范围）。 MySQL 也支持这个精度规范，但精度值仅用于确定存储大小。精度从 0 到 23 表示一个 4 字节的单精度 FLOAT 列，从 24 到 53 表示 8 字节双精度 DOUBLE 列。 MySQL 允许非标准语法：FLOAT（M，D）或 REAL（M，D）或DOUBLE PRECISION（M，D）。（M，D）表示总共可以存储最多 M 位数的值，其中 小数点后可以存 D 位数。 例如，定义为 FLOAT（7,4） 的列在显示时将显示为 -999.9999 。 MySQL 在存储值时执行四舍五入，因此，如果将 999.00009 插入到 FLOAT（7,4） 列中，则近似结果为999.0001。 因为浮点值是近似值而不是作为精确值存储，所以将其精确处理可能会导致一些问题。它们也受平台或实现依赖性的约束。有关更多信息，请参见 第B.5.4.8节“Problems with Floating-Point Values” 为了保证可移植性，在存储近似值时应使用 FLOAT 或 DOUBLE PRECISION，最好不要指定精度或数字位数。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"101、Go语言 之操作数据库","slug":"Golang/101、Go语言 之操作数据库","date":"2016-04-09T19:06:08.000Z","updated":"2020-08-07T14:10:11.741Z","comments":true,"path":"2016/04/10/Golang/101、Go语言 之操作数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/10/Golang/101、Go语言 之操作数据库/","excerpt":"","text":"Go语言 之操作数据库Go操作Mysql数据库使用Go操作MySQL等数据库，一般有两种方式： 一是使用database/sql接口，直接在代码里硬编码sql语句； 二是使用gorm，即对象关系映射的方式在代码里抽象的操作数据库 一般推荐使用第二种方式。 使用database/sql接口Go没有内置的驱动支持任何数据库，但是Go定义了database/sql接口，用户可以基于驱动接口开发相应数据库的驱动。但缺点是，直接用 github.com/go-sql-driver/mysql 访问数据库都是直接写 sql，取出结果然后自己拼成对象，使用上面不是很方便，可读性也不好。 连接到数据库我们以mysql为例，使用 github.com/go-sql-driver/mysql ，首先我们需要导入我们需要的包 1234import ( \"database/sql\" _ \"github.com/go-sql-driver/mysql\") 注意我们导入github.com/go-sql-driver/mysql 前面用了一个”_”,操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数,import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，我只初始化里面的 init函数和一些变量，但是往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的包，在 init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。 我们创建一张user表，并执行CRUD操作（增、删、改、查）。 代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\" \"time\")//数据库连接信息const ( USERNAME = \"root\" PASSWORD = \"123456\" NETWORK = \"tcp\" SERVER = \"127.0.0.1\" PORT = 3306 DATABASE = \"test\")//user表结构体定义type User struct &#123; Id int `json:\"id\" form:\"id\"` Username string `json:\"username\" form:\"username\"` Password string `json:\"password\" form:\"password\"` Status int `json:\"status\" form:\"status\"` // 0 正常状态， 1删除 Createtime int64 `json:\"createtime\" form:\"createtime\"`&#125;func main() &#123; conn := fmt.Sprintf(\"%s:%s@%s(%s:%d)/%s\",USERNAME, PASSWORD, NETWORK, SERVER, PORT, DATABASE) DB, err := sql.Open(\"mysql\", conn) if err != nil &#123; fmt.Println(\"connection to mysql failed:\", err) return &#125; DB.SetConnMaxLifetime(100*time.Second) //最大连接周期，超时的连接就close DB.SetMaxOpenConns(100) //设置最大连接数 CreateTable(DB) InsertData(DB) QueryOne(DB) QueryMulti(DB) UpdateData(DB) DeleteData(DB)&#125;func CreateTable(DB *sql.DB) &#123; sql := `CREATE TABLE IF NOT EXISTS users( id INT(4) PRIMARY KEY AUTO_INCREMENT NOT NULL, username VARCHAR(64), password VARCHAR(64), status INT(4), createtime INT(10) ); ` if _, err := DB.Exec(sql); err != nil &#123; fmt.Println(\"create table failed:\", err) return &#125; fmt.Println(\"create table successd\")&#125;//插入数据func InsertData(DB *sql.DB) &#123; result,err := DB.Exec(\"insert INTO users(username,password) values(?,?)\",\"test\",\"123456\") if err != nil&#123; fmt.Printf(\"Insert data failed,err:%v\", err) return &#125; lastInsertID,err := result.LastInsertId() //获取插入数据的自增ID if err != nil &#123; fmt.Printf(\"Get insert id failed,err:%v\", err) return &#125; fmt.Println(\"Insert data id:\", lastInsertID) rowsaffected,err := result.RowsAffected() //通过RowsAffected获取受影响的行数 if err != nil &#123; fmt.Printf(\"Get RowsAffected failed,err:%v\",err) return &#125; fmt.Println(\"Affected rows:\", rowsaffected)&#125;//查询单行func QueryOne(DB *sql.DB) &#123; user := new(User) //用new()函数初始化一个结构体对象 row := DB.QueryRow(\"select id,username,password from users where id=?\", 1) //row.scan中的字段必须是按照数据库存入字段的顺序，否则报错 if err := row.Scan(&amp;user.Id,&amp;user.Username,&amp;user.Password); err != nil &#123; fmt.Printf(\"scan failed, err:%v\\n\", err) return &#125; fmt.Println(\"Single row data:\", *user)&#125;//查询多行func QueryMulti(DB *sql.DB) &#123; user := new(User) rows, err := DB.Query(\"select id,username,password from users where id = ?\", 2) defer func() &#123; if rows != nil &#123; rows.Close() //关闭掉未scan的sql连接 &#125; &#125;() if err != nil &#123; fmt.Printf(\"Query failed,err:%v\\n\", err) return &#125; for rows.Next() &#123; err = rows.Scan(&amp;user.Id, &amp;user.Username, &amp;user.Password) //不scan会导致连接不释放 if err != nil &#123; fmt.Printf(\"Scan failed,err:%v\\n\", err) return &#125; fmt.Println(\"scan successd:\", *user) &#125;&#125;//更新数据func UpdateData(DB *sql.DB)&#123; result,err := DB.Exec(\"UPDATE users set password=? where id=?\",\"111111\",1) if err != nil&#123; fmt.Printf(\"Insert failed,err:%v\\n\", err) return &#125; fmt.Println(\"update data successd:\", result) rowsaffected,err := result.RowsAffected() if err != nil &#123; fmt.Printf(\"Get RowsAffected failed,err:%v\\n\",err) return &#125; fmt.Println(\"Affected rows:\", rowsaffected)&#125;//删除数据func DeleteData(DB *sql.DB)&#123; result,err := DB.Exec(\"delete from users where id=?\",1) if err != nil&#123; fmt.Printf(\"Insert failed,err:%v\\n\",err) return &#125; fmt.Println(\"delete data successd:\", result) rowsaffected,err := result.RowsAffected() if err != nil &#123; fmt.Printf(\"Get RowsAffected failed,err:%v\\n\",err) return &#125; fmt.Println(\"Affected rows:\", rowsaffected)&#125; 执行程序，输出结果如下所示： 12345678create table successdInsert data id: 1Affected rows: 1Single row data: &#123;1 test 123456 0 0&#125;update data successd: &#123;0xc0000a0000 0xc000010280&#125;Affected rows: 1delete data successd: &#123;0xc0000a0000 0xc0000102b0&#125;Affected rows: 1 OK，到这里大家是不是觉得这种实现方式很繁琐，假如要修改某个sql语句需要在代码中修改，这样很麻烦，代码设计也比较糟糕。因此这种方式并不推荐使用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"100、Go语言 之海量用户即时通讯示例","slug":"Golang/100、Go语言 之海量用户即时通讯示例","date":"2016-04-08T19:06:08.000Z","updated":"2020-08-07T14:10:11.741Z","comments":true,"path":"2016/04/09/Golang/100、Go语言 之海量用户即时通讯示例/","link":"","permalink":"https://www.zackaddy.xin/2016/04/09/Golang/100、Go语言 之海量用户即时通讯示例/","excerpt":"","text":"Go语言 之海量用户即时通讯示例","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"9、mysql 之 DECIMAL 数字类型","slug":"Mysql/9、mysql 之 DECIMAL 数字类型","date":"2016-04-08T16:05:26.000Z","updated":"2020-08-07T14:10:11.863Z","comments":true,"path":"2016/04/09/Mysql/9、mysql 之 DECIMAL 数字类型/","link":"","permalink":"https://www.zackaddy.xin/2016/04/09/Mysql/9、mysql 之 DECIMAL 数字类型/","excerpt":"","text":"mysql 之 DECIMAL 数字类型 DECIMAL数据类型用于在数据库中存储精确的数值 经常将DECIMAL数据类型用于保留准确精确度的列 例如会计系统中的货币数据。 语法1column_name DECIMAL(P,D); P是表示有效数字数的精度。 P范围为1〜65。 D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。 DECIMAL(P，D)表示列可以存储D位小数的P位数。十进制列的实际范围取决于精度和刻度。 如果使用ZEROFILL，MySQL将把显示值填充到0以显示由列定义指定的宽度。 另外，如果我们对DECIMAL列使用ZERO FILL，MySQL将自动将UNSIGNED属性添加到列。 1amount DECIMAL(6,2); 在此示例中，amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。 额外的语法MySQL允许使用以下语法： 1column_name DECIMAL(P); 这相当于： 1column_name DECIMAL(P,0); 如果使用column_name DECIMAL;P的默认值为10。 存储MySQL分别为整数和小数部分分配存储空间。 DECIMAL(19,9)，小数9位4个字节，整数10位为4+1个字节，总共需要9个字节 货币数据经常使用DECIMAL数据类型的货币数据，如价格，工资，账户余额等。如果要设计一个处理货币数据的数据库，则可参考以下语法 - 1amount DECIMAL(19,2); 但是，如果您要遵守公认会计原则(GAAP)规则，则货币栏必须至少包含4位小数，以确保舍入值不超过$0.01。 在这种情况下，应该定义具有4位小数的列，如下所示： 1amount DECIMAL(19,4); 示例 创建表 12345CREATE TABLE test_order ( id INT AUTO_INCREMENT PRIMARY KEY, description VARCHAR(255), cost DECIMAL(19,4) NOT NULL); 插入数据 12INSERT INTO test_order(description,cost)VALUES('Bicycle', 500.34),('Seat',10.23),('Break',5.21235); 结果 id description cost 1 Bicycle 500.3400 2 Seat 10.2300 3 Break 5.2124 更改cost字段 12ALTER TABLE test_orderMODIFY cost DECIMAL(19,4) zerofill; 结果 id description cost 1 Bicycle 000000000000500.3400 2 Seat 000000000000010.2300 3 Break 000000000000005.2124 6. 此时插入负值报错","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"99、Go语言 之HTTP编程","slug":"Golang/99、Go语言 之HTTP编程","date":"2016-04-07T19:06:08.000Z","updated":"2020-08-07T14:10:11.770Z","comments":true,"path":"2016/04/08/Golang/99、Go语言 之HTTP编程/","link":"","permalink":"https://www.zackaddy.xin/2016/04/08/Golang/99、Go语言 之HTTP编程/","excerpt":"","text":"Go语言 之HTTP编程概述Web工作方式我们平时浏览网页的时候,会打开浏览器，输入网址后按下回车键，然后就会显示出你想要浏览的内容。在这个看似简单的用户行为背后，到底隐藏了些什么呢？ 对于普通的上网过程，系统其实是这样做的：浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP，然后通过IP地址找到IP对应的服务器后，要求建立TCP连接，等浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包，服务器调用自身服务，返回HTTP Response（响应）包；客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。 DNS域名服务器（Domain Name Server）是进行域名(domain name)和与之相对应的IP地址转换的服务器。DNS中保存了一张域名解析表，解析消息的域名。 一个Web服务器也被称为HTTP服务器，它通过HTTP (HyperText Transfer Protocol 超文本传输协议)协议与客户端通信。这个客户端通常指的是Web浏览器(其实手机端客户端内部也是浏览器实现的)。 Web服务器的工作原理可以简单地归纳为： 客户机通过TCP/IP协议建立到服务器的TCP连接 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档 服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端 客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果 HTTP协议超文本传输协议(HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示： 地址（URL）URL全称为Unique Resource Location，用来表示网络资源，可以理解为网络文件路径。 基本URL的结构包含模式（协议）、服务器名称（IP地址）、路径和文件名。常见的协议/模式如http、https、ftp等。服务器的名称或IP地址后面有时还跟一个冒号和一个端口号。再后面是到达这个文件的路径和文件本身的名称。如： 123http://localhost[\":\"port][abs_path]http://192.168.31.1/html/indexhttps://pan.baidu.com/ URL的长度有限制，不同的服务器的限制值不太相同，但是不能无限长。 HTTP报文解析请求报文格式,获取请求报文为了更直观的看到浏览器发送的请求包，我们借助前面学习的TCP通信模型，编写一个简单的web服务器，只接收浏览器发送的内容，打印查看。服务器测试代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"net\" \"fmt\")func main() &#123; //创建、监听socket listenner, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"Listen err:\", err) return &#125; defer listenner.Close() //阻塞等待客户端连接 conn, err := listenner.Accept() if err != nil &#123; fmt.Println(\"Accept err:\", err) return &#125; defer conn.Close() fmt.Println(conn.RemoteAddr().String(), \"连接成功\") //连接客户端的网络地址 buf := make([]byte, 4096) //切片缓冲区，接收客户端发送数据 n, err := conn.Read(buf) //n 接收数据的长度 if err != nil &#123; fmt.Println(\"Read err:\", err) return &#125; result := buf[:n] //切片截取 fmt.Printf(\"#\\n%s#\", string(result))&#125; 在浏览器中输入url地址： 127.0.0.1:8000服务器端运行打印结果如下： 请求报文格式说明HTTP 请求报文由请求行、请求头部、空行、请求包体4个部分组成，如下图所示： 请求行 请求行由方法字段、URL 字段 和HTTP 协议版本字段 3个部分组成，他们之间使用空格隔开。常用的 HTTP 请求方法有 GET、POST。 GET： 当客户端要从服务器中读取某个资源时，使用GET 方法。GET 方法要求服务器将URL 定位的资源放在响应报文的数据部分，回送给客户端，即向服务器请求某个资源。 使用GET方法时，请求参数和对应的值附加在 URL 后面，利用一个问号(“?”)代表URL 的结尾与请求参数的开始，传递参数长度受限制，因此GET方法不适合用于上传数据。 通过GET方法来获取网页时，参数会显示在浏览器地址栏上，因此保密性很差。 POST： 当客户端给服务器提供信息较多时可以使用POST 方法，POST 方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。 GET 一般用于获取/查询资源信息，POST 会附带用户数据，一般用于更新资源信息。POST 方法将请求参数封装在HTTP 请求数据中，而且长度没有限制，因为POST携带的数据，在HTTP的请求正文中，以名称/值的形式出现，可以传输大量数据。 请求头部 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有： 请求头 含义 User-Agent 请求的浏览器类型 Accept 客户端可识别的响应内容类型列表，星号“ * ”用于按范围将类型分组，用“ / ”指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型 Accept-Language 客户端可接受的自然语言 Accept-Encoding 客户端可接受的编码压缩格式 Accept-Charset 可接受的应答的字符集 Host 请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机 connection 连接方式(close或keepalive) Cookie 存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie 空行 最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 请求包体 请求包体不在GET方法中使用，而在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求包体相关的最常使用的是包体类型Content-Type和包体长度Content-Length。 响应报文格式 要想获取响应报文，必须先发送请求报文给web服务器。服务器收到并解析浏览器（客户端）发送的请求报文后，借助http协议，回复相对应的响应报文。 下面我们借助net/http包，创建一个最简单的服务器，给浏览器回发送响应包。首先注册处理函数http.HandleFunc()，设置回调函数handler。而后绑定服务器的监听地址http.ListenAndserve()。 这个服务器启动后，当有浏览器发送请求，回调函数被调用，会向浏览器回复“hello world”作为网页内容。当然，是按照http协议的格式进行回复。 创建简单的响应服务器 服务器示例代码： 12345678910111213141516package mainimport \"net/http\"// 浏览器访问时，该函数被回调func handler(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(\"hello http\"))&#125;func main() &#123; // 注册处理函数 http.HandleFunc(\"/hello\", handler) // 绑定服务器监听地址 http.ListenAndServe(\"127.0.0.1:8000\", nil)&#125; 测试：启动服务器。打开浏览器，在URL中写入127.0.0.1:8000/hello，向服务器发送请求。会在浏览器中看到服务器回发的“hello http”。 回调函数handler会在浏览器访问服务器时被调用。服务器使用w.Write向浏览器写了“hello http”。 但服务器是怎样借助http协议将“hello http”字符串写回来的呢，服务器响应报文的具体格式是什么样的呢？ 接下来我们编写一个客户端，模拟浏览器给服务器发送“请求报文”的行为，然后将服务器回发的响应报文打印出来就可以看到了。 客户端测试示例代码： 1234567891011121314151617181920212223242526272829303132package mainimport ( \"net\" \"fmt\")func main() &#123; // 客户端主动连接服务器 conn, err := net.Dial(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"Dial err:\", err) return &#125; defer conn.Close() // 模拟浏览器，组织一个最简单的请求报文。包含请求行，请求头，空行即可。 requestHttpHeader := \"GET /hello HTTP/1.1\\r\\nHost:127.0.0.1:8000\\r\\n\\r\\n\" // 给服务器发送请求报文 conn.Write([]byte(requestHttpHeader)) buf := make([]byte, 4096) // 读取服务器回复 响应报文 n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"Read err:\", err) return &#125; // 打印观察 fmt.Printf(\"#\\n%s#\", string(buf[:n]))&#125; 启动程序，测试http的成功响应报文： 启动程序，测试http的失败响应报文： 响应报文格式说明HTTP 响应报文由状态行、响应头部、空行、响应包体4个部分组成 状态行 状态行由 HTTP 协议版本字段、状态码和状态码的描述文本3个部分组成，他们之间使用空格隔开。状态码：状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示：状态码| 含义–|–1xx| 表示服务器已接收了客户端请求，客户端可继续发送请求2xx| 表示服务器已成功接收到请求并进行处理3xx| 表示服务器要求客户端重定向4xx| 表示客户端的请求有非法内容5xx| 表示服务器未能正常处理客户端的请求而出现意外错误 常见的状态码举例：状态码| 含义–|–200 OK| 客户端请求成功400 Bad Request| 请求报文有语法错误401 Unauthorized| 未授权403 Forbidden| 服务器拒绝服务404 Not Found| 请求的资源不存在500 Internal Server Error| 服务器内部错误503 Server Unavailable| 服务器临时不能处理客户端请求(稍后可能可以) 响应头部 响应头可能包括： 响应头 含义 Location Location响应报头域用于重定向接受者到一个新的位置 Server Server 响应报头域包含了服务器用来处理请求的软件信息及其版本 Vary 指示不可缓存的请求头列表 Connection 连接方式 3. 空行 最后一个响应头部之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头部。4. 响应包体 服务器返回给客户端的文本信息。 Go语言HTTP编程Go语言标准库内建提供了net/http包，涵盖了HTTP客户端和服务端的具体实现。使用net/http包，我们可以很方便地编写HTTP客户端或服务端的程序。 HTTP服务端示例代码： 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"net/http\")//服务端编写的业务逻辑处理程序 —— 回调函数func myHandler(w http.ResponseWriter, r *http.Request) &#123; fmt.Println(\"method = \", r.Method) //请求方法 fmt.Println(\"URL = \", r.URL) // 浏览器发送请求文件路径 fmt.Println(\"header = \", r.Header) // 请求头 fmt.Println(\"body = \", r.Body) // 请求包体 fmt.Println(r.RemoteAddr, \"连接成功\") //客户端网络地址 w.Write([]byte(\"hello http\")) //给客户端回复数据&#125;func main() &#123; http.HandleFunc(\"/hello\", myHandler) // 注册处理函数 //该方法用于在指定的 TCP 网络地址 addr 进行监听，然后调用服务端处理程序来处理传入的连接请求。 //该方法有两个参数：第一个参数 addr 即监听地址；第二个参数表示服务端处理程序，通常为nil //当参2为nil时，服务端调用 http.DefaultServeMux 进行处理 http.ListenAndServe(\"127.0.0.1:8000\", nil)&#125; 浏览器输入url地址：127.0.0.1:8000/hello回调函数myHandler的函数原型固定。func myHandler(w http.ResponseWriter, r *http.Request) 有两个参数：w http.ResponseWriter 和 r *http.Request。w用来“给客户端回发数据”。它是一个interface： 12345type ResponseWriter interface &#123; Header() Header Write([]byte) (int, error) WriteHeader(int) &#125; r 用来“接收客户端发送的数据”。浏览器发送给服务器的http请求包的内容可以借助r来查看。它对应一个结构体： 12345678910 type Request struct &#123; Method string // 浏览器请求方法 GET、POST… URL *url.URL // 浏览器请求的访问路径 …… Header Header // 请求头部 Body io.ReadCloser // 请求包体 RemoteAddr string // 浏览器地址 …… ctx context.Context&#125; 查看一下结构体成员： 12345fmt.Println(\"Method = \", r.Method)fmt.Println(\"URL = \", r.URL)fmt.Println(\"Header = \", r.Header)fmt.Println(\"Body = \", r.Body)fmt.Println(r.RemoteAddr, \"连接成功\") 查看到如下内容： 练习： 在计算机中选定一个目录，存放jpg、png、txt、mp3、gif、m4a等类型文件。编写一个服务器程序，可以给浏览器提供该目录下文件的访问服务。 如：目录中存有图片文件：lf.jpg。用户在浏览器中输入：127.0.0.1:8000/lf.jpg 可以查看该图片。 HTTP客户端客户端访问web服务器数据，主要使用func Get(url string) (resp *Response, err error)函数来完成。读到的响应报文数据被保存在 Response 结构体中。 123456789type Response struct &#123; Status string // e.g. \"200 OK\" StatusCode int // e.g. 200 Proto string // e.g. \"HTTP/1.0\" …… Header Header Body io.ReadCloser ……&#125; 服务器发送的响应包体被保存在Body中。可以使用它提供的Read方法来获取数据内容。保存至切片缓冲区中，拼接成一个完整的字符串来查看。结束的时候，需要调用Body中的Close()方法关闭io。示例代码： 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"net/http\" \"fmt\")func main() &#123; // 使用Get方法获取服务器响应包数据 //resp, err := http.Get(\"http://www.baidu.com\") resp, err := http.Get(\"http://127.0.0.1:8000/hello\") if err != nil &#123; fmt.Println(\"Get err:\", err) return &#125; defer resp.Body.Close() // 获取服务器端读到的数据 fmt.Println(\"Status = \", resp.Status) // 状态 fmt.Println(\"StatusCode = \", resp.StatusCode) // 状态码 fmt.Println(\"Header = \", resp.Header) // 响应头部 fmt.Println(\"Body = \", resp.Body) // 响应包体 buf := make([]byte, 4096) // 定义切片缓冲区，存读到的内容 var result string // 获取服务器发送的数据包内容 for &#123; n, err := resp.Body.Read(buf) // 读body中的内容。 if n == 0 &#123; fmt.Println(\"Body.Read err:\", err) break &#125; result += string(buf[:n]) // 累加读到的数据内容 &#125; // 打印从body中读到的所有内容 fmt.Println(\"result = \", result)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"8、mysql 之整型","slug":"Mysql/8、mysql 之整型","date":"2016-04-07T17:15:57.000Z","updated":"2020-08-07T14:10:11.863Z","comments":true,"path":"2016/04/08/Mysql/8、mysql 之整型/","link":"","permalink":"https://www.zackaddy.xin/2016/04/08/Mysql/8、mysql 之整型/","excerpt":"","text":"mysql 之整型 如果不设置是否有符号，默认为无符号。 设置无符号添加unsigned关键字 插入数字超出整型范围，会报异常并插入临界值 不设置长度会有一个默认长度 搭配zerofill可在左侧自动填充0到类型长度 类型 存储 最小值 最大值 （字节） （符号/无符号） TINYINT 1 -128 127 0 SMALLINT 2 -32768 32767 0 MEDIUMINT 3 -8388608 8388607 0 INT 4 -2147483648 2147483647 0 BIGINT 8 -9223372036854775808 9223372036854775807 0","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"7、mysql 之插入数据","slug":"Mysql/7、mysql 之插入数据","date":"2016-04-07T01:11:03.000Z","updated":"2020-08-07T14:10:11.861Z","comments":true,"path":"2016/04/07/Mysql/7、mysql 之插入数据/","link":"","permalink":"https://www.zackaddy.xin/2016/04/07/Mysql/7、mysql 之插入数据/","excerpt":"","text":"Mysql 之插入数据 Replace into Insert into … on duplicate key update insert ignore into user表 Field Type Null Key Default Extra id int(11) NO PRI auto_increment username varchar(255) YES password varchar(255) YES INSERT INTO语法123456789INSERT INTO table_name (field1, field2,...fieldN) VALUES (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;INSERT INTO table_name VALUES (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;INSERT INTO table_name SET field = ?, field2 = ?;INSERT INTO table_name SELECT field,field2 INSERT INTO插入12345INSERT INTO user (username, password) VALUES ('hello', 123456);INSERT INTO user (password, username) VALUES (123456, 'hello');INSERT INTO user VALUES(NULL, 'hello', 123456);INSERT INTO user SET username = 'hello', password = 123456;INSERT INTO user SELECT NULL, 'hello', 123456 Replace into 存在自动增长主键时，指定主键且数据存在则更新否则插入12REPLACE INTO user VALUES (null, 'herghost', 123456) // 新增数据REPLACE INTO user VALUES (1, 'herghost', 789) // 更新数据 Insert into … on duplicate key update 存在自动增长主键时，指定主键且数据存在则更新否则插入123INSERT INTO user VALUES (NULL, 'herghost', 123456) ON DUPLICATE KEY UPDATE password = 66666 // 新增数据 herghost 123456INSERT INTO user VALUES (1, 'xxx', 123456) ON DUPLICATE KEY UPDATE password = 66666 // 更新数据 herghost 66666 insert ignore into 存在不增加数据，不存在则插入数据123INSERT IGNORE user VALUES (NULL, 'herghost', 123456) // 新增数据 herghost 123456INSERT IGNORE user VALUES (1, 'xxxx', 123456) // 不插入数据","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"98、Go语言 之并发聊天室示例","slug":"Golang/98、Go语言 之并发聊天室示例","date":"2016-04-06T19:06:08.000Z","updated":"2020-08-07T14:10:11.770Z","comments":true,"path":"2016/04/07/Golang/98、Go语言 之并发聊天室示例/","link":"","permalink":"https://www.zackaddy.xin/2016/04/07/Golang/98、Go语言 之并发聊天室示例/","excerpt":"","text":"Go语言 之并发聊天室示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package mainimport ( \"net\" \"fmt\" \"strings\" \"time\")// 创建用户结构体类型！type Client struct &#123; C chan string Name string Addr string&#125;// 创建全局map，存储在线用户var onlineMap map[string]Client// 创建全局 channel 传递用户消息。var message = make(chan string)func WriteMsgToClient(clnt Client, conn net.Conn) &#123; // 监听 用户自带Channel 上是否有消息。 for msg := range clnt.C &#123; conn.Write([]byte(msg + \"\\n\")) &#125;&#125;func MakeMsg(clnt Client, msg string) (buf string) &#123; buf = \"[\" + clnt.Addr + \"]\" + clnt.Name + \": \" + msg return&#125;func HandlerConnect(conn net.Conn) &#123; defer conn.Close() // 创建channel 判断，用户是否活跃。 hasData := make(chan bool) // 获取用户 网络地址 IP+port netAddr := conn.RemoteAddr().String() // 创建新连接用户的 结构体. 默认用户是 IP+port clnt := Client&#123;make(chan string), netAddr, netAddr&#125; // 将新连接用户，添加到在线用户map中. key: IP+port value：client onlineMap[netAddr] = clnt // 创建专门用来给当前 用户发送消息的 go 程 go WriteMsgToClient(clnt, conn) // 发送 用户上线消息到 全局channel 中 //message &lt;- \"[\" + netAddr + \"]\" + clnt.Name + \"login\" message &lt;- MakeMsg(clnt, \"login\") // 创建一个 channel ， 用来判断用退出状态 isQuit := make(chan bool) // 创建一个匿名 go 程， 专门处理用户发送的消息。 go func() &#123; buf := make([]byte, 4096) for &#123; n, err := conn.Read(buf) if n == 0 &#123; isQuit &lt;- true fmt.Printf(\"检测到客户端:%s退出\\n\", clnt.Name) return &#125; if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; // 将读到的用户消息，保存到msg中，string 类型 msg := string(buf[:n-1]) // 提取在线用户列表 if msg == \"who\" &amp;&amp; len(msg) == 3 &#123; conn.Write([]byte(\"online user list:\\n\")) // 遍历当前 map ，获取在线用户 for _, user := range onlineMap &#123; userInfo := user.Addr + \":\" + user.Name + \"\\n\" conn.Write([]byte(userInfo)) &#125; // 判断用户发送了 改名 命令 &#125; else if len(msg) &gt;=8 &amp;&amp; msg[:6] == \"rename\" &#123; // rename| newName := strings.Split(msg, \"|\")[1] // msg[8:] clnt.Name = newName // 修改结构体成员name onlineMap[netAddr] = clnt // 更新 onlineMap conn.Write([]byte(\"rename successful\\n\")) &#125;else &#123; // 将读到的用户消息，写入到message中。 message &lt;- MakeMsg(clnt, msg) &#125; hasData &lt;- true &#125; &#125;() // 保证 不退出 for &#123; // 监听 channel 上的数据流动 select &#123; case &lt;-isQuit: delete(onlineMap, clnt.Addr) // 将用户从 online移除 message &lt;- MakeMsg(clnt, \"logout\") // 写入用户退出消息到全局channel return case &lt;-hasData: // 什么都不做。 目的是重置 下面 case 的计时器。 case &lt;-time.After(time.Second * 60): delete(onlineMap, clnt.Addr) // 将用户从 online移除 message &lt;- MakeMsg(clnt, \"time out leaved\") // 写入用户退出消息到全局channel return &#125; &#125;&#125;func Manager() &#123; // 初始化 onlineMap onlineMap = make(map[string]Client) // 监听全局channel 中是否有数据, 有数据存储至 msg， 无数据阻塞。 for &#123; msg := &lt;-message // 循环发送消息给 所有在线用户。要想执行，必须 msg := &lt;-message 执行完， 解除阻塞。 for _, clnt := range onlineMap &#123; clnt.C &lt;- msg &#125; &#125;&#125;func main() &#123; // 创建监听套接字 listener, err := net.Listen(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"Listen err\", err) return &#125; defer listener.Close() // 创建管理者go程，管理map 和全局channel go Manager() // 循环监听客户端连接请求 for &#123; conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"Accept err\", err) return &#125; // 启动go程处理客户端数据请求 go HandlerConnect(conn) &#125;&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"97、Go语言 之Socket编程","slug":"Golang/97、Go语言 之Socket编程","date":"2016-04-05T19:06:08.000Z","updated":"2020-08-07T14:10:11.769Z","comments":true,"path":"2016/04/06/Golang/97、Go语言 之Socket编程/","link":"","permalink":"https://www.zackaddy.xin/2016/04/06/Golang/97、Go语言 之Socket编程/","excerpt":"","text":"Go语言 之Socket编程什么是SocketSocket，英文含义是【插座、插孔】，一般称之为套接字，用于描述IP地址和端口。可以实现不同程序间的数据通信。Socket起源于Unix，而Unix基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。 套接字的内核实现较为复杂，不宜在学习初期深入学习，了解到如下结构足矣。 在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。 常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。 网络应用程序设计模式C/S模式传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。 B/S模式浏览器(Browser)/服务器(Server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。 优缺点对于C/S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯所采用的通信协议，即为ftp协议的修改剪裁版。 因此，传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。 C/S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C/S模式应用程序的重要原因。 B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。 B/S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。 因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。 TCP的C/S架构 TCP客户端 动作 TCP服务端 - - net.Listen() net.Dial() 阻塞等待用户链接-&gt; Accept() Write() 数据（请求）-&gt; Read() Read() 数据（应答）&lt;- Write() Close() - Close() 简单的C/S模型通信Server端：Listen函数： 123func Listen(network, address string) (Listener, error) network：选用的协议：TCP、UDP， 如：“tcp”或 “udp” address：IP地址+端口号, 如：“127.0.0.1:8000”或 “:8000” Listener 接口： 12345type Listener interface &#123; Accept() (Conn, error) Close() error Addr() Addr&#125; Conn 接口： 12345678910type Conn interface &#123; Read(b []byte) (n int, err error) Write(b []byte) (n int, err error) Close() error LocalAddr() Addr RemoteAddr() Addr SetDeadline(t time.Time) error SetReadDeadline(t time.Time) error SetWriteDeadline(t time.Time) error&#125; 参看 https://studygolang.com/pkgdoc 中文帮助文档中的demo 示例代码： TCP服务器.go 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"net\" \"fmt\")func main() &#123; // 创建监听 listener, err:= net.Listen(\"tcp\", \":8000\") if err != nil &#123; fmt.Println(\"listen err:\", err) return &#125; defer listener.Close() // 主协程结束时，关闭listener fmt.Println(\"服务器等待客户端建立连接...\") // 等待客户端连接请求 conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"accept err:\", err) return &#125; defer conn.Close() // 使用结束，断开与客户端链接 fmt.Println(\"客户端与服务器连接建立成功...\") // 接收客户端数据 buf := make([]byte, 1024) // 创建1024大小的缓冲区，用于read n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"read err:\", err) return &#125; fmt.Println(\"服务器读到:\", string(buf[:n])) // 读多少，打印多少。&#125; 在整个通信过程中，服务器端有两个socket参与进来，但用于通信的只有 conn 这个socket。它是由 listener创建的。隶属于服务器端。 Client 端Dial函数： 123func Dial(network, address string) (Conn, error) network：选用的协议：TCP、UDP，如：“tcp”或 “udp” address：服务器IP地址+端口号, 如：“121.36.108.11:8000”或 “www.itcast.cn:8000” Conn 接口： 12345678910type Conn interface &#123; Read(b []byte) (n int, err error) Write(b []byte) (n int, err error) Close() error LocalAddr() Addr RemoteAddr() Addr SetDeadline(t time.Time) error SetReadDeadline(t time.Time) error SetWriteDeadline(t time.Time) error&#125; 1234567891011121314151617181920212223package mainimport ( \"net\" \"fmt\")func main() &#123; // 主动发起连接请求 conn, err := net.Dial(\"tcp\", \"127.0.0.1:8000\") if err != nil &#123; fmt.Println(\"Dial err:\", err) return &#125; defer conn.Close() // 结束时，关闭连接 // 发送数据 _, err = conn.Write([]byte(\"Are u ready?\")) if err != nil &#123; fmt.Println(\"Write err:\", err) return &#125;&#125; 并发的C/S模型通信并发Server现在已经完成了客户端与服务端的通信，但是服务端只能接收一个用户发送过来的数据，怎样接收多个客户端发送过来的数据，实现一个高效的并发服务器呢？ Accept()函数的作用是等待客户端的链接，如果客户端没有链接，该方法会阻塞。如果有客户端链接，那么该方法返回一个Socket负责与客户端进行通信。所以，每来一个客户端，该方法就应该返回一个Socket与其通信，因此，可以使用一个死循环，将Accept()调用过程包裹起来。需要注意的是，实现并发处理多个客户端数据的服务器，就需要针对每一个客户端连接，单独产生一个Socket，并创建一个单独的goroutine与之完成通信。 1234567891011121314151617//监听 listener, err := net.Listen(\"tcp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"err = \", err) return &#125; defer listener.Close() //接收多个用户 for &#123; conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"err = \", err) return &#125; //处理用户请求, 新建一个协程 go HandleConn(conn)&#125; 将客户端的数据处理工作封装到HandleConn方法中，需将Accept()返回的Socket传递给该方法，变量conn的类型为：net.Conn。可以使用conn.RemoteAddr()来获取成功与服务器建立连接的客户端IP地址和端口号：Conn 接口： 12345678910type Conn interface &#123; Read(b []byte) (n int, err error) Write(b []byte) (n int, err error) Close() error LocalAddr() Addr RemoteAddr() Addr SetDeadline(t time.Time) error SetReadDeadline(t time.Time) error SetWriteDeadline(t time.Time) error&#125; 123 //获取客户端的网络地址信息 addr := conn.RemoteAddr().String() fmt.Println(addr, \" conncet sucessful\") 客户端可能持续不断的发送数据，因此接收数据的过程可以放在for循环中，服务端也持续不断的向客户端返回处理后的数据。添加一个限定，如果客户端发送一个“exit”字符串，表示客户端通知服务器不再向服务端发送数据，此时应该结束HandleConn方法，同时关闭与该客户端关联的Socket。 1234567891011121314151617buf := make([]byte, 2048) //创建一个切片，存储客户端发送的数据for &#123; //读取用户数据 n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"err = \", err) return &#125; fmt.Printf(\"[%s]: %s\\n\", addr, string(buf[:n])) if \"exit\" == string(buf[:n-2]) &#123; //自己写的客户端测试, 发送时，多了2个字符, \"\\r\\n\" fmt.Println(addr, \" exit\") return &#125; //服务器处理数据：把客户端数据转大写，再写回给client conn.Write([]byte(strings.ToUpper(string(buf[:n])))) &#125; 在上面的代码中，Read()方法获取客户端发送过来的数据，填充到切片buf中，返回的是实际填充的数据的长度，所以将客户端发送过来的数据进行打印，打印的是实际接收到的数据。 1fmt.Printf(\"[%s]: %s\\n\", addr, string(buf[:n])). 同时也可以将客户端的网络地址信息打印出来。 在判断客户端数据是否为“exit”字符串时，要注意，客户端会自动的多发送2个字符：“\\r\\n”（这在windows系统下代表回车、换行） Server使用Write方法将数据写回给客户端，参数类型是 []byte，需使用strings包下的ToUpper函数来完成大小写转换。 转换的对象即为string(buf[:n]) 综上，HandleConn方法完整定义如下： 12345678910111213141516171819202122232425262728293031//处理用户请求func HandleConn(conn net.Conn) &#123;//函数调用完毕，自动关闭conndefer conn.Close() //获取客户端的网络地址信息 addr := conn.RemoteAddr().String() fmt.Println(addr, \" conncet sucessful\") buf := make([]byte, 2048) for &#123; //读取用户数据 n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"err = \", err) return &#125; fmt.Printf(\"[%s]: %s\\n\", addr, string(buf[:n])) fmt.Println(\"len = \", len(string(buf[:n]))) //if \"exit\" == string(buf[:n-1]) &#123; // nc测试，发送时，只有 \\n if \"exit\" == string(buf[:n-2]) &#123; // 自己写的客户端测试, 发送时，多了2个字符, \"\\r\\n\" fmt.Println(addr, \" exit\") return &#125; //把数据转换为大写，再给用户发送 conn.Write([]byte(strings.ToUpper(string(buf[:n])))) &#125;&#125; 并发Client客户端不仅需要持续的向服务端发送数据，同时也要接收从服务端返回的数据。因此可将发送和接收放到不同的协程中。 主协程循环接收服务器回发的数据（该数据应已转换为大写），并打印至屏幕；子协程循环从键盘读取用户输入数据，写给服务器。读取键盘输入可使用 os.Stdin.Read(str)。定义切片str，将读到的数据保存至str中。 这样，客户端也实现了多任务。 客户端代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"net\" \"fmt\" \"os\")func main() &#123; // 主动发起连接请求 conn, err := net.Dial(\"tcp\", \"127.0.0.1:8001\") if err != nil &#123; fmt.Println(\"Dial err:\", err) return &#125; defer conn.Close() // 客户端终止时，关闭与服务器通信的 socket // 启动子协程，接收用户键盘输入 go func() &#123; str := make([]byte, 1024) // 创建用于存储用户键盘输入数据的切片缓冲区。 for &#123; // 反复读取 n, err :=os.Stdin.Read(str) // 获取用户键盘输入 if err != nil &#123; fmt.Println(\"os.Stdin.Read err:\", err) return &#125; // 将从键盘读到的数据，发送给服务器 _, err = conn.Write(str[:n]) // 读多少，写多少 if err != nil &#123; fmt.Println(\"conn.Write err:\", err) return &#125; &#125; &#125;() // 主协程，接收服务器回发数据，打印至屏幕 buf := make([]byte, 1024) // 定义用于存储服务器回发数据的切片缓冲区 for &#123; n, err := conn.Read(buf) // 从通信 socket 中读数据，存入切片缓冲区 if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; fmt.Printf(\"服务器回发：%s\\n\", string(buf[:n])) &#125;&#125; TCP通信首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序。 三次握手所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。好比两个人在打电话： Client:“喂，你听得到吗？” Server:“我听得到，你听得到我吗？” Client:“我能听到你，今天balabala…” 建立连接（三次握手）的过程 客户端发送一个带SYN标志的TCP报文到服务器。这是上图中三次握手过程中的段1。客户端发出SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。 服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。 客户必须再次回应服务器端一个ACK报文，这是报文段3。客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出。因此一共有三个段用于建立连接，称为“三方握手”。在建立连接的同时，双方协商了一些信息，例如，双方发送序号的初始值、最大段尺寸等。数据传输的过程 客户端发出段4，包含从序号1001开始的20个字节数据。 服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据。 客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。四次挥手所谓四次挥手（Four-Way-Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务器任一方执行close来触发。好比两个人打完电话要挂断： Client:“我要说的事情都说完了，我没事了。挂啦？” Server:“等下，我还有一个事儿。Balabala…” Server:“好了，我没事儿了。挂了啊。” Client:“ok！拜拜”关闭连接（四次握手）的过程由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端发出段7，FIN位表示关闭连接的请求。 服务器发出段8，应答客户端的关闭连接请求。 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。 客户端发出段10，应答服务器的关闭连接请求。 建立连接的过程是三次握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。 UDP通信在之前的案例中，我们一直使用的是TCP协议来编写Socket的客户端与服务端。其实也可以使用UDP协议来编写Socket的客户端与服务端。 UDP服务器由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信。 创建监听地址： 1func ResolveUDPAddr(network, address string) (*UDPAddr, error) 创建监听连接： 1func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error) 接收udp数据： 1func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error) 写出数据到udp： 1func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) 服务端完整代码实现如下： 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"net\")func main() &#123; //创建监听的地址，并且指定udp协议 udp_addr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8002\") if err != nil &#123; fmt.Println(\"ResolveUDPAddr err:\", err) return &#125; conn, err := net.ListenUDP(\"udp\", udp_addr) //创建监听链接 if err != nil &#123; fmt.Println(\"ListenUDP err:\", err) return &#125; defer conn.Close() buf := make([]byte, 1024) n, raddr, err := conn.ReadFromUDP(buf) //接收客户端发送过来的数据，填充到切片buf中。 if err != nil &#123; return &#125; fmt.Println(\"客户端发送：\", string(buf[:n])) _, err = conn.WriteToUDP([]byte(\"nice to see u in udp\"), raddr) //向客户端发送数据 if err != nil &#123; fmt.Println(\"WriteToUDP err:\", err) return &#125;&#125; UDP客户端udp客户端的编写与TCP客户端的编写，基本上是一样的，只是将协议换成udp.代码如下： 123456789101112131415161718192021222324package mainimport ( \"net\" \"fmt\")func main() &#123; conn, err := net.Dial(\"udp\", \"127.0.0.1:8002\") if err != nil &#123; fmt.Println(\"net.Dial err:\", err) return &#125; defer conn.Close() conn.Write([]byte(\"Hello! I'm client in UDP!\")) buf := make([]byte, 1024) n, err1 := conn.Read(buf) if err1 != nil &#123; return &#125; fmt.Println(\"服务器发来：\", string(buf[:n]))&#125; 并发其实对于UDP而言，服务器不需要并发，只要循环处理客户端数据即可。客户端也等同于TCP通信并发的客户端。服务器： 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"net\" \"fmt\")func main() &#123; // 创建 服务器 UDP 地址结构。指定 IP + port laddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8003\") if err != nil &#123; fmt.Println(\"ResolveUDPAddr err:\", err) return &#125; // 监听 客户端连接 conn, err := net.ListenUDP(\"udp\", laddr) if err != nil &#123; fmt.Println(\"net.ListenUDP err:\", err) return &#125; defer conn.Close() for &#123; buf := make([]byte, 1024) n, raddr, err := conn.ReadFromUDP(buf) if err != nil &#123; fmt.Println(\"conn.ReadFromUDP err:\", err) return &#125; fmt.Printf(\"接收到客户端[%s]：%s\", raddr, string(buf[:n])) conn.WriteToUDP([]byte(\"I-AM-SERVER\"), raddr) // 简单回写数据给客户端 &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; conn, err := net.Dial(\"udp\", \"127.0.0.1:8003\") if err != nil &#123; fmt.Println(\"net.Dial err:\", err) return &#125; defer conn.Close() go func() &#123; str := make([]byte, 1024) for &#123; n, err := os.Stdin.Read(str) //从键盘读取内容， 放在str if err != nil &#123; fmt.Println(\"os.Stdin. err1 = \", err) return &#125; conn.Write(str[:n]) // 给服务器发送 &#125; &#125;() buf := make([]byte, 1024) for &#123; n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; fmt.Println(\"服务器写来：\", string(buf[:n])) &#125;&#125; UDP与TCP的差异 TCP UDP 面向连接 面向无连接 要求系统资源较多 要求系统资源较少 TCP程序结构较复杂 UDP程序结构较简单 使用流式 使用数据包式 保证数据准确性 不保证数据准确性 保证数据顺序 不保证数据顺序 通讯速度较慢 通讯速度较快 文件传输流程简析借助TCP完成文件的传输，基本思路如下： 发送方（客户端）向服务端发送文件名，服务端保存该文件名。 接收方（服务端）向客户端返回一个消息ok，确认文件名保存成功。 发送方（客户端）收到消息后，开始向服务端发送文件数据。 接收方（服务端）读取文件内容，写入到之前保存好的文件中。 首先获取文件名。借助os包中的stat()函数来获取文件属性信息。在函数返回的文件属性中包含文件名和文件大小。Stat参数name传入的是文件访问的绝对路径。FileInfo中的Name()函数可以将文件名单独提取出来。 123456789func Stat(name string) (FileInfo, error) type FileInfo interface &#123; Name() string Size() int64 Mode() FileMode ModTime() time.Time IsDir() bool Sys() interface&#123;&#125; &#125; 获取文件属性示例： 1234567891011121314151617181920212223package mainimport ( \"os\" \"fmt\")func main() &#123; list := os.Args // 获取命令行参数，存入list中 if len(list) != 2 &#123; // 确保用户输入了一个命令行参数 fmt.Println(\"格式为：xxx.go 文件名\") return &#125; fileName := list[1] // 从命令行保存文件名(含路径) fileInfo, err := os.Stat(fileName) //根据文件名获取文件属性信息 fileInfo if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; fmt.Println(\"文件name为：\", fileInfo.Name()) // 得到文件名(不含路径) fmt.Println(\"文件size为：\", fileInfo.Size()) // 得到文件大小。单位字节&#125; 客户端实现实现流程大致如下： 提示用户输入文件名。接收文件名path（含访问路径） 使用os.Stat()获取文件属性，得到纯文件名（去除访问路径） 主动连接服务器，结束时关闭连接 给接收端（服务器）发送文件名conn.Write() 读取接收端回发的确认数据conn.Read() 判断是否为“ok”。如果是，封装函数SendFile() 发送文件内容。传参path和conn 只读Open文件, 结束时Close文件 循环读文件，读到EOF终止文件读取 将读到的内容原封不动Write给接收端（服务器） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"fmt\" \"os\" \"net\" \"io\")func SendFile(path string, conn net.Conn) &#123; // 以只读方式打开文件 f, err := os.Open(path) if err != nil &#123; fmt.Println(\"os.Open err:\", err) return &#125; defer f.Close() // 发送结束关闭文件。 // 循环读取文件，原封不动的写给服务器 buf := make([]byte, 4096) for &#123; n, err := f.Read(buf) // 读取文件内容到切片缓冲中 if err != nil &#123; if err == io.EOF &#123; fmt.Println(\"文件发送完毕\") &#125; else &#123; fmt.Println(\"f.Read err:\", err) &#125; return &#125; conn.Write(buf[:n]) // 原封不动写给服务器 &#125;&#125;func main() &#123; // 提示输入文件名 fmt.Println(\"请输入需要传输的文件：\") var path string fmt.Scan(&amp;path) // 获取文件名 fileInfo.Name() fileInfo, err := os.Stat(path) if err != nil &#123; fmt.Println(\"os.Stat err:\", err) return &#125; // 主动连接服务器 conn, err := net.Dial(\"tcp\", \"127.0.0.1:8005\") if err != nil &#123; fmt.Println(\"net.Dial err:\", err) return &#125; defer conn.Close() // 给接收端，先发送文件名 _, err = conn.Write([]byte(fileInfo.Name())) if err != nil &#123; fmt.Println(\"conn.Write err:\", err) return &#125; // 读取接收端回发确认数据 —— ok buf := make([]byte, 1024) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"conn.Read err:\", err) return &#125; // 判断如果是ok，则发送文件内容 if \"ok\" == string(buf[:n]) &#123; SendFile(path, conn) // 封装函数读文件，发送给服务器，需要path、conn &#125;&#125; 服务端实现实现流程大致如下： 创建监听listener，程序结束时关闭。 阻塞等待客户端连接，程序结束时关闭conn。 读取客户端发送文件名。保存fileName。 回发“ok”给客户端做应答 封装函数 RecvFile接收客户端发送的文件内容。传参fileName 和conn 按文件名Create文件，结束时Close 循环Read客户端发送的文件内容，当读到EOF说明文件读取完毕。 将读到的内容原封不动Write到创建的文件中 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( \"net\" \"fmt\" \"os\" \"io\")func RecvFile(fileName string, conn net.Conn) &#123; // 创建新文件 f, err := os.Create(fileName) if err != nil &#123; fmt.Println(\"Create err:\", err) return &#125; defer f.Close() // 接收客户端发送文件内容，原封不动写入文件 buf := make([]byte, 4096) for &#123; n, err := conn.Read(buf) if err != nil &#123; if err == io.EOF &#123; fmt.Println(\"文件接收完毕\") &#125; else &#123; fmt.Println(\"Read err:\", err) &#125; return &#125; f.Write(buf[:n]) // 写入文件，读多少写多少 &#125;&#125;func main() &#123; // 创建监听 listener, err := net.Listen(\"tcp\", \"127.0.0.1:8005\") if err != nil &#123; fmt.Println(\"Listen err:\", err) return &#125; defer listener.Close() // 阻塞等待客户端连接 conn, err := listener.Accept() if err != nil &#123; fmt.Println(\"Accept err:\", err) return &#125; defer conn.Close() // 读取客户端发送的文件名 buf := make([]byte, 1024) n, err := conn.Read(buf) if err != nil &#123; fmt.Println(\"Read err:\", err) return &#125; fileName := string(buf[:n]) // 保存文件名 // 回复 0k 给发送端 conn.Write([]byte(\"ok\")) // 接收文件内容 RecvFile(fileName, conn) // 封装函数接收文件内容， 传fileName 和 conn&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"6、mysql 之创建表","slug":"Mysql/6、mysql 之创建表","date":"2016-04-05T17:26:17.000Z","updated":"2020-08-07T14:10:11.858Z","comments":true,"path":"2016/04/06/Mysql/6、mysql 之创建表/","link":"","permalink":"https://www.zackaddy.xin/2016/04/06/Mysql/6、mysql 之创建表/","excerpt":"","text":"Mysql 之创建表语法1CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项]; 其中，[表定义选项]的格式为： 1&lt;列名1&gt; &lt;类型1&gt; [,…] &lt;列名n&gt; &lt;类型n&gt; 指定的数据库中创建表 test_db数据库中创建tb_emp1员工表 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 12345678910mysql&gt; USE test_db;Database changedmysql&gt; CREATE TABLE tb_emp1 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; );Query OK, 0 rows affected (0.37 sec) 显示所有表12mysql&gt; SHOW TABLES;Empty set (0.00 sec) 显示创建表时的CREATE TABLE语句1SHOW CREATE TABLE &lt;表名&gt;\\G； 查看表结构1234567891011mysql&gt; DESCRIBE pet;+---------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+-------------+------+-----+---------+-------+| name | varchar(20) | YES | | NULL | || owner | varchar(20) | YES | | NULL | || species | varchar(20) | YES | | NULL | || sex | char(1) | YES | | NULL | || birth | date | YES | | NULL | || death | date | YES | | NULL | |+---------+-------------+------+-----+---------+-------+ 各个字段的含义如下： Null：表示该列是否可以存储 NULL 值。 Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"5、mysql 之删除数据库","slug":"Mysql/5、mysql 之删除数据库","date":"2016-04-05T02:47:59.000Z","updated":"2020-08-07T14:10:11.855Z","comments":true,"path":"2016/04/05/Mysql/5、mysql 之删除数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/05/Mysql/5、mysql 之删除数据库/","excerpt":"","text":"Mysql 之删除数据库删除数据库是将已经存在的数据库从磁盘空间上清除，清除之后，数据库中的所有数据也将一同被删除。所以删除数据库需要特别谨慎，建议先备份数据。 删除一个已经确定存在的数据库MySQL 中删除数据库的基本SQL语句： 1DROP DATABASE test2; 运行之后会询问是否删除，运行输出如下： 12345You're about to run a destructive command.Do you want to proceed? (y/n): yYour call!Query OK, 0 rows affectedTime: 0.004s 删除一个不确定存在的数据库如果你没有创建 test2 这个数据，或者你的这个数据库被删除了，再次执行查看数据库的定义 “SHOW CREATE DATABASE” 结果会输出一条错误信息，即数据库 test2 已经不存在。输出结果如下： 12mysql&gt; SHOW CREATE DATABASE test2;ERROR 1049 (42000): Unknown database 'test2' 为了不产生错误，在删除数据库的时候可以加上一些简单的逻辑判断，判断数据库是否存在，不存在也不产生错误。 12mysql&gt; drop database if exists test2;Query OK, 0 rows affected, 1 warning (0.00 sec) 产生一个警告说明此数据库不存在。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"96、Go语言 之网络概括","slug":"Golang/96、Go语言 之网络概括","date":"2016-04-04T19:06:08.000Z","updated":"2020-08-07T14:10:11.769Z","comments":true,"path":"2016/04/05/Golang/96、Go语言 之网络概括/","link":"","permalink":"https://www.zackaddy.xin/2016/04/05/Golang/96、Go语言 之网络概括/","excerpt":"","text":"Go语言 之网络概括网络协议从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。假设，A、B双方欲传输文件。规定： 第一次，传输文件名，接收方接收到文件名，应答OK给传输方； 第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK； 第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。 由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。 这种仅在A、B之间被遵守的协议称之为原始协议。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协议。最早的ftp协议就是由此衍生而来。 典型协议 传输层 常见协议有TCP/UDP协议。 应用层 常见的协议有HTTP协议，FTP协议。 网络层 常见协议有IP协议、ICMP协议、IGMP协议。 网络接口层 常见协议有ARP协议、RARP协议。 TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。 FTP文件传输协议（File Transfer Protocol） IP协议是因特网互联协议（Internet Protocol） ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。 ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。 RARP是反向地址转换协议，通过MAC地址确定IP地址。 分层模型网络分层架构为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。 OSI/RM(理论上的标准) 物理层-》数据链路层-》网络层-》传输层-》会话层-》表示层-》应用层 TCP/IP(事实上的标准) 链路层-》网络层-》传输层-》应用层 越下面的层，越靠近硬件；越上面的层，越靠近用户。至于每一层叫什么名字，对应编程而言不重要，但面试的时候，面试官可能会问每一层的名字。业内普遍的分层方式有两种。OSI七层模型 和TCP/IP四层模型。可以通过背诵两个口诀来快速记忆： OSI七层模型：物、数、网、传、会、表、应 TCP/IP四层模型：链、网、传、应 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。层与协议每一层都是为了完成一种功能，为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守这规则，就叫做“协议”（protocol）。网络的每一层，都定义了很多协议。这些协议的总称，叫“TCP/IP协议”。TCP/IP协议是一个大家族，不仅仅只有TCP和IP协议，它还包括其它的协议，如下图： 协议功能 链路层为设备到设备 网络层为主机到主机 传输层为进程到进程 应用层为应用程序 链路层以太网规定，连入网络的所有设备，都必须具有“网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能。网卡的地址——MAC 地址，就是数据包的物理发送地址和物理接收地址。 网络层网络层的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做“网络地址”，这是我们平时所说的IP地址。这个IP地址好比我们的手机号码，通过手机号码可以得到用户所在的归属地。 网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。网络层协议包含的主要信息是源IP和目的IP。 于是，“网络层”出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理 MAC 地址。 传输层当我们一边聊QQ，一边聊微信，当一个数据包从互联网上发来的时候，我们怎么知道，它是来自QQ的内容，还是来自微信的内容？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做“端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。端口特点： 对于同一个端口，在不同系统中对应着不同的进程 对于同一个系统，一个端口只能被一个进程拥有应用层应用程序收到“传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。“应用层”的作用，就是规定应用程序的数据格式。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"4、mysql 之创建数据库","slug":"Mysql/4、mysql 之创建数据库","date":"2016-04-04T01:36:18.000Z","updated":"2020-08-07T14:10:11.853Z","comments":true,"path":"2016/04/04/Mysql/4、mysql 之创建数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/04/Mysql/4、mysql 之创建数据库/","excerpt":"","text":"mysql 之创建数据库MySQL安装好以后，首先需要创建数据库，你可以创建自己的数据库，这是使用 MySQL 各种功能的前提。 语法12CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;] [[DEFAULT] COLLATE &lt;校对规则名&gt;]; [ ]中的内容是可选的。语法说明如下： &lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，注意在 MySQL 中不区分大小写。 IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [DEFAULT] CHARACTER SET：指定数据库的默认字符集。 [DEFAULT] COLLATE：指定字符集的默认校对规则。 指定字符集和校对规则1234mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_chinese_ci;Query OK, 1 row affected (0.03 sec) 创建一个已知不存在的数据库连接好 MySQL 之后运行下面SQL语句创建数据库： 1CREATE DATABASE test; 运行上面SQL语句将输出下面信息 12Query OK, 1 row affectedTime: 0.011s 数据库创建之后可以使用 “SHOW CREATE DATABASE” 声明查看数据库的定义。运行下面SQL语句： 1SHOW CREATE DATABASE test\\G; 运行上面SQL语句将输出下面信息： 123456***************************[ 1. row ]***************************Database | testCreate Database | CREATE DATABASE `test` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */1 row in setTime: 0.001s 创建一个不确定存在的数据库如果你刚创建 test 这个数据，或者你的这个数据库已经存在，执行创建数据库的SQL语句 “CREATE DATABASE test;” 结果会输出一条错误信息，即不能创建数据库 test ，已经存在于数据库中。输出结果如下： 12mysql&gt; CREATE DATABASE test;ERROR 1007 (HY000): Can't create database 'test'; database exists 为了不产生错误，在创建数据库的时候可以加上一些简单的逻辑判断，判断数据库是否存在，不存在也不产生错误。会产生一个警告，如下： 12mysql&gt; CREATE DATABASE if not exists test;Query OK, 1 row affected, 1 warning (0.00 sec)","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"95、Go语言 之Test用例","slug":"Golang/95、Go语言 之Test用例","date":"2016-04-03T19:06:08.000Z","updated":"2020-08-07T14:10:11.769Z","comments":true,"path":"2016/04/04/Golang/95、Go语言 之Test用例/","link":"","permalink":"https://www.zackaddy.xin/2016/04/04/Golang/95、Go语言 之Test用例/","excerpt":"","text":"Go语言 之Test用例Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。 为什么需要测试完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少 bug，有两种有效的方式分别是代码审核和测试，Go语言中提供了 testing 包来实现单元测试功能。 测试规则要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以_test.go结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如： 123func TestXxx( t *testing.T )&#123; //......&#125; 编写测试用例有以下几点需要注意： 测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中； 测试用例的文件名必须以_test.go结尾；需要使用 import 导入 testing 包； 测试函数的名称要以Test或Benchmark开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数； 单元测试则以(t *testing.T)作为参数，性能测试以(t *testing.B)做为参数； 测试用例文件使用go test命令来执行，源码中不需要 main() 函数作为入口，所有以_test.go结尾的源码文件内以Test开头的函数都会自动执行。 Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。 单元（功能）测试在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go 具体代码如下所示： 123456789101112131415demo.go：package demo// 根据长宽获取面积func GetArea(weight int, height int) int &#123; return weight * height&#125;demo_test.go：package demoimport \"testing\"func TestGetArea(t *testing.T) &#123; area := GetArea(40, 50) if area != 2000 &#123; t.Error(\"测试失败\") &#125;&#125; 执行测试命令，运行结果如下所示： 12345PS D:\\code&gt; go test -v=== RUN TestGetArea--- PASS: TestGetArea (0.00s)PASSok _/D_/code 0.435s 性能（压力）测试将 demo_test.go 的代码改造成如下所示的样子： 1234567package demoimport \"testing\"func BenchmarkGetArea(t *testing.B) &#123; for i := 0; i &lt; t.N; i++ &#123; GetArea(40, 50) &#125;&#125; 执行测试命令，运行结果如下所示： 123456PS D:\\code&gt; go test -bench=\".\"goos: windowsgoarch: amd64BenchmarkGetArea-4 2000000000 0.35 ns/opPASSok _/D_/code 1.166s 上面信息显示了程序执行 2000000000 次，共耗时 0.35 纳秒。 覆盖率测试覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。 将 demo_test.go 代码改造成如下所示的样子： 12345678910111213package demoimport \"testing\"func TestGetArea(t *testing.T) &#123; area := GetArea(40, 50) if area != 2000 &#123; t.Error(\"测试失败\") &#125;&#125;func BenchmarkGetArea(t *testing.B) &#123; for i := 0; i &lt; t.N; i++ &#123; GetArea(40, 50) &#125;&#125; 执行测试命令，运行结果如下所示： 1234PS D:\\code&gt; go test -coverPASScoverage: 100.0% of statementsok _/D_/code 0.437s","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"94、Go语言 之Ratelimit服务流量限制","slug":"Golang/94、Go语言 之Ratelimit服务流量限制","date":"2016-04-02T19:06:08.000Z","updated":"2020-08-07T14:10:11.768Z","comments":true,"path":"2016/04/03/Golang/94、Go语言 之Ratelimit服务流量限制/","link":"","permalink":"https://www.zackaddy.xin/2016/04/03/Golang/94、Go语言 之Ratelimit服务流量限制/","excerpt":"","text":"Go语言 之Ratelimit服务流量限制计算机程序可依据其瓶颈分为磁盘 IO 瓶颈型，CPU 计算瓶颈型，⽹络带宽瓶颈型，分布式场景下有时候也会外部系统⽽导致⾃身瓶颈。 Web 系统打交道最多的是⽹络，⽆论是接收，解析⽤户请求，访问存储，还是把响应数据返回给⽤户，都是要⾛⽹络的。在没有 epoll/kqueue 之类的系统提供的 IO 多路复⽤接⼝之前，多个核⼼的现代计算机最头痛的是 C10k 问题，C10k 问题会导致计算机没有办法充分利⽤ CPU 来处理更多的⽤户连接，进⽽没有办法通过优化程序提升CPU利⽤率来处理更多的请求。 ⾃从 Linux 实现了 epoll，FreeBSD 实现了 kqueue ，这个问题基本解决了，我们可以借助内核提供的 API 轻松解决当年的 C10k 问题，也就是说如今如果你的程序主要是和⽹络打交道，那么瓶颈⼀定在⽤户程序⽽不在操作系统内核。 随着时代的发展，编程语⾔对这些系统调⽤⼜进⼀步进⾏了封装，如今做应⽤层开发，⼏乎不会在程序中看到 epoll 之类的字眼，⼤多数时候我们就只要聚焦在业务逻辑上就好。 Go语言的 net 库针对不同平台封装了不同的 syscall API，http 库⼜是构建在 net 库之上，所以在 Go语⾔中我们可以借助标准库，很轻松地写出⾼性能的 http 服务，下⾯是⼀个简单的 hello world 服务的代码： 1234567891011121314151617package mainimport ( \"io\" \"log\" \"net/http\")func sayhello(wr http.ResponseWriter, r *http.Request) &#123; wr.WriteHeader(200) io.WriteString(wr, \"hello world\")&#125;func main() &#123; http.HandleFunc(\"/\", sayhello) err := http.ListenAndServe(\":9090\", nil) if err != nil &#123; log.Fatal(\"ListenAndServe:\", err) &#125;&#125; 我们需要衡量⼀下这个 Web 服务的吞吐量，再具体⼀些，实际上就是接⼝的 QPS。借助 wrk，在家⽤电脑 Macbook Pro 上对这个 hello world 服务进⾏基准测试，Mac 的硬件情况如下： 12345678910111213141516CPU: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHzCore: 2Threads: 4Graphics/Displays: Chipset Model: Intel Iris Graphics 6100 Resolution: 2560 x 1600 Retina Memory Slots: Size: 4 GB Speed: 1867 MHz Size: 4 GB Speed: 1867 MHz Storage: Size: 250.14 GB (250,140,319,744 bytes) Media Name: APPLE SSD SM0256G Media Size: 250.14 GB (250,140,319,744 bytes) Medium Type: SSD 测试结果： 1234567891011121314151617181920212223242526272829~ ❯❯❯ wrk -c 10 -d 10s -t10 http://localhost:9090Running 10s test @ http://localhost:9090 10 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 339.99us 1.28ms 44.43ms 98.29% Req/Sec 4.49k 656.81 7.47k 73.36% 449588 requests in 10.10s, 54.88MB readRequests/sec: 44513.22Transfer/sec: 5.43MB~ ❯❯❯ wrk -c 10 -d 10s -t10 http://localhost:9090Running 10s test @ http://localhost:9090 10 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 334.76us 1.21ms 45.47ms 98.27% Req/Sec 4.42k 633.62 6.90k 71.16% 443582 requests in 10.10s, 54.15MB readRequests/sec: 43911.68Transfer/sec: 5.36MB~ ❯❯❯ wrk -c 10 -d 10s -t10 http://localhost:9090Running 10s test @ http://localhost:9090 10 threads and 10 connections Thread Stats Avg Stdev Max +/- Stdev Latency 379.26us 1.34ms 44.28ms 97.62% Req/Sec 4.55k 591.64 8.20k 76.37% 455710 requests in 10.10s, 55.63MB readRequests/sec: 45118.57Transfer/sec: 5.51MB 多次测试的结果在 4 万左右的 QPS 浮动，响应时间最多也就是 40ms 左右，对于⼀个 Web 程序来说，这已经是很不错的成绩了，我们只是照抄了别⼈的示例代码，就完成了⼀个⾼性能的 hello world 服务器，是不是很有成就感？ 这还只是家⽤ PC，线上服务器⼤多都是 24 核⼼起，32G 内存 +，CPU 基本都是 Intel i7。所以同样的程序在服务器上运⾏会得到更好的结果。 这⾥的 hello world 服务没有任何业务逻辑。真实环境的程序要复杂得多，有些程序偏⽹络 IO 瓶颈，例如⼀些 CDN 服务、Proxy 服务；有些程序偏 CPU/GPU 瓶颈，例如登陆校验服务、图像处理服务；有些程序瓶颈偏磁盘，例如专⻔的存储系统，数据库。 不同的程序瓶颈会体现在不同的地⽅，这⾥提到的这些功能单⼀的服务相对来说还算容易分析。如果碰到业务逻辑复杂代码量巨⼤的模块，其瓶颈并不是三下五除⼆可以推测出来的，还是需要从压⼒测试中得到更为精确的结论。 对于 IO/Network 瓶颈类的程序，其表现是⽹卡 / 磁盘 IO 会先于 CPU 打满，这种情况即使优化 CPU 的使⽤也不能提⾼整个系统的吞吐量，只能提⾼磁盘的读写速度，增加内存⼤⼩，提升⽹卡的带宽来提升整体性能。 ⽽ CPU 瓶颈类的程序，则是在存储和⽹卡未打满之前 CPU 占⽤率提前到达 100%，CPU 忙于各种计算任务，IO 设备相对则较闲。 ⽆论哪种类型的服务，在资源使⽤到极限的时候都会导致请求堆积，超时，系统 hang 死，最终伤害到终端⽤户。对于分布式的 Web 服务来说，瓶颈还不⼀定总在系统内部，也有可能在外部。 ⾮计算密集型的系统往往会在关系型数据库环节失守，⽽这时候 Web 模块本身还远远未达到瓶颈。不管我们的服务瓶颈在哪⾥，最终要做的事情都是⼀样的，那就是流量限制。 常⻅的流量限制⼿段流量限制的⼿段有很多，最常⻅的：漏桶、令牌桶两种： 漏桶是指我们有⼀个⼀直装满了⽔的桶，每过固定的⼀段时间即向外漏⼀滴⽔。如果你接到了这滴⽔，那么你就可以继续服务请求，如果没有接到，那么就需要等待下⼀滴⽔。 令牌桶则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数⽬可以按照需要消耗的资源进⾏相应的调整。如果没有令牌，可以选择等待，或者放弃。 这两种⽅法看起来很像，不过还是有区别的。漏桶流出的速率固定，⽽令牌桶只要在桶中有令牌，那就可以拿。也就是说令牌桶是允许⼀定程度的并发的，⽐如同⼀个时刻，有 100 个⽤户请求，只要令牌桶中有 100 个令牌，那么这 100 个请求全都会放过去。令牌桶在桶中没有令牌的情况下也会退化为漏桶模型。 令牌桶 实际应⽤中令牌桶应⽤较为⼴泛，开源界流⾏的限流器⼤多数都是基于令牌桶思想的。并且在此基础上进⾏了⼀定程度的扩充，⽐如 12github.com/juju/ratelimit 提供了⼏种不同特⾊的令牌桶填充⽅式：func NewBucket(fillInterval time.Duration, capacity int64) *Bucket 默认的令牌桶，fillInterval 指每过多⻓时间向桶⾥放⼀个令牌，capacity 是桶的容量，超过桶容量的部分会被直接丢弃。桶初始是满的。 1func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket 和普通的 NewBucket() 的区别是，每次向桶中放令牌时，是放 quantum 个令牌，⽽不是⼀个令牌。 1func NewBucketWithRate(rate float64, capacity int64) *Bucket 这个就有点特殊了，会按照提供的⽐例，每秒钟填充令牌数。例如 capacity 是 100，⽽ rate 是 0.1，那么每秒会填充 10 个令牌。 从桶中获取令牌也提供了⼏个 API： 1234567func (tb *Bucket) Take(count int64) time.Duration &#123;&#125;func (tb *Bucket) TakeAvailable(count int64) int64 &#123;&#125;func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) ( time.Duration, bool,) &#123;&#125;func (tb *Bucket) Wait(count int64) &#123;&#125;func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool &#123;&#125; 名称和功能都⽐较直观，这⾥就不再赘述了。相⽐于开源界更为有名的 Google 的 Java ⼯具库 Guava 中提供的 ratelimiter，这个库不⽀持令牌桶预热，且⽆法修改初始的令牌容量，所以可能个别极端情况下的需求⽆法满⾜。 但在明⽩令牌桶的基本原理之后，如果没办法满⾜需求，相信大家也可以很快对其进⾏修改并⽀持⾃⼰的业务场景。 原理从功能上来看，令牌桶模型实际上就是对全局计数的加减法操作过程，但使⽤计数需要我们⾃⼰加读写锁，有⼩⼩的思想负担。如果我们对 Go语⾔已经⽐较熟悉的话，很容易想到可以⽤ buffered channel 来完成简单的加令牌取令牌操作： 1var tokenBucket = make(chan struct&#123;&#125;, capacity) 每过⼀段时间向 tokenBucket 中添加 token，如果 bucket 已经满了，那么直接放弃： 12345678910111213fillToken := func() &#123; ticker := time.NewTicker(fillInterval) for &#123; select &#123; case &lt;-ticker.C: select &#123; case tokenBucket &lt;- struct&#123;&#125;&#123;&#125;: default: &#125; fmt.Println(\"current token cnt:\", len(tokenBucket), time.Now()) &#125; &#125;&#125; 把代码组合起来： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"time\")func main() &#123; var fillInterval = time.Millisecond * 10 var capacity = 100 var tokenBucket = make(chan struct&#123;&#125;, capacity) fillToken := func() &#123; ticker := time.NewTicker(fillInterval) for &#123; select &#123; case &lt;-ticker.C: select &#123; case tokenBucket &lt;- struct&#123;&#125;&#123;&#125;: default: &#125; fmt.Println(\"current token cnt:\", len(tokenBucket), time.Now()) &#125; &#125; &#125; go fillToken() time.Sleep(time.Hour)&#125; 看看运⾏结果： 123456789101112current token cnt: 98 2019-08-30 17:34:31.44304 +0800 CST m=+1.007173201current token cnt: 99 2019-08-30 17:34:31.4530154 +0800 CST m=+1.017148601current token cnt: 100 2019-08-30 17:34:31.462987 +0800 CST m=+1.027120201current token cnt: 100 2019-08-30 17:34:31.4729601 +0800 CST m=+1.037093301current token cnt: 100 2019-08-30 17:34:31.4829352 +0800 CST m=+1.047068401current token cnt: 100 2019-08-30 17:34:31.4939354 +0800 CST m=+1.058068601current token cnt: 100 2019-08-30 17:34:31.5028803 +0800 CST m=+1.067013501current token cnt: 100 2019-08-30 17:34:31.5128549 +0800 CST m=+1.076988101current token cnt: 100 2019-08-30 17:34:31.5248539 +0800 CST m=+1.088987101current token cnt: 100 2019-08-30 17:34:31.5348291 +0800 CST m=+1.098962301current token cnt: 100 2019-08-30 17:34:31.5437705 +0800 CST m=+1.107903701current token cnt: 100 2019-08-30 17:34:31.5537455 +0800 CST m=+1.117878701 在 1s 钟的时候刚好填满 100 个，没有太⼤的偏差。不过这⾥可以看到，Go 的定时器存在⼤约 0.001s 的误差，所以如果令牌桶⼤⼩在 1000 以上的填充可能会有⼀定的误差。对于⼀般的服务来说，这⼀点误差⽆关紧要。 上⾯的令牌桶的取令牌操作实现起来也⽐较简单，简化问题，我们这⾥只取⼀个令牌： 1234567891011121314151617func TakeAvailable(block bool) bool&#123; var takenResult bool if block &#123; select &#123; case &lt;-tokenBucket: takenResult = true &#125; &#125; else &#123; select &#123; case &lt;-tokenBucket: takenResult = true default: takenResult = false &#125; &#125; return takenResult&#125; ⼀些公司⾃⼰造的限流的轮⼦就是⽤上⾯这种⽅式来实现的，不过如果开源版 ratelimit 也如此的话，那我们也没什么可说的了。现实并不是这样的。 我们来思考⼀下，令牌桶每隔⼀段固定的时间向桶中放令牌，如果我们记下上⼀次放令牌的时间为 t1，和当时的令牌数 k1，放令牌的时间间隔为 ti，每次向令牌桶中放 x 个令牌，令牌桶容量为 cap。现在如果有⼈来调⽤ TakeAvailable 来取 n 个令牌，我们将这个时刻记为 t2。在 t2 时刻，令牌桶中理论上应该有多少令牌呢？伪代码如下： 12cur = k1 + ((t2 - t1)/ti) * xcur = cur &gt; cap ? cap : cur 我们⽤两个时间点的时间差，再结合其它的参数，理论上在取令牌之前就完全可以知道桶⾥有多少令牌了。那劳⼼费⼒地像本⼩节前⾯向 channel ⾥填充 token 的操作，理论上是没有必要的。 只要在每次 Take 的时候，再对令牌桶中的 token 数进⾏简单计算，就可以得到正确的令牌数。是不是很像惰性求值的感觉？ 在得到正确的令牌数之后，再进⾏实际的 Take 操作就好，这个 Take 操作只需要对令牌数进⾏简单的减法即可，记得加锁以保证并发安全。github.com/juju/ratelimit 这个库就是这样做的。 服务瓶颈和 QoS前⾯我们说了很多 CPU 瓶颈、IO 瓶颈之类的概念，这种性能瓶颈从⼤多数公司都有的监控系统中可以⽐较快速地定位出来，如果⼀个系统遇到了性能问题，那监控图的反应⼀般都是最快的。 虽然性能指标很重要，但对⽤户提供服务时还应考虑服务整体的 QoS。QoS 全称是 Quality of Service，顾名思义是服务质量。QoS 包含有可⽤性、吞吐量、时延、时延变化和丢失等指标。⼀般来讲我们可以通过优化系统，来提⾼ Web 服务的 CPU 利⽤率，从⽽提⾼整个系统的吞吐量。但吞吐量提⾼的同时，⽤户体验是有可能变差的。 ⽤户⻆度⽐较敏感的除了可⽤性之外，还有时延。虽然你的系统吞吐量⾼，但半天刷不开⻚⾯，想必会造成⼤量的⽤户流失。所以在⼤公司的Web服务性能指标中，除了平均响应时延之外，还会把响应时间的 95 分位，99 分位也拿出来作为性能标准。 平均响应在提⾼ CPU 利⽤率没受到太⼤影响时，可能 95 分位、99 分位的响应时间⼤幅度攀升了，那么这时候就要考虑提⾼这些 CPU 利⽤率所付出的代价是否值得了。在线系统的机器⼀般都会保持 CPU 有⼀定的余裕。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"3、mysql 之查看选择数据库","slug":"Mysql/3、mysql 之查看选择数据库","date":"2016-04-02T18:25:11.000Z","updated":"2020-08-07T14:10:11.850Z","comments":true,"path":"2016/04/03/Mysql/3、mysql 之查看选择数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/03/Mysql/3、mysql 之查看选择数据库/","excerpt":"","text":"Mysql 之查看选择数据库查看数据库MySQL数据库连接成功之后，就可以使用SQL语句来查看当前所有存在的数据库，显示的一些默认的数据库是在 MySQL安装完成之后，在其目录 data 自动创建的几个必要的数据库，输入SQL语句如下： 123456789101112mysql&gt; SHOW DATABASES;+--------------------+| Database ||--------------------|| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in setTime: 0.031s 使用“SHOW DATABASES;” 语句之行完之后，就可以看到，数据库表包含了5个数据库，mysql是必须的，它主要描述用户访问权限，用户经常使用test数据库做测试的工作，其他数据库将在后面的章节做一些介绍。这个命令起到一些小作用，可以帮助你查看创建的数据库是否创建成功，选择你创建的数据库等操作。 选择数据库如果你在你创建好的数据库里面创建表，对表坐一系列的操作，这个时候你需要使用到选择命令“USE”。比如我进入 test 数据库，输入语句如下： 123mysql&gt; USE test;You are now connected to database \"test\" as user \"root\"Time: 0.003s 使用“USE test;”语句之后，反馈出连接数据库成功，可以看出使用 root 用户连接到 “test” 数据了，并且输出连接时间。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"93、Go语言 之json用法讲解","slug":"Golang/93、Go语言 之json用法讲解","date":"2016-04-02T00:43:10.000Z","updated":"2020-08-07T14:10:11.768Z","comments":true,"path":"2016/04/02/Golang/93、Go语言 之json用法讲解/","link":"","permalink":"https://www.zackaddy.xin/2016/04/02/Golang/93、Go语言 之json用法讲解/","excerpt":"","text":"Go语言 之json用法讲解简介json格式可以算我们日常最常用的序列化格式之一了，Go语言作为一个由Google开发，号称互联网的C语言的语言，自然也对JSON格式支持很好。但是Go语言是个强类型语言，对格式要求极其严格而JSON格式虽然也有类型，但是并不稳定，Go语言在解析来源为非强类型语言时比如PHP等序列化的JSON时，经常遇到一些问题诸如字段类型变化导致无法正常解析的情况，导致服务不稳定。所以本篇的主要目的 挖掘Golang解析json的绝大部分能力 比较优雅的解决解析json时存在的各种问题 深入一下Golang解析json的过程 Golang解析JSON之Tag篇一个结构体正常序列化过后是什么样的呢？ 1234567891011121314151617181920212223242526272829package mainimport ( \"encoding/json\" \"fmt\") // Product 商品信息type Product struct &#123; Name string ProductID int64 Number int Price float64 IsOnSale bool&#125; func main() &#123; p := &amp;Product&#123;&#125; p.Name = \"Xiao mi 6\" p.IsOnSale = true p.Number = 10000 p.Price = 2499.00 p.ProductID = 1 data, _ := json.Marshal(p) fmt.Println(string(data))&#125; //结果&#123;\"Name\":\"Xiao mi 6\",\"ProductID\":1,\"Number\":10000,\"Price\":2499,\"IsOnSale\":true&#125; 何为Tag，tag就是标签，给结构体的每个字段打上一个标签，标签冒号前是类型，后面是标签名 123456789101112// Product _type Product struct &#123; Name string `json:\"name\"` ProductID int64 `json:\"-\"` // 表示不进行序列化 Number int `json:\"number\"` Price float64 `json:\"price\"` IsOnSale bool `json:\"is_on_sale,string\"`&#125; // 序列化过后，可以看见 &#123;\"name\":\"Xiao mi 6\",\"number\":10000,\"price\":2499,\"is_on_sale\":\"false\"&#125; 3. omitempty，tag里面加上omitempy，可以在序列化的时候忽略0值或者空值 123456789101112131415161718192021222324252627282930package main import ( \"encoding/json\" \"fmt\") // Product _type Product struct &#123; Name string `json:\"name\"` ProductID int64 `json:\"product_id,omitempty\"` Number int `json:\"number\"` Price float64 `json:\"price\"` IsOnSale bool `json:\"is_on_sale,omitempty\"`&#125; func main() &#123; p := &amp;Product&#123;&#125; p.Name = \"Xiao mi 6\" p.IsOnSale = false p.Number = 10000 p.Price = 2499.00 p.ProductID = 0 data, _ := json.Marshal(p) fmt.Println(string(data))&#125;// 结果&#123;\"name\":\"Xiao mi 6\",\"number\":10000,\"price\":2499&#125; 4. type，有些时候，我们在序列化或者反序列化的时候，可能结构体类型和需要的类型不一致，这个时候可以指定,支持string,number和boolean 123456789101112131415161718192021222324252627package main import ( \"encoding/json\" \"fmt\") // Product _type Product struct &#123; Name string `json:\"name\"` ProductID int64 `json:\"product_id,string\"` Number int `json:\"number,string\"` Price float64 `json:\"price,string\"` IsOnSale bool `json:\"is_on_sale,string\"`&#125; func main() &#123; var data = `&#123;\"name\":\"Xiao mi 6\",\"product_id\":\"10\",\"number\":\"10000\",\"price\":\"2499\",\"is_on_sale\":\"true\"&#125;` p := &amp;Product&#123;&#125; err := json.Unmarshal([]byte(data), p) fmt.Println(err) fmt.Println(*p)&#125;// 结果&lt;nil&gt;&#123;Xiao mi 6 10 10000 2499 true&#125; 自定义解析JSON很多时候，我们可能遇到这样的场景，就是远端返回的JSON数据不是你想要的类型，或者你想做额外的操作，比如在解析的过程中进行校验，或者类型转换，那么我们可以这样或者在解析过程中进行数据转换 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package main import ( \"bytes\" \"encoding/json\" \"fmt\") // Mail _type Mail struct &#123; Value string&#125; // UnmarshalJSON _func (m *Mail) UnmarshalJSON(data []byte) error &#123; // 这里简单演示一下，简单判断即可 if bytes.Contains(data, []byte(\"@\")) &#123; return fmt.Errorf(\"mail format error\") &#125; m.Value = string(data) return nil&#125; // UnmarshalJSON _func (m *Mail) MarshalJSON() (data []byte, err error) &#123; if m != nil &#123; data = []byte(m.Value) &#125; return&#125; // Phone _type Phone struct &#123; Value string&#125; // UnmarshalJSON _func (p *Phone) UnmarshalJSON(data []byte) error &#123; // 这里简单演示一下，简单判断即可 if len(data) != 11 &#123; return fmt.Errorf(\"phone format error\") &#125; p.Value = string(data) return nil&#125; // UnmarshalJSON _func (p *Phone) MarshalJSON() (data []byte, err error) &#123; if p != nil &#123; data = []byte(p.Value) &#125; return&#125; // UserRequest _type UserRequest struct &#123; Name string Mail Mail Phone Phone&#125; func main() &#123; user := UserRequest&#123;&#125; user.Name = \"ysy\" user.Mail.Value = \"yangshiyu@x.com\" user.Phone.Value = \"18900001111\" fmt.Println(json.Marshal(user))&#125; 为什么要这样？如果是客户端开发，需要开发大量的API，接收大量的JSON，在开发早期定义各种类型看起来是很大的工作量，不如写 if else 判断数据简单暴力。但是到开发末期，你会发现预先定义的方式能极大的提高你的代码质量，减少代码量。下面实例1和实例2，谁能减少代码一目了然 实例1，if else做数据校验 123456789101112131415161718192021222324// UserRequest _type UserRequest struct &#123; Name string Mail string Phone string&#125;func AddUser(data []byte) (err error) &#123; user := &amp;UserRequest&#123;&#125; err = json.Unmarshal(data, user) if err != nil &#123; return &#125; // if isMail(user.Mail) &#123; return fmt.Errorf(\"mail format error\") &#125; if isPhone(user.Phone) &#123; return fmt.Errorf(\"phone format error\") &#125; // TODO return&#125; 实例2，利用预先定义好的类型，在解析时就进行判断 1234567891011121314151617// UserRequest _type UserRequest struct &#123; Name string Mail Mail Phone Phone&#125; func AddUser(data []byte) &#123; user := &amp;UserRequest&#123;&#125; err = json.Unmarshal(data, user) if err != nil &#123; return &#125; // TODO &#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"2、mysql 之连接数据库","slug":"Mysql/2、mysql 之连接数据库","date":"2016-04-01T20:50:15.000Z","updated":"2020-08-07T14:10:11.847Z","comments":true,"path":"2016/04/02/Mysql/2、mysql 之连接数据库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/02/Mysql/2、mysql 之连接数据库/","excerpt":"","text":"Mysql 之连接数据库简介登录MySQL数据库有多种方式，GUI登录最方便，有特别多的App可以提供图形化工具登录MySQL，并且方便的查看数据信息 MySQL命令语法用户名是你登录的用户，主机名或者IP地址为可选项，如果是本地连接则不需要，远程连接需要填写，密码是对应用户的密码。 1mysql –u用户名 [–h主机名或者IP地址,-P端口号] –p密码 该命令是在命令行窗口下执行，而不是MySQL的命令行； 输入-p后可以直接跟上密码，也可以按回车，会提示你输入密码，二者都是相同的效果； –p密码选项不一定是要在最后； –u、-h、-p后无空格。 MySQL命令连接数据库首先将这个使用率高达80%以上的“mysql”命令工具简单的做一个讲解，在操作系统命令终端提示符下输入 mysql -h 127.0.0.1 -u用户名 -p密码，将出现一个如下的简单提示: 123456789101112131415→ mysql -h127.0.0.1 -P3306 -uroot -prootpasswordWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 99Server version: 5.7.14 MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; -h127.0.0.1 其中“-p”是参数，“rootpassword”，默认本地参数可忽略 -P3306 其中“-P”是参数(注意大写)，“3306”，默认本地参数可忽略 -uroot 其中“-u”是参数，“root” 是用户名。 -prootpassword 其中“-p”是参数，“rootpassword” 是用户名。 Commands end with ; or \\g. 命令的结束符，用“;”或者“\\g”符号结束，但是冒号结束退出是不行的。 Your MySQL connection id is 99 其中 id 表示客户端的连接 ID，该数据记录了 MySQL 服务到目前为止的连接次数，每次新连接都会自动加 1。由于数据库服务是我安装了好久的，所以当前 ID 值为 99。 Server version: 5.7.14 MySQL MySQL的版本。 Community Server (GPL) 表示 MySQL 软件是社区版。 Type &#39;help;&#39; or &#39;\\h&#39; for help. 表示输入 “help;” 或者 “\\h” 命令可以查看帮助信息。 Type &#39;\\c&#39; to clear the current input statement. 表示输入“\\c” 命令可以清除前面的命令。 你只需要在mysql&gt;命令中输入 SQL 语句，同时并以分号“;”结束。最后摁Enter键即可操作 MySQL软件。 当然，具体的版本和连接信息可能不同，但都可以使用这个实用程序。请注意: 命令输入在mysql&gt; 之后； 用q\\、quit、exit三种命令可以退出命令行实用程序； 帮助命令，输入help或\\h获得帮助，可以获得其它特定的命令的帮助(如，输入help select获得使用SELECT语句的帮助)； 开启MySQL的远程帐号用GUI连接数据库如果报下面错误，是你的 MySQL远程连接账号没有开启。 123Unable to connect to host 192.168.188.114, or the request timed out.Be sure that the address is correct and that you have the necessary privileges, or try increasing the connection timeout (currently 10 seconds).MySQL said: Host '192.168.188.106' is not allowed to connect to this MariaDB server 通过下面的命令，解决不能连接的错误，进入 MySQL 执行下面语句。 1234# 你想root使用123456从'192.168.188.106'主机连接到mysql服务器 wabg库下面所有表的话。MySQL&gt; grant all PRIVILEGES on wabg.* to root@'192.168.188.106' identified by '123456' WITH GRANT OPTION;# 你想myuser使用mypassword从任何主机连接到mysql服务器的话MySQL&gt; grant all PRIVILEGES on *.* to 'myuser'@'%' identified by 'mypassword' WITH GRANT OPTION; 上面的语句表示将 wabg 数据库的所有权限授权给 root 这个用户，允许 root 用户在 192.168.1.106 这个 IP 进行远程登陆，并设置 root 用户的密码为 123456 。 all PRIVILEGES 表示赋予所有的权限给指定用户，这里也可以替换为赋予某一具体的权限 wabg.* 表示上面的权限是针对于哪个表的，wabg指的是数据库，后面的 * 表示对于所有的表，由此可以推理出： 对于全部数据库的全部表授权为“ . ” 对于某一数据库的全部表授权为“ 数据库名.* ” 对于某一数据库的某一表授权为“数据库名.表名” root 表示你要给哪个用户授权，这个用户可以是存在的用户，也可以是不存在的用户。 192.168.188.106 表示允许远程连接的 IP 地址，如果想不限制链接的 IP 则设置为“%”即可。 123456 为用户的密码。 如何开启MySQL的远程帐号？执行了上面的语句后，再执行下面的语句，方可立即生效。 1MySQL&gt; flush privileges; 当你报下面错误，提示您的密码不满足当前的策略要求。错误如下： 123ERROR 1819 (HY000): Your password does not satisfy the current policy requirements# 或者mysqladmin: unable to change password; error: 'Your password does not satisfy the current policy requirements' 解决方法：可以按照现有策略设置密码，也可以更改密码策略。 1234# 更改密码策略为LOWMySQL&gt; set global validate_password_policy=0;# 更改密码长度 密码最小长度为4MySQL&gt; set global validate_password_length=4; 进入 MySQL 查看你的密码验证策略 12345678910111213mysql&gt; SHOW VARIABLES LIKE 'validate_password%';+--------------------------------------+-------+| Variable_name | Value |+--------------------------------------+-------+| validate_password_check_user_name | OFF | | validate_password_dictionary_file | | | validate_password_length | 4 | | validate_password_mixed_case_count | 1 | | validate_password_number_count | 1 | | validate_password_policy | LOW | | validate_password_special_char_count | 1 | +--------------------------------------+-------+7 rows in set (0.00 sec) validate_password_check_user_name 不得使用当前会话用户名作为密码的一部分 validate_password_dictionary_file 验证密码强度的字典文件路径 validate_password_length 密码最小长度 validate_password_mixed_case_count 密码至少要包含的小写字母个数和大写字母个数 validate_password_number_count 密码至少要包含的数字个数 validate_password_policy 密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG 0/LOW：只检查长度。 1/MEDIUM：检查长度、数字、大小写、特殊字符。 2/STRONG：检查长度、数字、大小写、特殊字符字典文件。 validate_password_special_char_count 密码至少要包含的特殊字符数 MySQL修改密码登陆mysql修改1234567修改密码mysql&gt; alter user 'root'@'localhost' identified by '123';刷新权限mysql&gt; flush privileges; 不登陆mysql之windows修改密码 打开cmd 输入 mysqld –skip-grant-tables 开启另一个cmd 输入 mysql，不需要密码直接连接到mysql mysql&gt; update user set password=password(‘123456’) where user=’root’ and host=’localhost’; 不登陆mysql之linux修改密码 service mysqld stop 修改mysql的配置文件my.conf, 在文件的[mysqld]标签下添加一句：skip-grant-tables 重启数据库 service mysqld start 重启数据库 service mysqld start 进入到mysql数据库 mysql -u root 运行语句：use mysql; 继续运行语句：update mysql.user set authentication_string=password(‘root_password’) where user=’root’; root_password替换成你想要的密码 把第2步添加的东西删除 重启mysql","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"1、mysql 之启动、停止、重启服务","slug":"Mysql/1、mysql 之启动、停止、重启服务","date":"2016-04-01T04:52:45.000Z","updated":"2020-08-07T14:10:11.844Z","comments":true,"path":"2016/04/01/Mysql/1、mysql 之启动、停止、重启服务/","link":"","permalink":"https://www.zackaddy.xin/2016/04/01/Mysql/1、mysql 之启动、停止、重启服务/","excerpt":"","text":"Mysql 之启动、停止、重启服务Mac在Mac系统下如果你官方下载安装就可以在系统偏好设置&gt; MySQL里面进行操作 123mysql.server start ＃ 1.启动 mysql.server stop ＃ 2.停止 mysql.server restart ＃ 3.重启 Linux1234启动：service mysqld start停止：service mysqld stop重启：service mysqld restart查看状态：service mysqld status Windows12345678C:\\&gt; mysqld —remove以上命令默认MySQL服务名为MySQL。如果Windows对应服务名不同，则你可以使用以下命令显示提供服务名：C:\\&gt; mysqld —install service_nameC:\\&gt; mysqld —install service_name —defaults–file=C:\\file_nameC:\\&gt; net start service_nameC:\\&gt; mysqld —remove service_nameC:\\&gt; net stop service_name","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/tags/Mysql/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://www.zackaddy.xin/categories/Mysql/"}]},{"title":"92、Go语言 之依赖注入inject库","slug":"Golang/92、Go语言 之依赖注入inject库","date":"2016-03-31T21:10:29.000Z","updated":"2020-08-07T14:10:11.768Z","comments":true,"path":"2016/04/01/Golang/92、Go语言 之依赖注入inject库/","link":"","permalink":"https://www.zackaddy.xin/2016/04/01/Golang/92、Go语言 之依赖注入inject库/","excerpt":"","text":"Go语言 之依赖注入inject库前面己经对反射的基本概念和相关 API 进行了讲解，本节结合一个非常著名的包 inject 展开讲解，inject 借助反射提供了对 2 种类型实体的注入：函数和结构。Go 著名的 Web 框架 martini 的依赖注入使用的就是这个包。 依赖注入和控制反转在介绍 inject 之前先简单介绍“依赖注入”和“控制反转”的概念。正常情况下，对函数或方法的调用是调用方的主动直接行为，调用方清楚地知道被调的函数名是什么，参数有哪些类型，直接主动地调用；包括对象的初始化也是显式地直接初始化。 所谓的“控制反转”就是将这种主动行为变成间接的行为，主调方不是直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为我们称为“控制反转”，控制反转可以解藕调用方和被调方。 “库”和“框架”能很好地解释“控制反转”的概念。一般情况下，使用库的程序是程序主动地调用库的功能，但使用框架的程序常常由框架驱动整个程序，在框架下写的业务代码是被框架驱动的，这种模式就是“控制反转”。 “依赖注入”是实现“控制反转”的一种方法，如果说“控制反转”是一种设计思想，那么“依赖注入”就是这种思想的一种实现，通过注入的参数或实例的方式实现控制反转。如果没有特殊说明，我们通常说的“依赖注入”和“控制反转”是一个东西。 大家可能会疑惑，为什么不直接光明正大地调用，而非要拐弯抹角地进行间接调用，控制反转的价值在哪里呢？一句话“解耦”，有了控制反转就不需要调用者将代码写死，可以让控制反转的框架代码读取配置，动态地构建对象，这一点在 Java 的 Spring 框架中体现得尤为突出。 控制反转是解决复杂问题一种方法，特别是在 Web 框架中为路由和中间件的灵活注入提供了很好的方法。但是软件开发没有银弹，当问题足够复杂时，应该考虑的是服务拆分，而不是把复杂的逻辑用一个“大盒子”装起来，看起来干净了，但也只是看起来干净，实现还是很复杂，这也是使用框架带来的副作用。 inject 实践inject 是 Go语言依赖注入的实现，它实现了对结构（struct）和函数的依赖注入。在介绍具体实现之前，先来想一个问题，如何通过一个字符串类型的函数名调用函数。Go 没有 Java 中的 Class.forName 方法可以通过类名直接构造对象，所以这种方法是行不通的，能想到的方法就是使用 map 实现一个字符串到函数的映射，代码如下： 1234567891011func fl() &#123; println (\"fl\")&#125;func f2 () &#123; println (\"f2\")&#125;funcs := make(map[string] func ())funcs [\"fl\"] = flfuncs [\"f2\"] = flfuncs [\"fl\"]()funcs [\"f2\"]() 但是这有个缺陷，就是 map 的 Value 类型被写成 func()，不同参数和返回值的类型的函数并不能通用。将 map 的 Value 定义为 interface{} 空接口类型是否能解决该问题？可以解决该问题，但需要借助类型断言或反射来实现，通过类型断言实现等于又绕回去了，反射是一种可行的办法。inject 包借助反射实现函数的注入调用，下面通过一个例子来看一下。 123456789101112131415161718192021package mainimport ( \"fmt\" \"github.com/codegangsta/inject\")type Sl interface&#123;&#125;type S2 interface&#123;&#125;func Format(name string, company S1, level S2, age int) &#123; fmt.Printf(\"name ＝ %s, company=%s, level=%s, age ＝ %d!\\n\", name, company, level, age)&#125;func main() &#123; //控制实例的创建 inj := inject.New() //实参注入 inj.Map(\"tom\") inj.MapTo(\"tencent\", (*S1) (nil)) inj.MapTo(\"T4\", (*S2) (nil)) inj.Map(23) //函数反转调用 inj.Invoke(Format)&#125; 执行结果： 1name=tom, cornpany=tencent, level=T4, age=23! 可见 inject 提供了一种注入参数调用函数的通用功能，inject.New() 相当于创建了一个控制实例，由其来实现对函数的注入调用。inject 包不但提供了对函数的注入，还实现了对 struct 类型的注入，看下一个示例。 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"github.com/codegangsta/inject\")type S1 interface&#123;&#125;type S2 interface&#123;&#125;type Staff struct &#123; Name string `inject` Company S1 `inject` Level S2 `inject` Age int `inject`&#125;func main() &#123; //创建被注入实例 s := Staff &#123;&#125; //控制实例的创建 inj :＝ inject.New() //初始化注入值 inj.Map (\"tom\") inj.MapTo (\"tencent\", (*S1) (nil)) inj.MapTo (\"T4\",(＊S2) (nil)) inj.Map(23) //实现对 struct 注入 inj.Apply (&amp;s) //打印结果 fmt.Printf (\"s ＝ %v\\n\", s)&#125; 执行结果： 1s = &#123;tom tencent T4 23&#125; 可以看到 inject 提供了一种对结构类型的通用注入方法。至此，我们仅仅从宏观层面了解 iniect 能做什么，下面从源码实现角度来分析 inject。 inject 原理分析inject 包只有 178 行代码（包括注释），却提供了一个完美的依赖注入实现，下面采用自顶向下的方法分析其实现原理。入口函数 Newinject.New() 函数构建一个具体类型 injector 实例作为内部注入引擎，返回的是一个 Injector 类型的接口。这里也体现了一种面向接口的设计思想：对外暴露接口方法，对外隐藏内部实现。示例如下： 12345func New() Injector &#123; return &amp;injector &#123; values : make(map[reflect.Type)reflect.Value), &#125;&#125; 接口设计下面来看一下具体的接口设计，Injector 暴露了所有方法给外部使用者，这些方法又可以归纳为两大类。第一类方法是对参数注入进行初始化，将结构类型的字段的注入和函数的参数注入统一成一套方法实现；第二类是专用注入实现，分别是生成结构对象和调用函数方法。 在代码设计上，inject 将接口的粒度拆分得很细，将多个接口组合为一个大的接口，这也符合 Go 的 Duck 类型接口设计的原则。injector 按照上述方法拆分为三个接口。示例如下： 12345678910type Injector interface &#123; //抽象生成注入结构实例的接口 Applicator //抽象函数调用的接口 Invoker //抽象注入参数的接口 TypeMapper //实现一个注入实例链， 下游的能覆盖上游的类型 SetParent(Injector)&#125; TypeMapper 接口实现对注入参数操作的汇总，包括设置和查找相关的类型和值的方法。注意：无论函数的实参，还是结构的字段，在 inject 内部，都存放在 map[reflect.Type]reflect.Value 类型的 map 里面，具体实现在后面介绍 injector 时会讲解。 12345678type TypeMapper interface &#123; //如下三个方法是设直参数 Map(interface&#123;&#125;) TypeMapper MapTo(interface&#123;&#125;, interface&#123;&#125;) TypeMapper Set(reflect.Type, reflect.Value) TypeMapper //查找参数 Get(reflect.Type) reflect.Value&#125; Invoker 接口中 Invoke 方法是对被注入实参函数的调用： 123type Invoker interface &#123; Invoke (interface&#123;&#125;) ([]reflect.Value, error)&#125; Applicator 接口中 Apply 方法实现对结构的注入： 123type Applicator interface &#123; Apply(interface&#123;&#125;) error&#125; 下面梳理了整个 inject 包的处理流程：通过 inject.New() 创建注入引擎，注入引擎被隐藏，返回的是 Injector 接口类型变量。调用 TypeMapper 接口（Injector 内嵌 TypeMapper）的方法注入 struct 的字段值或函数的实参值。调用 Invoker 方法执行被注入的函数，或者调用 Applicator 接口方法获得被注入后的结构实例。 内部实现下面具体看一下 inject 内部注入引擎 injector 的实现，首先看一下 injector 的数据结构。 1234type injector struct &#123; values map[reflect.Type]reflect.Value parent Injector&#125; values 里面存放的可以是被注入 struct 的字段类型和值，也可以是函数实参的类型和值。注意：values 是以 reflect.Type 为 Key 的 map，如果一个结构的字段类型相同，则后面注入的参数会覆盖前面的参数，规避办法是使用 MapTo 方法，通过抽象出一个接口类型来避免被覆盖。 1234func (i *injector) MapTo (val interface&#123;&#125;, ifacePtr interface&#123;&#125;) TypeMapper &#123; i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf (val) return i&#125; injector 里面的 parent 的作用是实现多个注入引擎，其构成了一个链。 下面重点分析 injector 对函数的注入实现。示例如下： 1234567891011121314151617func (inj *injector) Invoke(f interface&#123;&#125;) ([]reflect.Value, error) &#123; //获取函数类型的 Type t := reflect.TypeOf(f) //构造一个存放函数实参 Value 值的数纽 var in = make([]reflect.Value, t.NumIn()) //使用反射获取函数实参 reflect.Type，逐个去 injector 中查找注入的 Value 值 for i := O; i &lt; t.NumIn(); i++ &#123; argType := t.In(i) val := inj.Get(argType) if !val.IsValid() &#123; return nil, fmt.Errorf(\"Value not found for type %v\", argType) &#125; in[i] = val &#125; //反射调用函数 return reflect.ValueOf(f).Call(in), nil&#125; inject 对函数注入调用实现很简洁，就是从 injector 里面获取函数实参，然后调用函数。 通过对 inject 包的分析，认识到其“短小精悍”、功能强大，这些实现的基础是依靠反射。但同时注意到包含反射的代码相对来说复杂难懂，虽然 inject 的实现只有短短 200 行代码，但阅读起来并不是很流畅。所以说反射是一把双刃剑，好用但代码不好读。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"91、Go语言 之通过反射reflect调用函数","slug":"Golang/91、Go语言 之通过反射reflect调用函数","date":"2016-03-30T17:13:27.000Z","updated":"2020-08-07T14:10:11.768Z","comments":true,"path":"2016/03/31/Golang/91、Go语言 之通过反射reflect调用函数/","link":"","permalink":"https://www.zackaddy.xin/2016/03/31/Golang/91、Go语言 之通过反射reflect调用函数/","excerpt":"","text":"Go语言 之通过反射reflect调用函数如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将参数使用反射值对象的切片 []reflect.Value 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。 下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。 反射调用函数： 12345678910111213141516171819package mainimport ( \"fmt\" \"reflect\")// 普通函数func add(a, b int) int &#123; return a + b&#125;func main() &#123; // 将函数包装为反射值对象 funcValue := reflect.ValueOf(add) // 构造函数参数, 传入两个整型值 paramList := []reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125; // 反射调用函数 retList := funcValue.Call(paramList) // 获取第一个返回值, 取整数值 fmt.Println(retList[0].Int())&#125; 代码说明如下： 第 9～12 行，定义一个普通的加法函数。 第 17 行，将 add 函数包装为反射值对象。 第 20 行，将 10 和 20 两个整型值使用 reflect.ValueOf 包装为 reflect.Value，再将反射值对象的切片 []reflect.Value 作为函数的参数。 第 23 行，使用 funcValue 函数值对象的 Call() 方法，传入参数列表 paramList 调用 add() 函数。 第 26 行，调用成功后，通过 retList[0] 取返回值的第一个参数，使用 Int 取返回值的整数值。提示反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"90、Go语言 之通过反射reflect类型信息创建实例","slug":"Golang/90、Go语言 之通过反射reflect类型信息创建实例","date":"2016-03-30T04:41:27.000Z","updated":"2020-08-07T14:10:11.767Z","comments":true,"path":"2016/03/30/Golang/90、Go语言 之通过反射reflect类型信息创建实例/","link":"","permalink":"https://www.zackaddy.xin/2016/03/30/Golang/90、Go语言 之通过反射reflect类型信息创建实例/","excerpt":"","text":"Go语言 之通过反射reflect类型信息创建实例当已知 reflect.Type 时，可以动态地创建这个类型的实例，实例的类型为指针。例如 reflect.Type 的类型为 int 时，创建 int 的指针，即*int，代码如下： 1234567891011121314package mainimport ( \"fmt\" \"reflect\")func main() &#123; var a int // 取变量a的反射类型对象 typeOfA := reflect.TypeOf(a) // 根据反射类型对象创建类型实例 aIns := reflect.New(typeOfA) // 输出Value的类型和种类 fmt.Println(aIns.Type(), aIns.Kind())&#125; 代码输出如下： 1*int ptr 代码说明如下： 第 13 行，获取变量 a 的反射类型对象。 第 16 行，使用 reflect.New() 函数传入变量 a 的反射类型对象，创建这个类型的实例值，值以 reflect.Value 类型返回。这步操作等效于：new(int)，因此返回的是 *int 类型的实例。 第 19 行，打印 aIns 的类型为 *int，种类为指针。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"89、Go语言通过反射reflect修改变量的值","slug":"Golang/89、Go语言通过反射reflect修改变量的值","date":"2016-03-28T21:56:56.000Z","updated":"2020-08-07T14:10:11.767Z","comments":true,"path":"2016/03/29/Golang/89、Go语言通过反射reflect修改变量的值/","link":"","permalink":"https://www.zackaddy.xin/2016/03/29/Golang/89、Go语言通过反射reflect修改变量的值/","excerpt":"","text":"Go语言通过反射reflect修改变量的值Go语言中类似 x、x.f[1] 和 *p 形式的表达式都可以表示变量，但是其它如 x + 1 和 f(2) 则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。 对于 reflect.Values 也有类似的区别。有一些 reflect.Values 是可取地址的；其它一些则不可以。考虑以下的声明语句： 12345x := 2 // value type variable?a := reflect.ValueOf(2) // 2 int nob := reflect.ValueOf(x) // 2 int noc := reflect.ValueOf(&amp;x) // &amp;x *int nod := c.Elem() // 2 int yes (x) 其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的 Value。 我们可以通过调用 reflect.Value 的 CanAddr 方法来判断其是否可以被取地址： 1234fmt.Println(a.CanAddr()) // \"false\"fmt.Println(b.CanAddr()) // \"false\"fmt.Println(c.CanAddr()) // \"false\"fmt.Println(d.CanAddr()) // \"true\" 每当我们通过指针间接地获取的 reflect.Value 都是可取地址的，即使开始的是一个不可取地址的 Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice 的索引表达式 e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。 以此类推，reflect.ValueOf(e).Index(i) 对于的值也是可取地址的，即使原始的 reflect.ValueOf(e) 不支持也没有关系。 使用 reflect.Value 对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。 判定及获取元素的相关方法使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。 反射值对象的判定及获取元素的方法方法名| 备 注Elem() Value| 取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 ValueAddr() Value| 对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机CanAddr() bool| 表示值是否可寻址CanSet() bool| 返回值能否被修改。要求值可寻址且是导出的字段 值修改相关方法使用 reflect.Value 修改值的相关方法如下表所示。 反射值对象修改值的方法Set(x Value)| 将值设置为传入的反射值对象的值–|–Setlnt(x int64)| 使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机SetUint(x uint64)| 使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机SetFloat(x float64)| 使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机SetBool(x bool)| 使用 bool 设置值。当值的类型不是 bod 时会发生宕机SetBytes(x []byte)| 设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机SetString(x string)| 设置字符串值。当值的类型不是 string 时会发生宕机以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。 在已知值的类型时，应尽量使用值对应类型的反射设置值。 值可修改条件之一：可被寻址通过反射修改变量值的前提条件之一：这个值必须可以被寻址。简单地说就是这个变量必须能被修改。示例代码如下： 123456789101112package mainimport ( \"reflect\")func main() &#123; // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象 valueOfA := reflect.ValueOf(a) // 尝试将a修改为1(此处会发生崩溃) valueOfA.SetInt(1)&#125; 程序运行崩溃，打印错误： 1panic: reflect: reflect.Value.SetInt using unaddressable value 报错意思是：SetInt 正在使用一个不能被寻址的值。从 reflect.ValueOf 传入的是 a 的值，而不是 a 的地址，这个 reflect.Value 当然是不能被寻址的。将代码修改一下，重新运行： 1234567891011121314151617package mainimport ( \"fmt\" \"reflect\")func main() &#123; // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象(a的地址) valueOfA := reflect.ValueOf(&amp;a) // 取出a地址的元素(a的值) valueOfA = valueOfA.Elem() // 修改a的值为1 valueOfA.SetInt(1) // 打印a的值 fmt.Println(valueOfA.Int())&#125; 代码输出如下： 11 下面是对代码的分析： 第 14 行中，将变量 a 取值后传给 reflect.ValueOf()。此时 reflect.ValueOf() 返回的 valueOfA 持有变量 a 的地址。 第 17 行中，使用 reflect.Value 类型的 Elem() 方法获取 a 地址的元素，也就是 a 的值。reflect.Value 的 Elem() 方法返回的值类型也是 reflect.Value。 第 20 行，此时 valueOfA 表示的是 a 的值且可以寻址。使用 SetInt() 方法设置值时不再发生崩溃。 第 23 行，正确打印修改的值。提示当 reflect.Value 不可寻址时，使用 Addr() 方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的 Addr() 方法类似于语言层的&amp;操作；Elem() 方法类似于语言层的*操作，但并不代表这些方法与语言层操作等效。值可修改条件之一：被导出结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改，代码如下：123456789101112131415package mainimport ( \"reflect\")func main() &#123; type dog struct &#123; legCount int &#125; // 获取dog实例的反射值对象 valueOfDog := reflect.ValueOf(dog&#123;&#125;) // 获取legCount字段的值 vLegCount := valueOfDog.FieldByName(\"legCount\") // 尝试设置legCount的值(这里会发生崩溃) vLegCount.SetInt(4)&#125; 程序发生崩溃，报错： 1panic: reflect: reflect.Value.SetInt using value obtained using unexported field 报错的意思是：SetInt() 使用的值来自于一个未导出的字段。 为了能修改这个值，需要将该字段导出。将 dog 中的 legCount 的成员首字母大写，导出 LegCount 让反射可以访问，修改后的代码如下： 123type dog struct &#123; LegCount int&#125; 然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下： 1vLegCount := valueOfDog.FieldByName(\"LegCount\") 再次运行程序，发现仍然报错： 1panic: reflect: reflect.Value.SetInt using unaddressable value 这个错误表示第 13 行构造的 valueOfDog 这个结构体实例不能被寻址，因此其字段也不能被修改。修改代码，取结构体的指针，再通过 reflect.Value 的 Elem() 方法取到值的反射值对象。修改后的完整代码如下： 12345678910111213141516171819package mainimport ( \"reflect\" \"fmt\")func main() &#123; type dog struct &#123; LegCount int &#125; // 获取dog实例地址的反射值对象 valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;) // 取出dog实例地址的元素 valueOfDog = valueOfDog.Elem() // 获取legCount字段的值 vLegCount := valueOfDog.FieldByName(\"LegCount\") // 尝试设置legCount的值(这里会发生崩溃) vLegCount.SetInt(4) fmt.Println(vLegCount.Int())&#125; 代码输出如下： 14 代码说明如下： 第 11 行，将 LegCount 首字母大写导出该字段。 第 14 行，获取 dog 实例指针的反射值对象。 第 17 行，取 dog 实例的指针元素，也就是 dog 的实例。 第 20 行，取 dog 结构体中 LegCount 字段的成员值。 第 23 行，修改该成员值。 第 25 行，打印该成员值。 值的修改从表面意义上叫可寻址，换一种说法就是值必须“可被设置”。那么，想修改变量值，一般的步骤是： 取这个变量的地址或者这个变量所在的结构体已经是指针类型。 使用 reflect.ValueOf 进行值包装。 通过 Value.Elem() 获得指针值指向的元素值对象（Value），因为值对象（Value）内部对象为指针时，使用 set 设置时会报出宕机错误。 使用 Value.Set 设置值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"88、Go语言 之判断反射reflect值的空IsNil()和有效性IsValid()","slug":"Golang/88、Go语言 之判断反射reflect值的空IsNil()和有效性IsValid()","date":"2016-03-27T21:50:52.000Z","updated":"2020-08-07T14:10:11.766Z","comments":true,"path":"2016/03/28/Golang/88、Go语言 之判断反射reflect值的空IsNil()和有效性IsValid()/","link":"","permalink":"https://www.zackaddy.xin/2016/03/28/Golang/88、Go语言 之判断反射reflect值的空IsNil()和有效性IsValid()/","excerpt":"","text":"Go语言 之判断反射reflect值的空IsNil()和有效性IsValid()反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。 反射值对象的零值和有效性判断方法方 法| 说 明–|–IsNil() bool| 返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作IsValid() bool| 判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。下面的例子将会对各种方式的空指针进行 IsNil() 和 IsValid() 的返回值判定检测。同时对结构体成员及方法查找 map 键值对的返回值进行 IsValid() 判定，参考下面的代码。 反射值对象的零值和有效性判断： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"reflect\")func main() &#123; // *int的空指针 var a *int fmt.Println(\"var a *int:\", reflect.ValueOf(a).IsNil()) // nil值 fmt.Println(\"nil:\", reflect.ValueOf(nil).IsValid()) // *int类型的空指针 fmt.Println(\"(*int)(nil):\", reflect.ValueOf((*int)(nil)).Elem().IsValid()) // 实例化一个结构体 s := struct&#123;&#125;&#123;&#125; // 尝试从结构体中查找一个不存在的字段 fmt.Println(\"不存在的结构体成员:\", reflect.ValueOf(s).FieldByName(\"\").IsValid()) // 尝试从结构体中查找一个不存在的方法 fmt.Println(\"不存在的结构体方法:\", reflect.ValueOf(s).MethodByName(\"\").IsValid()) // 实例化一个map m := map[int]int&#123;&#125; // 尝试从map中查找一个不存在的键 fmt.Println(\"不存在的键：\", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid())&#125; 代码输出如下： 123456var a *int: truenil: false(*int)(nil): false不存在的结构体成员: false不存在的结构体方法: false不存在的键： false 代码说明如下： 第 11 行，声明一个 *int 类型的指针，初始值为 nil。 第 12 行，将变量 a 包装为 reflect.Value 并且判断是否为空，此时变量 a 为空指针，因此返回 true。 第 15 行，对 nil 进行 IsValid() 判定（有效性判定），返回 false。 第 18 行，(int)(nil) 的含义是将 nil 转换为 *int，也就是int 类型的空指针。此行将 nil 转换为 int 类型，并取指针指向元素。由于 nil 不指向任何元素，int 类型的 nil 也不能指向任何元素，值不是有效的。因此这个反射值使用 Isvalid() 判断时返回 false。 第 21 行，实例化一个结构体。 第 24 行，通过 FieldByName 查找 s 结构体中一个空字符串的成员，如成员不存在，IsValid() 返回 false。 第 27 行，通过 MethodByName 查找 s 结构体中一个空字符串的方法，如方法不存在，IsValid() 返回 false。 第 30 行，实例化一个 map，这种写法与 make 方式创建的 map 等效。 第 33 行，MapIndex() 方法能根据给定的 reflect.Value 类型的值查找 map，并且返回查找到的结果。 IsNil() 常被用于判断指针是否为空；IsValid() 常被用于判定返回值是否有效。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"87、Go语言 之通过反射reflect访问结构体成员的值","slug":"Golang/87、Go语言 之通过反射reflect访问结构体成员的值","date":"2016-03-27T03:55:33.000Z","updated":"2020-08-07T14:10:11.766Z","comments":true,"path":"2016/03/27/Golang/87、Go语言 之通过反射reflect访问结构体成员的值/","link":"","permalink":"https://www.zackaddy.xin/2016/03/27/Golang/87、Go语言 之通过反射reflect访问结构体成员的值/","excerpt":"","text":"Go语言 之通过反射reflect访问结构体成员的值反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。 反射值对象的成员访问方法方 法| 备 注–|–Field(i int) Value| 根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机NumField() int| 返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机FieldByName(name string) Value| 根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机FieldByIndex(index []int) Value| 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体或索引超界时发生宕机FieldByNameFunc(match func(string) bool) Value| 根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机下面代码构造一个结构体包含不同类型的成员。通过 reflect.Value 提供的成员访问函数，可以获得结构体值的各种数据。 反射访问结构体成员值： 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"reflect\")// 定义结构体type dummy struct &#123; a int b string // 嵌入字段 float32 bool next *dummy&#125;func main() &#123; // 值包装结构体 d := reflect.ValueOf(dummy&#123; next: &amp;dummy&#123;&#125;, &#125;) // 获取字段数量 fmt.Println(\"NumField\", d.NumField()) // 获取索引为2的字段(float32字段) floatField := d.Field(2) // 输出字段类型 fmt.Println(\"Field\", floatField.Type()) // 根据名字查找字段 fmt.Println(\"FieldByName(\\\"b\\\").Type\", d.FieldByName(\"b\").Type()) // 根据索引查找值中, next字段的int字段的值 fmt.Println(\"FieldByIndex([]int&#123;4, 0&#125;).Type()\", d.FieldByIndex([]int&#123;4, 0&#125;).Type())&#125; 代码说明如下： 第 9 行，定义结构体，结构体的每个字段的类型都不一样。 第 24 行，实例化结构体并包装为 reflect.Value 类型，成员中包含一个 *dummy 的实例。 第 29 行，获取结构体的字段数量。 第 32 和 35 行，获取索引为2的字段值（float32 字段），并且打印类型。 第 38 行，根据b字符串，查找到 b 字段的类型。 第 41 行，[]int{4,0} 中的 4 表示，在 dummy 结构中索引值为 4 的成员，也就是 next。next 的类型为 dummy，也是一个结构体，因此使用 []int{4,0} 中的 0 继续在 next 值的基础上索引，结构为 dummy 中索引值为 0 的 a 字段，类型为 int。 代码输出如下： 1234NumField 5Field float32FieldByName(\"b\").Type stringFieldByIndex([]int&#123;4, 0&#125;).Type() int","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"86、Go语言 之通过反射reflect.ValueOf()和reflect.Value获取值信息","slug":"Golang/86、Go语言 之通过反射reflect.ValueOf()和reflect.Value获取值信息","date":"2016-03-25T19:07:30.000Z","updated":"2020-08-07T14:10:11.766Z","comments":true,"path":"2016/03/26/Golang/86、Go语言 之通过反射reflect.ValueOf()和reflect.Value获取值信息/","link":"","permalink":"https://www.zackaddy.xin/2016/03/26/Golang/86、Go语言 之通过反射reflect.ValueOf()和reflect.Value获取值信息/","excerpt":"","text":"Go语言 之通过反射reflect.ValueOf()和reflect.Value获取值信息当我们将一个接口值传递给一个 reflect.ValueOf 函数调用时，此调用返回的是代表着此接口值的动态值的一个 reflect.Value 值。我们必须通过间接的途径获得一个代表一个接口值的 reflect.Value 值。 reflect.Value 类型有很多方法（ https://studygolang.com/pkgdoc ）。我们可以调用这些方法来观察和操纵一个 reflect.Value 属主值表示的 Go 值。这些方法中的有些适用于所有种类类型的值，有些只适用于一种或几种类型的值。 通过不合适的 reflect.Value 属主值调用某个方法将在运行时产生一个恐慌。请阅读 reflect 代码库中各个方法的文档来获取如何正确地使用这些方法。 一个 reflect.Value 值的 CanSet 方法将返回此 reflect.Value 值代表的 Go 值是否可以被修改（可以被赋值）。如果一个 Go 值可以被修改，则我们可以调用对应的 reflect.Value 值的 Set 方法来修改此 Go 值。注意：reflect.ValueOf 函数直接返回的 reflect.Value 值都是不可修改的。 反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用 reflect.Value 获取和设置变量的值。 使用反射值对象包装任意值Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下： 1value := reflect.ValueOf(rawValue) reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。 从反射值对象获取被包装的值Go语言中可以通过 reflect.Value 重新获得原始值。 1) 从反射值对象（reflect.Value）中获取值的方法可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。 反射值获取原始值的方法方法名| 说 明–|–Interface() interface {}| 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型Int() int64| 将值以 int 类型返回，所有有符号整型均可以此方式返回Uint() uint64| 将值以 uint 类型返回，所有无符号整型均可以此方式返回Float() float64| 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回Bool() bool| 将值以 bool 类型返回Bytes() []bytes| 将值以字节数组 []bytes 类型返回String() string| 将值以字符串类型返回 2) 从反射值对象（reflect.Value）中获取值的例子下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。 12345678910111213141516package mainimport ( \"fmt\" \"reflect\")func main() &#123; // 声明整型变量a并赋初值 var a int = 1024 // 获取变量a的反射值对象 valueOfA := reflect.ValueOf(a) // 获取interface&#123;&#125;类型的值, 通过类型断言转换 var getA int = valueOfA.Interface().(int) // 获取64位的值, 强制类型转换为int类型 var getA2 int = int(valueOfA.Int()) fmt.Println(getA, getA2)&#125; 代码输出如下： 11024 1024 代码说明如下： 第 11 行，声明一个变量，类型为 int，设置初值为 1024。 第 14 行，获取变量 a 的反射值对象，类型为 reflect.Value，这个过程和 reflect.TypeOf() 类似。 第 17 行，将 valueOfA 反射值对象以 interface{} 类型取出，通过类型断言转换为 int 类型并赋值给 getA。 第 20 行，将 valueOfA 反射值对象通过 Int 方法，以 int64 类型取出，通过强制类型转换，转换为原本的 int 类型。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"85、Go语言 之结构体标签Struct Tag","slug":"Golang/85、Go语言 之结构体标签Struct Tag","date":"2016-03-25T02:42:09.000Z","updated":"2020-08-07T14:10:11.766Z","comments":true,"path":"2016/03/25/Golang/85、Go语言 之结构体标签Struct Tag/","link":"","permalink":"https://www.zackaddy.xin/2016/03/25/Golang/85、Go语言 之结构体标签Struct Tag/","excerpt":"","text":"Go语言 之结构体标签Struct Tag通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。 JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。 提示结构体标签（Struct Tag）类似于 C# 中的特性（Attribute）。C# 允许在类、字段、方法等前面添加 Attribute，然后在反射系统中可以获取到这个属性系统。例如： 12345[Conditional(\"DEBUG\")]public static void Message(string msg)&#123; Console.WriteLine(msg)；&#125; 结构体标签的格式Tag 在结构体字段后方书写的格式如下： 1`key1:\"value1\" key2:\"value2\"` 结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 从结构体标签中获取值StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示： func(tag StructTag)Get(key string)string 根据 Tag 中的键获取对应的值，例如 key1:&quot;value1&quot;key2:&quot;value2&quot; 的 Tag 中，可以传入“key1”获得“value1”。 func(tag StructTag)Lookup(key string)(value string,ok bool) 根据 Tag 中的键，查询值是否存在。 结构体标签格式错误导致的问题编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，参见下面这个例子： 123456789101112131415package mainimport ( \"fmt\" \"reflect\")func main() &#123; type cat struct &#123; Name string Type int `json: \"type\" id:\"100\"` &#125; typeOfCat := reflect.TypeOf(cat&#123;&#125;) if catType, ok := typeOfCat.FieldByName(\"Type\"); ok &#123; fmt.Println(catType.Tag.Get(\"json\")) &#125;&#125; 代码输出空字符串，并不会输出期望的 type。 第 12 行中，在json:和”type”之间增加了一个空格。这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。 这个错误在开发中非常容易被疏忽，造成难以察觉的错误。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"84、Go语言 之通过反射reflect获取结构体的成员类型","slug":"Golang/84、Go语言 之通过反射reflect获取结构体的成员类型","date":"2016-03-24T02:32:38.000Z","updated":"2020-08-07T14:10:11.765Z","comments":true,"path":"2016/03/24/Golang/84、Go语言 之通过反射reflect获取结构体的成员类型/","link":"","permalink":"https://www.zackaddy.xin/2016/03/24/Golang/84、Go语言 之通过反射reflect获取结构体的成员类型/","excerpt":"","text":"Go语言 之通过反射reflect获取结构体的成员类型任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的 NumField() 和 Field() 方法获得结构体成员的详细信息。与成员获取相关的 reflect.Type 的方法如下表所示。 结构体成员访问的方法列表方法| 说明–|–Field(i int) StructField| 根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机NumField() int| 返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机FieldByName(name string) (StructField, bool)| 根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机FieldByIndex(index []int) StructField| 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时 发生宕机FieldByNameFunc( match func(string) bool) (StructField,bool)| 根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机 结构体字段类型reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（Struct Tag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。StructField 的结构如下： 123456789type StructField struct &#123; Name string // 字段名 PkgPath string // 字段路径 Type Type // 字段反射类型对象 Tag StructTag // 字段的结构体标签 Offset uintptr // 字段在结构体中的相对偏移 Index []int // Type.FieldByIndex中的返回的索引值 Anonymous bool // 是否为匿名字段&#125; 字段说明如下。 Name：为字段名称。 PkgPath：字段在结构体中的路径。 Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。 Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。 Index：FieldByIndex 中的索引顺序。 Anonymous：表示该字段是否为匿名字段。 获取成员反射信息下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。 反射访问结构体成员类型及信息： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"reflect\")func main() &#123; // 声明一个空结构体 type cat struct &#123; Name string // 带有结构体tag的字段 Type int `json:\"type\" id:\"100\"` &#125; // 创建cat的实例 ins := cat&#123;Name: \"mimi\", Type: 1&#125; // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 遍历结构体所有成员 for i := 0; i &lt; typeOfCat.NumField(); i++ &#123; // 获取每个成员的结构体字段类型 fieldType := typeOfCat.Field(i) // 输出成员名和tag fmt.Printf(\"name: %v tag: '%v'\\n\", fieldType.Name, fieldType.Tag) &#125; // 通过字段名, 找到字段类型信息 if catType, ok := typeOfCat.FieldByName(\"Type\"); ok &#123; // 从tag中取出需要的tag fmt.Println(catType.Tag.Get(\"json\"), catType.Tag.Get(\"id\")) &#125;&#125; 代码输出如下： 123name: Name tag: ''name: Type tag: 'json:\"type\" id:\"100\"'type 100 代码说明如下： 第 11 行，声明了带有两个成员的 cat 结构体。 第 15 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以`开始和结尾的字符串。这个字符串在 Go 语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。 第 19 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。 第 22 行，获取实例的反射类型对象。 第 25 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。 第 28 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。 第 31 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是StructField 结构体。 第 35 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，cat Type 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。 第 38 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"83、Go语言 之通过反射reflect获取指针指向的元素类型","slug":"Golang/83、Go语言 之通过反射reflect获取指针指向的元素类型","date":"2016-03-22T21:52:43.000Z","updated":"2020-08-07T14:10:11.765Z","comments":true,"path":"2016/03/23/Golang/83、Go语言 之通过反射reflect获取指针指向的元素类型/","link":"","permalink":"https://www.zackaddy.xin/2016/03/23/Golang/83、Go语言 之通过反射reflect获取指针指向的元素类型/","excerpt":"","text":"Go语言 之通过反射reflect获取指针指向的元素类型Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个*操作，代码如下： 1234567891011121314151617181920package mainimport ( \"fmt\" \"reflect\")func main() &#123; // 声明一个空结构体 type cat struct &#123; &#125; // 创建cat的实例 ins := &amp;cat&#123;&#125; // 获取结构体实例的反射类型对象 typeOfCat := reflect.TypeOf(ins) // 显示反射类型对象的名称和种类 fmt.Printf(\"name:'%v' kind:'%v'\\n\",typeOfCat.Name(), typeOfCat.Kind()) // 取类型的元素 typeOfCat = typeOfCat.Elem() // 显示反射类型对象的名称和种类 fmt.Printf(\"element name: '%v', element kind: '%v'\\n\", typeOfCat.Name(), typeOfCat.Kind())&#125; 代码输出如下： 12name: '' kind: 'ptr'element name: 'cat', element kind: 'struct' 代码说明如下： 第 15 行，创建了cat结构体的实例，ins 是一个 *cat 类型的指针变量。 第 18 行，对指针变量获取反射类型信息。 第 21 行，输出指针变量的类型名称和种类。Go 语言的反射中对所有指针变量的种类都是 Ptr，但注意，指针变量的类型名称是空，不是 *cat。 第 24 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。 第 27 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"82、Go语言 之通过反射reflect获取类型信息","slug":"Golang/82、Go语言 之通过反射reflect获取类型信息","date":"2016-03-21T21:14:03.000Z","updated":"2020-08-07T14:10:11.765Z","comments":true,"path":"2016/03/22/Golang/82、Go语言 之通过反射reflect获取类型信息/","link":"","permalink":"https://www.zackaddy.xin/2016/03/22/Golang/82、Go语言 之通过反射reflect获取类型信息/","excerpt":"","text":"Go语言 之通过反射reflect获取类型信息在 Go语言中通过调用 reflect.TypeOf 函数，我们可以从一个任何非接口类型的值创建一个 reflect.Type 值。reflect.Type 值表示着此非接口值的类型。通过此值，我们可以得到很多此非接口类型的信息。当然，我们也可以将一个接口值传递给一个 reflect.TypeOf 函数调用，但是此调用将返回一个表示着此接口值的动态类型的 reflect.Type 值。 实际上，reflect.TypeOf 函数的唯一参数的类型为 interface{}，reflect.TypeOf 函数将总是返回一个表示着此唯一接口参数值的动态类型的 reflect.Type 值。 那如何得到一个表示着某个接口类型的 reflect.Type 值呢？我们必须通过下面将要介绍的一些间接途径来达到这一目的。 类型 reflect.Type 为一个接口类型，它指定了若干方法（https://studygolang.com/pkgdoc）。 通过这些方法，我们能够观察到一个 reflect.Type 值所表示的 Go类型的各种信息。这些方法中的有的适用于所有种类（https://studygolang.com/pkgdoc） 的类型，有的只适用于一种或几种类型。通过不合适的 reflect.Type 属主值调用某个方法将在运行时产生一个恐慌。 使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。下面通过例子来理解获取类型对象的过程： 12345678910111213package mainimport ( \"fmt\" \"reflect\")type Box intfunc main() &#123; var a Box typeOfA := reflect.TypeOf(a) fmt.Println(typeOfA.Name(), typeOfA.Kind())&#125; 代码输出如下： 1Box int Type方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071type Type interface &#123; // Kind返回该接口的具体分类 Kind() Kind // Name返回该类型在自身包内的类型名，如果是未命名类型会返回\"\" Name() string // PkgPath返回类型的包路径，即明确指定包的import路径，如\"encoding/base64\" // 如果类型为内建类型(string, error)或未命名类型(*T, struct&#123;&#125;, []int)，会返回\"\" PkgPath() string // 返回类型的字符串表示。该字符串可能会使用短包名（如用base64代替\"encoding/base64\"） // 也不保证每个类型的字符串表示不同。如果要比较两个类型是否相等，请直接用Type类型比较。 String() string // 返回要保存一个该类型的值需要多少字节；类似unsafe.Sizeof Size() uintptr // 返回当从内存中申请一个该类型值时，会对齐的字节数 Align() int // 返回当该类型作为结构体的字段时，会对齐的字节数 FieldAlign() int // 如果该类型实现了u代表的接口，会返回真 Implements(u Type) bool // 如果该类型的值可以直接赋值给u代表的类型，返回真 AssignableTo(u Type) bool // 如该类型的值可以转换为u代表的类型，返回真 ConvertibleTo(u Type) bool // 返回该类型的字位数。如果该类型的Kind不是Int、Uint、Float或Complex，会panic Bits() int // 返回array类型的长度，如非数组类型将panic Len() int // 返回该类型的元素类型，如果该类型的Kind不是Array、Chan、Map、Ptr或Slice，会panic Elem() Type // 返回map类型的键的类型。如非映射类型将panic Key() Type // 返回一个channel类型的方向，如非通道类型将会panic ChanDir() ChanDir // 返回struct类型的字段数（匿名字段算作一个字段），如非结构体类型将panic NumField() int // 返回struct类型的第i个字段的类型，如非结构体或者i不在[0, NumField())内将会panic Field(i int) StructField // 返回索引序列指定的嵌套字段的类型， // 等价于用索引中每个值链式调用本方法，如非结构体将会panic FieldByIndex(index []int) StructField // 返回该类型名为name的字段（会查找匿名字段及其子字段）， // 布尔值说明是否找到，如非结构体将panic FieldByName(name string) (StructField, bool) // 返回该类型第一个字段名满足函数match的字段，布尔值说明是否找到，如非结构体将会panic FieldByNameFunc(match func(string) bool) (StructField, bool) // 如果函数类型的最后一个输入参数是\"...\"形式的参数，IsVariadic返回真 // 如果这样，t.In(t.NumIn() - 1)返回参数的隐式的实际类型（声明类型的切片） // 如非函数类型将panic IsVariadic() bool // 返回func类型的参数个数，如果不是函数，将会panic NumIn() int // 返回func类型的第i个参数的类型，如非函数或者i不在[0, NumIn())内将会panic In(i int) Type // 返回func类型的返回值个数，如果不是函数，将会panic NumOut() int // 返回func类型的第i个返回值的类型，如非函数或者i不在[0, NumOut())内将会panic Out(i int) Type // 返回该类型的方法集中方法的数目 // 匿名字段的方法会被计算；主体类型的方法会屏蔽匿名字段的同名方法； // 匿名字段导致的歧义方法会滤除 NumMethod() int // 返回该类型方法集中的第i个方法，i不在[0, NumMethod())范围内时，将导致panic // 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态 // 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil Method(int) Method // 根据方法名返回该类型方法集中的方法，使用一个布尔值说明是否发现该方法 // 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态 // 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil MethodByName(string) (Method, bool) // 内含隐藏或非导出方法&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"81、Go语言 之反射reflect规则浅析","slug":"Golang/81、Go语言 之反射reflect规则浅析","date":"2016-03-21T01:42:36.000Z","updated":"2020-08-07T14:10:11.765Z","comments":true,"path":"2016/03/21/Golang/81、Go语言 之反射reflect规则浅析/","link":"","permalink":"https://www.zackaddy.xin/2016/03/21/Golang/81、Go语言 之反射reflect规则浅析/","excerpt":"","text":"Go语言 之反射reflect规则浅析前面讲解了 Value 和 Type 的基本概念，本节重点讲解反射对象 Value、Type 和类型实例之间的相互转化 反射对象关系图：反射对象关系 反射 API反射 API 的分类总结如下。 1) 从实例到 Value通过实例获取 Value 对象，直接使用 12reflect.ValueOf() 函数。例如：func ValueOf(i interface &#123;&#125;) Value 2) 从实例到 Type通过实例获取反射对象的 Type，直接使用 reflect.TypeOf() 函数。例如： 1func TypeOf(i interface&#123;&#125;) Type 3) 从 Type 到 ValueType 里面只有类型信息，所以直接从一个 Type 接口变量里面是无法获得实例的 Value 的，但可以通过该 Type 构建一个新实例的 Value。reflect 包提供了两种方法，示例如下： 1234//New 返回的是一个 Value，该 Value 的 type 为 PtrTo(typ)，即 Value 的 Type 是指定 typ 的指针类型func New(typ Type) Value//Zero 返回的是一个 typ 类型的零佳，注意返回的 Value 不能寻址，位不可改变func Zero(typ Type) Value 如果知道一个类型值的底层存放地址，则还有一个函数是可以依据 type 和该地址值恢复出 Value 的。例如： 1func NewAt(typ Type, p unsafe.Pointer) Value 4) 从 Value 到 Type从反射对象 Value 到 Type 可以直接调用 Value 的方法，因为 Value 内部存放着到 Type 类型的指针。例如： 1func (v Value) Type() Type 5) 从 Value 到实例Value 本身就包含类型和值信息，reflect 提供了丰富的方法来实现从 Value 到实例的转换。例如： 123456789//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例//可以使用接口类型查询去还原为具体的类型func (v Value) Interface() （i interface&#123;&#125;)//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则直接引起 panicfunc (v Value) Bool () boolfunc (v Value) Float() float64func (v Value) Int() int64func (v Value) Uint() uint64 6) 从 Value 的指针到值从一个指针类型的 Value 获得值类型 Value 有两种方法，示例如下。 1234//如果 v 类型是接口，则 Elem() 返回接口绑定的实例的 Value，如采 v 类型是指针，则返回指针值的 Value，否则引起 panicfunc (v Value) Elem() Value//如果 v 是指针，则返回指针值的 Value，否则返回 v 自身，该函数不会引起 panicfunc Indirect(v Value) Value 7) Type 指针和值的相互转换指针类型 Type 到值类型 Type。例如： 123//t 必须是 Array、Chan、Map、Ptr、Slice，否则会引起 panic//Elem 返回的是其内部元素的 Typet.Elem() Type 值类型 Type 到指针类型 Type。例如： 12//PtrTo 返回的是指向 t 的指针型 Typefunc PtrTo(t Type) Type 8) Value 值的可修改性Value 值的修改涉及如下两个方法： 1234//通过 CanSet 判断是否能修改func (v Value ) CanSet() bool//通过 Set 进行修改func (v Value ) Set(x Value) Value 值在什么情况下可以修改？我们知道实例对象传递给接口的是一个完全的值拷贝，如果调用反射的方法 reflect.ValueOf() 传进去的是一个值类型变量， 则获得的 Value 实际上是原对象的一个副本，这个 Value 是无论如何也不能被修改的。 如果传进去的是一个指针，虽然接口内部转换的也是指针的副本，但通过指针还是可以访问到最原始的对象，所以此种情况获得的 Value 是可以修改的。下面来看一个简单的示例。 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"reflect\")type User struct &#123; id int Name string Age int&#125;func main() &#123; u := User&#123;Id: 1, Name:\"andes\", Age: 20&#125; va := reflect.ValueOf(u) vb := reflect.ValueOf(&amp;u) //值类型是可修改的 fmt.Println(va.CanSet(), va.FieldByName(\"Name\").CanSet()) //false false //指针类型是可修改的 fmt.Println(vb.CanSet(), vb.Elem().FieldByName(\"Name\").CanSet()) //false false fmt.Printf(\"%v\\n\", vb) name :＝\"shine\" vc := reflect.ValueOf(name) //通过 Set 函数修改变量的值 vb.Elem().FieldByName(\"Name\").Set(vc) fmt.Printf(\"%v\\n\", vb)&#125; 运行结果： 1234false falsefalse true&amp;&#123;1 andes 20)&amp;&#123;1 shine 20) 这里归纳出了反射的三条定律： 反射可以从接口值得到反射对象。 反射可以从反射对象获得接口值。 若要修改一个反射对象，则其值必须可以修改。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"80、Go语言 之反射reflect概述","slug":"Golang/80、Go语言 之反射reflect概述","date":"2016-03-20T02:42:27.000Z","updated":"2020-08-07T14:10:11.764Z","comments":true,"path":"2016/03/20/Golang/80、Go语言 之反射reflect概述/","link":"","permalink":"https://www.zackaddy.xin/2016/03/20/Golang/80、Go语言 之反射reflect概述/","excerpt":"","text":"Go语言 之反射reflect概述Go语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，但是在编译时并不知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。 反射（reflection）是在 Java 出现后迅速流行起来的一种概念。通过反射，你可以获取丰富的类型信息，并可以利用这些类型信息做非常灵活的工作。 在 Java 中，你可以读取配置并根据类型名称创建对应的类型，这是一种常见的编程手法。Java 中的很多重要框架和技术（比如 Spring/IoC、Hibernate、Struts）等都严重依赖于反射功能。虽然，使用 Java EE 时很多人都觉得很麻烦，比如需要配置大量 XML 格式的配置程序，但这毕竟不是反射的错，反而更加说明了反射所带来的高可配置性。 大多数现代的高级语言都以各种形式支持反射功能，除了一切以性能为上的 C++ 语言。Go语言的反射实现了反射的大部分功能，但没有像 Java 语言那样内置类型工厂，故而无法做到像 Java 那样通过类型字符串创建对象实例。 反射是把双刃剑，功能强大但代码可读性并不理想。若非必要，并不推荐使用反射，下面我们将介绍反射功能在 Go语言中的具体体现以及反射的基本使用方法。 基本概念Go语言中的反射与其他语言有比较大的不同。首先我们要理解两个基本概念 Type 和 Value，它们也是 Go语言包中 reflect 空间里最重要的两个类型。我们先看一下下面的定义： 123456type MyReader struct &#123; Name string&#125;func (r MyReader)Read(p []byte) (n int, err error) &#123; // 实现自己的Read方法&#125; 因为 MyReader 类型实现了 io.Reader 接口的所有方法（其实就是一个 Read() 函数），所以 MyReader 实现了接口 io.Reader。我们可以按如下方式来进行 MyReader 的实例化和赋值： 12var reader io.Readerreader = &amp;MyReader&#123;\"a.txt\"&#125; 现在我们可以再来解释一下什么是 Type，什么是 Value。 对所有接口进行反射，都可以得到一个包含 Type 和 Value 的信息结构。比如我们对上例的 reader 进行反射，也将得到一个 Type 和 Value，Type 为 io.Reader，Value 为 MyReader{“a.txt”}。顾名思义，Type 主要表达的是被反射的这个变量本身的类型信息，而 Value 则为该变量实例本身的信息。 基本用法通过使用 Type 和 Value，我们可以对一个类型进行各项灵活的操作。接下来我们分别演示反射的几种最基本用途。 1) 获取类型信息为了理解反射的功能，我们先来看看下面代码所示的这个小程序。 123456789package mainimport ( \"fmt\" \"reflect\")func main() &#123; var x float64 = 3.4 fmt.Println(\"type:\", reflect.TypeOf(x))&#125; 运行上述代码，输出结果如下所示： 1type: float64 Type 和 Value 都包含了大量的方法，其中第一个有用的方法应该是 Kind，这个方法返回该类型的具体信息：Uint、Float64 等。Value 类型还包含了一系列类型方法，比如 Int()，用于返回对应的值。查看以下示例： 123456789var x float64 = 3.4v := reflect.ValueOf(x)fmt.Println(\"type:\", v.Type())fmt.Println(\"kind is float64:\", v.Kind() == reflect.Float64)fmt.Println(\"value:\", v.Float())结果为：type: float64kind is float64: truevalue: 3.4 2) 获取值类型类型 Type 中有一个成员函数 CanSet()，其返回值为 bool 类型。如果你在注意到这个函数之前就直接设置了值，很有可能会收到一些看起来像异常的错误处理消息。 可能很多人会置疑为什么要有这么个奇怪的函数，可以设置所有的域不是很好吗？这里先解释一下这个函数存在的原因。 我们在之前的学习中提到过 Go语言中所有的类型都是值类型，即这些变量在传递给函数的时候将发生一次复制。基于这个原则，我们再次看一下下面的语句： 123var x float64 = 3.4v := reflect.ValueOf(x)v.Set(4.1) 最后一条语句试图修改 v 的内容。是否可以成功地将 x 的值改为 4.1 呢？先要理清 v 和 x 的关系。在调用 ValueOf() 的地方，需要注意到 x 将会产生一个副本，因此 ValueOf() 内部对 x 的操作其实都是对着 x 的一个副本。 假如 v 允许调用 Set()，那么我们也可以想象出，被修改的将是这个 x 的副本，而不是 x 本身。如果允许这样的行为，那么执行结果将会非常困惑。调用明明成功了，为什么 x 的值还是原来的呢？为了解决这个问题 Go语言，引入了可设属性这个概念（Settability）。如果 CanSet() 返回 false，表示你不应该调用 Set() 和 SetXxx() 方法，否则会收到这样的错误： 1panic: reflect.Value.SetFloat using unaddressable value 现在我们知道，有些场景下不能使用反射修改值，那么到底什么情况下可以修改的呢？其实这还是跟传值的道理类似。我们知道，直接传递一个 float 到函数时，函数不能对外部的这个 float 变量有任何影响，要想有影响的话，可以传入该 float 变量的指针。下面的示例小幅修改了之前的例子，成功地用反射的方式修改了变量 x 的值： 123456789var x float64 = 3.4p := reflect.ValueOf(&amp;x) // 注意：得到X的地址fmt.Println(\"type of p:\", p.Type())fmt.Println(\"settability of p:\" , p.CanSet())v := p.Elem()fmt.Println(\"settability of v:\" , v.CanSet())v.SetFloat(7.1)fmt.Println(v.Interface())fmt.Println(x) 对结构的反射操作之前讨论的都是简单类型的反射操作，现在我们讨论一下结构的反射操作。下面的示例演示了如何获取一个结构中所有成员的值： 123456789101112type T struct &#123; A int B string&#125;t := T&#123;203, \"mh203\"&#125;s := reflect.ValueOf(&amp;t).Elem()typeOfT := s.Type()for i := 0; i &lt; s.NumField(); i++ &#123; f := s.Field(i) fmt.Printf(\"%d: %s %s = %v\\n\", i, typeOfT.Field(i).Name, f.Type(), f.Interface())&#125; 以上例子的输出为： 120: A int = 2031: B string = mh203 可以看出，对于结构的反射操作并没有根本上的不同，只是用了 Field() 方法来按索引获取对应的成员。当然，在试图修改成员的值时，也需要注意可赋值属性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"79、Go语言 之并发饥饿","slug":"Golang/79、Go语言 之并发饥饿","date":"2016-03-19T02:41:51.000Z","updated":"2020-08-07T14:10:11.764Z","comments":true,"path":"2016/03/19/Golang/79、Go语言 之并发饥饿/","link":"","permalink":"https://www.zackaddy.xin/2016/03/19/Golang/79、Go语言 之并发饥饿/","excerpt":"","text":"Go语言 之并发饥饿饥饿：是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。 关于”饥饿“的比喻：在“首堵”北京的某一天，天气阴沉，空气中充斥着雾霾和地沟油的味道，某个苦逼的临时工交警正在处理塞车，有两条道A和B上都堵满了车辆，其中A道堵的时间最长，B相对相对堵的时间较短，这时，前面道路已疏通，交警按照最佳分配原则，示意B道上车辆先过，B道路上过了一辆又一辆，A道上排队时间最长的确没法通过，只能等B道上没有车辆通过的时候再等交警发指令让A道依次通过，这也就是ReentrantLock显示锁里提供的不公平锁机制（当然了，ReentrantLock也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"78、Go语言 之并发活锁","slug":"Golang/78、Go语言 之并发活锁","date":"2016-03-17T22:42:21.000Z","updated":"2020-08-07T14:10:11.763Z","comments":true,"path":"2016/03/18/Golang/78、Go语言 之并发活锁/","link":"","permalink":"https://www.zackaddy.xin/2016/03/18/Golang/78、Go语言 之并发活锁/","excerpt":"","text":"Go语言 之并发活锁活锁、死锁本质上是一样的，原因是在获取临界区资源时，并发多个进程/线程声明资源占用(加锁)的顺序不一致，死锁是加不上就死等，活锁是加不上就放开已获得的资源重试，其实单机场景活锁不太常见。举个例子资源A和B，进程P1和P2， 123456789101112131415start：P1 lock AP2 lock BP1 lock B fail context switchP2 lock A fail context switchP1 release AP2 release Bgoto start 单个core时如果调度的不好还是有可能出现的，多core情况下，冲突窗口很小，很难出现两个进程的节奏碰的这么巧。 但是在分布式场景下，由于加锁失败，而要释放已获得的资源再重试，这个过程涉及网络通信，冲突窗口变大，使得活锁出现概率也变大。比如paxos的prepare和accept，两个并发提案P1和P2，P2用更大proposal id的prepare形成多数派，将使得之前已经prepare成功的P1无法accept，P1只能用更更大的proposal id重试，而使得P2又无法accept，把prepare和accept看做两个资源A和B，每个提案都是按BAB的顺序获取资源（因为prepare阶段的应答蕴含了对accept增加了限制），过程中存在BA和AB两种资源获取顺序，是典型的活锁场景","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"77、Go语言 之并发死锁","slug":"Golang/77、Go语言 之并发死锁","date":"2016-03-17T04:56:44.000Z","updated":"2020-08-07T14:10:11.763Z","comments":true,"path":"2016/03/17/Golang/77、Go语言 之并发死锁/","link":"","permalink":"https://www.zackaddy.xin/2016/03/17/Golang/77、Go语言 之并发死锁/","excerpt":"","text":"Go语言 之并发死锁死锁我们先看一段程序。 12345678910111213141516171819type value struct &#123; mu sync.Mutex value int&#125;var wg sync.WaitGroupprintSum := func(v1, v2 *value) &#123; defer wg.Done() v1.mu.Lock() defer v1.mu.Unlock() time.Sleep(2*time.Second) v2.mu.Lock() defer v2.mu.Unlock() fmt.Printf(\"sum=%v\\n\", v1.value + v2.value)&#125;var a, b valuewg.Add(2)go printSum(&amp;a, &amp;b)go printSum(&amp;b, &amp;a)wg.Wait() 第 8 行，进入临界区. 第 9 行，这里使用 defer 语句在 printSum 返回之前退出临界区。 第 10 行, 我们 sleep 了一段时间来模拟工作（并触发死锁）。运行结果：1fatal error: all goroutines are asleep - deadlock! 解释：我们第一次调用 printSum 锁定 a 然后尝试锁定 b，但与此同时我们对 printSum 的第二次调用已锁定 b 并试图锁定 a。两个 goroutine 彼此无限等待。 当且仅当以下所有条件同时存在于系统中时，才会出现资源上的死锁情况， 下面是产生死锁的四个必要条件1： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 让我们检查一下我们设计的程序，并确定它是否满足所有四个条件： printSum 函数确实需要a和b的独占访问权，因此它满足这个条件。 因为 printSum 函数持有 a 或 b 并且正在等待另一个，所以它满足这个条件。 我们没有任何办法让我们的 goroutines 被抢先一步。 我们第一次调用 printSum 正在等待第二次调用，反之亦然。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"76、Go语言 之等待组sync.WaitGroup","slug":"Golang/76、Go语言 之等待组sync.WaitGroup","date":"2016-03-15T19:20:40.000Z","updated":"2020-08-07T14:10:11.762Z","comments":true,"path":"2016/03/16/Golang/76、Go语言 之等待组sync.WaitGroup/","link":"","permalink":"https://www.zackaddy.xin/2016/03/16/Golang/76、Go语言 之等待组sync.WaitGroup/","excerpt":"","text":"Go语言 之等待组sync.WaitGroupGo语言中除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务 在 sync.WaitGroup（等待组）类型中，每个 sync.WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。 等待组有下面几个方法可用，如下表所示。 等待组的方法方法名| 功能–|–(wg * WaitGroup) Add(delta int) |等待组的计数器 +1(wg * WaitGroup) Done() |等待组的计数器 -1(wg * WaitGroup) Wait() |当等待组计数器不等于 0 时阻塞直到变 0。 对于一个可寻址的 sync.WaitGroup 值 wg： 我们可以使用方法调用 wg.Add(delta) 来改变值 wg 维护的计数。 方法调用 wg.Done() 和 wg.Add(-1) 是完全等价的。 如果一个 wg.Add(delta) 或者 wg.Done() 调用将 wg 维护的计数更改成一个负数，一个恐慌将产生。 当一个协程调用了 wg.Wait() 时， 如果此时 wg 维护的计数为零，则此 wg.Wait() 此操作为一个空操作（noop）； 否则（计数为一个正整数），此协程将进入阻塞状态。当以后其它某个协程将此计数更改至 0 时（一般通过调用 wg.Done()），此协程将重新进入运行状态（即 wg.Wait() 将返回）。 等待组内部拥有一个计数器，计数器的值可以通过方法调用实现计数器的增加和减少。当我们添加了 N 个并发任务进行工作时，就将等待组的计数器值增加 N。每个任务完成时，这个值减 1。同时，在另外一个 goroutine 中等待这个等待组的计数器值为 0 时，表示所有任务已经完成。 下面的代码演示了这一过程： 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"net/http\" \"sync\")func main() &#123; // 声明一个等待组 var wg sync.WaitGroup // 准备一系列的网站地址 var urls = []string&#123; \"http://www.github.com/\", \"https://www.qiniu.com/\", \"https://www.golangtc.com/\", &#125; // 遍历这些地址 for _, url := range urls &#123; // 每一个任务开始时, 将等待组增加1 wg.Add(1) // 开启一个并发 go func(url string) &#123; // 使用defer, 表示函数完成时将等待组值减1 defer wg.Done() // 使用http访问提供的地址 _, err := http.Get(url) // 访问完成后, 打印地址和可能发生的错误 fmt.Println(url, err) // 通过参数传递url地址 &#125;(url) &#125; // 等待所有的任务完成 wg.Wait() fmt.Println(\"over\")&#125; 代码说明如下： 第 12 行，声明一个等待组，对一组等待任务只需要一个等待组，而不需要每一个任务都使用一个等待组。 第 15 行，准备一系列可访问的网站地址的字符串切片。 第 22 行，遍历这些字符串切片。 第 25 行，将等待组的计数器加1，也就是每一个任务加 1。 第 28 行，将一个匿名函数开启并发。 第 31 行，在匿名函数结束时会执行这一句以表示任务完成。wg.Done() 方法等效于执行 wg.Add(-1)。 第 34 行，使用 http 包提供的 Get() 函数对 url 进行访问，Get() 函数会一直阻塞直到网站响应或者超时。 第 37 行，在网站响应和超时后，打印这个网站的地址和可能发生的错误。 第 40 行，这里将 url 通过 goroutine 的参数进行传递，是为了避免 url 变量通过闭包放入匿名函数后又被修改的问题。 第 44 行，等待所有的网站都响应或者超时后，任务完成，Wait 就会停止阻塞。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"75、Go语言 之互斥锁sync.Mutex和读写互斥锁sync.RWMutex","slug":"Golang/75、Go语言 之互斥锁sync.Mutex和读写互斥锁sync.RWMutex","date":"2016-03-15T02:50:17.000Z","updated":"2020-08-07T14:10:11.762Z","comments":true,"path":"2016/03/15/Golang/75、Go语言 之互斥锁sync.Mutex和读写互斥锁sync.RWMutex/","link":"","permalink":"https://www.zackaddy.xin/2016/03/15/Golang/75、Go语言 之互斥锁sync.Mutex和读写互斥锁sync.RWMutex/","excerpt":"","text":"Go语言 之互斥锁sync.Mutex和读写互斥锁sync.RWMutexGo语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。 Mutex 是最简单的一种锁类型，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。 RWMutex 相对友好些，是经典的单写多读模型。在读锁占用的情况下，会阻止写，但不阻止读，也就是多个 goroutine 可同时获取读锁（调用 RLock() 方法；而写锁（调用 Lock() 方法）会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占。从 RWMutex 的实现看，RWMutex 类型其实组合了 Mutex： 1234567type RWMutex struct &#123; w Mutex writerSem uint32 readerSem uint32 readerCount int32 readerWait int32&#125; 对于这两种锁类型，任何一个 Lock() 或 RLock() 均需要保证对应有 Unlock() 或 RUnlock() 调用与之对应，否则可能导致等待该锁的所有 goroutine 处于饥饿状态，甚至可能导致死锁。锁的典型使用模式如下： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"sync\")var ( // 逻辑中使用的某个变量 count int // 与变量对应的使用互斥锁 countGuard sync.Mutex)func GetCount() int &#123; // 锁定 countGuard.Lock() // 在函数退出时解除锁定 defer countGuard.Unlock() return count&#125;func SetCount(c int) &#123; countGuard.Lock() count = c countGuard.Unlock()&#125;func main() &#123; // 可以进行并发安全的设置 SetCount(1) // 可以进行并发安全的获取 fmt.Println(GetCount())&#125; 代码说明如下： 第 10 行是某个逻辑步骤中使用到的变量，无论是包级的变量还是结构体成员字段，都可以。 第 13 行，一般情况下，建议将互斥锁的粒度设置得越小越好，降低因为共享访问时等待的时间。这里笔者习惯性地将互斥锁的变量命名为以下格式：1变量名+Guard 以表示这个互斥锁用于保护这个变量。 第 16 行是一个获取 count 值的函数封装，通过这个函数可以并发安全的访问变量 count。 第 19 行，尝试对 countGuard 互斥量进行加锁。一旦 countGuard 发生加锁，如果另外一个 goroutine 尝试继续加锁时将会发生阻塞，直到这个 countGuard 被解锁。 第 22 行使用 defer 将 countGuard 的解锁进行延迟调用，解锁操作将会发生在 GetCount() 函数返回时。 第 27 行在设置 count 值时，同样使用 countGuard 进行加锁、解锁操作，保证修改 count 值的过程是一个原子过程，不会发生并发访问冲突。 在读多写少的环境中，可以优先使用读写互斥锁（sync.RWMutex），它比互斥锁更加高效。sync 包中的 RWMutex 提供了读写互斥锁的封装。 我们将互斥锁例子中的一部分代码修改为读写互斥锁，参见下面代码： 12345678910111213var ( // 逻辑中使用的某个变量 count int // 与变量对应的使用互斥锁 countGuard sync.RWMutex)func GetCount() int &#123; // 锁定 countGuard.RLock() // 在函数退出时解除锁定 defer countGuard.RUnlock() return count&#125; 代码说明如下： 第 6 行，在声明 countGuard 时，从 sync.Mutex 互斥锁改为 sync.RWMutex 读写互斥锁。 第 12 行，获取 count 的过程是一个读取 count 数据的过程，适用于读写互斥锁。在这一行，把 countGuard.Lock() 换做 countGuard.RLock()，将读写互斥锁标记为读状态。如果此时另外一个 goroutine 并发访问了 countGuard，同时也调用了 countGuard.RLock() 时，并不会发生阻塞。 第 15 行，与读模式加锁对应的，使用读模式解锁。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"74、Go语言 之关闭通道chan后继续使用通道chan","slug":"Golang/74、Go语言 之关闭通道chan后继续使用通道chan","date":"2016-03-14T02:38:52.000Z","updated":"2020-08-07T14:10:11.762Z","comments":true,"path":"2016/03/14/Golang/74、Go语言 之关闭通道chan后继续使用通道chan/","link":"","permalink":"https://www.zackaddy.xin/2016/03/14/Golang/74、Go语言 之关闭通道chan后继续使用通道chan/","excerpt":"","text":"Go语言 之关闭通道chan后继续使用通道chan通道是一个引用对象，和 map 类似。map 在没有任何外部引用时，Go语言程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection, GC）。类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。 格式使用 close() 来关闭一个通道： 1close(ch) 关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。 给被关闭通道发送数据将会触发 panic被关闭的通道不会被置为 nil。如果尝试对已经关闭的通道进行发送，将会触发宕机： 提示触发宕机的原因是给一个已经关闭的通道发送数据。 从已关闭的通道接收数据时将不会发生阻塞从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。 12345678910111213package mainimport ( \"fmt\")func main() &#123; // 创建一个无缓冲字符串通道 ch := make(chan int) close(ch) a := &lt;-ch fmt.Println(a); fmt.Println(\"666\")&#125; 结果如下 120666","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"73、Go语言 之RPC远程过程调用","slug":"Golang/73、Go语言 之RPC远程过程调用","date":"2016-03-12T21:03:46.000Z","updated":"2020-08-07T14:10:11.762Z","comments":true,"path":"2016/03/13/Golang/73、Go语言 之RPC远程过程调用/","link":"","permalink":"https://www.zackaddy.xin/2016/03/13/Golang/73、Go语言 之RPC远程过程调用/","excerpt":"","text":"Go语言 之RPC远程过程调用服务器开发中会使用RPC（Remote Procedure Call，远程过程调用）简化进程间通信的过程。RPC 能有效地封装通信过程，让远程的数据收发通信过程看起来就像本地的函数调用一样。 本例中，使用通道代替 Socket 实现 RPC 的过程。客户端与服务器运行在同一个进程，服务器和客户端在两个 goroutine 中运行。 我们先给出完整代码，然后再详细分析每一个部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"errors\" \"fmt\" \"time\")// 模拟RPC客户端的请求和接收消息封装func RPCClient(ch chan string, req string) (string, error) &#123; // 向服务器发送请求 ch &lt;- req // 等待服务器返回 select &#123; case ack := &lt;-ch: // 接收到服务器返回数据 return ack, nil case &lt;-time.After(time.Second): // 超时 return \"\", errors.New(\"Time out\") &#125;&#125;// 模拟RPC服务器端接收客户端请求和回应func RPCServer(ch chan string) &#123; for &#123; // 接收客户端请求 data := &lt;-ch // 打印接收到的数据 fmt.Println(\"server received:\", data) // 反馈给客户端收到 ch &lt;- \"roger\" &#125;&#125;func main() &#123; // 创建一个无缓冲字符串通道 ch := make(chan string) // 并发执行服务器逻辑 go RPCServer(ch) // 客户端请求数据和接收数据 recv, err := RPCClient(ch, \"hi\") if err != nil &#123; // 发生错误打印 fmt.Println(err) &#125; else &#123; // 正常接收到数据 fmt.Println(\"client received\", recv) &#125;&#125; 客户端请求和接收封装下面的代码封装了向服务器请求数据，等待服务器返回数据，如果请求方超时，该函数还会处理超时逻辑。 模拟 RPC 的代码： 123456789101112// 模拟RPC客户端的请求和接收消息封装func RPCClient(ch chan string, req string) (string, error) &#123; // 向服务器发送请求 ch &lt;- req // 等待服务器返回 select &#123; case ack := &lt;-ch: // 接收到服务器返回数据 return ack, nil case &lt;-time.After(time.Second): // 超时 return \"\", errors.New(\"Time out\") &#125;&#125; 代码说明如下： 第 5 行，模拟 socket 向服务器发送一个字符串信息。服务器接收后，结束阻塞执行下一行。 第 8 行，使用 select 开始做多路复用。注意，select 虽然在写法上和 switch 一样，都可以拥有 case 和 default。但是 select 关键字后面不接任何语句，而是将要复用的多个通道语句写在每一个 case 上，如第 9 行和第 11 行所示。 第 11 行，使用了 time 包提供的函数 After()，从字面意思看就是多少时间之后，其参数是 time 包的一个常量，time.Second 表示 1 秒。time.After 返回一个通道，这个通道在指定时间后，通过通道返回当前时间。 第 12 行，在超时时，返回超时错误。 RPCClient() 函数中，执行到 select 语句时，第 9 行和第 11 行的通道操作会同时开启。如果第 9 行的通道先返回，则执行第 10 行逻辑，表示正常接收到服务器数据；如果第 11 行的通道先返回，则执行第 12 行的逻辑，表示请求超时，返回错误。 服务器接收和反馈数据服务器接收到客户端的任意数据后，先打印再通过通道返回给客户端一个固定字符串，表示服务器已经收到请求。 1234567891011// 模拟RPC服务器端接收客户端请求和回应func RPCServer(ch chan string) &#123; for &#123; // 接收客户端请求 data := &lt;-ch // 打印接收到的数据 fmt.Println(\"server received:\", data) //向客户端反馈已收到 ch &lt;- \"roger\" &#125;&#125; 代码说明如下： 第 3 行，构造出一个无限循环。服务器处理完客户端请求后，通过无限循环继续处理下一个客户端请求。 第 5 行，通过字符串通道接收一个客户端的请求。 第 8 行，将接收到的数据打印出来。 第 11 行，给客户端反馈一个字符串。 运行整个程序，客户端可以正确收到服务器返回的数据，客户端 RPCClient() 函数的代码按下面代码中加粗部分的分支执行。 1234567// 等待服务器返回select &#123;case ack := &lt;-ch: // 接收到服务器返回数据 return ack, nilcase &lt;-time.After(time.Second): // 超时 return \"\", errors.New(\"Time out\")&#125; 程序输出如下： 12server received: hiclient received roger 模拟超时上面的例子虽然有客户端超时处理，但是永远不会触发，因为服务器的处理速度很快，也没有真正的网络延时或者“服务器宕机”的情况。因此，为了展示 select 中超时的处理，在服务器逻辑中增加一条语句，故意让服务器延时处理一段时间，造成客户端请求超时，代码如下： 12345678910111213// 模拟RPC服务器端接收客户端请求和回应func RPCServer(ch chan string) &#123; for &#123; // 接收客户端请求 data := &lt;-ch // 打印接收到的数据 fmt.Println(\"server received:\", data) // 通过睡眠函数让程序执行阻塞2秒的任务 time.Sleep(time.Second * 2) // 反馈给客户端收到 ch &lt;- \"roger\" &#125;&#125; 第 11 行中，time.Sleep() 函数会让 goroutine 执行暂停 2 秒。使用这种方法模拟服务器延时，造成客户端超时。客户端处理超时 1 秒时通道就会返回： 1234567// 等待服务器返回select &#123;case ack := &lt;-ch: // 接收到服务器返回数据 return ack, nilcase &lt;-time.After(time.Second): // 超时 return \"\", errors.New(\"Time out\")&#125; 上面代码中，加黑部分的代码就会被执行。 主流程主流程中会创建一个无缓冲的字符串格式通道。将通道传给服务器的 RPCServer() 函数，这个函数并发执行。使用 RPCClient() 函数通过 ch 对服务器发出 RPC 请求，同时接收服务器反馈数据或者等待超时。参考下面代码： 123456789101112131415func main() &#123; // 创建一个无缓冲字符串通道 ch := make(chan string) // 并发执行服务器逻辑 go RPCServer(ch) // 客户端请求数据和接收数据 recv, err := RPCClient(ch, \"hi\") if err != nil &#123; // 发生错误打印 fmt.Println(err) &#125; else &#123; // 正常接收到数据 fmt.Println(\"client received\", recv) &#125;&#125; 代码说明如下： 第 4 行，创建无缓冲的字符串通道，这个通道用于模拟网络和 socke t概念，既可以从通道接收数据，也可以发送。 第 7 行，并发执行服务器逻辑。服务器一般都是独立进程的，这里使用并发将服务器和客户端逻辑同时在一个进程内运行。 第 10 行，使用 RPCClient() 函数，发送“hi”给服务器，同步等待服务器返回。 第 13 行，如果通信过程发生错误，打印错误。 第 16 行，正常接收时，打印收到的数据。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"72、Go语言 之chan通道select同时处理接收和发送多个通道的数据","slug":"Golang/72、Go语言 之chan通道select同时处理接收和发送多个通道的数据","date":"2016-03-11T18:52:02.000Z","updated":"2020-08-07T14:10:11.761Z","comments":true,"path":"2016/03/12/Golang/72、Go语言 之chan通道select同时处理接收和发送多个通道的数据/","link":"","permalink":"https://www.zackaddy.xin/2016/03/12/Golang/72、Go语言 之chan通道select同时处理接收和发送多个通道的数据/","excerpt":"","text":"Go语言 之chan通道select同时处理接收和发送多个通道的数据多路复用是通信和网络中的一个专业术语。多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。 提示报话机同一时刻只能有一边进行收或者发的单边通信，报话机需要遵守的通信流程如下： 说话方在完成时需要补上一句“完毕”，随后放开通话按钮，从发送切换到接收状态，收听对方说话。 收听方在听到对方说“完毕”时，按下通话按钮，从接收切换到发送状态，开始说话。 电话可以在说话的同时听到对方说话，所以电话是一种多路复用的设备，一条通信线路上可以同时接收或者发送数据。同样的，网线、光纤也都是基于多路复用模式来设计的，网线、光纤不仅可支持同时收发数据，还支持多个人同时收发数据。 在使用通道时，想同时接收多个通道的数据是一件困难的事情。通道在接收数据时，如果没有数据可以接收将会发生阻塞。虽然可以使用如下模式进行遍历，但运行性能会非常差。 12345678for&#123; // 尝试接收ch1通道 data, ok := &lt;-ch1 // 尝试接收ch2通道 data, ok := &lt;-ch2 // 接收后续通道 …&#125; Go语言中提供了 select 关键字，可以同时响应多个通道的操作。select 的用法与 switch 语句非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。 与 switch 语句可以选择任何可使用相等比较的条件相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致结构如下： 123456789select&#123; case 操作1: 响应操作1 case 操作2: 响应操作2 … default: 没有操作情况&#125; 操作1、操作2：包含通道收发语句，请参考下表。 操 作 语句示例 接收任意数据 case &lt;- ch; 接收变量 case d := &lt;- ch; 发送数据 case ch &lt;- 100; 响应操作1、响应操作2：当操作发生时，会执行对应 case 的响应操作。 default：当没有任何操作时，默认执行 default 中的语句。 可以看出，select 不像 switch，后面并不带判断条件，而是直接去查看 case 语句。每个 case 语句都必须是一个面向 channel 的操作。 基于此功能，我们可以实现一个有趣的程序： 123456789ch := make(chan int, 1)for &#123; select &#123; case ch &lt;- 0: case ch &lt;- 1: &#125; i := &lt;-ch fmt.Println(\"Value received:\", i)&#125; 能看明白这段代码的含义吗？其实很简单，这个程序实现了一个随机向 ch 中写入一个 0 或者 1 的过程。当然，这是个死循环。关于 select 的详细使用方法，请参考下节的示例。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"71、Go语言 之chan通道select超时机制","slug":"Golang/71、Go语言 之chan通道select超时机制","date":"2016-03-10T17:21:34.000Z","updated":"2020-08-07T14:10:11.761Z","comments":true,"path":"2016/03/11/Golang/71、Go语言 之chan通道select超时机制/","link":"","permalink":"https://www.zackaddy.xin/2016/03/11/Golang/71、Go语言 之chan通道select超时机制/","excerpt":"","text":"Go语言 之chan超时机制在前面对 channel 的介绍中，我们完全没有提到错误处理的问题，而这个问题显然是不能被忽略的。 在并发编程的通信过程中，最需要处理的就是超时问题，即向 channel 写数据时发现 channel 已满，或者从 channel 试图读取数据时发现 channel 为空。如果不正确处理这些情况，很可能会导致整个 goroutine 锁死。 虽然 goroutine 是 Go语言引入的新概念，但通信锁死问题已经存在很长时间，在之前的 C/C++ 开发中也存在。操作系统在提供此类系统级通信函数时也会考虑入超时场景，因此这些方法通常都会带一个独立的超时参数。超过设定的时间时，仍然没有处理完任务，则该方法会立即终止并返回对应的超时信息。 超时机制本身虽然也会带来一些问题，比如在运行比较快的机器或者高速的网络上运行正常的程序，到了慢速的机器或者网络上运行就会出问题，从而出现结果不一致的现象，但从根本上来说，解决死锁问题的价值要远大于所带来的问题。 使用 channel 时需要小心，比如对于以下这个用法： 1i := &lt;-ch 不出问题的话一切都正常运行。但如果出现了一个错误情况，即永远都没有人往 ch 里写数据，那么上述这个读取动作也将永远无法从 ch 中读取到数据，导致的结果就是整个 goroutine 永远阻塞并没有挽回的机会。如果 channel 只是被同一个开发者使用，那样出问题的可能性还低一些。但如果一旦对外公开，就必须考虑到最差的情况并对程序进行保护。 Go语言没有提供直接的超时处理机制，但我们可以利用 select 机制。虽然 select 机制不是专为超时而设计的，却能很方便地解决超时问题。因为 select 的特点是只要其中一个 case 已经完成，程序就会继续往下执行，而不会考虑其他 case 的情况。 基于此特性，我们来为 channel 实现超时机制： 12345678910111213// 首先，我们实现并执行一个匿名的超时等待函数timeout := make(chan bool, 1)go func() &#123; time.Sleep(1e9) // 等待1秒钟 timeout &lt;- true&#125;()// 然后我们把timeout这个channel利用起来select &#123; case &lt;-ch: // 从ch中读取到数据 case &lt;-timeout: // 一直没有从ch中读取到数据，但从timeout中读取到了数据&#125; 这样使用 select 机制可以避免永久等待的问题，因为程序会在 timeout 中获取到一个数据后继续执行，无论对 ch 的读取是否还处于等待状态，从而达成 1 秒超时的效果。 这种写法看起来是一个小技巧，但却是在 Go语言开发中避免 channel 通信超时的最有效方法。在实际的开发过程中，这种写法也需要被合理利用起来，从而有效地提高代码质量。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"70、Go语言 之chan带缓冲的通道","slug":"Golang/70、Go语言 之chan带缓冲的通道","date":"2016-03-09T19:28:31.000Z","updated":"2020-08-07T14:10:11.761Z","comments":true,"path":"2016/03/10/Golang/70、Go语言 之chan带缓冲的通道/","link":"","permalink":"https://www.zackaddy.xin/2016/03/10/Golang/70、Go语言 之chan带缓冲的通道/","excerpt":"","text":"Go语言 之chan带缓冲的通道Go语言中有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。 这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。 在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。 无缓冲通道保证收发过程同步。无缓冲收发过程类似于快递员给你电话让你下楼取快递，整个递交快递的过程是同步发生的，你和快递员不见不散。但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就成了异步收发过程，效率可以有明显的提升。带缓冲的通道就是这样的一个“快递柜”。 创建带缓冲通道如何创建带缓冲的通道呢？参见如下代码： 1通道实例 := make(chan 通道类型, 缓冲大小) 通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。 缓冲大小：决定通道最多可以保存的元素数量。 通道实例：被创建出的通道实例。 下面通过一个例子中来理解带缓冲通道的用法，参见下面的代码： 1234567891011121314package mainimport \"fmt\"func main() &#123; // 创建一个3个元素缓冲大小的整型通道 ch := make(chan int, 3) // 查看当前通道的大小 fmt.Println(len(ch)) // 发送3个整型元素到通道 ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 // 查看当前通道的大小 fmt.Println(len(ch))&#125; 代码输出如下： 1203 代码说明如下： 第 8 行，创建一个带有 3 个元素缓冲大小的整型类型的通道。 第 11 行，查看当前通道的大小。带缓冲的通道在创建完成时，内部的元素是空的，因此使用 len() 获取到的返回值为 0。 第 14～16 行，发送 3 个整型元素到通道。因为使用了缓冲通道。即便没有 goroutine 接收，发送者也不会发生阻塞。 第 19 行，由于填充了 3 个通道，此时的通道长度变为 3。阻塞条件带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞： 带缓冲通道被填满时，尝试再次发送数据时发生阻塞。 带缓冲通道为空时，尝试接收数据时发生阻塞。为什么Go语言对通道要限制长度而不提供无限长度的通道？我们知道通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"69、Go语言 之chan无缓冲通道","slug":"Golang/69、Go语言 之chan无缓冲通道","date":"2016-03-09T03:02:07.000Z","updated":"2020-08-07T14:10:11.760Z","comments":true,"path":"2016/03/09/Golang/69、Go语言 之chan无缓冲通道/","link":"","permalink":"https://www.zackaddy.xin/2016/03/09/Golang/69、Go语言 之chan无缓冲通道/","excerpt":"","text":"Go语言 之chan无缓冲通道Go语言中无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 这个示例程序展示如何用无缓冲的通道来模拟// 2 个goroutine 间的网球比赛package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")// wg 用来等待程序结束var wg sync.WaitGroupfunc init() &#123; rand.Seed(time.Now().UnixNano())&#125;// main 是所有Go 程序的入口func main() &#123; // 创建一个无缓冲的通道 court := make(chan int) // 计数加 2，表示要等待两个goroutine wg.Add(2) // 启动两个选手 go player(\"Nadal\", court) go player(\"Djokovic\", court) // 发球 court &lt;- 1 // 等待游戏结束 wg.Wait()&#125;// player 模拟一个选手在打网球func player(name string, court chan int) &#123; // 在函数退出时调用Done 来通知main 函数工作已经完成 defer wg.Done() for &#123; // 等待球被击打过来 ball, ok := &lt;-court if !ok &#123; // 如果通道被关闭，我们就赢了 fmt.Printf(\"Player %s Won\\n\", name) return &#125; // 选随机数，然后用这个数来判断我们是否丢球 n := rand.Intn(100) if n%13 == 0 &#123; fmt.Printf(\"Player %s Missed\\n\", name) // 关闭通道，表示我们输了 close(court) return &#125; // 显示击球数，并将击球数加1 fmt.Printf(\"Player %s Hit %d\\n\", name, ball) ball++ // 将球打向对手 court &lt;- ball &#125;&#125; 运行这个程序，输出结果如下所示。 12345Player Nadal Hit 1Player Djokovic Hit 2Player Nadal Hit 3Player Djokovic MissedPlayer Nadal Won","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"68、Go语言 之chan单向通道","slug":"Golang/68、Go语言 之chan单向通道","date":"2016-03-08T03:49:43.000Z","updated":"2020-08-07T14:10:11.760Z","comments":true,"path":"2016/03/08/Golang/68、Go语言 之chan单向通道/","link":"","permalink":"https://www.zackaddy.xin/2016/03/08/Golang/68、Go语言 之chan单向通道/","excerpt":"","text":"Go语言 之chan单向通道Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 只能用于发送或者接收数据。channel 本身必然是同时支持读写的，否则根本没法用。 假如一个 channel 真的只能读，那么肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写，即使写进去了，也没有丝毫意义，因为没有机会读取里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。 单向通道的声明格式我们在将一个 channel 变量传递到一个函数时，可以通过将其指定为单向 channel 变量，从而限制该函数中可以对此 channel 的操作，比如只能往这个 channel 写，或者只能从这个 channel 读。 单向 channel 变量的声明非常简单，只能发送的通道类型为chan&lt;-，只能接收的通道类型为&lt;-chan，格式如下： 12var 通道实例 chan&lt;- 元素类型 // 只能发送通道var 通道实例 &lt;-chan 元素类型 // 只能接收通道 元素类型：通道包含的元素类型。通道实例：声明的通道变量。单向通道的使用例子示例代码如下： 12345ch := make(chan int)// 声明一个只能发送的通道类型, 并赋值为chvar chSendOnly chan&lt;- int = ch//声明一个只能接收的通道类型, 并赋值为chvar chRecvOnly &lt;-chan int = ch 上面的例子中，chSendOnly 只能发送数据，如果尝试接收数据，将会出现如下报错： 1invalid operation: &lt;-chSendOnly (receive from send-only type chan&lt;- int) 同理，chRecvOnly 也是不能发送的。 当然，使用 make 创建通道时，也可以创建一个只发送或只读取的通道： 123ch := make(&lt;-chan int)var chReadOnly &lt;-chan int = ch&lt;-chReadOnly 上面代码编译正常，运行也是正确的。但是，一个不能填充数据（发送）只能读取的通道是毫无意义的。 time包中的单向通道time 包中的计时器会返回一个 timer 实例，代码如下： 123456timer := time.NewTimer(time.Second)timer的Timer类型定义如下：type Timer struct &#123; C &lt;-chan Time r runtimeTimer&#125; 第 2 行中 C 通道的类型就是一种只能接收的单向通道。如果此处不进行通道方向约束，一旦外部向通道发送数据，将会造成其他使用到计时器的地方逻辑产生混乱。 因此，单向通道有利于代码接口的严谨性。 关闭 channel关闭 channel 非常简单，直接使用 Go语言内置的 close() 函数即可： 1close(ch) 在介绍了如何关闭 channel 之后，我们就多了一个问题：如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用多重返回值的方式： 1x, ok := &lt;-ch 这个用法与 map 中的按键获取 value 的过程比较类似，只需要看第二个 bool 返回值即可，如果返回值是 false 则表示 ch 已经被关闭。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"67、Go语言 之通道chan与goroutine之间通信的管道","slug":"Golang/67、Go语言 之通道chan与goroutine之间通信的管道","date":"2016-03-06T22:15:48.000Z","updated":"2020-08-07T14:10:11.760Z","comments":true,"path":"2016/03/07/Golang/67、Go语言 之通道chan与goroutine之间通信的管道/","link":"","permalink":"https://www.zackaddy.xin/2016/03/07/Golang/67、Go语言 之通道chan与goroutine之间通信的管道/","excerpt":"","text":"Go语言 之通道chan与goroutine之间通信的管道如果说 goroutine 是 Go语言程序的并发体的话，那么 channels 就是它们之间的通信机制。一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。 Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。 在地铁站、食堂、洗手间等公共场所人很多的情况下，大家养成了排队的习惯，目的也是避免拥挤、插队导致的低效的资源使用和交换过程。代码与数据也是如此，多个 goroutine 为了争抢数据，势必造成执行的低效率，使用队列的方式是最高效的，channel 就是一种队列一样的结构。 通道的特性Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。 通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。 声明通道类型通道本身需要一个类型进行修饰，就像切片类型需要标识元素类型。通道的元素类型就是在其内部传输的数据类型，声明如下：var 通道变量 chan 通道类型 通道类型：通道内的数据类型。通道变量：保存通道的变量。 chan 类型的空值是 nil，声明后需要配合 make 后才能使用。 创建通道通道是引用类型，需要使用 make 进行创建，格式如下：通道实例 := make(chan 数据类型) 数据类型：通道内传输的元素类型。通道实例：通过make创建的通道句柄。 请看下面的例子： 1234ch1 := make(chan int) // 创建一个整型类型的通道ch2 := make(chan interface&#123;&#125;) // 创建一个空接口类型的通道, 可以存放任意格式type Equip struct&#123; /* 一些字段 */ &#125;ch2 := make(chan *Equip) // 创建Equip指针类型的通道, 可以存放*Equip 使用通道发送数据通道创建后，就可以使用通道进行发送和接收操作。 1) 通道发送数据的格式通道的发送使用特殊的操作符&lt;-，将数据通过通道发送的格式为： 1通道变量 &lt;- 值 通道变量：通过make创建好的通道实例。值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。 2) 通过通道发送数据的例子使用 make 创建一个通道后，就可以使用&lt;-向通道发送数据，代码如下： 123456// 创建一个空接口通道ch := make(chan interface&#123;&#125;)// 将0放入通道中ch &lt;- 0// 将hello字符串放入通道中ch &lt;- \"hello\" 3) 发送将持续阻塞直到数据被接收把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示，代码如下： 1234567package mainfunc main() &#123; // 创建一个整型通道 ch := make(chan int) // 尝试将0通过通道发送 ch &lt;- 0&#125; 运行代码，报错： 1fatal error: all goroutines are asleep - deadlock! 报错的意思是：运行时发现所有的 goroutine（包括main）都处于等待 goroutine。也就是说所有 goroutine 中的 channel 并没有形成发送和接收对应的代码。 使用通道接收数据通道接收同样使用&lt;-操作符，通道接收有如下特性：① 通道的收发操作在不同的两个 goroutine 间进行。 由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行。 ② 接收将持续阻塞直到发送方发送数据。 如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。 ③ 每次接收一个元素。通道一次只能接收一个数据元素。 通道的数据接收一共有以下 4 种写法。 1) 阻塞接收数据阻塞模式接收数据时，将接收变量作为&lt;-操作符的左值，格式如下： 1data := &lt;-ch 执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。 2) 非阻塞接收数据使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下： 1data, ok := &lt;-ch data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。ok：表示通道是否关闭。 非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，可以参见后面的内容。 3) 接收任意数据，忽略接收的数据阻塞接收数据后，忽略从通道返回的数据，格式如下： 1&lt;-ch 执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。 使用通道做并发同步的写法，可以参考下面的例子： 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; // 构建一个通道 ch := make(chan int) // 开启一个并发匿名函数 go func() &#123; fmt.Println(\"start goroutine\") // 通过通道通知main的goroutine ch &lt;- 0 fmt.Println(\"exit goroutine\") &#125;() fmt.Println(\"wait goroutine\") // 等待匿名goroutine &lt;-ch fmt.Println(\"all done\")&#125; 执行代码，输出如下： 1234wait goroutinestart goroutineexit goroutineall done 代码说明如下： 第 10 行，构建一个同步用的通道。 第 13 行，开启一个匿名函数的并发。 第 18 行，匿名 goroutine 即将结束时，通过通道通知 main 的 goroutine，这一句会一直阻塞直到 main 的 goroutine 接收为止。第 27 行，开启 goroutine 后，马上通过通道等待匿名 goroutine 结束。4) 循环接收通道的数据接收可以借用 for range 语句进行多个元素的接收操作，格式如下：12for data := range ch &#123;&#125; 通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过 for 遍历获得的变量只有一个，即上面例子中的 data。 遍历通道数据的例子请参考下面的代码。 使用 for 从通道中接收数据： 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"time\")func main() &#123; // 构建一个通道 ch := make(chan int) // 开启一个并发匿名函数 go func() &#123; // 从3循环到0 for i := 3; i &gt;= 0; i-- &#123; // 发送3到0之间的数值 ch &lt;- i // 每次发送完时等待 time.Sleep(time.Second) &#125; &#125;() // 遍历接收通道数据 for data := range ch &#123; // 打印通道数据 fmt.Println(data) // 当遇到数据0时, 退出接收循环 if data == 0 &#123; break &#125; &#125;&#125; 执行代码，输出如下： 12343210 代码说明如下： 第 12 行，通过 make 生成一个整型元素的通道。 第 15 行，将匿名函数并发执行。 第 18 行，用循环生成 3 到 0 之间的数值。 第 21 行，将 3 到 0 之间的数值依次发送到通道 ch 中。 第 24 行，每次发送后暂停 1 秒。 第 30 行，使用 for 从通道中接收数据。 第 33 行，将接收到的数据打印出来。 第 36 行，当接收到数值 0 时，停止接收。如果继续发送，由于接收 goroutine 已经退出，没有 goroutine 发送到通道，因此运行时将会触发宕机报错。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"66、Go语言 之goroutine和coroutine的区别","slug":"Golang/66、Go语言 之goroutine和coroutine的区别","date":"2016-03-05T17:10:58.000Z","updated":"2020-08-07T14:10:11.759Z","comments":true,"path":"2016/03/06/Golang/66、Go语言 之goroutine和coroutine的区别/","link":"","permalink":"https://www.zackaddy.xin/2016/03/06/Golang/66、Go语言 之goroutine和coroutine的区别/","excerpt":"","text":"Go语言 之goroutine和coroutine的区别C#、Lua、Python 语言都支持 coroutine 特性。coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同： goroutine 可能发生并行执行； 但 coroutine 始终顺序执行。 goroutines 意味着并行（或者可以以并行的方式部署），coroutines 一般来说不是这样的，goroutines 通过通道来通信；coroutines 通过让出和恢复操作来通信，goroutines 比 coroutines 更强大，也很容易从 coroutines 的逻辑复用到 goroutines。 狭义地说，goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持；coroutine 始终发生在单线程，coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。 goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。 goroutine 和 coroutine 的概念和运行机制都是脱胎于早期的操作系统。 coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。 goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"65、Go语言 之并发与并行","slug":"Golang/65、Go语言 之并发与并行","date":"2016-03-04T18:53:25.000Z","updated":"2020-08-07T14:10:11.759Z","comments":true,"path":"2016/03/05/Golang/65、Go语言 之并发与并行/","link":"","permalink":"https://www.zackaddy.xin/2016/03/05/Golang/65、Go语言 之并发与并行/","excerpt":"","text":"Go语言 之并发与并行在讲解并发概念时，总会涉及另外一个概念并行。下面让我们来了解并发和并行之间的区别。 并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。 并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。 举例 并发：排两个队伍去一台咖啡机冲咖啡 并行：排两个队伍去两台咖啡机冲咖啡 并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。 在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，也是指导 Go语言设计的哲学。 如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"64、Go语言 之GOMAXPROCS调整并发的运行性能","slug":"Golang/64、Go语言 之GOMAXPROCS调整并发的运行性能","date":"2016-03-03T22:39:02.000Z","updated":"2020-08-07T14:10:11.759Z","comments":true,"path":"2016/03/04/Golang/64、Go语言 之GOMAXPROCS调整并发的运行性能/","link":"","permalink":"https://www.zackaddy.xin/2016/03/04/Golang/64、Go语言 之GOMAXPROCS调整并发的运行性能/","excerpt":"","text":"Go语言 之GOMAXPROCS调整并发的运行性能在 Go语言程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为： 1runtime.GOMAXPROCS(逻辑CPU数量) 这里的逻辑CPU数量可以有如下几种数值： &lt;1：不修改任何数值。 =1：单核心执行。 &gt;1：多核并发执行。 一般情况下，可以使用 runtime.NumCPU() 查询 CPU 数量，并使用 runtime.GOMAXPROCS() 函数进行设置，例如： 1runtime.GOMAXPROCS(runtime.NumCPU()) Go 1.5 版本之前，默认使用的是单核心执行。从 Go 1.5 版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用 CPU。 GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"63、Go语言 之race竞争检测器","slug":"Golang/63、Go语言 之race竞争检测器","date":"2016-03-02T23:52:26.000Z","updated":"2020-08-07T14:10:11.759Z","comments":true,"path":"2016/03/03/Golang/63、Go语言 之race竞争检测器/","link":"","permalink":"https://www.zackaddy.xin/2016/03/03/Golang/63、Go语言 之race竞争检测器/","excerpt":"","text":"Go语言 之race竞争检测器Go语言中如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race candition）。 竞争状态的存在是让并发程序变得复杂的地方，十分容易引起潜在问题。对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个 goroutine 对共享资源进行读和写操作。 【示例】包含竞争状态的示例程序。 12345678910111213141516171819202122232425262728293031323334353637383940// 这个示例程序展示如何在程序里造成竞争状态// 实际上不希望出现这种情况package mainimport ( \"fmt\" \"runtime\" \"sync\")var ( // counter 是所有goroutine 都要增加其值的变量 counter int // wg 用来等待程序结束 wg sync.WaitGroup)// main 是所有Go 程序的入口func main() &#123; // 计数加 2，表示要等待两个goroutine wg.Add(2) // 创建两个goroutine go incCounter(1) go incCounter(2) // 等待 goroutine 结束 wg.Wait() fmt.Println(\"Final Counter:\", counter)&#125;// incCounter 增加包里counter 变量的值func incCounter(id int) &#123; // 在函数退出时调用Done 来通知main 函数工作已经完成 defer wg.Done() for count := 0; count &lt; 2; count++ &#123; // 捕获 counter 的值 value := counter // 当前 goroutine 从线程退出，并放回到队列 runtime.Gosched() // 增加本地value 变量的值 value++ // 将该值保存回counter counter = value &#125;&#125; 输出结果如下所示。 1Final Counter: 2 变量 counter 会进行 4 次读和写操作，每个 goroutine 执行两次。但是，程序终止时，counter 变量的值为 2。下图提供了为什么会这样的线索。 竞争状态下程序行为的图像表达图：竞争状态下程序行为的图像表达 每个 goroutine 都会覆盖另一个 goroutine 的工作。这种覆盖发生在goroutine 切换的时候。每个 goroutine 创造了一个 counter 变量的副本，之后就切换到另一个 goroutine。当这个 goroutine 再次运行的时候，counter 变量的值已经改变了，但是 goroutine 并没有更新自己的那个副本的值，而是继续使用这个副本的值，用这个值递增，并存回 counter 变量，结果覆盖了另一个 goroutine 完成的工作。 代码说明如下： 在第 25 行和第 26 行，使用 incCounter 函数创建了两个 goroutine。 在第 34 行，incCounter 函数对包内变量 counter 进行了读和写操作，而这个变量是这个示例程序里的共享资源。每个 goroutine 都会先读出这个 counter 变量的值。 在第 40 行将 counter 变量的副本存入一个叫作 value 的本地变量。 在第 46 行，incCounter 函数对 value 的副本的值加 1。 在第 49 行将这个新值存回到 counter 变量。 这个函数在第 43 行调用了 runtime 包的 Gosched 函数，用于将 goroutine 从当前线程退出，给其他 goroutine 运行的机会。在两次操作中间这样做的目的是强制调度器切换两个 goroutine，以便让竞争状态的效果变得更明显。 Go语言有一个特别的工具，可以在代码里检测竞争状态。在查找这类错误的时候，这个工具非常好用，尤其是在竞争状态并不像这个例子里这么明显的时候。让我们用这个竞争检测器来检测一下我们的示例代码，代码如下所示。 12345678910111213141516171819go build -race // 用竞争检测器标志来编译程序./example // 运行程序==================WARNING: DATA RACEWrite by goroutine 5: main.incCounter() /example/main.go:49 +0x96Previous read by goroutine 6: main.incCounter() /example/main.go:40 +0x66Goroutine 5 (running) created at: main.main() /example/main.go:25 +0x5cGoroutine 6 (running) created at: main.main() /example/main.go:26 +0x73==================Final Counter: 2Found 1 data race(s) 上述代码中的竞争检测器指出了 4 行代码有问题，如下所示。 1234Line 49: counter = valueLine 40: value := counterLine 25: go incCounter(1)Line 26: go incCounter(2) 上面展示了竞争检测器查到的哪个 goroutine 引发了数据竞争，以及哪两行代码有冲突。毫不奇怪，这几行代码分别是对 counter 变量的读和写操作。一种修正代码、消除竞争状态的办法是，使用 Go语言提供的锁机制，来锁住共享资源，从而保证 goroutine 的同步状态。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"62、Go语言 之goroutine轻量级线程","slug":"Golang/62、Go语言 之goroutine轻量级线程","date":"2016-03-01T18:54:30.000Z","updated":"2020-08-07T14:10:11.758Z","comments":true,"path":"2016/03/02/Golang/62、Go语言 之goroutine轻量级线程/","link":"","permalink":"https://www.zackaddy.xin/2016/03/02/Golang/62、Go语言 之goroutine轻量级线程/","excerpt":"","text":"Go语言 之goroutine轻量级线程在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。 虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go语言中被称为 goroutine。 goroutine 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。 Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。 使用普通函数创建 goroutineGo 程序中使用 go 关键字为一个函数创建一个 goroutine。一个函数可以被创建多个 goroutine，一个 goroutine 必定对应一个函数。 1) 格式为一个普通函数创建 goroutine 的写法如下：go 函数名( 参数列表 ) 函数名：要调用的函数名。参数列表：调用函数需要传入的参数。 使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。 如果需要在 goroutine 中返回数据，请使用后面介绍的通道（channel）特性，通过通道把数据从 goroutine 中作为返回值传出。 2) 例子使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码： 12345678910111213141516171819202122package mainimport ( \"fmt\" \"time\")func running() &#123; var times int // 构建一个无限循环 for &#123; times++ fmt.Println(\"tick\", times) // 延时1秒 time.Sleep(time.Second) &#125;&#125;func main() &#123; // 并发执行程序 go running() // 接受命令行输入, 不做任何事情 var input string fmt.Scanln(&amp;input)&#125; 命令行输出如下： 12345tick 1tick 2tick 3tick 4tick 5 代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。 代码说明如下： 第 12 行，使用 for 形成一个无限循环。 第 13 行，times 变量在循环中不断自增。 第 14 行，输出 times 变量的值。 第 17 行，使用 time.Sleep 暂停 1 秒后继续循环。 第 25 行，使用 go 关键字让 running() 函数并发运行。 第 29 行，接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。 这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。 使用匿名函数创建goroutinego 关键字后也可以为匿名函数或闭包启动 goroutine。 1) 使用匿名函数创建goroutine的格式使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数，格式如下： 123go func( 参数列表 )&#123; 函数体&#125;( 调用参数列表 ) 其中： 参数列表：函数体内的参数变量列表。 函数体：匿名函数的代码。 调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。2) 使用匿名函数创建goroutine的例子在 main() 函数中创建一个匿名函数并为匿名函数启动 goroutine。匿名函数没有参数。代码将并行执行定时打印计数的效果。参见下面的代码：1234567891011121314151617package mainimport ( \"fmt\" \"time\")func main() &#123; go func() &#123; var times int for &#123; times++ fmt.Println(\"tick\", times) time.Sleep(time.Second) &#125; &#125;() var input string fmt.Scanln(&amp;input)&#125; 代码说明如下： 第 10 行，go 后面接匿名函数启动 goroutine。 第 12～19 行的逻辑与前面程序的 running() 函数一致。 第 21 行的括号的功能是调用匿名函数的参数列表。由于第 10 行的匿名函数没有参数，因此第 21 行的参数列表也是空的。提示所有 goroutine 在 main() 函数结束时会一同结束。 goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。 终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。虽然可以用 golang.org/x/net/context 包进行 goroutine 生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。 截止 Go 1.9 版本，暂时没有标准接口获取 goroutine 的 ID。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"61、Go语言 之go mod包依赖管理工具使用详解","slug":"Golang/61、Go语言 之go mod包依赖管理工具使用详解","date":"2016-02-29T19:12:18.000Z","updated":"2020-08-07T14:10:11.758Z","comments":true,"path":"2016/03/01/Golang/61、Go语言 之go mod包依赖管理工具使用详解/","link":"","permalink":"https://www.zackaddy.xin/2016/03/01/Golang/61、Go语言 之go mod包依赖管理工具使用详解/","excerpt":"","text":"Go语言 之go mod包依赖管理工具使用详解 go run 运行当个.go文件 go install 在编译源代码之后还安装到指定的目录 go build 加上可编译的go源文件可以得到一个可执行文件 go get = git clone + go install 从指定源上面下载或者更新指定的代码和依赖，并对他们进行编译和安装 go modules 是 golang 1.11 新加的特性。现在 1.12 已经发布了，是时候用起来了。Modules 官方定义为：模块是相关 Go 包的集合。modules 是源代码交换和版本控制的单元。go 命令直接支持使用 modules，包括记录和解析对其他模块的依赖性。modules 替换旧的基于 GOPATH 的方法来指定在给定构建中使用哪些源文件。 如何使用 Modules？1) 首先需要把 golang 升级到 1.11（现在 1.12 已经发布了，建议使用 1.12）2) 设置 GO111MODULEGO111MODULE GO111MODULE 有三个值：off, on 和 auto（默认值）。 GO111MODULE=off，go 命令行将不会支持 module 功能，寻找依赖包的方式将会沿用旧版本那种通过 vendor 目录或者 GOPATH 模式来查找。 GO111MODULE=on，go 命令行会使用 modules，而一点也不会去 GOPATH 目录下查找。 GO111MODULE=auto，默认值，go 命令行将会根据当前目录来决定是否启用 module 功能。这种情况下可以分为两种情形： 当前目录在 GOPATH/src 之外且该目录包含 go.mod 文件 当前文件在包含 go.mod 文件的目录下面。 当 modules 功能启用时，依赖包的存放位置变更为 $GOPATH/pkg，允许同一个 package 多个版本并存，且多个项目可以共享缓存的 module。 go modgolang 提供了 go mod 命令来管理包。 go mod 有以下命令： 命令 说明 download download modules to local cache (下载依赖包) edit edit go.mod from tools or scripts (编辑go.mod) graph print module requirement graph (打印模块依赖图) init initialize new module in current directory (在当前目录初始化mod) tidy add missing and remove unused modules (拉取缺少的模块，移除不用的模块) vendor make vendored copy of dependencies (将依赖复制到vendor下) verify verify dependencies have expected content (验证依赖是否正确) why explain why packages or modules are needed (解释为什么需要依赖) ### 如何在项目中使用 【示例 1】创建一个新项目 1) 在 GOPATH 目录之外新建一个目录，并使用go mod init初始化生成 go.mod 文件12345678910~ mkdir hello~ cd hellohello go mod init hellogo: creating new go.mod: module hellohello lsgo.modhello cat go.modmodule hellogo 1.12 go.mod 文件一旦创建后，它的内容将会被 go toolchain 全面掌控。go toolchain 会在各类命令执行时，比如 go get、go build、go mod 等修改和维护 go.mod 文件。 go.mod 提供了 module, require、replace 和 exclude 四个命令 module 语句指定包的名字（路径） require 语句指定的依赖项模块 replace 语句可以替换依赖项模块 exclude 语句可以忽略依赖项模块 2) 添加依赖新建一个 server.go 文件，写入以下代码： 123456789101112package mainimport ( \"net/http\" \"github.com/labstack/echo\")func main() &#123; e := echo.New() e.GET(\"/\", func(c echo.Context) error &#123; return c.String(http.StatusOK, \"Hello, World!\") &#125;) e.Logger.Fatal(e.Start(\":1323\"))&#125; 执行go run server.go运行代码会发现 go mod 会自动查找依赖自动下载： 12345678910111213141516171819$ go run server.gogo: finding github.com/labstack/echo v3.3.10+incompatiblego: downloading github.com/labstack/echo v3.3.10+incompatiblego: extracting github.com/labstack/echo v3.3.10+incompatiblego: finding github.com/labstack/gommon/color latestgo: finding github.com/labstack/gommon/log latestgo: finding github.com/labstack/gommon v0.2.8# 此处省略很多行... ____ __ / __/___/ / ___/ _// __/ _ \\/ _ \\/___/\\__/_//_/\\___/ v3.3.10-devHigh performance, minimalist Go web frameworkhttps://echo.labstack.com____________________________________O/_______ O\\⇨ http server started on [::]:1323 现在查看 go.mod 内容：$ cat go.mod 123456789101112module hellogo 1.12require ( github.com/labstack/echo v3.3.10+incompatible // indirect github.com/labstack/gommon v0.2.8 // indirect github.com/mattn/go-colorable v0.1.1 // indirect github.com/mattn/go-isatty v0.0.7 // indirect github.com/valyala/fasttemplate v1.0.0 // indirect golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect) go module 安装 package 的原則是先拉最新的 release tag，若无 tag 则拉最新的 commit，详见 Modules 官方介绍。go 会自动生成一个 go.sum 文件来记录 dependency tree： 12345678$ cat go.sumgithub.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=github.com/labstack/gommon v0.2.8 h1:JvRqmeZcfrHC5u6uVleB4NxxNbzx6gpbJiQknDbKQu0=github.com/labstack/gommon v0.2.8/go.mod h1:/tj9csK2iPSBvn+3NLM9e52usepMtrd5ilFYA+wQNJ4=github.com/mattn/go-colorable v0.1.1 h1:G1f5SKeVxmagw/IyvzvtZE4Gybcc4Tr1tf7I8z0XgOg=github.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=... 省略很多行 再次执行脚本go run server.go发现跳过了检查并安装依赖的步骤。 可以使用命令 go list -m -u all 来检查可以升级的 package，使用 go get -u need-upgrade-package 升级后会将新的依赖版本更新到 go.mod * 也可以使用 go get -u 升级所有依赖 go get 升级有一下几种方法： 运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z 是修订版本号，y 是次要版本号) 运行 go get -u=patch 将会升级到最新的修订版本 运行 go get package@version 将会升级到指定的版本号 version 运行 go get 如果有版本的更改，那么 go.mod 文件也会更改 【示例 2】改造现有项目 (helloword) 项目目录为： 1234567$ tree.├── api│ └── apis.go└── server.go1 directory, 2 files server.go 源码为： 12345678910package mainimport ( api \"./api\" // 这里使用的是相对路径 \"github.com/labstack/echo\")func main() &#123; e := echo.New() e.GET(\"/\", api.HelloWorld) e.Logger.Fatal(e.Start(\":1323\"))&#125; api/apis.go 源码为： 12345678package apiimport ( \"net/http\" \"github.com/labstack/echo\")func HelloWorld(c echo.Context) error &#123; return c.JSON(http.StatusOK, \"hello world\")&#125; 1) 使用 go mod init *** 初始化 go.mod$ go mod init helloworld 1go: creating new go.mod: module helloworld 2) 运行go run server.go 123456go: finding github.com/labstack/gommon/color latestgo: finding github.com/labstack/gommon/log latestgo: finding golang.org/x/crypto/acme/autocert latestgo: finding golang.org/x/crypto/acme latestgo: finding golang.org/x/crypto latestbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api 首先还是会查找并下载安装依赖，然后运行脚本 server.go，这里会抛出一个错误： 1build command-line-arguments: cannot find module for path _/home/gs/helloworld/api 但是 go.mod 已经更新： 12345678910111213$ cat go.modmodule helloworldgo 1.12require ( github.com/labstack/echo v3.3.10+incompatible // indirect github.com/labstack/gommon v0.2.8 // indirect github.com/mattn/go-colorable v0.1.1 // indirect github.com/mattn/go-isatty v0.0.7 // indirect github.com/valyala/fasttemplate v1.0.0 // indirect golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect) 那为什么会抛出这个错误呢？ 这是因为 server.go 中使用 internal package 的方法跟以前已经不同了，由于 go.mod 会扫描同工作目录下所有 package 并且变更引入方法，必须将 helloworld 当成路径的前缀，也就是需要写成 import helloworld/api，以往 GOPATH/dep 模式允许的 import ./api 已经失效，详情可以查看这个 issue。 3) 更新旧的 package import 方式 所以 server.go 需要改写成： 12345678910package mainimport ( api \"helloworld/api\" // 这是更新后的引入方法 \"github.com/labstack/echo\")func main() &#123; e := echo.New() e.GET(\"/\", api.HelloWorld) e.Logger.Fatal(e.Start(\":1323\"))&#125; 一个小坑：开始在 golang1.11 下使用 go mod 遇到过 go build github.com/valyala/fasttemplate: module requires go 1.12 这种错误，遇到类似这种需要升级到 1.12 的问题，直接升级 golang1.12 就好了。 4) 到这里就和新创建一个项目没什么区别了 使用 replace 替换无法直接获取的 package由于某些已知的原因，并不是所有的package都能成功下载，比如：golang.org 下的包。 modules 可以通过在 go.mod 文件中使用 replace 指令替换成 github 上对应的库，比如： 123replace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a) 或者 1replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =&gt; github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"60、Go语言 之工厂模式自动注册——管理多个包的结构体","slug":"Golang/60、Go语言 之工厂模式自动注册——管理多个包的结构体","date":"2016-02-28T16:48:05.000Z","updated":"2020-08-07T14:10:11.758Z","comments":true,"path":"2016/02/29/Golang/60、Go语言 之工厂模式自动注册——管理多个包的结构体/","link":"","permalink":"https://www.zackaddy.xin/2016/02/29/Golang/60、Go语言 之工厂模式自动注册——管理多个包的结构体/","excerpt":"","text":"Go语言 之工厂模式自动注册——管理多个包的结构体本例利用包的 init 特性，将 cls1 和 cls2 两个包注册到工厂，使用字符串创建这两个注册好的结构实例。 完整代码的结构如下： 1234567891011.└── src └── chapter08 └── clsfactory ├── main.go └── base └── factory.go └── cls1 └── reg.go └── cls2 └── reg.go 类工厂（具体文件：…/chapter08/clsfactory/base/factory.go） 123456789101112131415161718192021package base// 类接口type Class interface &#123; Do()&#125;var (// 保存注册好的工厂信息 factoryByName = make(map[string]func() Class))// 注册一个类生成工厂func Register(name string, factory func() Class) &#123; factoryByName[name] = factory&#125;// 根据名称创建对应的类func Create(name string) Class &#123; if f, ok := factoryByName[name]; ok &#123; return f() &#125; else &#123; panic(\"name not found\") &#125;&#125; 这个包叫base，负责处理注册和使用工厂的基础代码，该包不会引用任何外部的包。 以下是对代码的说明： 第 4 行定义了“产品”：类。 第 10 行使用了一个 map 保存注册的工厂信息。 第 14 行提供给工厂方注册使用，所谓的“工厂”，就是一个定义为func() Class的普通函数，调用此函数，创建一个类实例，实现的工厂内部结构体会实现 Class 接口。 第 19 行定义通过名字创建类实例的函数，该函数会在注册好后调用。 第 20 行在已经注册的信息中查找名字对应的工厂函数，找到后，在第 21 行调用并返回接口。 第 23 行是如果创建的名字没有找到时，报错。 类1及注册代码（具体文件：…/chapter08/clsfactory/cls1/reg.go） 123456789101112131415161718package cls1import ( \"chapter08/clsfactory/base\" \"fmt\")// 定义类1type Class1 struct &#123;&#125;// 实现Class接口func (c *Class1) Do() &#123; fmt.Println(\"Class1\")&#125;func init() &#123; // 在启动时注册类1工厂 base.Register(\"Class1\", func() base.Class &#123; return new(Class1) &#125;)&#125; 上面的代码展示了Class1的工厂及产品定义过程。 第 9～15 行定义 Class1 结构，该结构实现了 base 中的 Class 接口。 第 20 行，Class1 结构的实例化过程叫 Class1 的工厂，使用 base.Register() 函数在 init() 函数被调用时与一个字符串关联，这样，方便以后通过名字重新调用该函数并创建实例。 类2及注册代码（具体文件：…/chapter08/clsfactory/cls2/reg.go） 123456789101112131415161718package cls2import ( \"chapter08/clsfactory/base\" \"fmt\")// 定义类2type Class2 struct &#123;&#125;// 实现Class接口func (c *Class2) Do() &#123; fmt.Println(\"Class2\")&#125;func init() &#123; // 在启动时注册类2工厂 base.Register(\"Class2\", func() base.Class &#123; return new(Class2) &#125;)&#125; Class2 的注册与 Class1 的定义和注册过程类似。 类工程主流程（具体文件：…/chapter08/clsfactory/main.go） 1234567891011121314package mainimport ( \"chapter08/clsfactory/base\" _ \"chapter08/clsfactory/cls1\" // 匿名引用cls1包, 自动注册 _ \"chapter08/clsfactory/cls2\" // 匿名引用cls2包, 自动注册)func main() &#123; // 根据字符串动态创建一个Class1实例 c1 := base.Create(\"Class1\") c1.Do() // 根据字符串动态创建一个Class2实例 c2 := base.Create(\"Class2\") c2.Do()&#125; 下面是对代码的说明： 第 5 和第 6 行使用匿名引用方法导入了 cls1 和 cls2 两个包。在 main() 函数调用前，这两个包的 init() 函数会被自动调用，从而自动注册 Class1 和 Class2。 第 12 和第 16 行，通过 base.Create() 方法查找字符串对应的类注册信息，调用工厂方法进行实例创建。 第 13 和第 17 行，调用类的方法。 执行下面的指令进行编译： 123export GOPATH=/home/davy/golangbook/codego install chapter08/clsfactory$GOPATH/bin/clsfactory 代码输出如下： 12Class1Class2","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"59、Go语言 之import导入包","slug":"Golang/59、Go语言 之import导入包","date":"2016-02-28T00:38:50.000Z","updated":"2020-08-07T14:10:11.757Z","comments":true,"path":"2016/02/28/Golang/59、Go语言 之import导入包/","link":"","permalink":"https://www.zackaddy.xin/2016/02/28/Golang/59、Go语言 之import导入包/","excerpt":"","text":"Go语言 之import导入包可以在一个 Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用/进行路径分隔。 默认导入的写法导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的。 1) 单行导入单行导入格式如下： 12import \"包1\"import \"包2\" 2) 多行导入当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下： 12345import( \"包1\" \"包2\" …) 理解 import 的机制。 1234567.└── src └── chapter08 └── importadd ├── main.go └── mylib └── add.go 代码8-1 加函数（具体文件：…/chapter08/importadd/mylib/add.go） 1234package mylibfunc Add(a, b int) int &#123; return a + b&#125; 第 3 行中的 Add() 函数以大写 A 开头，表示将 Add() 函数导出供包外使用。当首字母小写时，为包内使用，包外无法引用到。 add.go 在 mylib 文件夹下，习惯上将文件夹的命名与包名一致，命名为 mylib 包。 代码8-2 导入包（具体文件：…/chapter08/importadd/main.go） 12345678package mainimport ( \"chapter08/importadd/mylib\" \"fmt\")func main() &#123; fmt.Println(mylib.Add(1, 2))&#125; 代码说明如下： 第 4 行，导入 chapter08/importadd/mylib 包。 第 9 行，使用 mylib 作为包名，并引用 Add() 函数调用。 在命令行中运行下面代码： 123export GOPATH=/home/davy/golangbook/codego install chapter08/importadd$GOPATH/bin/importadd 命令说明如下： 第 1 行，根据你的 GOPATH 不同，设置 GOPATH。 第 2 行，使用 go install 指令编译并安装 chapter08/code8-1 到 GOPATH 的 bin 目录下。 第 3 行，执行 GOPATH 的 bin 目录下的可执行文件 code8-1。 运行代码，输出结果如下： 13 导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt 和 goimports 工具都可以将不同分组导入的包独立排序。） 1234567import ( \"fmt\" \"html/template\" \"os\" \"golang.org/x/net/html\" \"golang.org/x/net/ipv4\") 导入包后自定义引用的包名如果我们想同时导入两个有着名字相同的包，例如 math/rand 包和 crypto/rand 包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。 1234import ( \"crypto/rand\" mrand \"math/rand\" // 将名称替换为mrand避免冲突) 导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。 导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为 path 的变量，那么我们可以将”path”标准包重命名为 pathpkg。 每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。 匿名导入包——只导入包但不使用包内类型和数值如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下： 123import ( _ \"path/to/package\") 其中，path/to/package 表示要导入的包名，下画线_表示匿名导入包。 匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。 包在程序启动前的初始化入口：init在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。 例如，为了提高数学库计算三角函数的执行效率，可以在程序启动时，将三角函数的值提前在内存中建成索引表，外部程序通过查表的方式迅速获得三角函数的值。但是三角函数索引表的初始化函数的调用不希望由每一个外部使用三角函数的开发者调用，如果在三角函数的包内有一个机制可以告诉三角函数包程序何时启动，那么就可以解决初始化的问题。 Go 语言为以上问题提供了一个非常方便的特性：init() 函数。 init() 函数的特性如下：每个源码可以使用 1 个 init() 函数。init() 函数会在程序执行前（main() 函数执行前）被自动调用。调用顺序为 main() 中引用的包，以深度优先顺序初始化。 例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为： 1C.init→B.init→A.init→main 说明：同一个包中的多个 init() 函数的调用顺序不可预期。init() 函数不能被其他函数调用。 理解包导入后的init()函数初始化顺序Go 语言包会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。 在运行时，被最后导入的包会最先初始化并调用 init() 函数。 通过下面的代码理解包的初始化顺序。 代码8-3 包导入初始化顺序入口（…/chapter08/pkginit/main.go） 12345package mainimport \"chapter08/code8-2/pkg1\"func main() &#123; pkg1.ExecPkg1()&#125; 代码说明如下： 第 3 行，导入 pkg1 包。 第 7 行，调用 pkg1 包的 ExecPkg1() 函数。 代码8-4 包导入初始化顺序pkg1（…/chapter08/pkginit/pkg1/pkg1.go） 123456789101112package pkg1import ( \"chapter08/code8-2/pkg2\" \"fmt\")func ExecPkg1() &#123; fmt.Println(\"ExecPkg1\") pkg2.ExecPkg2()&#125;func init() &#123; fmt.Println(\"pkg1 init\")&#125; 代码说明如下： 第 4 行，导入 pkg2 包。 第 8 行，声明 ExecPkg1() 函数。 第 12 行，调用 pkg2 包的 ExecPkg2() 函数。 第 15 行，在 pkg1 包初始化时，打印 pkg1 init。 代码8-5 包导入初始化顺序pkg2（…/chapter08/pkginit/pkg2/pkg2.go） 12345678package pkg2import \"fmt\"func ExecPkg2() &#123; fmt.Println(\"ExecPkg2\")&#125;func init() &#123; fmt.Println(\"pkg2 init\")&#125; 代码说明如下： 第 5 行，声明 ExecPkg2() 函数。 第 10 行，在 pkg2 包初始化时，打印 pkg2 init。 执行代码，输出如下： 1234pkg2 initpkg1 initExecPkg1ExecPkg2","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"58、Go语言 之让外部访问包的类型和值","slug":"Golang/58、Go语言 之让外部访问包的类型和值","date":"2016-02-26T21:43:40.000Z","updated":"2020-08-07T14:10:11.757Z","comments":true,"path":"2016/02/27/Golang/58、Go语言 之让外部访问包的类型和值/","link":"","permalink":"https://www.zackaddy.xin/2016/02/27/Golang/58、Go语言 之让外部访问包的类型和值/","excerpt":"","text":"Go语言 之让外部访问包的类型和值在 Go语言中，如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。 导出包内标识符下面代码中包含一系列未导出标识符，它们的首字母都为小写，这些标识符可以在包内自由使用，但是包外无法访问它们，代码如下： 12345package mypkgvar myVar = 100const myConst = \"hello\"type myStruct struct &#123;&#125; 将 myStruct 和 myConst 首字母大写，导出这些标识符，修改后代码如下： 12345package mypkgvar myVar = 100const MyConst = \"hello\"type MyStruct struct &#123;&#125; 此时，MyConst 和 MyStruct 可以被外部访问，而 myVar 由于首字母是小写，因此只能在 mypkg 包内使用，不能被外部包引用。 导出结构体及接口成员在被导出的结构体或接口中，如果它们的字段或方法首字母是大写，外部可以访问这些字段和方法，代码如下： 123456789101112type MyStruct struct &#123; // 包外可以访问的字段 ExportedField int // 仅限包内访问的字段 privateField int&#125;type MyInterface interface &#123; // 包外可以访问的方法 ExportedMethod() // 仅限包内访问的方法 privateMethod()&#125; 在代码中，MyStruct 的 ExportedField 和 MyInterface 的 ExportedMethod() 可以被包外访问。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"57、Go语言 之常用内置包简介","slug":"Golang/57、Go语言 之常用内置包简介","date":"2016-02-26T03:25:51.000Z","updated":"2020-08-07T14:10:11.756Z","comments":true,"path":"2016/02/26/Golang/57、Go语言 之常用内置包简介/","link":"","permalink":"https://www.zackaddy.xin/2016/02/26/Golang/57、Go语言 之常用内置包简介/","excerpt":"","text":"Go语言 之常用内置包简介标准的Go语言代码库中包含了大量的包，并且在安装 Go 的时候多数会自动安装到系统中。我们可以在 $GOROOT/src/pkg 目录中查看这些包。下面简单介绍一些我们开发中常用的包。 1) fmtfmt 包实现了格式化的标准输入输出，这与C语言中的 printf 和 scanf 类似。其中的 fmt.Printf() 和 fmt.Println() 是开发者使用最为频繁的函数。 格式化短语派生于C语言，一些短语（%- 序列）是这样使用：%v：默认格式的值。当打印结构时，加号（%+v）会增加字段名；%#v：Go样式的值表达；%T：带有类型的 Go 样式的值表达。 2) io这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。 3) bufiobufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。 在 bufio 各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行。当发起一次读写操作时，会首先尝试从缓冲区获取数据，只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。 4) sortsort 包提供了用于对切片和用户定义的集合进行排序的功能。 5) strconvstrconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。 6) osos 包提供了不依赖平台的操作系统函数接口，设计像 Unix 风格，但错误处理是 go 风格，当 os 包使用时，如果失败后返回错误类型而不是错误数量。 7) syncsync 包实现多线程中锁机制以及其他同步互斥机制。 8) flagflag 包提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。 9) encoding/jsonJSON 目前广泛用做网络程序中的通信格式。encoding/json 包提供了对 JSON 的基本支持，比如从一个对象序列化为 JSON 字符串，或者从 JSON 字符串反序列化出一个具体的对象等。 10) html/template主要实现了 web 开发中生成 html 的 template 的一些函数。 11) net/httpnet/http 包提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。 通过 net/http 包，只需要数行代码，即可实现一个爬虫或者一个 Web 服务器，这在传统语言中是无法想象的。 12) reflectreflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。 13) os/execos/exec 包提供了执行自定义 linux 命令的相关实现。 14) stringsstrings 包主要是处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。 strings 包与 bytes 包的函数接口功能基本一致。 15) bytesbytes 包提供了对字节切片进行读写操作的一系列函数。字节切片处理的函数比较多，分为基本处理函数、比较函数、后缀检查函数、索引函数、分割函数、大小写处理函数和子切片处理函数等。 16) loglog 包主要用于在程序中输出日志。 log 包中提供了三类日志输出接口，Print、Fatal 和 Panic。Print 是普通输出；Fatal 是在执行完 Print 后，执行 os.Exit(1)；Panic 是在执行完 Print 后调用 panic() 方法。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"56、Go语言 之包的简单示例","slug":"Golang/56、Go语言 之包的简单示例","date":"2016-02-24T21:36:08.000Z","updated":"2020-08-07T14:10:11.756Z","comments":true,"path":"2016/02/25/Golang/56、Go语言 之包的简单示例/","link":"","permalink":"https://www.zackaddy.xin/2016/02/25/Golang/56、Go语言 之包的简单示例/","excerpt":"","text":"Go语言 之包的简单示例12345work - main - main.go - model - person.go person.go 中的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435package modelimport \"fmt\"type person struct &#123; Name string age int //其它包不能直接访问.. sal float64&#125;//写一个工厂模式的函数，相当于构造函数func NewPerson(name string) *person &#123; return &amp;person&#123; Name : name, &#125;&#125;//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法func (p *person) SetAge(age int) &#123; if age &gt;0 &amp;&amp; age &lt;150 &#123; p.age = age &#125; else &#123; fmt.Println(\"年龄范围不正确..\") //给程序员给一个默认值 &#125;&#125;func (p *person) GetAge() int &#123; return p.age&#125;func (p *person) SetSal(sal float64) &#123; if sal &gt;= 3000 &amp;&amp; sal &lt;= 30000 &#123; p.sal = sal &#125; else &#123; fmt.Println(\"薪水范围不正确..\") &#125;&#125;func (p *person) GetSal() float64 &#123; return p.sal&#125; main.go 中的代码如下所示： 123456789101112package mainimport ( \"fmt\" \"../model\")func main() &#123; p := model.NewPerson(\"smith\") p.SetAge(18) p.SetSal(5000) fmt.Println(p) fmt.Println(p.Name, \" age =\", p.GetAge(), \" sal = \", p.GetSal())&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"55、Go语言 之包的基本介绍","slug":"Golang/55、Go语言 之包的基本介绍","date":"2016-02-24T01:37:44.000Z","updated":"2020-08-07T14:10:11.756Z","comments":true,"path":"2016/02/24/Golang/55、Go语言 之包的基本介绍/","link":"","permalink":"https://www.zackaddy.xin/2016/02/24/Golang/55、Go语言 之包的基本介绍/","excerpt":"","text":"Go语言 之包的基本介绍包的基本概念Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。 包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在GOPATH/src/a/b/ 下定义一个包 c。在包 c 的源码中只需声明为package c，而不是声明为package a/b/c，但是在导入 c 包时，需要带上路径，例如import &quot;a/b/c&quot;。 包的习惯用法： 包名一般是小写的，使用一个简短且有意义的名称。 包名一般要和所在的目录同名，也可以不同，包名中不能包含- 等特殊符号。 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。 包名为 main 的包为应用程序的入口包，编译不包含 main - 包的源码文件时不会得到可执行文件。一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。包的导入要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：import “包的路径” 注意事项：import 导入语句通常放在源码文件开头包声明语句的下面；导入的包名需要使用双引号包裹起来；包名是从GOPATH/src/ 后开始计算的，使用/ 进行路径分隔。 包的导入有两种写法，分别是单行导入和多行导入。 单行导入单行导入的格式如下： 12import \"包 1 的路径\"import \"包 2 的路径\" 多行导入多行导入的格式如下： 1234import ( \"包 1 的路径\" \"包 2 的路径\") 包的导入路径包的引用路径有两种写法，分别是全路径导入和相对路径导入。 全路径导入包的绝对路径就是GOROOT/src/或GOPATH/src/后面包的存放路径，如下所示： 123import \"lab/test\"import \"database/sql/driver\"import \"database/sql\" 上面代码的含义如下： test 包是自定义的包，其源码位于GOPATH/src/lab/test 目录下； driver 包的源码位于GOROOT/src/database/sql/driver 目录下； sql 包的源码位于GOROOT/src/database/sql 目录下。相对路径导入相对路径只能用于导入GOPATH 下的包，标准包的导入只能使用全路径导入。 例如包 a 的所在路径是GOPATH/src/lab/a，包 b 的所在路径为GOPATH/src/lab/b，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下： 12// 相对路径导入import \"../a\" 当然了，也可以使用上面的全路径导入，如下所示： 12// 全路径导入import \"lab/a\" 包的引用格式包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。 1) 标准引用格式1import \"fmt\" 此时可以用fmt.作为前缀来使用 fmt 包中的方法，这是常用的一种方式。 示例代码如下： 12345package mainimport \"fmt\"func main() &#123; fmt.Println(\"C语言中文网\")&#125; 2) 自定义别名引用格式在导入包的时候，我们还可以为导入的包设置别名，如下所示： 1import F \"fmt\" 其中 F 就是 fmt 包的别名，使用时我们可以使用F.来代替标准引用格式的fmt.来作为前缀使用 fmt 包中的方法。 示例代码如下： 12345package mainimport F \"fmt\"func main() &#123; F.Println(\"C语言中文网\")&#125; 3) 省略引用格式1import . \"fmt\" 这种格式相当于把 fmt 包直接合并到当前程序中，在使用 fmt 包内的方法是可以不用加前缀fmt.，直接引用。 示例代码如下： 123456package mainimport . \"fmt\"func main() &#123; //不需要加前缀 fmt. Println(\"C语言中文网\")&#125; 4) 匿名引用格式在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式，如下所示： 1import _ \"fmt\" 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。 使用标准格式引用包，但是代码中却没有使用包，编译器会报错。如果包中有 init 初始化函数，则通过import _ “包的路径” 这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。 示例代码如下： 12345678package mainimport ( _ \"database/sql\" \"fmt\")func main() &#123; fmt.Println(\"C语言中文网\")&#125; 注意： 一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。 包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。 包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。包加载通过前面一系列的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示。 Go语言包的初始化有如下特点： 包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。 Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。 先初始化常量，然后是全局变量，最后执行包的 init 函数。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"54、Go语言 之error接口","slug":"Golang/54、Go语言 之error接口","date":"2016-02-22T21:32:23.000Z","updated":"2020-08-07T14:10:11.756Z","comments":true,"path":"2016/02/23/Golang/54、Go语言 之error接口/","link":"","permalink":"https://www.zackaddy.xin/2016/02/23/Golang/54、Go语言 之error接口/","excerpt":"","text":"Go语言 之error接口错误处理在每个编程语言中都是一项重要内容，通常开发中遇到的分为异常与错误两种，Go语言中也不例外。本节我们主要来学习一下Go语言中的错误处理。 在C语言中通过返回 -1 或者 NULL 之类的信息来表示错误，但是对于使用者来说，如果不查看相应的 API 说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如返回 0 是成功还是失败？ 针对这样的情况，Go语言中引入 error 接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含 error。error 处理过程类似于C语言中的错误码，可逐层返回，直到被处理。 error 基本用法Go语言中返回的 error 类型究竟是什么呢？查看Go语言的源码就会发现 error 类型是一个非常简单的接口类型，如下所示： 12345// The error built-in interface type is the conventional interface for// representing an error condition, with the nil value representing no error.type error interface &#123; Error() string&#125; error 接口有一个签名为 Error() string 的方法，所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述，在使用 fmt.Println 打印错误时，会在内部调用 Error() string 方法来得到该错误的描述。 一般情况下，如果函数需要返回错误，就将 error 作为多个返回值中的最后一个（但这并非是强制要求）。 创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error，示例代码如下： 1234567891011121314151617181920package mainimport ( \"errors\" \"fmt\" \"math\")func Sqrt(f float64) (float64, error) &#123; if f &lt; 0 &#123; return -1, errors.New(\"math: square root of negative number\") &#125; return math.Sqrt(f), nil&#125;func main() &#123; result, err := Sqrt(-13) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(result) &#125;&#125; 运行结果如下： 1math: square root of negative number 上面代码中简单介绍了使用 errors.New 来返回一个错误信息，与其他语言的异常相比，Go语言的方法相对更加容易、直观。 自定义错误类型除了上面的 errors.New 用法之外，我们还可以使用 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"math\")type dualError struct &#123; Num float64 problem string&#125;func (e dualError) Error() string &#123; return fmt.Sprintf(\"Wrong!!!,because \\\"%f\\\" is a negative number\", e.Num)&#125;func Sqrt(f float64) (float64, error) &#123; if f &lt; 0 &#123; return -1, dualError&#123;Num: f&#125; &#125; return math.Sqrt(f), nil&#125;func main() &#123; result, err := Sqrt(-13) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(result) &#125;&#125; 运行结果如下： 1Wrong!!!,because \"-13.000000\" is a negative number","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"53、Go语言 之空接口类型","slug":"Golang/53、Go语言 之空接口类型","date":"2016-02-22T00:18:09.000Z","updated":"2020-08-07T14:10:11.755Z","comments":true,"path":"2016/02/22/Golang/53、Go语言 之空接口类型/","link":"","permalink":"https://www.zackaddy.xin/2016/02/22/Golang/53、Go语言 之空接口类型/","excerpt":"","text":"Go语言 之空接口类型空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。提示空接口类型类似于 C# 或 Java 语言中的 Object、C语言中的 void*、C++ 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。 空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。 将值保存到空接口空接口的赋值如下： 1234567var any interface&#123;&#125;any = 1fmt.Println(any)any = \"hello\"fmt.Println(any)any = falsefmt.Println(any) 代码输出如下： 1231hellofalse 对代码的说明： 第 1 行，声明 any 为 interface{} 类型的变量。 第 3 行，为 any 赋值一个整型 1。 第 4 行，打印 any 的值，提供给 fmt.Println 的类型依然是 interface{}。 第 6 行，为 any 赋值一个字符串 hello。此时 any 内部保存了一个字符串。但类型依然是 interface{}。 第 9 行，赋值布尔值。从空接口获取值保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：12345678// 声明a变量, 类型int, 初始值为1var a int = 1// 声明i变量, 类型为interface&#123;&#125;, 初始值为a, 此时i的值变为1var i interface&#123;&#125; = a// 声明b变量, 尝试赋值ivar b int = i第8行代码编译报错：cannot use i (type interface &#123;&#125;) as type int in assignment: need type assertion 编译器告诉我们，不能将i变量视为int类型赋值给b。 在代码第 15 行中，将 a 的值赋值给 i 时，虽然 i 在赋值完成后的内部值为 int，但 i 还是一个 interface{} 类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。 为了让第 8 行的操作能够完成，编译器提示我们得使用 type assertion，意思就是类型断言。 使用类型断言修改第 8 行代码如下： 1var b int = i.(int) 修改后，代码可以编译通过，并且 b 可以获得 i 变量保存的 a 变量的值：1。空接口的值比较空接口在保存不同的值后，可以和其他变量值一样使用==进行比较操作。空接口的比较有以下几种特性。 1) 类型不同的空接口间的比较结果不相同保存有类型不同的值的空接口进行比较时，Go 语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下： 123456// a保存整型var a interface&#123;&#125; = 100// b保存字符串var b interface&#123;&#125; = \"hi\"// 两个空接口不相等fmt.Println(a == b) 代码输出如下： 1false 2) 不能比较空接口中的动态值当接口中保存有动态类型的值时，运行时将触发错误，代码如下： 123456// c保存包含10的整型切片var c interface&#123;&#125; = []int&#123;10&#125;// d保存包含20的整型切片var d interface&#123;&#125; = []int&#123;20&#125;// 这里会发生崩溃fmt.Println(c == d) 代码运行到第8行时发生崩溃： 1panic: runtime error: comparing uncomparable type []int 这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。 类型的可比较性类 型 | 说 明–|–map |宕机错误，不可比较切片（[]T）| 宕机错误，不可比较通道（channel）| 可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false数组（[容量]T）| 可比较，编译期知道两个数组是否一致结构体| 可比较，可以逐个比较结构体的值函数| 可比较","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"52、Go语言 之接口和类型之间的转换","slug":"Golang/52、Go语言 之接口和类型之间的转换","date":"2016-02-20T18:28:30.000Z","updated":"2020-08-07T14:10:11.755Z","comments":true,"path":"2016/02/21/Golang/52、Go语言 之接口和类型之间的转换/","link":"","permalink":"https://www.zackaddy.xin/2016/02/21/Golang/52、Go语言 之接口和类型之间的转换/","excerpt":"","text":"Go语言 之接口和类型之间的转换Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。 类型断言的格式类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。 类型断言的基本格式如下：t := i.(T)其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量。 这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic。例如： 1234var w io.Writerw = os.Stdoutf := w.(*os.File) // 成功: f == os.Stdoutc := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer 第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 i 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。 在下面的第一个类型断言后，w 和 rw 都持有 os.Stdout 因此它们每个有一个动态类型 *os.File，但是变量 w 是一个 io.Writer 类型只对外公开出文件的 Write 方法，然而 rw 变量也只公开它的 Read 方法。 12345var w io.Writerw = os.Stdoutrw := w.(io.ReadWriter) // 成功：*os.file具有读写功能w = new(ByteCounter)rw = w.(io.ReadWriter) // 死机：*字节计数器没有读取方法 如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于 nil 接口值的情况。 如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：t,ok := i.(T)这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true。这里 ok 可以被认为是：i 接口是否实现 T 类型的结果。 将接口转换为其他接口实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。 鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的 Fly() 和 Walk() 方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。 将鸟和猪的实例创建后，被保存到 interface{} 类型的 map 中。interface{} 类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的 interface{} 变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回 false。例如下面的代码： 12var obj interface = new(bird)f, isFlyer := obj.(Flyer) 代码中，new(bird) 产生 *bird 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。 下面是详细的代码（代码1）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport \"fmt\"// 定义飞行动物接口type Flyer interface &#123; Fly()&#125;// 定义行走动物接口type Walker interface &#123; Walk()&#125;// 定义鸟类type bird struct &#123;&#125;// 实现飞行动物接口func (b *bird) Fly() &#123; fmt.Println(\"bird: fly\")&#125;// 为鸟添加Walk()方法, 实现行走动物接口func (b *bird) Walk() &#123; fmt.Println(\"bird: walk\")&#125;// 定义猪type pig struct &#123;&#125;// 为猪添加Walk()方法, 实现行走动物接口func (p *pig) Walk() &#123; fmt.Println(\"pig: walk\")&#125;func main() &#123;// 创建动物的名字到实例的映射 animals := map[string]interface&#123;&#125;&#123; \"bird\": new(bird), \"pig\": new(pig), &#125; // 遍历映射 for name, obj := range animals &#123; // 判断对象是否为飞行动物 f, isFlyer := obj.(Flyer) // 判断对象是否为行走动物 w, isWalker := obj.(Walker) fmt.Printf(\"name: %s isFlyer: %v isWalker: %v\\n\", name, isFlyer, isWalker) // 如果是飞行动物则调用飞行动物接口 if isFlyer &#123; f.Fly() &#125; // 如果是行走动物则调用行走动物接口 if isWalker &#123; w.Walk() &#125; &#125;&#125; 代码说明如下： 第 6 行定义了飞行动物的接口。 第 11 行定义了行走动物的接口。 第 16 和 30 行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。 第 41 行是一个 map，映射对象名字和对象实例，实例是鸟和猪。 第 47 行开始遍历 map，obj 为 interface{} 接口类型。 第 50 行中，使用类型断言获得 f，类型为 Flyer 及 isFlyer 的断言成功的判定。 第 52 行中，使用类型断言获得 w，类型为 Walker 及 isWalker 的断言成功的判定。 第 57 和 62 行，根据飞行动物和行走动物两者是否断言成功，调用其接口。 代码输出如下： 12345name: pig isFlyer: false isWalker: truepig: walkname: bird isFlyer: true isWalker: truebird: flybird: walk 将接口转换为其他类型在代码 1 中，可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 *pig 类型，请参考下面的代码： 1234p1 := new(pig)var a Walker = p1p2 := a.(*pig)fmt.Printf(\"p1=%p p2=%p\", p1, p2) 对代码的说明如下： 第 3 行，由于 pig 实现了 Walker 接口，因此可以被隐式转换为 Walker 接口类型保存于 a 中。 第 4 行，由于 a 中保存的本来就是 *pig 本体，因此可以转换为 *pig 类型。 第 6 行，对比发现，p1 和 p2 指针是相同的。 如果尝试将上面这段代码中的 Walker 类型的 a 转换为 *bird 类型，将会发出运行时错误，请参考下面的代码： 123p1 := new(pig)var a Walker = p1p2 := a.(*bird) 运行时报错： 1panic: interface conversion: main.Walker is *main.pig, not *main.bird 报错意思是：接口转换时，main.Walker 接口的内部保存的是 *main.pig，而不是 *main.bird。 因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。总结接口和其他类型的转换可以在 Go 语言中自由进行，前提是已经完全实现。 接口断言类似于流程控制中的 if。但大量类型断言出现时，应使用更为高效的类型分支 switch 特性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"51、Go语言 之接口的嵌套组合","slug":"Golang/51、Go语言 之接口的嵌套组合","date":"2016-02-19T18:52:19.000Z","updated":"2020-08-07T14:10:11.755Z","comments":true,"path":"2016/02/20/Golang/51、Go语言 之接口的嵌套组合/","link":"","permalink":"https://www.zackaddy.xin/2016/02/20/Golang/51、Go语言 之接口的嵌套组合/","excerpt":"","text":"Go语言 之接口的嵌套组合在 Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。 系统包中的接口嵌套组合Go语言的 io 包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3个接口，代码如下： 12345678910type Writer interface &#123; Write(p []byte) (n int, err error)&#125;type Closer interface &#123; Close() error&#125;type WriteCloser interface &#123; Writer Closer&#125; 代码说明如下： 第 1 行定义了写入器（Writer），如这个接口较为常用，常用于 I/O 设备的数据写入。 第 5 行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。 第 9 行定义了写入关闭器（WriteCloser），这个接口由 Writer 和 Closer 两个接口嵌入。也就是说，WriteCloser 同时拥有了 Writer 和 Closer 的特性。在代码中使用接口嵌套组合在代码中使用 io.Writer、io.Closer 和 io.WriteCloser 这 3 个接口时，只需要按照接口实现的规则实现 io.Writer 接口和 io.Closer 接口即可。而 io.WriteCloser 接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了 io.Writer 和 io.Closer 接口，详细实现代码如下：123456789101112131415161718192021222324252627package mainimport ( \"io\")// 声明一个设备结构type device struct &#123;&#125;// 实现io.Writer的Write()方法func (d *device) Write(p []byte) (n int, err error) &#123; return 0, nil&#125;// 实现io.Closer的Close()方法func (d *device) Close() error &#123; return nil&#125;func main() &#123; // 声明写入关闭器, 并赋予device的实例 var wc io.WriteCloser = new(device) // 写入数据 wc.Write(nil) // 关闭设备 wc.Close() // 声明写入器, 并赋予device的新实例 var writeOnly io.Writer = new(device) // 写入数据 writeOnly.Write(nil)&#125; 代码说明如下： 第 8 行定义了 device 结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的 3 种接口。 第 12 行，实现了 io.Writer 的 Write() 方法。 第 17 行，实现了 io.Closer 的 Close() 方法。 第 24 行，对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。 第 27 行，调用了 wc（io.WriteCloser接口）的 Write() 方法，由于 wc 被赋值 *device，因此最终会调用 device 的 Write() 方法。 第 30 行，与 27 行类似，最终调用 device 的 Close() 方法。 第 33 行，再次创建一个 device 的实例，writeOnly 是一个 io.Writer 接口，这个接口只有 Write() 方法。 第 36 行，writeOnly 只能调用 Write() 方法，没有 Close() 方法。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"50、Go语言 之接口的类型断言","slug":"Golang/50、Go语言 之接口的类型断言","date":"2016-02-19T03:03:21.000Z","updated":"2020-08-07T14:10:11.755Z","comments":true,"path":"2016/02/19/Golang/50、Go语言 之接口的类型断言/","link":"","permalink":"https://www.zackaddy.xin/2016/02/19/Golang/50、Go语言 之接口的类型断言/","excerpt":"","text":"Go语言 之类型断言类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。 在Go语言中类型断言的语法格式如下：value, ok := x.(T) 其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。 该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型： 如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。 如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。 无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。 示例代码如下： 12345678910package mainimport ( \"fmt\")func main() &#123; var x interface&#123;&#125; x = 10 value, ok := x.(int) fmt.Print(value, \",\", ok)&#125; 运行结果如下： 110,true 需要注意如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。 示例代码如下： 12345678910package mainimport ( \"fmt\")func main() &#123; var x interface&#123;&#125; x = \"Hello\" value := x.(int) fmt.Println(value)&#125; 运行结果如下： 1panic: interface conversion: interface &#123;&#125; is string, not int 类型断言还可以配合 switch 使用，示例代码如下： 123456789101112131415161718192021package mainimport ( \"fmt\")func main() &#123; var a int a = 10 getType(a)&#125;func getType(a interface&#123;&#125;) &#123; switch a.(type) &#123; case int: fmt.Println(\"the type of a is int\") case string: fmt.Println(\"the type of a is string\") case float64: fmt.Println(\"the type of a is float\") default: fmt.Println(\"unknown type\") &#125;&#125; 运行结果如下： 1the type of a is int","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"49、Go语言 之类型与接口的关系","slug":"Golang/49、Go语言 之类型与接口的关系","date":"2016-02-17T17:54:44.000Z","updated":"2020-08-07T14:10:11.754Z","comments":true,"path":"2016/02/18/Golang/49、Go语言 之类型与接口的关系/","link":"","permalink":"https://www.zackaddy.xin/2016/02/18/Golang/49、Go语言 之类型与接口的关系/","excerpt":"","text":"Go语言 之类型与接口的关系在 Go语言中类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。 一个类型可以实现多个接口一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。 Socket 和文件一样，在使用完毕后，也需要对资源进行释放。 把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码： 12345678type Socket struct &#123;&#125;func (s *Socket) Write(p []byte) (n int, err error) &#123; return 0, nil&#125;func (s *Socket) Close() error &#123; return nil&#125; Socket 结构的 Write() 方法实现了 io.Writer 接口： 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 同时，Socket 结构也实现了 io.Closer 接口： 123type Closer interface &#123; Close() error&#125; 使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口 在代码中使用Socket结构实现的Writer接口和Closer接口代码如下： 1234567891011121314// 使用io.Writer的代码, 并不知道Socket和io.Closer的存在func usingWriter( writer io.Writer)&#123; writer.Write( nil )&#125;// 使用io.Closer, 并不知道Socket和io.Writer的存在func usingCloser( closer io.Closer) &#123; closer.Close()&#125;func main() &#123; // 实例化Socket s := new(Socket) usingWriter(s) usingCloser(s)&#125; usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。 多个类型可以实现相同的接口一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。 Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下： 123456789101112131415161718// 一个服务需要满足能够开启和写日志的功能type Service interface &#123; Start() // 开启服务 Log(string) // 日志输出&#125;// 日志器type Logger struct &#123;&#125;// 实现Service的Log()方法func (g *Logger) Log(l string) &#123;&#125;// 游戏服务type GameService struct &#123; Logger // 嵌入日志器&#125;// 实现Service的Start()方法func (g *GameService) Start() &#123;&#125; 代码说明如下： 第 2 行，定义服务接口，一个服务需要实现 Start() 方法和日志方法。 第 8 行，定义能输出日志的日志器结构。 第 12 行，为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。 第 17 行，定义 GameService 结构。 第 18 行，在 GameService 中嵌入 Logger 日志器，以实现日志功能。 第 22 行，GameService 的 Start() 方法实现了 Service 的 Start() 方法。 此时，实例化 GameService，并将实例赋给 Service，代码如下： 123var s Service = new(GameService)s.Start()s.Log(“hello”) s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"48、Go语言 之实现接口的条件","slug":"Golang/48、Go语言 之实现接口的条件","date":"2016-02-16T21:10:10.000Z","updated":"2020-08-07T14:10:11.754Z","comments":true,"path":"2016/02/17/Golang/48、Go语言 之实现接口的条件/","link":"","permalink":"https://www.zackaddy.xin/2016/02/17/Golang/48、Go语言 之实现接口的条件/","excerpt":"","text":"Go语言 之实现接口的条件如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。 实现关系在 Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。 接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。 接口被实现的条件一：接口的方法与实现接口的类型方法格式一致在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。 为了抽象数据写入的过程，定义 DataWriter 接口来描述数据写入需要实现的方法，接口中的 WriteData() 方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现 WriteData 方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现 DataWriter 接口的 WriteData 方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考下面的代码。 数据写入器的抽象： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")// 定义一个数据写入器type DataWriter interface &#123; WriteData(data interface&#123;&#125;) error&#125;// 定义文件结构，用于实现DataWritertype file struct &#123;&#125;// 实现DataWriter接口的WriteData方法func (d *file) WriteData(data interface&#123;&#125;) error &#123; // 模拟写入数据 fmt.Println(\"WriteData:\", data) return nil&#125;func main() &#123; // 实例化file f := new(file) // 声明一个DataWriter的接口 var writer DataWriter // 将接口赋值f，也就是*file类型 writer = f // 使用DataWriter接口进行数据写入 writer.WriteData(\"data\")&#125; 代码说明如下： 第 8 行，定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，输入一个 interface{} 类型的 data，返回一个 error 结构表示可能发生的错误。 第 17 行，file 的 WriteData() 方法使用指针接收器。输入一个 interface{} 类型的 data，返回 error。 第 27 行，实例化 file 赋值给 f，f 的类型为 *file。 第 30 行，声明 DataWriter 类型的 writer 接口变量。 第 33 行，将 *file 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。 第 36 行，DataWriter 接口类型的 writer 使用 WriteData() 方法写入一个字符串。 运行代码，输出如下： 1WriteData: data 当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。 1) 函数名不一致导致的报错在以上代码的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改 file 结构的 WriteData() 方法名，将这个方法签名（第17行）修改为： 1func (d *file) WriteDataX(data interface&#123;&#125;) error &#123; 编译代码，报错： 12cannot use f (type *file) as type DataWriter in assignment: *file does not implement DataWriter (missing WriteData method) 报错的位置在第 33 行。报错含义是：不能将 f 变量（类型file）视为 DataWriter 进行赋值。原因：file 类型未实现 DataWriter 接口（丢失 WriteData 方法）。 WriteDataX 方法的签名本身是合法的。但编译器扫描到第 33 行代码时，发现尝试将 *file 类型赋值给 DataWriter 时，需要检查 *file 类型是否完全实现了 DataWriter 接口。显然，编译器因为没有找到 DataWriter 需要的 WriteData() 方法而报错。 2) 实现接口的方法签名不一致导致的报错将修改的代码恢复后，再尝试修改 WriteData() 方法，把 data 参数的类型从 interface{} 修改为 int 类型，代码如下： 1func (d *file) WriteData(data int) error &#123; 编译代码，报错： 1234cannot use f (type *file) as type DataWriter in assignment: *file does not implement DataWriter (wrong type for WriteData method) have WriteData(int) error want WriteData(interface &#123;&#125;) error 这次未实现 DataWriter 的理由变为（错误的 WriteData() 方法类型）发现 WriteData(int)error，期望 WriteData(interface{})error。 这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。 接口被实现的条件二：接口中所有方法均被实现当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。 在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下： 123456// 定义一个数据写入器type DataWriter interface &#123; WriteData(data interface&#123;&#125;) error // 能否写入 CanWrite() bool&#125; 新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错： 12cannot use f (type *file) as type DataWriter in assignment: *file does not implement DataWriter (missing CanWrite method) 需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。 Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。 实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。提示传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。 对于 Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用 GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"47、Go语言 之接口声明（定义）","slug":"Golang/47、Go语言 之接口声明（定义）","date":"2016-02-15T22:52:28.000Z","updated":"2020-08-07T14:10:11.754Z","comments":true,"path":"2016/02/16/Golang/47、Go语言 之接口声明（定义）/","link":"","permalink":"https://www.zackaddy.xin/2016/02/16/Golang/47、Go语言 之接口声明（定义）/","excerpt":"","text":"Go语言 之接口声明（定义）Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。 但是 Go语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性。很多面向对象的语言都有相似的接口概念，但 Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。 这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。 接口声明的格式每个接口类型由数个方法组成。接口的形式代码如下： 12345type 接口类型名 interface&#123; 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 …&#125; 对各个部分的说明：接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如： 123type writer interface&#123; Write([]byte) error&#125; 开发中常见的接口及写法Go语言提供的很多包中都有接口，例如 io 包中提供的 Writer 接口： 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 这个接口可以调用 Write() 方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。 类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用 String() 方法时，都可以获得对象对应的字符串。在 fmt 包中定义如下： 123type Stringer interface &#123; String() string&#125; Stringer 接口在 Go语言中的使用频率非常高，功能类似于 Java 或者 C# 语言里的 ToString 的操作。 Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"46、Go语言 之初始化内嵌结构体","slug":"Golang/46、Go语言 之初始化内嵌结构体","date":"2016-02-15T03:39:27.000Z","updated":"2020-08-07T14:10:11.753Z","comments":true,"path":"2016/02/15/Golang/46、Go语言 之初始化内嵌结构体/","link":"","permalink":"https://www.zackaddy.xin/2016/02/15/Golang/46、Go语言 之初始化内嵌结构体/","excerpt":"","text":"Go语言 之初始化内嵌结构体结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。 车辆结构的组装和初始化： 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"// 车轮type Wheel struct &#123; Size int&#125;// 引擎type Engine struct &#123; Power int // 功率 Type string // 类型&#125;// 车type Car struct &#123; Wheel Engine&#125;func main() &#123; c := Car&#123; // 初始化轮子 Wheel: Wheel&#123; Size: 18, &#125;, // 初始化引擎 Engine: Engine&#123; Type: \"1.4T\", Power: 143, &#125;, &#125; fmt.Printf(\"%+v\\n\", c)&#125; 代码说明如下： 第 6 行定义车轮结构。 第 11 行定义引擎结构。 第 17 行定义车结构，由车轮和引擎结构体嵌入。 第 27 行，将 Car 的 Wheel 字段使用 Wheel 结构体进行初始化。 第 32 行，将 Car 的 Engine 字段使用 Engine 结构体进行初始化。初始化内嵌匿名结构体在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考下面的代码。1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"// 车轮type Wheel struct &#123; Size int&#125;// 车type Car struct &#123; Wheel // 引擎 Engine struct &#123; Power int // 功率 Type string // 类型 &#125;&#125;func main() &#123; c := Car&#123; // 初始化轮子 Wheel: Wheel&#123; Size: 18, &#125;, // 初始化引擎 Engine: struct &#123; Power int Type string &#125;&#123; Type: \"1.4T\", Power: 143, &#125;, &#125; fmt.Printf(\"%+v\\n\", c)&#125; 代码说明如下： 第 14 行中原来的 Engine 结构体被直接定义在 Car 的结构体中。这种嵌入的写法就是将原来的结构体类型转换为 struct{…}。 第 30 行，需要对 Car 的 Engine 字段进行初始化，由于 Engine 字段的类型并没有被单独定义，因此在初始化其字段时需要先填写 struct{…} 声明其类型。 第 3行开始填充这个匿名结构体的数据，按“键：值”格式填充。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"45、Go语言 之类型内嵌和结构体内嵌","slug":"Golang/45、Go语言 之类型内嵌和结构体内嵌","date":"2016-02-13T18:44:46.000Z","updated":"2020-08-07T14:10:11.753Z","comments":true,"path":"2016/02/14/Golang/45、Go语言 之类型内嵌和结构体内嵌/","link":"","permalink":"https://www.zackaddy.xin/2016/02/14/Golang/45、Go语言 之类型内嵌和结构体内嵌/","excerpt":"","text":"Go语言 之类型内嵌和结构体内嵌结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。 可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go语言中的继承是通过内嵌或组合来实现的，所以可以说，在 Go语言中，相比较于继承，组合更受青睐。 考虑如下的程序： 12345678910111213141516171819202122232425262728package mainimport \"fmt\"type innerS struct &#123; in1 int in2 int&#125;type outerS struct &#123; b int c float32 int // anonymous field innerS //anonymous field&#125;func main() &#123; outer := new(outerS) outer.b = 6 outer.c = 7.5 outer.int = 60 outer.in1 = 5 outer.in2 = 10 fmt.Printf(\"outer.b is: %d\\n\", outer.b) fmt.Printf(\"outer.c is: %f\\n\", outer.c) fmt.Printf(\"outer.int is: %d\\n\", outer.int) fmt.Printf(\"outer.in1 is: %d\\n\", outer.in1) fmt.Printf(\"outer.in2 is: %d\\n\", outer.in2) // 使用结构体字面量 outer2 := outerS&#123;6, 7.5, 60, innerS&#123;5, 10&#125;&#125; fmt.Printf(\"outer2 is:\", outer2)&#125; 运行结果如下所示： 123456outer.b is: 6outer.c is: 7.500000outer.int is: 60outer.in1 is: 5outer.in2 is: 10outer2 is:&#123;6 7.5 60 &#123;5 10&#125;&#125; 通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。 内嵌结构体同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。 示例代码如下所示： 1234567891011121314package mainimport \"fmt\"type A struct &#123; ax, ay int&#125;type B struct &#123; A bx, by float32&#125;func main() &#123; b := B&#123;A&#123;1, 2&#125;, 3.0, 4.0&#125; fmt.Println(b.ax, b.ay, b.bx, b.by) fmt.Println(b.A)&#125; 输出： 121 2 3 4&#123;1 2&#125; 结构内嵌特性Go语言的结构体内嵌有如下特性。 1) 内嵌的结构体可以直接访问其成员变量嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。 2) 内嵌结构体的字段名是它的类型名内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下： 1234var c Colorc.BasicColor.R = 1c.BasicColor.G = 1c.BasicColor.B = 0 一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"44、Go语言 之为任意类型添加方法","slug":"Golang/44、Go语言 之为任意类型添加方法","date":"2016-02-12T18:14:03.000Z","updated":"2020-08-07T14:10:11.753Z","comments":true,"path":"2016/02/13/Golang/44、Go语言 之为任意类型添加方法/","link":"","permalink":"https://www.zackaddy.xin/2016/02/13/Golang/44、Go语言 之为任意类型添加方法/","excerpt":"","text":"Go语言 之为任意类型添加方法Go语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。为基本类型添加方法在Go语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如： 123if v == 0 &#123; // v等于0&#125; 如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如： 123if v.IsZero() &#123; // v等于0&#125; 为基本类型添加方法的详细实现流程如下： 1234567891011121314151617181920package mainimport ( \"fmt\")// 将int定义为MyInt类型type MyInt int// 为MyInt添加IsZero()方法func (m MyInt) IsZero() bool &#123; return m == 0&#125;// 为MyInt添加Add()方法func (m MyInt) Add(other int) int &#123; return other + int(m)&#125;func main() &#123; var b MyInt fmt.Println(b.IsZero()) b = 1 fmt.Println(b.Add(2))&#125; 代码输出如下： 12true3 代码说明如下： 第 8 行，使用 type MyInt int 将 int 定义为自定义的 MyInt 类型。 第 11 行，为 MyInt 类型添加 IsZero() 方法，该方法使用了 (m MyInt) 的非指针接收器，数值类型没有必要使用指针接收器。 第 16 行，为 MyInt 类型添加 Add() 方法。 第 17 行，由于 m 的类型是 MyInt 类型，但其本身是 int 类型，因此可以将 m 从 MyInt 类型转换为 int 类型再进行计算。 第 24 行，调用 b 的 IsZero() 方法，由于使用非指针接收器，b的值会被复制进入 IsZero() 方法进行判断。 第 28 行，调用 b 的 Add() 方法，同样也是非指针接收器，结果直接通过 Add() 方法返回。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"43、Go语言 之结构体方法和接收器","slug":"Golang/43、Go语言 之结构体方法和接收器","date":"2016-02-11T17:38:46.000Z","updated":"2020-08-07T14:10:11.752Z","comments":true,"path":"2016/02/12/Golang/43、Go语言 之结构体方法和接收器/","link":"","permalink":"https://www.zackaddy.xin/2016/02/12/Golang/43、Go语言 之结构体方法和接收器/","excerpt":"","text":"Go语言 之结构体方法和接收器在Go语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在Go语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。 接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误invalid receiver type…。 接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在Go语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。 类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。 因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。 提示在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。 为结构体添加方法本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。 1) 面向过程实现方法面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下： 1234567891011type Bag struct &#123; items []int&#125;// 将一个物品放入背包的过程func Insert(b *Bag, itemid int) &#123; b.items = append(b.items, itemid)&#125;func main() &#123; bag := new(Bag) Insert(bag, 1001)&#125; 代码说明如下： 第 1 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。 第 6 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。 第 7 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。 第 12 行，创建背包实例 bag。 第 14 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。 Insert() 函数将 *Bag 参数放在第一位，强调 Insert 会操作 *Bag 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。 2) Go语言的结构体方法将背包及放入背包的物品中使用Go语言的结构体和方法方式编写，为 *Bag 创建一个方法，代码如下： 12345678910type Bag struct &#123; items []int&#125;func (b *Bag) Insert(itemid int) &#123; b.items = append(b.items, itemid)&#125;func main() &#123; b := new(Bag) b.Insert(1001)&#125; 第 5 行中，Insert(itemid int) 的写法与函数一致，(b*Bag) 表示接收器，即 Insert 作用的对象实例。 每个方法只能有一个接收器 第 13 行中，在 Insert() 转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用 b 的 Insert。 接收器——方法作用的目标接收器的格式如下： 123func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) &#123; 函数体&#125; 对各部分的说明：接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。方法名、参数列表、返回参数：格式与函数定义一致。 接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。 1) 理解指针类型的接收器指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。 由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。 在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。 1234567891011121314151617181920212223package mainimport \"fmt\"// 定义属性结构type Property struct &#123; value int // 属性值&#125;// 设置属性值func (p *Property) SetValue(v int) &#123; // 修改p的成员变量 p.value = v&#125;// 取属性值func (p *Property) Value() int &#123; return p.value&#125;func main() &#123; // 实例化属性 p := new(Property) // 设置值 p.SetValue(100) // 打印值 fmt.Println(p.Value())&#125; 运行程序，输出如下： 1100 代码说明如下： 第 6 行，定义一个属性结构，拥有一个整型的成员变量。 第 11 行，定义属性值的方法。 第 14 行，设置属性值方法的接收器类型为指针，因此可以修改成员值，即便退出方法，也有效。 第 18 行，定义获取值的方法。 第 25 行，实例化属性结构。 第 28 行，设置值，此时成员变量变为 100。 第 31 行，获取成员变量。2) 理解非指针类型的接收器当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。 点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。 1234567891011121314151617181920212223package mainimport ( \"fmt\")// 定义点结构type Point struct &#123; X int Y int&#125;// 非指针接收器的加方法func (p Point) Add(other Point) Point &#123; // 成员值与参数相加后返回新的结构 return Point&#123;p.X + other.X, p.Y + other.Y&#125;&#125;func main() &#123; // 初始化点 p1 := Point&#123;1, 1&#125; p2 := Point&#123;2, 2&#125; // 与另外一个点相加 result := p1.Add(p2) // 输出结果 fmt.Println(result)&#125; 代码输出如下： 1&#123;3 3&#125; 代码说明如下： 第 8 行，定义一个点结构，拥有 X 和 Y 两个整型分量。 第 14 行，为 Point 结构定义一个 Add() 方法，传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如P4 := P1.Add( P2 ).Add( P3 ) 第 23 和 24 行，初始化两个点 p1 和 p2。 第 27 行，将 p1 和 p2 相加后返回结果。 第 30 行，打印结果。 由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改。 3) 指针和非指针接收器的使用在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"42、Go语言 之结构体的构造函数","slug":"Golang/42、Go语言 之结构体的构造函数","date":"2016-02-11T00:20:22.000Z","updated":"2020-08-07T14:10:11.752Z","comments":true,"path":"2016/02/11/Golang/42、Go语言 之结构体的构造函数/","link":"","permalink":"https://www.zackaddy.xin/2016/02/11/Golang/42、Go语言 之结构体的构造函数/","excerpt":"","text":"Go语言 之结构体的构造函数Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。 其他编程语言构造函数的一些常见功能及特性如下： 每个类可以添加构造函数，多个构造函数使用函数重载实现。 构造函数一般与类名同名，且没有返回值。 构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。 对于 C++ 来说，还有默认构造函数、拷贝构造函数等。多种方式创建和初始化结构体——模拟构造函数重载如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：1234567891011121314type Cat struct &#123; Color string Name string&#125;func NewCatByName(name string) *Cat &#123; return &amp;Cat&#123; Name: name, &#125;&#125;func NewCatByColor(color string) *Cat &#123; return &amp;Cat&#123; Color: color, &#125;&#125; 代码说明如下： 第 1 行定义 Cat 结构，包含颜色和名字字段。 第 6 行定义用名字构造猫结构的函数，返回 Cat 指针。 第 7 行取地址实例化猫的结构体。 第 8 行初始化猫的名字字段，忽略颜色字段。 第 12 行定义用颜色构造猫结构的函数，返回 Cat 指针。 在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。 带有父子关系的结构体的构造和初始化——模拟父级构造调用黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码： 12345678910111213141516171819type Cat struct &#123; Color string Name string&#125;type BlackCat struct &#123; Cat // 嵌入Cat, 类似于派生&#125;// “构造基类”func NewCat(name string) *Cat &#123; return &amp;Cat&#123; Name: name, &#125;&#125;// “构造子类”func NewBlackCat(color string) *BlackCat &#123; cat := &amp;BlackCat&#123;&#125; cat.Color = color return cat&#125; 代码说明如下： 第 6 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。 第 11 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。 第 18 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。 第 19 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。 第 20 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。 这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。 总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"41、Go语言 之初始化结构体的成员变量","slug":"Golang/41、Go语言 之初始化结构体的成员变量","date":"2016-02-09T17:29:42.000Z","updated":"2020-08-07T14:10:11.752Z","comments":true,"path":"2016/02/10/Golang/41、Go语言 之初始化结构体的成员变量/","link":"","permalink":"https://www.zackaddy.xin/2016/02/10/Golang/41、Go语言 之初始化结构体的成员变量/","excerpt":"","text":"Go语言 之初始化结构体的成员变量结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。 使用“键值对”初始化结构体结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。 键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。 结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。 1) 键值对初始化结构体的书写格式键值对初始化的格式如下： 12345ins := 结构体类型名&#123; 字段1: 字段1的值, 字段2: 字段2的值, …&#125; 下面是对各个部分的说明：结构体类型：定义结构体时的类型名称。字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。字段1的值、字段2的值：结构体成员字段的初始值。 键值之间以:分隔，键值对之间以,分隔。 2) 使用键值对填充结构体的例子下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下： 12345678910111213type People struct &#123; name string child *People&#125;relation := &amp;People&#123; name: \"爷爷\", child: &amp;People&#123; name: \"爸爸\", child: &amp;People&#123; name: \"我\", &#125;, &#125;,&#125; 代码说明如下： 第 1 行，定义 People 结构体。 第 2 行，结构体的字符串字段。 第 3 行，结构体的结构体指针字段，类型是 *People。 第 6 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。 第 8 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。提示：结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。 使用多个值的列表初始化结构体Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。 1) 多个值列表初始化结构体的书写格式多个值使用逗号分隔初始化结构体，例如： 12345ins := 结构体类型名&#123; 字段1的值, 字段2的值, …&#125; 使用这种格式初始化时，需要注意：必须初始化结构体的所有字段。每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。键值对与值列表的初始化形式不能混用。 2) 多个值列表初始化结构体的例子下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如： 12345678910111213type Address struct &#123; Province string City string ZipCode int PhoneNumber string&#125;addr := Address&#123; \"四川\", \"成都\", 610000, \"0\",&#125;fmt.Println(addr) 运行代码，输出如下： 1&#123;四川 成都 610000 0&#125; 初始化匿名结构体匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。 1) 匿名结构体定义格式和初始化写法匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示： 1234567891011ins := struct &#123; // 匿名结构体字段定义 字段1 字段类型1 字段2 字段类型2 …&#125;&#123; // 字段值初始化 初始化字段1: 字段1的值, 初始化字段2: 字段2的值, …&#125; 下面是对各个部分的说明： 字段1、字段2……：结构体定义的字段名。初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。 字段类型1、字段类型2……：结构体定义字段的类型。 字段1的值、字段2的值……：结构体初始化字段的初始值。 键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为： 12345ins := struct &#123; 字段1 字段类型1 字段2 字段类型2 …&#125; 2) 使用匿名结构体的例子在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下： 1234567891011121314151617181920212223package mainimport ( \"fmt\")// 打印消息类型, 传入匿名结构体func printMsgType(msg *struct &#123; id int data string&#125;) &#123; // 使用动词%T打印msg的类型 fmt.Printf(\"%T\\n\", msg)&#125;func main() &#123; // 实例化一个匿名结构体 msg := &amp;struct &#123; // 定义部分 id int data string &#125;&#123; // 值初始化部分 1024, \"hello\", &#125; printMsgType(msg)&#125; 代码输出如下： 1*struct &#123; id int; data string &#125; 代码说明如下： 第 8 行，定义 printMsgType() 函数，参数为 msg，类型为*struct{id int data string}，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。 第 14 行，使用字符串格式化中的%T动词，将 msg 的类型名打印出来。 第 20 行，对匿名结构体进行实例化，同时初始化成员。 第 21 和 22 行，定义匿名结构体的字段。 第 24 和 25 行，给匿名结构体字段赋予初始值。 第 28 行，将 msg 传入 printMsgType() 函数中进行函数调用。 匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"40、Go语言 之实例化结构体","slug":"Golang/40、Go语言 之实例化结构体","date":"2016-02-08T20:20:29.000Z","updated":"2020-08-07T14:10:11.751Z","comments":true,"path":"2016/02/09/Golang/40、Go语言 之实例化结构体/","link":"","permalink":"https://www.zackaddy.xin/2016/02/09/Golang/40、Go语言 之实例化结构体/","excerpt":"","text":"Go语言 之实例化结构体结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。 实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。 Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。基本的实例化形式结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。 $$$基本实例化格式如下：var ins T 其中，T 为结构体类型，ins 为结构体的实例。 用结构体表示的点结构（Point）的实例化过程请参见下面的代码： 1234567type Point struct &#123; X int Y int&#125;var p Pointp.X = 10p.Y = 20 在例子中，使用.来访问结构体的成员变量，如p.X和p.Y等，结构体成员变量的赋值方法与普通变量一致。 创建指针类型的结构体Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。 使用 new 的格式如下： 1ins := new(T) 其中：T 为类型，可以是结构体、整型、字符串等。ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。 Go语言让我们可以像访问普通结构体一样使用.来访问结构体指针的成员。 下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下： 12345678type Player struct&#123; Name string HealthPoint int MagicPoint int&#125;tank := new(Player)tank.Name = \"Canon\"tank.HealthPoint = 300 经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。Go语言和 C/C++在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用-&gt;操作符。 在Go语言中，访问结构体指针的成员变量时可以继续使用.，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。 取结构体的地址实例化在Go语言中，对结构体进行&amp;取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：ins := &amp;T{} 其中：T 表示结构体类型。ins 为结构体的实例，类型为 *T，是指针类型。 下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：``type Command struct { Name string // 指令名称 Var *int // 指令绑定的变量 Comment string // 指令的注释}var version int = 1cmd := &amp;Command{}cmd.Name = “version”cmd.Var = &amp;versioncmd.Comment = “show version”代码说明如下： 第 1 行，定义 Command 结构体，表示命令行指令第 3 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值– 随时保持同步。 第 7 行，命令绑定的目标整型变量：版本号。 第 9 行，对结构体取地址实例化。 第 10～12 行，初始化成员字段。 取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下： 123456789101112func newCommand(name string, varref *int, comment string) *Command &#123; return &amp;Command&#123; Name: name, Var: varref, Comment: comment, &#125;&#125;cmd = newCommand( \"version\", &amp;version, \"show version\",)","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"39、Go语言 之结构体定义","slug":"Golang/39、Go语言 之结构体定义","date":"2016-02-07T23:33:29.000Z","updated":"2020-08-07T14:10:11.750Z","comments":true,"path":"2016/02/08/Golang/39、Go语言 之结构体定义/","link":"","permalink":"https://www.zackaddy.xin/2016/02/08/Golang/39、Go语言 之结构体定义/","excerpt":"","text":"Go语言 之结构体定义Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。 结构体成员也可以称为“字段”，这些字段有以下特性： 字段拥有自己的类型和值； 字段名必须唯一； 字段的类型也可以是结构体，甚至是字段所在结构体的类型。 使用关键字 type 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。 结构体的定义格式如下： 12345type 类型名 struct &#123; 字段1 字段1类型 字段2 字段2类型 …&#125; 对各个部分的说明： 类型名：标识自定义结构体的名称，在同一个包内不能重复。 struct{}：表示结构体类型，type 类型名 struct{}可以理解为将 struct{} 结构体定义为类型名的类型。 字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。 字段1类型、字段2类型……：表示结构体各个字段的类型。 使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下： 1234type Point struct &#123; X int Y int&#125; 同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下： 123type Color struct &#123; R, G, B byte&#125; 结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"38、Go语言 之计算函数执行时间","slug":"Golang/38、Go语言 之计算函数执行时间","date":"2016-02-06T16:08:12.000Z","updated":"2020-08-07T14:10:11.750Z","comments":true,"path":"2016/02/07/Golang/38、Go语言 之计算函数执行时间/","link":"","permalink":"https://www.zackaddy.xin/2016/02/07/Golang/38、Go语言 之计算函数执行时间/","excerpt":"","text":"Go语言 之计算函数执行时间函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，要得到函数的运行时间，最简单的办法就是在函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，这个时间间隔就是函数的运行时间。 在Go语言中我们可以使用 time 包中的 Since() 函数来获取函数的运行时间，Go语言官方文档中对 Since() 函数的介绍是这样的。 1func Since(t Time) Duration Since() 函数返回从 t 到现在经过的时间，等价于time.Now().Sub(t)。 【示例】使用 Since() 函数获取函数的运行时间。 1234567891011121314151617package mainimport ( \"fmt\" \"time\")func test() &#123; start := time.Now() // 获取当前时间 sum := 0 for i := 0; i &lt; 100000000; i++ &#123; sum++ &#125; elapsed := time.Since(start) fmt.Println(\"该函数执行完成耗时：\", elapsed)&#125;func main() &#123; test()&#125; 运行结果如下所示：该函数执行完成耗时： 39.8933ms 上面我们提到了 time.Now().Sub() 的功能类似于 Since() 函数，想要使用 time.Now().Sub() 获取函数的运行时间只需要把我们上面代码的第 14 行简单修改一下就行。 【示例 2】使用 time.Now().Sub() 获取函数的运行时间。 1234567891011121314151617package mainimport ( \"fmt\" \"time\")func test() &#123; start := time.Now() // 获取当前时间 sum := 0 for i := 0; i &lt; 100000000; i++ &#123; sum++ &#125; elapsed := time.Now().Sub(start) fmt.Println(\"该函数执行完成耗时：\", elapsed)&#125;func main() &#123; test()&#125; 运行结果如下所示：该函数执行完成耗时： 36.8769ms 由于计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"37、Go语言 之宕机恢复（recover）——防止程序崩溃","slug":"Golang/37、Go语言 之宕机恢复（recover）——防止程序崩溃","date":"2016-02-05T16:21:25.000Z","updated":"2020-08-07T14:10:11.750Z","comments":true,"path":"2016/02/06/Golang/37、Go语言 之宕机恢复（recover）——防止程序崩溃/","link":"","permalink":"https://www.zackaddy.xin/2016/02/06/Golang/37、Go语言 之宕机恢复（recover）——防止程序崩溃/","excerpt":"","text":"Go语言 之宕机恢复（recover）——防止程序崩溃Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。 通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。提示在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。 Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。 让程序在崩溃时继续执行下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。 保护运行函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"runtime\")// 崩溃时需要传递的上下文信息type panicContext struct &#123; function string // 所在函数&#125;// 保护方式允许一个函数func ProtectRun(entry func()) &#123; // 延迟处理的函数 defer func() &#123; // 发生宕机时，获取panic传递的上下文并打印 err := recover() switch err.(type) &#123; case runtime.Error: // 运行时错误 fmt.Println(\"runtime error:\", err) default: // 非运行时错误 fmt.Println(\"error:\", err) &#125; &#125;() entry()&#125;func main() &#123; fmt.Println(\"运行前\") // 允许一段手动触发的错误 ProtectRun(func() &#123; fmt.Println(\"手动宕机前\") // 使用panic传递上下文 panic(&amp;panicContext&#123; \"手动触发panic\", &#125;) fmt.Println(\"手动宕机后\") &#125;) // 故意造成空指针访问错误 ProtectRun(func() &#123; fmt.Println(\"赋值宕机前\") var a *int *a = 1 fmt.Println(\"赋值宕机后\") &#125;) fmt.Println(\"运行后\")&#125; 代码输出结果： 123456运行前手动宕机前error: &amp;&#123;手动触发panic&#125;赋值宕机前runtime error: runtime error: invalid memory address or nil pointer dereference运行后 对代码的说明： 第 9 行声明描述错误的结构体，保存执行错误的函数。 第 17 行使用 defer 将闭包延迟执行，当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。 第 20 行，recover() 获取到 panic 传入的参数。 第 22 行，使用 switch 对 err 变量进行类型断言。 第 23 行，如果错误是有 Runtime 层抛出的运行时错误，如空指针访问、除数为 0 等情况，打印运行时错误。 第 25 行，其他错误，打印传递过来的错误数据。 第 44 行，使用 panic 手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover 就会获取到这个结构体信息，并打印出来。 第 57 行，模拟代码中空指针赋值造成的错误，此时会由 Runtime 层抛出错误，被 ProtectRun() 函数的 recover() 函数捕获到。panic 和 recover 的关系panic 和 recover 的组合有如下特性： 有 panic 没 recover，程序宕机。 有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。提示虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。 在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。 如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"36、Go语言 之宕机抛异常（panic）","slug":"Golang/36、Go语言 之宕机抛异常（panic）","date":"2016-02-05T01:56:37.000Z","updated":"2020-08-07T14:10:11.750Z","comments":true,"path":"2016/02/05/Golang/36、Go语言 之宕机抛异常（panic）/","link":"","permalink":"https://www.zackaddy.xin/2016/02/05/Golang/36、Go语言 之宕机抛异常（panic）/","excerpt":"","text":"Go语言 之宕机抛异常（panic）Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。 宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，宕机有时也是一种合理的止损方法。 一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。 对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。 虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。 手动触发宕机Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。 Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示： 1234package mainfunc main() &#123; panic(\"crash\")&#125; 代码运行崩溃并输出如下： 123456panic: crashgoroutine 1 [running]:main.main() D:/code/main.go:4 +0x40exit status 2 以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下： 1func panic(v interface&#123;&#125;) //panic() 的参数可以是任意类型的。 在运行依赖的必备资源缺失时主动触发宕机regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。 编译正则表达式函数有两种，具体如下： 1) func Compile(expr string) (*Regexp, error)编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。 2) func MustCompile(str string) *Regexp当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。 MustCompile 的代码如下： 1234567func MustCompile(str string) *Regexp &#123; regexp, error := Compile(str) if error != nil &#123; panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) &#125; return regexp&#125; 代码说明如下： 第 1 行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。 第 2 行，Compile() 是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。 第 3 和第 4 行判断如果有错，则使用 panic() 触发宕机。 第 6 行，没有错误时返回正则表达式对象。 手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。 在宕机时触发延迟执行语句当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，参考下面代码： 1234567package mainimport \"fmt\"func main() &#123; defer fmt.Println(\"宕机后要做的事情1\") defer fmt.Println(\"宕机后要做的事情2\") panic(\"宕机\")&#125; 代码输出如下： 12345678宕机后要做的事情2宕机后要做的事情1panic: 宕机goroutine 1 [running]:main.main() D:/code/main.go:8 +0xf8exit status 2 对代码的说明： 第 6 行和第 7 行使用 defer 语句延迟了 2 个语句。 第 8 行发生宕机。 宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"35、Go语言 之处理运行时错误","slug":"Golang/35、Go语言 之处理运行时错误","date":"2016-02-03T19:12:38.000Z","updated":"2020-08-07T14:10:11.749Z","comments":true,"path":"2016/02/04/Golang/35、Go语言 之处理运行时错误/","link":"","permalink":"https://www.zackaddy.xin/2016/02/04/Golang/35、Go语言 之处理运行时错误/","excerpt":"","text":"Go语言 之处理运行时错误Go语言的错误处理思想及设计包含以下特征：一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。 Go语言没有类似 Java 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。 Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。 net 包中的例子net.Dial() 是Go语言系统包 net 即中的一个函数，一般用于创建一个 Socket 连接。 net.Dial 拥有两个返回值，即 Conn 和 error，这个函数是阻塞的，因此在 Socket 操作后，会返回 Conn 连接对象和 error，如果发生错误，error 会告知错误的类型，Conn 会返回空。 根据Go语言的错误处理机制，Conn 是其重要的返回值，因此，为这个函数增加一个错误返回，类似为 error，参见下面的代码： 1234func Dial(network, address string) (Conn, error) &#123; var d Dialer return d.Dial(network, address)&#125; 在 io 包中的 Writer 接口也拥有错误返回，代码如下： 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; io 包中还有 Closer 接口，只有一个错误返回，代码如下： 123type Closer interface &#123; Close() error&#125; 错误接口的定义格式error 是 Go 系统声明的接口类型，代码如下： 123type error interface &#123; Error() string&#125; 所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误。 自定义一个错误返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下： 1var err = errors.New(\"this is an error\") 错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。 1) errors 包Go语言的 errors 中对 New 的定义非常简单，代码如下： 123456789101112// 创建错误对象func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;// 错误字符串type errorString struct &#123; s string&#125;// 返回发生何种错误func (e *errorString) Error() string &#123; return e.s&#125; 代码说明如下： 第 2 行，将 errorString 结构体实例化，并赋值错误描述的成员。 第 7 行，声明 errorString 结构体，拥有一个成员，描述错误内容。 第 12 行，实现 error 接口的 Error() 方法，该方法返回成员中的错误描述。2) 在代码中使用错误定义下面的代码会定义一个除法函数，当除数为 0 时，返回一个预定义的除数为 0 的错误。123456789101112131415161718package mainimport ( \"errors\" \"fmt\")// 定义除数为0的错误var errDivisionByZero = errors.New(\"division by zero\")func div(dividend, divisor int) (int, error) &#123; // 判断除数为0的情况并返回 if divisor == 0 &#123; return 0, errDivisionByZero &#125; // 正常计算，返回空错误 return dividend / divisor, nil&#125;func main() &#123; fmt.Println(div(1, 0))&#125; 代码输出如下： 10 division by zero 代码说明： 第 9 行，预定义除数为 0 的错误。 第 11 行，声明除法函数，输入被除数和除数，返回商和错误。 第 14 行，在除法计算中，如果除数为 0，计算结果为无穷大，为了避免这种情况，对除数进行判断，并返回商为 0 和除数为 0 的错误对象。 第 19 行，进行正常的除法计算，没有发生错误时，错误对象返回 nil。示例：在解析中使用自定义错误使用 errors.New 定义的错误字符串的错误类型是无法提供丰富的错误信息的，那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。 下面代码将实现一个解析错误（ParseError），这种错误包含两个内容，分别是文件名和行号，解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，就需要将文件名和行号返回。 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\")// 声明一个解析错误type ParseError struct &#123; Filename string // 文件名 Line int // 行号&#125;// 实现error接口，返回错误描述func (e *ParseError) Error() string &#123; return fmt.Sprintf(\"%s:%d\", e.Filename, e.Line)&#125;// 创建一些解析错误func newParseError(filename string, line int) error &#123; return &amp;ParseError&#123;filename, line&#125;&#125;func main() &#123; var e error // 创建一个错误实例，包含文件名和行号 e = newParseError(\"main.go\", 1) // 通过error接口查看错误描述 fmt.Println(e.Error()) // 根据错误接口具体的类型，获取详细错误信息 switch detail := e.(type) &#123; case *ParseError: // 这是一个解析错误 fmt.Printf(\"Filename: %s Line: %d\\n\", detail.Filename, detail.Line) default: // 其他类型的错误 fmt.Println(\"other error\") &#125;&#125; 代码输出如下： 12main.go:1Filename: main.go Line: 1 代码说明如下： 第 8 行，声明了一个解析错误的结构体，解析错误包含有 2 个成员，分别是文件名和行号。 第 14 行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。 第 19 行，根据给定的文件名和行号创建一个错误实例。 第 25 行，声明一个错误接口类型。 第 27 行，创建一个实例，这个错误接口内部是 *ParserError 类型，携带有文件名 main.go 和行号 1。 第 30 行，调用 Error() 方法，通过第 15 行返回错误的详细信息。 第 33 行，通过错误断言，取出发生错误的详细类型。 第 34 行，通过分析这个错误的类型，得知错误类型为 *ParserError，此时可以获取到详细的错误信息。 第 36 行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。 错误对象都要实现 error 接口的 Error() 方法，这样，所有的错误都可以获得字符串的描述，如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"34、Go语言 之defer延迟执行","slug":"Golang/34、Go语言 之defer延迟执行","date":"2016-02-02T22:29:03.000Z","updated":"2020-08-07T14:10:11.749Z","comments":true,"path":"2016/02/03/Golang/34、Go语言 之defer延迟执行/","link":"","permalink":"https://www.zackaddy.xin/2016/02/03/Golang/34、Go语言 之defer延迟执行/","excerpt":"","text":"Go语言 之defer延迟执行Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。 关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。 多个延迟执行语句的处理顺序当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出），下面的代码是将一系列的数值打印语句按顺序延迟处理，如下所示： 12345678910111213package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"defer begin\") // 将defer放入延迟调用栈 defer fmt.Println(1) defer fmt.Println(2) // 最后一个放入, 位于栈顶, 最先调用 defer fmt.Println(3) fmt.Println(\"defer end\")&#125; 代码输出如下： 12345defer begindefer end321 结果分析如下：代码的延迟顺序与最终的执行顺序是反向的。延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。 使用延迟执行语句在函数退出时释放资源处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。 defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。 1) 使用延迟并发解锁在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码： 1234567891011121314151617var ( // 一个演示用的映射 valueByKey = make(map[string]int) // 保证使用映射时的并发安全的互斥锁 valueByKeyGuard sync.Mutex)// 根据键读取值func readValue(key string) int &#123; // 对共享资源加锁 valueByKeyGuard.Lock() // 取值 v := valueByKey[key] // 对共享资源解锁 valueByKeyGuard.Unlock() // 返回值 return v&#125; 代码说明如下： 第 3 行，实例化一个 map，键是 string 类型，值为 int。 第 5 行，map 默认不是并发安全的，准备一个 sync.Mutex 互斥量保护 map 的访问。 第 9 行，readValue() 函数给定一个键，从 map 中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。 第 11 行，使用互斥量加锁。 第 13 行，从 map 中获取值。 第 15 行，使用互斥量解锁。 第 17 行，返回获取到的 map 值。 使用 defer 语句对上面的语句进行简化，参考下面的代码。 1234567func readValue(key string) int &#123; valueByKeyGuard.Lock() // defer后面的语句不会马上调用, 而是延迟到函数结束时调用 defer valueByKeyGuard.Unlock() return valueByKey[key]&#125; 上面的代码中第 6~8 行是对前面代码的修改和添加的代码，代码说明如下： 第 6 行在互斥量加锁后，使用 defer 语句添加解锁，该语句不会马上执行，而是等 readValue() 函数返回时才会被执行。 第 8 行，从 map 查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。2) 使用延迟释放文件句柄文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源，在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码：123456789101112131415161718192021222324// 根据文件名查询其大小func fileSize(filename string) int64 &#123; // 根据文件名打开文件, 返回文件句柄和错误 f, err := os.Open(filename) // 如果打开时发生错误, 返回文件大小为0 if err != nil &#123; return 0 &#125; // 取文件状态信息 info, err := f.Stat() // 如果获取信息时发生错误, 关闭文件并返回文件大小为0 if err != nil &#123; f.Close() return 0 &#125; // 取文件大小 size := info.Size() // 关闭文件 f.Close() // 返回文件大小 return size&#125; 代码说明如下： 第 2 行，定义获取文件大小的函数，返回值是 64 位的文件大小值。 第 5 行，使用 os 包提供的函数 Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。 第 8 行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为 0。 第 13 行，此时文件句柄 f 可以正常使用，使用 f 的方法 Stat() 来获取文件的信息，获取信息时，可能也会发生错误。 第 16～19 行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用 f 的 Close() 方法来关闭文件，否则会发生资源泄露。 第 22 行，获取文件大小。 第 25 行，关闭文件、释放资源。 第 28 行，返回获取到的文件大小。 在上面的例子中，第 25 行是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下： 12345678910111213141516func fileSize(filename string) int64 &#123; f, err := os.Open(filename) if err != nil &#123; return 0 &#125; // 延迟调用Close, 此时Close不会被调用 defer f.Close() info, err := f.Stat() if err != nil &#123; // defer机制触发, 调用Close关闭文件 return 0 &#125; size := info.Size() // defer机制触发, 调用Close关闭文件 return size&#125; 代码中加粗部分为对比前面代码而修改的部分，代码说明如下： 第 10 行，在文件正常打开后，使用 defer，将 f.Close() 延迟调用，注意，不能将这一句代码放在第 4 行空行处，一旦文件打开错误，f 将为空，在延迟语句触发时，将触发宕机错误。 第 16 行和第 22 行，defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"33、Go语言 之可变参数","slug":"Golang/33、Go语言 之可变参数","date":"2016-02-01T19:55:48.000Z","updated":"2020-08-07T14:10:11.749Z","comments":true,"path":"2016/02/02/Golang/33、Go语言 之可变参数/","link":"","permalink":"https://www.zackaddy.xin/2016/02/02/Golang/33、Go语言 之可变参数/","excerpt":"","text":"Go语言 之可变参数在C语言时代大家一般都用过 printf() 函数，从那个时候开始其实已经在感受可变参数的魅力和价值，如同C语言中的 printf() 函数，Go语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能。 本节我们将介绍可变参数的用法。合适地使用可变参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等。 可变参数类型可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型： 12345func myfunc(args ...int) &#123; for _, arg := range args &#123; fmt.Println(arg) &#125;&#125; 上面这段代码的意思是，函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int，所以它可以用如下方式调用： 12myfunc(2, 3, 4)myfunc(1, 3, 7, 13) 形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖（syntactic sugar），即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。 从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。 假如没有…type这样的语法糖，开发者将不得不这么写： 12345func myfunc2(args []int) &#123; for _, arg := range args &#123; fmt.Println(arg) &#125;&#125; 从函数的实现角度来看，这没有任何影响，该怎么写就怎么写，但从调用方来说，情形则完全不同： 1myfunc2([]int&#123;1, 3, 7, 13&#125;) 大家会发现，我们不得不加上[]int{}来构造一个数组切片实例，但是有了…type这个语法糖，我们就不用自己来处理了。 任意类型的可变参数之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型： 123func Printf(format string, args ...interface&#123;&#125;) &#123; // ...&#125; 用 interface{} 传递任意类型数据是Go语言的惯例用法，使用 interface{} 仍然是类型安全的，这和 C/C++ 不太一样，下面通过示例来了解一下如何分配传入 interface{} 类型的数据。 1234567891011121314151617181920212223package mainimport \"fmt\"func MyPrintf(args ...interface&#123;&#125;) &#123; for _, arg := range args &#123; switch arg.(type) &#123; case int: fmt.Println(arg, \"is an int value.\") case string: fmt.Println(arg, \"is a string value.\") case int64: fmt.Println(arg, \"is an int64 value.\") default: fmt.Println(arg, \"is an unknown type.\") &#125; &#125;&#125;func main() &#123; var v1 int = 1 var v2 int64 = 234 var v3 string = \"hello\" var v4 float32 = 1.234 MyPrintf(v1, v2, v3, v4)&#125; 该程序的输出结果为： 12341 is an int value.234 is an int64 value.hello is a string value.1.234 is an unknown type. 遍历可变参数列表——获取每一个参数的值可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码： 12345678910111213141516171819202122package mainimport ( \"bytes\" \"fmt\")// 定义一个函数, 参数数量为0~n, 类型约束为字符串func joinStrings(slist ...string) string &#123; // 定义一个字节缓冲, 快速地连接字符串 var b bytes.Buffer // 遍历可变参数列表slist, 类型为[]string for _, s := range slist &#123; // 将遍历出的字符串连续写入字节数组 b.WriteString(s) &#125; // 将连接好的字节数组转换为字符串并输出 return b.String()&#125;func main() &#123; // 输入3个字符串, 将它们连成一个字符串 fmt.Println(joinStrings(\"pig \", \"and\", \" rat\")) fmt.Println(joinStrings(\"hammer\", \" mom\", \" and\", \" hawk\"))&#125; 代码输出如下： 12pig and rathammer mom and hawk 代码说明如下： 第 8 行，定义了一个可变参数的函数，slist 的类型为 []string，每一个参数的类型都是 string，也就是说，该函数只接受字符串类型作为参数。 第 11 行，bytes.Buffer 在这个例子中的作用类似于 StringBuilder，可以高效地进行字符串连接操作。 第 13 行，遍历 slist 可变参数，s 为每个参数的值，类型为 string。 第 15 行，将每一个传入参数放到 bytes.Buffer 中。 第 19 行，将 bytes.Buffer 中的数据转换为字符串作为函数返回值返回。 第 24 行，输入 3 个字符串，使用 joinStrings() 函数将参数连接为字符串输出。 第 25 行，输入 4 个字符串，连接后输出。 如果要获取可变参数的数量，可以使用 len() 函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。 获得可变参数类型——获得每一个参数的类型当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型，下面的代码演示将一系列不同类型的值传入 printTypeValue() 函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。 打印类型及值： 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"bytes\" \"fmt\")func printTypeValue(slist ...interface&#123;&#125;) string &#123; // 字节缓冲作为快速字符串连接 var b bytes.Buffer // 遍历参数 for _, s := range slist &#123; // 将interface&#123;&#125;类型格式化为字符串 str := fmt.Sprintf(\"%v\", s) // 类型的字符串描述 var typeString string // 对s进行类型断言 switch s.(type) &#123; case bool: // 当s为布尔类型时 typeString = \"bool\" case string: // 当s为字符串类型时 typeString = \"string\" case int: // 当s为整型类型时 typeString = \"int\" &#125; // 写字符串前缀 b.WriteString(\"value: \") // 写入值 b.WriteString(str) // 写类型前缀 b.WriteString(\" type: \") // 写类型字符串 b.WriteString(typeString) // 写入换行符 b.WriteString(\"\\n\") &#125; return b.String()&#125;func main() &#123; // 将不同类型的变量通过printTypeValue()打印出来 fmt.Println(printTypeValue(100, \"str\", true))&#125; 代码输出如下： 123value: 100 type: intvalue: str type: stringvalue: true type: bool 代码说明如下： 第 8 行，printTypeValue() 输入不同类型的值并输出类型和值描述。 第 11 行，bytes.Buffer 字节缓冲作为快速字符串连接。 第 14 行，遍历 slist 的每一个元素，类型为 interface{}。 第 17 行，使用 fmt.Sprintf 配合%v动词，可以将 interface{} 格式的任意值转为字符串。 第 20 行，声明一个字符串，作为变量的类型名。 第 23 行，switch s.(type) 可以对 interface{} 类型进行类型断言，也就是判断变量的实际类型。 第 24～29 行为 s 变量可能的类型，将每种类型的对应类型字符串赋值到 typeString 中。 第 33～42 行为写输出格式的过程。在多个可变参数函数中传递参数可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加…，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。 下面的例子模拟 print() 函数及实际调用的 rawPrint() 函数，两个函数都拥有可变参数，需要将参数从 print 传递到 rawPrint 中。 可变参数传递： 123456789101112131415161718package mainimport \"fmt\"// 实际打印的函数func rawPrint(rawList ...interface&#123;&#125;) &#123; // 遍历可变参数切片 for _, a := range rawList &#123; // 打印参数 fmt.Println(a) &#125;&#125;// 打印函数封装func print(slist ...interface&#123;&#125;) &#123; // 将slist可变参数切片完整传递给下一个函数 rawPrint(slist...)&#125;func main() &#123; print(1, 2, 3)&#125; 代码输出如下： 123123 对代码的说明： 第 9～13 行，遍历 rawPrint() 的参数列表 rawList 并打印。 第 20 行，将变量在 print 的可变参数列表中添加…后传递给 rawPrint()。 第 25 行，传入 1、2、3 这 3 个整型值并进行打印。 如果尝试将第 20 行修改为： 1rawPrint(\"fmt\", slist) 再次执行代码，将输出： 1[1 2 3] 此时，slist（类型为 []interface{}）将被作为一个整体传入 rawPrint()，rawPrint() 函数中遍历的变量也就是 slist 的切片值。 可变参数使用…进行传递与切片间使用 append 连接是同一个特性。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"32、Go语言 之闭包","slug":"Golang/32、Go语言 之闭包","date":"2016-02-01T03:02:37.000Z","updated":"2020-08-07T14:10:11.748Z","comments":true,"path":"2016/02/01/Golang/32、Go语言 之闭包/","link":"","permalink":"https://www.zackaddy.xin/2016/02/01/Golang/32、Go语言 之闭包/","excerpt":"","text":"Go语言 之闭包Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：函数 + 引用环境 = 闭包 一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。其它编程语言中的闭包闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。 闭包对环境中变量的引用过程也可以被称为“捕获”，在 C++11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。 在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。 闭包在各种语言中的实现也是不尽相同的，在 Lua 语言中，无论闭包还是函数都属于 Prototype 概念，被捕获的变量以 Upvalue 的形式引用到闭包中。 C++ 与 C# 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。 在闭包内部修改引用的变量闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解： 12345678910// 准备一个字符串str := \"hello world\"// 创建一个匿名函数foo := func() &#123; // 匿名函数中访问str str = \"hello dude\"&#125;// 调用匿名函数foo() 代码说明如下： 第 2 行，准备一个字符串用于修改。 第 5 行，创建一个匿名函数。 第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。 第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。 代码输出： 1hello dude 示例：闭包的记忆效应被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。 累加器的实现： 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\")// 提供一个值, 每次调用函数会指定对值进行累加func Accumulate(value int) func() int &#123; // 返回一个闭包 return func() int &#123; // 累加 value++ // 返回一个累加值 return value &#125;&#125;func main() &#123; // 创建一个累加器, 初始值为1 accumulator := Accumulate(1) // 累加1并打印 fmt.Println(accumulator()) fmt.Println(accumulator()) // 打印累加器的函数地址 fmt.Printf(\"%p\\n\", accumulator) // 创建一个累加器, 初始值为1 accumulator2 := Accumulate(10) // 累加1并打印 fmt.Println(accumulator2()) // 打印累加器的函数地址 fmt.Printf(\"%p\\n\", accumulator2)&#125; 代码说明如下： 第 8 行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。 第 11 行，返回一个闭包函数，每次返回会创建一个新的函数实例。 第 14 行，对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。 第 17 行，将修改后的值通过闭包的返回值返回。 第 24 行，创建一个累加器，初始值为 1，返回的 accumulator 是类型为 func()int 的函数变量。 第 27 行，调用 accumulator() 时，代码从 11 行开始执行匿名函数逻辑，直到第 17 行返回。 第 32 行，打印累加器的函数地址。 对比输出的日志发现 accumulator 与 accumulator2 输出的函数地址不同，因此它们是两个不同的闭包实例。 每调用一次 accumulator 都会自动对引用的变量进行累加。 示例：闭包实现生成器闭包的记忆效应被用于实现类似于设计模式中工厂模式的生成器，下面的例子展示了创建一个玩家生成器的过程。 玩家生成器的实现： 12345678910111213141516171819202122package mainimport ( \"fmt\")// 创建一个玩家生成器, 输入名称, 输出生成器func playerGen(name string) func() (string, int) &#123; // 血量一直为150 hp := 150 // 返回创建的闭包 return func() (string, int) &#123; // 将变量引用到闭包中 return name, hp &#125;&#125;func main() &#123; // 创建一个玩家生成器 generator := playerGen(\"high noon\") // 返回玩家的名字和血量 name, hp := generator() // 打印值 fmt.Println(name, hp)&#125; 代码输出如下： 1high noon 150 代码说明如下： 第 8 行，playerGen() 需要提供一个名字来创建一个玩家的生成函数。 第 11 行，声明并设定 hp 变量为 150。 第 14～18 行，将 hp 和 name 变量引用到匿名函数中形成闭包。 第 24 行中，通过 playerGen 传入参数调用后获得玩家生成器。 第 27 行，调用这个玩家生成器函数，可以获得玩家的名称和血量。 闭包还具有一定的封装性，第 11 行的变量是 playerGen 的局部变量，playerGen 的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"31、Go语言 之匿名函数","slug":"Golang/31、Go语言 之匿名函数","date":"2016-01-31T02:20:31.000Z","updated":"2020-08-07T14:10:11.748Z","comments":true,"path":"2016/01/31/Golang/31、Go语言 之匿名函数/","link":"","permalink":"https://www.zackaddy.xin/2016/01/31/Golang/31、Go语言 之匿名函数/","excerpt":"","text":"Go语言 之匿名函数Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。 匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。 定义一个匿名函数匿名函数的定义格式如下： 123func(参数列表)(返回参数列表)&#123; 函数体&#125; 匿名函数的定义就是没有名字的普通函数定义。 1) 在定义时调用匿名函数匿名函数可以在声明后调用，例如： 123func(data int) &#123; fmt.Println(\"hello\", data)&#125;(100) 注意第3行}后的(100)，表示对匿名函数进行调用，传递参数为 100。 2) 将匿名函数赋值给变量匿名函数可以被赋值，例如： 123456// 将匿名函数体保存到f()中f := func(data int) &#123; fmt.Println(\"hello\", data)&#125;// 使用f()调用f(100) 匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。 匿名函数用作回调函数下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下： 12345678910111213141516package mainimport ( \"fmt\")// 遍历切片的每个元素, 通过给定函数进行元素访问func visit(list []int, f func(int)) &#123; for _, v := range list &#123; f(v) &#125;&#125;func main() &#123; // 使用匿名函数打印切片内容 visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123; fmt.Println(v) &#125;)&#125; 代码说明如下： 第 8 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。 第 18 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。 第 19～20 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。 匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下： 123func TrimFunc(s string, f func(rune) bool) string &#123; return TrimRightFunc(TrimLeftFunc(s, f), f)&#125; 使用匿名函数实现操作封装下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下： 12345678910111213141516171819202122232425package mainimport ( \"flag\" \"fmt\")var skillParam = flag.String(\"skill\", \"\", \"skill to perform\")func main() &#123; flag.Parse() var skill = map[string]func()&#123; \"fire\": func() &#123; fmt.Println(\"chicken fire\") &#125;, \"run\": func() &#123; fmt.Println(\"soldier run\") &#125;, \"fly\": func() &#123; fmt.Println(\"angel fly\") &#125;, &#125; if f, ok := skill[*skillParam]; ok &#123; f() &#125; else &#123; fmt.Println(\"skill not found\") &#125;&#125; 代码说明如下： 第 8 行，定义命令行参数 skill，从命令行输入 –skill 可以将=后的字符串传入 skillParam 指针变量。 第 12 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。 第 14 行，定义一个从字符串映射到 func() 的 map，然后填充这个 map。 第 15～23 行，初始化 map 的键值对，值为匿名函数。 第 26 行，skillParam 是一个 *string 类型的指针变量，使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。 第 29 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。 运行代码，结果如下： 1234PS D:\\code&gt; go run main.go --skill=flyangel flyPS D:\\code&gt; go run main.go --skill=runsoldier run","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"30、Go语言 之函数变量","slug":"Golang/30、Go语言 之函数变量","date":"2016-01-29T22:59:36.000Z","updated":"2020-08-07T14:10:11.748Z","comments":true,"path":"2016/01/30/Golang/30、Go语言 之函数变量/","link":"","permalink":"https://www.zackaddy.xin/2016/01/30/Golang/30、Go语言 之函数变量/","excerpt":"","text":"Go语言 之函数变量 在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下： 123456789101112package mainimport ( \"fmt\")func fire() &#123; fmt.Println(\"fire\")&#125;func main() &#123; var f func() f = fire f()&#125; 代码输出结果： 1fire 代码说明： 第 7 行，定义了一个 fire() 函数。 第 13 行，将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil。 第 15 行，将 fire() 函数作为值，赋给函数变量 f，此时 f 的值为 fire() 函数。 第 17 行，使用函数变量 f 进行函数调用，实际调用的是 fire() 函数。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"29、Go语言 之函数声明","slug":"Golang/29、Go语言 之函数声明","date":"2016-01-29T03:43:39.000Z","updated":"2020-08-07T14:10:11.747Z","comments":true,"path":"2016/01/29/Golang/29、Go语言 之函数声明/","link":"","permalink":"https://www.zackaddy.xin/2016/01/29/Golang/29、Go语言 之函数声明/","excerpt":"","text":"Go语言 之函数声明函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。 因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。 编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。 当函数执行到代码块最后一行}之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。 Go语言里面拥三种类型的函数： 普通的带有名字的函数 匿名函数或者 lambda 函数 方法普通函数声明（定义）函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。123func 函数名(形式参数列表)(返回值列表)&#123; 函数体&#125; 形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。 如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中： 1234func hypot(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y)&#125;fmt.Println(hypot(3,4)) // \"5\" x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。 如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。 正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的： 1234func f(i, j, k int, s, t string) &#123; /* ... */ &#125;func f(i int, j int, k int, s string, t string) &#123; /* ... */ &#125;``` 下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符_可以强调某个参数未被使用。 func add(x int, y int) int {return x + y}func sub(x, y int) (z int) { z = x - y; return}func first(x int, _ int) int { return x }func zero(int, int) int { return 0 }fmt.Printf(“%T\\n”, add) // “func(int, int) int”fmt.Printf(“%T\\n”, sub) // “func(int, int) int”fmt.Printf(“%T\\n”, first) // “func(int, int) int”fmt.Printf(“%T\\n”, zero) // “func(int, int) int” 1234567函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。### **函数的返回值**Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下： conn, err := connectToNetwork() 1234567891011在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。其它编程语言中函数的返回值C/C++ 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果，C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。C# 语言也没有多返回值特性，C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。#### **1) 同一种类型返回值**如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下： func typedTwoValues() (int, int) { return 1, 2}func main() { a, b := typedTwoValues() fmt.Println(a, b)} 1代码输出结果： 1 2 1234567纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。#### **2) 带有变量名的返回值**Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下： func namedRetValues() (a, b int) { a = 1 b = 2 return} 1234代码说明如下：- 第 1 行，对两个整型返回值进行命名，分别为 a 和 b。- 第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。- 第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。 func namedRetValues() (a, b int) { a = 1 return a, 2} 12提示同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码： func namedRetValues() (a, b int, int) 1编译报错提示： mixed named and unnamed function parameters 123456789101112131415意思是：在函数参数中混合使用了命名和非命名参数。### **调用函数**函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。Go语言的函数调用格式如下：返回值变量列表 = 函数名(参数列表)下面是对各个部分的说明：函数名：需要调用的函数名。参数列表：参数变量以逗号分隔，尾部无须以分号结尾。返回值变量列表：多个返回值使用逗号分隔。例如，加法函数调用样式如下： result := add(1,1)```","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"28、Go语言 之continue继续下一次循环","slug":"Golang/28、Go语言 之continue继续下一次循环","date":"2016-01-27T16:34:25.000Z","updated":"2020-08-07T14:10:11.747Z","comments":true,"path":"2016/01/28/Golang/28、Go语言 之continue继续下一次循环/","link":"","permalink":"https://www.zackaddy.xin/2016/01/28/Golang/28、Go语言 之continue继续下一次循环/","excerpt":"","text":"Go语言 之continue继续下一次循环Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如： 1234567891011121314package mainimport \"fmt\"func main() &#123;OuterLoop: for i := 0; i &lt; 2; i++ &#123; for j := 0; j &lt; 5; j++ &#123; switch j &#123; case 2: fmt.Println(i, j) continue OuterLoop &#125; &#125; &#125;&#125; 代码输出结果如下： 120 21 2 代码说明：第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"27、Go语言 之break（跳出循环）","slug":"Golang/27、Go语言 之break（跳出循环）","date":"2016-01-26T17:51:41.000Z","updated":"2020-08-07T14:10:11.747Z","comments":true,"path":"2016/01/27/Golang/27、Go语言 之break（跳出循环）/","link":"","permalink":"https://www.zackaddy.xin/2016/01/27/Golang/27、Go语言 之break（跳出循环）/","excerpt":"","text":"Go语言 之break（跳出循环）Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。 跳出指定循环： 1234567891011121314151617package mainimport \"fmt\"func main() &#123;OuterLoop: for i := 0; i &lt; 2; i++ &#123; for j := 0; j &lt; 5; j++ &#123; switch j &#123; case 2: fmt.Println(i, j) break OuterLoop case 3: fmt.Println(i, j) break OuterLoop &#125; &#125; &#125;&#125; 代码输出如下： 10 2 代码说明如下： 第 7 行，外层循环的标签。 第 8 行和第 9 行，双层循环。 第 10 行，使用 switch 进行数值分支判断。 第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"26、Go语言 之goto语句","slug":"Golang/26、Go语言 之goto语句","date":"2016-01-25T16:39:07.000Z","updated":"2020-08-07T14:10:11.747Z","comments":true,"path":"2016/01/26/Golang/26、Go语言 之goto语句/","link":"","permalink":"https://www.zackaddy.xin/2016/01/26/Golang/26、Go语言 之goto语句/","excerpt":"","text":"Go语言 之goto语句Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。 使用 goto 退出多层循环下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下： 1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; var breakAgain bool // 外循环 for x := 0; x &lt; 10; x++ &#123; // 内循环 for y := 0; y &lt; 10; y++ &#123; // 满足某个条件时, 退出循环 if y == 2 &#123; // 设置退出标记 breakAgain = true // 退出本次循环 break &#125; &#125; // 根据标记, 还需要退出一次循环 if breakAgain &#123; break &#125; &#125; fmt.Println(\"done\")&#125; 代码说明如下： 第 10 行，构建外循环。 第 13 行，构建内循环。 第 16 行，当 y==2 时需要退出所有的 for 循环。 第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。 第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。 第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。 第 34 行，退出所有循环后，打印 done。 将上面的代码使用Go语言的 goto 语句进行优化： 1234567891011121314151617package mainimport \"fmt\"func main() &#123; for x := 0; x &lt; 10; x++ &#123; for y := 0; y &lt; 10; y++ &#123; if y == 2 &#123; // 跳转到标签 goto breakHere &#125; &#125; &#125; // 手动返回, 避免执行进入标签 return // 标签breakHere: fmt.Println(\"done\")&#125; 代码说明如下： 第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。 第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。 第 23 行，定义 breakHere 标签。 使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。使用 goto 集中处理错误多处错误处理存在代码重复时是非常棘手的，例如： 12345678910111213err := firstCheckError()if err != nil &#123; fmt.Println(err) exitProcess() return&#125;err = secondCheckError()if err != nil &#123; fmt.Println(err) exitProcess() return&#125;fmt.Println(\"done\") 代码说明如下： 第 1 行，执行某逻辑，返回错误。 第 2～6 行，如果发生错误，打印错误退出进程。 第 8 行，执行某逻辑，返回错误。 第 10～14 行，发生错误后退出流程。 第 16 行，没有任何错误，打印完成。 在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。 使用 goto 语句来实现同样的逻辑： 12345678910111213 err := firstCheckError() if err != nil &#123; goto onExit &#125; err = secondCheckError() if err != nil &#123; goto onExit &#125; fmt.Println(\"done\") returnonExit: fmt.Println(err) exitProcess() 代码说明如下： 第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。 第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"25、Go语言 之switch case语句","slug":"Golang/25、Go语言 之switch case语句","date":"2016-01-24T23:44:27.000Z","updated":"2020-08-07T14:10:11.746Z","comments":true,"path":"2016/01/25/Golang/25、Go语言 之switch case语句/","link":"","permalink":"https://www.zackaddy.xin/2016/01/25/Golang/25、Go语言 之switch case语句/","excerpt":"","text":"Go语言 之switch case语句Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。 相对于C语言和 Java 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。 基本写法Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下： 123456789var a = \"hello\"switch a &#123;case \"hello\": fmt.Println(1)case \"world\": fmt.Println(2)default: fmt.Println(0)&#125; 代码输出如下： 11 上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。 1) 一分支多值当出现多个 case 要放在一起的时候，可以写成下面这样： 12345var a = \"mum\"switch a &#123;case \"mum\", \"daddy\": fmt.Println(\"family\")&#125; 不同的 case 表达式使用逗号分隔。 2) 分支表达式case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下： 12345var r int = 11switch &#123;case r &gt; 10 &amp;&amp; r &lt; 20: fmt.Println(r)&#125; 注意，这种情况的 switch 后面不再需要跟判断变量。跨越 case 的 fallthrough——兼容C语言的 case 设计在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下： 12345678var s = \"hello\"switch &#123;case s == \"hello\": fmt.Println(\"hello\") fallthroughcase s != \"world\": fmt.Println(\"world\")&#125; 代码输出如下： 12helloworld 新编写的代码，不建议使用 fallthrough。 3)类型判断123var i interface&#123;&#125; = \"5\";a, ok := i.(int)fmt.Println(a, ok, i) // 0 false 5 1234567891011var arg interface&#123;&#125; = 5switch arg.(type) &#123; case int: fmt.Println(arg, \"is an int value.\") case string: fmt.Println(arg, \"is a string value.\") case int64: fmt.Println(arg, \"is an int64 value.\") default: fmt.Println(arg, \"is an unknown type.\")&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"24、Go语言 之for循环","slug":"Golang/24、Go语言 之for循环","date":"2016-01-23T18:33:31.000Z","updated":"2020-08-07T14:10:11.746Z","comments":true,"path":"2016/01/24/Golang/24、Go语言 之for循环/","link":"","permalink":"https://www.zackaddy.xin/2016/01/24/Golang/24、Go语言 之for循环/","excerpt":"","text":"Go语言 之for循环与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 C++ 中非常接近： 1234sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125; 可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号()括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 for(;;){}和do{} while(1);，而直接简化为如下的写法： 1234567sum := 0for &#123; sum++ if sum &gt; 100 &#123; break &#125;&#125; 使用循环语句时，需要注意的有以下几点： 左花括号{必须与 for 处于同一行。 Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。 Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：12345678910for j := 0; j &lt; 5; j++ &#123; for i := 0; i &lt; 10; i++ &#123; if i &gt; 5 &#123; break JLoop &#125; fmt.Println(i) &#125;&#125;JLoop:// ... 上述代码中，break 语句终止的是 JLoop 标签处的外层循环。 for 中的初始语句——开始循环时执行的语句初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。 初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下： 1234step := 2for ; step &gt; 0; step-- &#123; fmt.Println(step)&#125; 这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。 for 中的条件表达式——控制是否循环的开关每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。 1) 结束循环时带可执行语句的无限循环下面代码忽略条件表达式，但是保留结束语句，代码如下： 123456var i intfor ; ; i++ &#123; if i &gt; 10 &#123; break &#125;&#125; 代码说明如下：第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。2) 无限循环上面的代码还可以改写为更美观的写法，代码如下： 1234567var i intfor &#123; if i &gt; 10 &#123; break &#125; i++&#125; 代码说明如下： 第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。 第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。 无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。3) 只有一个循环条件的循环在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码： 1234var i intfor i &lt;= 10 &#123; i++&#125; 在代码第 3 行中，将之前使用if i&gt;10{}判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。 上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。 for 中的结束语句——每次循环结束时执行的语句在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"23、Go语言 之if、else","slug":"Golang/23、Go语言 之if、else","date":"2016-01-22T19:13:32.000Z","updated":"2020-08-07T14:10:11.746Z","comments":true,"path":"2016/01/23/Golang/23、Go语言 之if、else/","link":"","permalink":"https://www.zackaddy.xin/2016/01/23/Golang/23、Go语言 之if、else/","excerpt":"","text":"Go语言 之if、else在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号{}括起来的代码块，否则就忽略该代码块继续执行后续的代码。 123if condition &#123; // do something&#125; 如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。 12345if condition &#123; // do something&#125; else &#123; // do something&#125; 如果存在第三个分支，则可以使用下面这种三个独立分支的形式： 1234567if condition1 &#123; // do something&#125; else if condition2 &#123; // do something else&#125;else &#123; // catch-all or default&#125; else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。 关键字 if 和 else 之后的左大括号{必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号}必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。 非法的 Go 代码: 1234if x&#123;&#125;else &#123; // 无效的&#125; 要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号}与对应的 if 关键字垂直对齐。 在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &amp;&amp;、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。 举例通过下面的例子来了解 if 的写法： 123456var ten int = 11if ten &gt; 10 &#123; fmt.Println(\"&gt;10\")&#125; else &#123; fmt.Println(\"&lt;=10\")&#125; 代码输出如下： 1&gt;10 代码说明如下：第 1 行，声明整型变量并赋值 11。第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。 特殊写法if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下： 1234if err := Connect(); err != nil &#123; fmt.Println(err) return&#125; Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。 err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。 这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。提示在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"22、Go语言 之make和new关键字","slug":"Golang/22、Go语言 之make和new关键字","date":"2016-01-22T00:49:00.000Z","updated":"2020-08-07T14:10:11.746Z","comments":true,"path":"2016/01/22/Golang/22、Go语言 之make和new关键字/","link":"","permalink":"https://www.zackaddy.xin/2016/01/22/Golang/22、Go语言 之make和new关键字/","excerpt":"","text":"Go语言 之make和new关键字Go语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化，下面我们就来具体介绍一下。 new在Go语言中，new 函数描述如下： 1234// The new built-in function allocates memory. The first argument is a type,// not a value, and the value returned is a pointer to a newly// allocated zero value of that type.func new(Type) *Type 从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。 【示例】使用 new 函数为变量分配内存空间。 1234var sum *intsum = new(int) //分配空间*sum = 98fmt.Println(*sum) 当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示： 12345678type Student struct &#123; name string age int&#125;var s *Students = new(Student) //分配空间s.name =\"dequan\"fmt.Println(s) 这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错： 123panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277]goroutine 1 [running]: 这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。 makemake 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。 在Go语言中，make 函数的描述如下： 1234567891011121314151617// The make built-in function allocates and initializes an object of type// slice, map, or chan (only). Like new, the first argument is a type, not a// value. Unlike new, make's return type is the same as the type of its// argument, not a pointer to it. The specification of the result depends on// the type:// Slice: The size specifies the length. The capacity of the slice is// equal to its length. A second integer argument may be provided to// specify a different capacity; it must be no smaller than the// length, so make([]int, 0, 10) allocates a slice of length 0 and// capacity 10.// Map: An empty map is allocated with enough space to hold the// specified number of elements. The size may be omitted, in which case// a small starting size is allocated.// Channel: The channel's buffer is initialized with the specified// buffer capacity. If zero, or the size is omitted, the channel is// unbuffered.func make(t Type, size ...IntegerType) Type 通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。 Go语言中的 new 和 make 主要区别如下： make 只能用来分配及初始化类型为 - slice、map、chan 的数据。new 可以分配任意类型的数据； new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type； new 分配的空间被清零。make 分配空间后，会进行初始化；实现原理接下来我们将分别介绍一下 make 和 new 在初始化不同数据结构时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。 make我们已经了解了 make 在创建 slice、map 和 channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的数据结构初始化原理。 在编译期的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。 new内置函数 new 会在编译期的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject： 1234567891011121314151617func callnew(t *types.Type) *Node &#123; if t.NotInHeap() &#123; yyerror(\"%v is go:notinheap; heap allocation disallowed\", t) &#125; dowidth(t) if t.Size() == 0 &#123; z := newname(Runtimepkg.Lookup(\"zerobase\")) z.SetClass(PEXTERN) z.Type = t return typecheck(nod(OADDR, z, nil), ctxExpr) &#125; fn := syslook(\"newobject\") fn = substArgTypes(fn, t) v := mkcall1(fn, types.NewPtr(t), nil, typename(t)) v.SetNonNil(true) return v&#125; 需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存： 123456789101112131415161718192021222324252627func walkstmt(n *Node) *Node &#123; switch n.Op &#123; case ODCL: v := n.Left if v.Class() == PAUTOHEAP &#123; if prealloc[v] == nil &#123; prealloc[v] = callnew(v.Type) &#125; nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v]) nn.SetColas(true) nn = typecheck(nn, ctxStmt) return walkstmt(nn) &#125; case ONEW: if n.Esc == EscNone &#123; r := temp(n.Type.Elem()) r = nod(OAS, r, nil) r = typecheck(r, ctxStmt) init.Append(r) r = nod(OADDR, r.Left, nil) r = typecheck(r, ctxExpr) n = r &#125; else &#123; n = callnew(n.Type.Elem()) &#125; &#125;&#125; 当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。 newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针： 123func newobject(typ *_type) unsafe.Pointer &#123; return mallocgc(typ.size, typ, true)&#125; 总结最后，简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"21、Go语言 之nil空值、零值","slug":"Golang/21、Go语言 之nil空值、零值","date":"2016-01-20T17:28:52.000Z","updated":"2020-08-07T14:10:11.745Z","comments":true,"path":"2016/01/21/Golang/21、Go语言 之nil空值、零值/","link":"","permalink":"https://www.zackaddy.xin/2016/01/21/Golang/21、Go语言 之nil空值、零值/","excerpt":"","text":"Go语言 之nil空值、零值在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串””，而指针、切片、映射、通道、函数和接口的零值则是 nil。 nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。 下面通过几个方面来介绍一下Go语言中 nil。 nil 标识符是不能比较的1234567package mainimport ( \"fmt\")func main() &#123; fmt.Println(nil==nil)&#125; 运行结果如下所示： 123PS D:\\code&gt; go run .\\main.go# command-line-arguments.\\main.go:8:21: invalid operation: nil == nil (operator == not defined on nil) 这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。 12&gt;&gt;&gt; None == NoneTrue 从上面的运行结果不难看出，==对于 nil 来说是一种未定义的操作。 nil 不是关键字或保留字nil 并不是Go语言的关键字或者保留字，也就是说我们可以定义一个名称为 nil 的变量，比如下面这样： 1var nil = errors.New(\"my god\") 虽然上面的声明语句可以通过编译，但是并不提倡这么做。 nil 没有默认类型12345678package mainimport ( \"fmt\")func main() &#123; fmt.Printf(\"%T\", nil) print(nil)&#125; 运行结果如下所示： 123PS D:\\code&gt; go run .\\main.go# command-line-arguments.\\main.go:9:10: use of untyped nil 不同类型 nil 的指针是一样的12345678910package mainimport ( \"fmt\")func main() &#123; var arr []int var num *int fmt.Printf(\"%p\\n\", arr) fmt.Printf(\"%p\", num)&#125; 运行结果如下所示： 123PS D:\\code&gt; go run .\\main.go0x00x0 通过运行结果可以看出 arr 和 num 的指针都是 0x0。 不同类型的 nil 是不能比较的123456789package mainimport ( \"fmt\")func main() &#123; var m map[int]string var ptr *int fmt.Printf(m == ptr)&#125; 运行结果如下所示： 123PS D:\\code&gt; go run .\\main.go# command-line-arguments.\\main.go:10:20: invalid operation: arr == ptr (mismatched types []int and *int) 两个相同类型的 nil 值也可能无法比较在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的，下面的语句无法编译。 123456789package mainimport ( \"fmt\")func main() &#123; var s1 []int var s2 []int fmt.Printf(s1 == s2)&#125; 运行结果如下所示： 123PS D:\\code&gt; go run .\\main.go# command-line-arguments.\\main.go:10:19: invalid operation: s1 == s2 (slice can only be compared to nil) 通过上面的错误提示可以看出，能够将上述不可比较类型的空值直接与 nil 标识符进行比较，如下所示： 12345678package mainimport ( \"fmt\")func main() &#123; var s1 []int fmt.Println(s1 == nil)&#125; 运行结果如下所示： 12PS D:\\code&gt; go run .\\main.gotrue nil 是 map、slice、pointer、channel、func、interface 的零值123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; var m map[int]string var ptr *int var c chan int var sl []int var f func() var i interface&#123;&#125; fmt.Printf(\"%#v\\n\", m) fmt.Printf(\"%#v\\n\", ptr) fmt.Printf(\"%#v\\n\", c) fmt.Printf(\"%#v\\n\", sl) fmt.Printf(\"%#v\\n\", f) fmt.Printf(\"%#v\\n\", i)&#125; 运行结果如下所示： 1234567PS D:\\code&gt; go run .\\main.gomap[int]string(nil)(*int)(nil)(chan int)(nil)[]int(nil)(func())(nil)&lt;nil&gt; 零值是Go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值。 不同类型的 nil 值占用的内存大小可能是不一样的一个类型的所有的值的内存布局都是一样的，nil 也不例外，nil 的大小与同类型中的非 nil 类型的大小是一样的。但是不同类型的 nil 值的大小可能不同。 12345678910111213141516171819package mainimport ( \"fmt\" \"unsafe\")func main() &#123; var p *struct&#123;&#125; fmt.Println( unsafe.Sizeof( p ) ) // 8 var s []int fmt.Println( unsafe.Sizeof( s ) ) // 24 var m map[int]bool fmt.Println( unsafe.Sizeof( m ) ) // 8 var c chan string fmt.Println( unsafe.Sizeof( c ) ) // 8 var f func() fmt.Println( unsafe.Sizeof( f ) ) // 8 var i interface&#123;&#125; fmt.Println( unsafe.Sizeof( i ) ) // 16&#125; 运行结果如下所示： 1234567PS D:\\code&gt; go run .\\main.go82488816 具体的大小取决于编译器和架构，上面打印的结果是在 64 位架构和标准编译器下完成的，对应 32 位的架构的，打印的大小将减半。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"20、Go语言 之list","slug":"Golang/20、Go语言 之list","date":"2016-01-20T00:19:48.000Z","updated":"2020-08-07T14:10:11.745Z","comments":true,"path":"2016/01/20/Golang/20、Go语言 之list/","link":"","permalink":"https://www.zackaddy.xin/2016/01/20/Golang/20、Go语言 之list/","excerpt":"","text":"Go语言 之list 列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。 列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。 如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。 那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。 如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。 在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。 初始化列表list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。 1) 通过 container/list 包的 New() 函数初始化 list 1变量名 := list.New() 2) 通过 var 关键字声明初始化 list 1var 变量名 list.List 列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。 在列表中插入元素双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。提示这两个方法都会返回一个 *list.Element 结构，如果在以后的使用中需要删除插入的元素，则只能通过 *list.Element 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。 下面代码展示如何给 list 添加元素： 123l := list.New()l.PushBack(\"fist\")l.PushFront(67) 代码说明如下： 第 1 行，创建一个列表实例。 第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。 第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。 列表插入元素的方法如下表所示。 方 法 功 能 InsertAfter(v interface {}, mark * Element) * Element 在 mark 点之后插入元素，mark 点由其他插入函数提供 InsertBefore(v interface {}, mark * Element) *Element 在 mark 点之前插入元素，mark 点由其他插入函数提供 PushBackList(other *List) 添加 other 列表元素到尾部 PushFrontList(other *List) 添加 other 列表元素到头部 ### 从列表中删除元素 列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。 列表操作元素： 1234567891011121314151617package mainimport \"container/list\"func main() &#123; l := list.New() // 尾部添加 l.PushBack(\"canon\") // 头部添加 l.PushFront(67) // 尾部添加后保存元素句柄 element := l.PushBack(\"fist\") // 在fist之后添加high l.InsertAfter(\"high\", element) // 在fist之前添加noon l.InsertBefore(\"noon\", element) // 使用 l.Remove(element)&#125; 代码说明如下： 第 6 行，创建列表实例。 第 9 行，将字符串 canon 插入到列表的尾部。 第 12 行，将数值 67 添加到列表的头部。 第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。 第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。 第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。 第 24 行，移除 element 变量对应的元素。 下表中展示了每次操作后列表的实际元素情况。 列表元素操作的过程操作内容| 列表元素–|–l.PushBack(“canon”) |canonl.PushFront(67) 67, |canonelement := l.PushBack(“fist”) |67, canon, fistl.InsertAfter(“high”, element) |67, canon, fist, highl.InsertBefore(“noon”, element) |67, canon, noon, fist, highl.Remove(element) |67, canon, noon, high 遍历列表——访问列表的每一个元素遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示。 12345678l := list.New()// 尾部添加l.PushBack(\"canon\")// 头部添加l.PushFront(67)for i := l.Front(); i != nil; i = i.Next() &#123; fmt.Println(i.Value)&#125; 代码输出如下： 1267canon 代码说明如下： 第 1 行，创建一个列表实例。 第 4 行，将 canon 放入列表尾部。 第 7 行，在队列头部放入 67。 第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。 第 10 行，使用遍历返回的 *list.Element 的 Value 成员取得放入列表时的原值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"19、Go语言 之map并发操作","slug":"Golang/19、Go语言 之map并发操作","date":"2016-01-19T04:01:04.000Z","updated":"2020-08-07T14:10:11.744Z","comments":true,"path":"2016/01/19/Golang/19、Go语言 之map并发操作/","link":"","permalink":"https://www.zackaddy.xin/2016/01/19/Golang/19、Go语言 之map并发操作/","excerpt":"","text":"Go语言 之map并发操作 Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。 下面来看下并发情况下读写 map 时会出现的问题，代码如下： 12345678910111213141516171819// 创建一个int到int的映射m := make(map[int]int)// 开启一段并发代码go func() &#123; // 不停地对map进行写入 for &#123; m[1] = 1 &#125;&#125;()// 开启一段并发代码go func() &#123; // 不停地对map进行读取 for &#123; _ = m[1] &#125;&#125;()// 无限循环, 让并发程序在后台执行for &#123;&#125; 运行代码会报错，输出如下： 1fatal error: concurrent map read and map write 错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。 需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。 sync.Map 有以下特性：无须初始化，直接声明即可。sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。 并发安全的 sync.Map 演示代码如下： 123456789101112131415161718192021package mainimport ( \"fmt\" \"sync\")func main() &#123; var scene sync.Map // 将键值对保存到sync.Map scene.Store(\"greece\", 97) scene.Store(\"london\", 100) scene.Store(\"egypt\", 200) // 从sync.Map中根据键取值 fmt.Println(scene.Load(\"london\")) // 根据键删除对应的键值对 scene.Delete(\"london\") // 遍历所有sync.Map中的键值对 scene.Range(func(k, v interface&#123;&#125;) bool &#123; fmt.Println(\"iterate:\", k, v) return true &#125;)&#125; 代码输出如下： 123100 trueiterate: egypt 200iterate: greece 97 代码说明如下： 第 10 行，声明 scene，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。 第 13～15 行，将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。 第 18 行，提供一个 sync.Map 的键给 scene.Load() 方法后将查询到键对应的值返回。 第 21 行，sync.Map 的 Delete 可以使用指定的键将对应的键值对删除。 第 24 行，Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。 sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"18、Go语言 之map元素删除","slug":"Golang/18、Go语言 之map元素删除","date":"2016-01-17T21:33:25.000Z","updated":"2020-08-07T14:10:11.744Z","comments":true,"path":"2016/01/18/Golang/18、Go语言 之map元素删除/","link":"","permalink":"https://www.zackaddy.xin/2016/01/18/Golang/18、Go语言 之map元素删除/","excerpt":"","text":"Go语言 之map元素删除 Go语言提供了一个内置函数 delete()，用于删除容器内的元素，下面我们简单介绍一下如何用 delete() 函数删除 map 内的元素。 使用 delete() 函数从 map 中删除键值对使用 delete() 内建函数从 map 中删除一组键值对，delete() 函数的格式如下： 1delete(map, 键) 其中 map 为要删除的 map 实例，键为要删除的 map 中键值对的键。 从 map 中删除一组键值对可以通过下面的代码来完成： 123456789scene := make(map[string]int)// 准备map数据scene[\"route\"] = 66scene[\"brazil\"] = 4scene[\"china\"] = 960delete(scene, \"brazil\")for k, v := range scene &#123; fmt.Println(k, v)&#125; 代码输出如下： 12route 66china 960 这个例子中使用 delete() 函数将 brazil 从 scene 这个 map 中删除了。 清空 map 中的所有元素有意思的是，Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"17、Go语言 之map遍历","slug":"Golang/17、Go语言 之map遍历","date":"2016-01-16T21:42:56.000Z","updated":"2020-08-07T14:10:11.744Z","comments":true,"path":"2016/01/17/Golang/17、Go语言 之map遍历/","link":"","permalink":"https://www.zackaddy.xin/2016/01/17/Golang/17、Go语言 之map遍历/","excerpt":"","text":"Go语言 之map遍历map 的遍历过程使用 for range 循环完成，代码如下： 1234567scene := make(map[string]int)scene[\"route\"] = 66scene[\"brazil\"] = 4scene[\"china\"] = 960for k, v := range scene &#123; fmt.Println(k, v)&#125; 遍历对于Go语言的很多对象来说都是差不多的，直接使用 for range 语法即可，遍历时，可以同时获得键和值，如只遍历值，可以使用下面的形式： 1for _, v := range scene &#123; 将不需要的键使用_改为匿名变量形式。 只遍历键时，使用下面的形式： 1for k := range scene &#123; 无须将值改为匿名变量形式，忽略值即可。注意：遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。 如果需要特定顺序的遍历结果，正确的做法是先排序，代码如下： 1234567891011121314151617scene := make(map[string]int)// 准备map数据scene[\"route\"] = 66scene[\"brazil\"] = 4scene[\"china\"] = 960// 声明一个切片保存map数据var sceneList []string// 将map数据遍历复制到切片中for k := range scene &#123; sceneList = append(sceneList, k)&#125;// 对切片进行排序sort.Strings(sceneList)// 输出fmt.Println(sceneList)代码输出如下：[brazil china route] 代码说明如下： 第 1 行，创建一个 map 实例，键为字符串，值为整型。 第 4～6 行，将 3 个键值对写入 map 中。 第 9 行，声明 sceneList 为字符串切片，以缓冲和排序 map 中的所有元素。 第 12 行，将 map 中元素的键遍历出来，并放入切片中。 第 17 行，对 sceneList 字符串切片进行排序，排序时，sceneList 会被修改。 第 20 行，输出排好序的 map 的键。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"16、Go语言 之map","slug":"Golang/16、Go语言 之map","date":"2016-01-16T00:16:20.000Z","updated":"2020-08-07T14:10:11.744Z","comments":true,"path":"2016/01/16/Golang/16、Go语言 之map/","link":"","permalink":"https://www.zackaddy.xin/2016/01/16/Golang/16、Go语言 之map/","excerpt":"","text":"Go语言 之map Go语言中 map 是一种特殊的数据结构，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value。 map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。 map 概念map 是引用类型，可以使用如下方式声明： 1var mapname map[keytype]valuetype 其中： mapname 为 map 的变量名。 keytype 为键类型。 valuetype 是键对应的值类型。提示：[keytype] 和 valuetype 之间允许有空格。 在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目。 【示例】 1234567891011121314151617package mainimport \"fmt\"func main() &#123; var mapLit map[string]int //var mapCreated map[string]float32 var mapAssigned map[string]int mapLit = map[string]int&#123;\"one\": 1, \"two\": 2&#125; mapCreated := make(map[string]float32) mapAssigned = mapLit mapCreated[\"key1\"] = 4.5 mapCreated[\"key2\"] = 3.14159 mapAssigned[\"two\"] = 3 fmt.Printf(\"Map literal at \\\"one\\\" is: %d\\n\", mapLit[\"one\"]) fmt.Printf(\"Map created at \\\"key2\\\" is: %f\\n\", mapCreated[\"key2\"]) fmt.Printf(\"Map assigned at \\\"two\\\" is: %d\\n\", mapLit[\"two\"]) fmt.Printf(\"Map literal at \\\"ten\\\" is: %d\\n\", mapLit[\"ten\"])&#125; 输出结果： 1234Map literal at \"one\" is: 1Map created at \"key2\" is: 3.14159Map assigned at \"two\" is: 3Map literal at \"ten\" is: 0 示例中 mapLit 演示了使用{key1: value1, key2: value2}的格式来初始化 map ，就像数组和结构体一样。 上面代码中的 mapCreated 的创建方式mapCreated := make(map[string]float)等价于mapCreated := map[string]float{} 。 mapAssigned 是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。 注意：可以使用 make()，但不能使用 new() 来构造 map，如果错误的使用 new() 分配了一个引用对象，会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址： 1mapCreated := new(map[string]float) 接下来当我们调用mapCreated[“key1”] = 4.5的时候，编译器会报错：invalid operation: mapCreated[“key1”] (index of type *map[string]float). map 容量和数组不同，map 可以根据新增的 key-value 动态的伸缩，因此它不存在固定长度或者最大限制，但是也可以选择标明 map 的初始容量 capacity，格式如下： 1make(map[keytype]valuetype, cap) 例如： 1map2 := make(map[string]float, 100) 当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。 这里有一个 map 的具体例子，即将音阶和对应的音频映射起来： 123noteFrequency := map[string]float32 &#123;\"C0\": 16.35, \"D0\": 18.35, \"E0\": 20.60, \"F0\": 21.83,\"G0\": 24.50, \"A0\": 27.50, \"B0\": 30.87, \"A4\": 440&#125; 用切片作为 map 的值既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题，示例代码如下所示： 12mp1 := make(map[int][]int)mp2 := make(map[int]*[]int) map取值返回两个值123456var skill = map[string]int&#123; \"fire\": 1, \"run\": 2, &#125; f, ok := skill[\"run\"] fmt.Println(f, ok) // 2 true 123456var skill = map[string]int&#123; \"fire\": 1, \"run\": 2, &#125; f, ok := skill[\"x\"] fmt.Println(f, ok) // 0 false","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"15、Go语言 之多维切片","slug":"Golang/15、Go语言 之多维切片","date":"2016-01-14T23:08:02.000Z","updated":"2020-08-07T14:10:11.743Z","comments":true,"path":"2016/01/15/Golang/15、Go语言 之多维切片/","link":"","permalink":"https://www.zackaddy.xin/2016/01/15/Golang/15、Go语言 之多维切片/","excerpt":"","text":"Go语言 之多维切片 Go语言中同样允许使用多维切片，声明一个多维数组的语法格式如下： 1var sliceName [][]...[]sliceType 其中，sliceName 为切片的名字，sliceType为切片的类型，每个[ ]代表着一个维度，切片有几个维度就需要几个[ ]。 下面以二维切片为例，声明一个二维切片并赋值，代码如下所示。 1234567//声明一个二维切片var slice [][]int//为二维切片赋值slice = [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;上面的代码也可以简写为下面的样子。// 声明一个二维整型切片并赋值slice := [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125; 上面的代码中展示了一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片 【示例】组合切片的切片 1234// 声明一个二维整型切片并赋值slice := [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;// 为第一个切片追加值为 20 的元素slice[0] = append(slice[0], 20) Go语言里使用 append() 函数处理追加的方式很简明，先增长切片，再将新的整型切片赋值给外层切片的第一个元素，当上面代码中的操作完成后，再将切片复制到外层切片的索引为 0 的元素","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"14、Go语言 之切片迭代","slug":"Golang/14、Go语言 之切片迭代","date":"2016-01-13T19:03:33.000Z","updated":"2020-08-07T14:10:11.743Z","comments":true,"path":"2016/01/14/Golang/14、Go语言 之切片迭代/","link":"","permalink":"https://www.zackaddy.xin/2016/01/14/Golang/14、Go语言 之切片迭代/","excerpt":"","text":"Go语言 之切片迭代 Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素 如下所示： 123456// 创建一个整型切片，并赋值slice := []int&#123;10, 20, 30, 40&#125;// 迭代每一个元素，并显示其值for index, value := range slice &#123; fmt.Printf(\"Index: %d Value: %d\\n\", index, value)&#125; 第 4 行中的 index 和 value 分别用来接收 range 关键字返回的切片中每个元素的索引和值，这里的 index 和 value 不是固定的，读者也可以定义成其它的名字。 上面代码的输出结果为： 1234Index: 0 Value: 10Index: 1 Value: 20Index: 2 Value: 30Index: 3 Value: 40 当迭代切片时，关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本，如下图所示。 使用 range 迭代切片会创建每个元素的副本图：使用 range 迭代切片会创建每个元素的副本 需要强调的是，range 返回的是每个元素的副本，而不是直接返回对该元素的引用，如下所示。 【示例 1】range 提供了每个元素的副本 123456// 创建一个整型切片，并赋值slice := []int&#123;10, 20, 30, 40&#125;// 迭代每个元素，并显示值和地址for index, value := range slice &#123; fmt.Printf(\"Value: %d Value-Addr: %X ElemAddr: %X\\n\", value, &amp;value, &amp;slice[index])&#125; 输出结果为： 1234Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C 因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &amp;slice[index]）。 如果不需要索引值，也可以使用下划线_来忽略这个值，代码如下所示。 【示例 2】使用空白标识符（下划线）来忽略索引值 123456// 创建一个整型切片，并赋值slice := []int&#123;10, 20, 30, 40&#125;// 迭代每个元素，并显示其值for _, value := range slice &#123; fmt.Printf(\"Value: %d\\n\", value)&#125; 输出结果为： 1234Value: 10Value: 20Value: 30Value: 40 关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环，代码如下所示。 【示例 3】使用传统的 for 循环对切片进行迭代 123456// 创建一个整型切片，并赋值slice := []int&#123;10, 20, 30, 40&#125;// 从第三个元素开始迭代每个元素for index := 2; index &lt; len(slice); index++ &#123; fmt.Printf(\"Index: %d Value: %d\\n\", index, slice[index])&#125; 输出结果为： 12Index: 2 Value: 30Index: 3 Value: 40 在前面几节的学习中我们了解了两个特殊的内置函数 len() 和 cap()，可以用于处理数组、切片和通道，对于切片，函数 len() 可以返回切片的长度，函数 cap() 可以返回切片的容量，在上面的示例中，使用到了函数 len() 来控制循环迭代的次数。 当然，range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等，这些我们将在后面的学习中详细介绍。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"13、Go语言 之切片删除","slug":"Golang/13、Go语言 之切片删除","date":"2016-01-12T16:08:31.000Z","updated":"2020-08-07T14:10:11.743Z","comments":true,"path":"2016/01/13/Golang/13、Go语言 之切片删除/","link":"","permalink":"https://www.zackaddy.xin/2016/01/13/Golang/13、Go语言 之切片删除/","excerpt":"","text":"Go语言 之切片删除 Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。 从开头位置删除删除开头的元素可以直接移动数据指针： 123a = []int&#123;1, 2, 3&#125;a = a[1:] // 删除开头1个元素a = a[N:] // 删除开头N个元素 也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）： 123a = []int&#123;1, 2, 3&#125;a = append(a[:0], a[1:]...) // 删除开头1个元素a = append(a[:0], a[N:]...) // 删除开头N个元素 还可以用 copy() 函数来删除开头的元素： 123a = []int&#123;1, 2, 3&#125;a = a[:copy(a, a[1:])] // 删除开头1个元素a = a[:copy(a, a[N:])] // 删除开头N个元素 从中间位置删除对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成： 12345a = []int&#123;1, 2, 3, ...&#125;a = append(a[:i], a[i+1:]...) // 删除中间1个元素a = append(a[:i], a[i+N:]...) // 删除中间N个元素a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素 从尾部删除123a = []int&#123;1, 2, 3&#125;a = a[:len(a)-1] // 删除尾部1个元素a = a[:len(a)-N] // 删除尾部N个元素 删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。 【示例】删除切片指定位置的元素。 123456789101112package mainimport \"fmt\"func main() &#123; seq := []string&#123;\"a\", \"b\", \"c\", \"d\", \"e\"&#125; // 指定删除位置 index := 2 // 查看删除位置之前的元素和之后的元素 fmt.Println(seq[:index], seq[index+1:]) // 将删除点前后的元素连接起来 seq = append(seq[:index], seq[index+1:]...) fmt.Println(seq)&#125; 代码输出结果： 12[a b] [d e][a b d e] 代码说明如下： 第 1 行，声明一个整型切片，保存含有从 a 到 e 的字符串。 第 4 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。 第 7 行，seq[:index] 表示的就是被删除元素的前半部分，值为 [1 2]，seq[index+1:] 表示的是被删除元素的后半部分，值为 [4 5]。 第 10 行，使用 append() 函数将两个切片连接起来。 第 12 行，输出连接好的新切片，此时，索引为 2 的元素已经被删除。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"12、Go语言 之切片复制","slug":"Golang/12、Go语言 之切片复制","date":"2016-01-12T00:13:46.000Z","updated":"2020-08-07T14:10:11.743Z","comments":true,"path":"2016/01/12/Golang/12、Go语言 之切片复制/","link":"","permalink":"https://www.zackaddy.xin/2016/01/12/Golang/12、Go语言 之切片复制/","excerpt":"","text":"Go语言 之切片复制 内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。 copy() 函数的使用格式如下： 1copy( destSlice, srcSlice []T) int 其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。 下面的代码展示了使用 copy() 函数将一个切片复制到另一个切片的过程： 1234slice1 := []int&#123;1, 2, 3, 4, 5&#125;slice2 := []int&#123;5, 4, 3&#125;copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题。 【示例】通过代码演示对切片的引用和复制操作后对切片元素的影响。 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() &#123; // 设置元素数量为1000 const elementCount = 1000 // 预分配足够多的元素切片 srcData := make([]int, elementCount) // 将切片赋值 for i := 0; i &lt; elementCount; i++ &#123; srcData[i] = i &#125; // 引用切片数据 refData := srcData // 预分配足够多的元素切片 copyData := make([]int, elementCount) // 将数据复制到新的切片空间中 copy(copyData, srcData) // 修改原始数据的第一个元素 srcData[0] = 999 // 打印引用切片的第一个元素 fmt.Println(refData[0]) // 打印复制切片的第一个和最后一个元素 fmt.Println(copyData[0], copyData[elementCount-1]) // 复制原始数据从4到6(不包含) copy(copyData, srcData[4:6]) for i := 0; i &lt; 5; i++ &#123; fmt.Printf(\"%d \", copyData[i]) &#125;&#125; 代码说明如下： 第 8 行，定义元素总量为 1000。 第 11 行，预分配拥有 1000 个元素的整型切片，这个切片将作为原始数据。 第 14～16 行，将 srcData 填充 0～999 的整型值。 第 19 行，将 refData 引用 srcData，切片不会因为等号操作进行元素的复制。 第 22 行，预分配与 srcData 等大（大小相等）、同类型的切片 copyData。 第 24 行，使用 copy() 函数将原始数据复制到 copyData 切片空间中。 第 27 行，修改原始数据的第一个元素为 999。 第 30 行，引用数据的第一个元素将会发生变化。 第 33 行，打印复制数据的首位数据，由于数据是复制的，因此不会发生变化。 第 36 行，将 srcData 的局部数据复制到 copyData 中。 第 38～40 行，打印复制局部数据后的 copyData 元素。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"11、Go语言 之切片增加元素","slug":"Golang/11、Go语言 之切片增加元素","date":"2016-01-11T03:57:12.000Z","updated":"2020-08-07T14:10:11.743Z","comments":true,"path":"2016/01/11/Golang/11、Go语言 之切片增加元素/","link":"","permalink":"https://www.zackaddy.xin/2016/01/11/Golang/11、Go语言 之切片增加元素/","excerpt":"","text":"Go语言 之切片增加元素 内建函数 append() 可以为切片动态添加元素 1234var a []inta = append(a, 1) // 追加1个元素a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式a = append(a, []int&#123;1,2,3&#125;...) // 追加一个切片, 切片需要解包 不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。 切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下： 12345var numbers []intfor i := 0; i &lt; 10; i++ &#123; numbers = append(numbers, i) fmt.Printf(\"len: %d cap: %d pointer: %p\\n\", len(numbers), cap(numbers), numbers)&#125; 代码输出如下： 12345678910len: 1 cap: 1 pointer: 0xc0420080e8len: 2 cap: 2 pointer: 0xc042008150len: 3 cap: 4 pointer: 0xc04200e320len: 4 cap: 4 pointer: 0xc04200e320len: 5 cap: 8 pointer: 0xc04200c200len: 6 cap: 8 pointer: 0xc04200c200len: 7 cap: 8 pointer: 0xc04200c200len: 8 cap: 8 pointer: 0xc04200c200len: 9 cap: 16 pointer: 0xc042074000len: 10 cap: 16 pointer: 0xc042074000 代码说明如下： 第 1 行，声明一个整型切片。 第 4 行，循环向 numbers 切片中添加 10 个数。 第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。 通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。 往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。 员工和工位就是切片中的元素。 办公地就是分配好的内存。 搬家就是重新分配内存。 无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。 由于搬家后地址发生变化，因此内存“地址”也会有修改。 除了在切片的尾部追加，我们还可以在切片的开头添加元素： 123var a = []int&#123;1,2,3&#125;a = append([]int&#123;0&#125;, a...) // 在开头添加1个元素a = append([]int&#123;-3,-2,-1&#125;, a...) // 在开头添加1个切片 在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。 因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素： 123var a []inta = append(a[:i], append([]int&#123;x&#125;, a[i:]...)...) // 在第i个位置插入xa = append(a[:i], append([]int&#123;1,2,3&#125;, a[i:]...)...) // 在第i个位置插入切片 每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"10、Go语言 之切片","slug":"Golang/10、Go语言 之切片","date":"2016-01-10T02:57:44.000Z","updated":"2020-08-07T14:10:11.742Z","comments":true,"path":"2016/01/10/Golang/10、Go语言 之切片/","link":"","permalink":"https://www.zackaddy.xin/2016/01/10/Golang/10、Go语言 之切片/","excerpt":"","text":"Go语言 之切片从数组或切片生成新的切片切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。 从连续内存区域生成切片是常见的操作，格式如下： 1slice [开始位置 : 结束位置] 语法说明如下： slice：表示目标切片对象； 开始位置：对应目标切片对象的索引； 结束位置：对应目标切片的结束索引。 从数组生成切片，代码如下： 12var a = [3]int&#123;1, 2, 3&#125;fmt.Println(a, a[1:2]) 其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下： 1[1 2 3] [2] 其中 [2] 就是 a[1:2] 切片操作的结果。 从数组或切片生成新的切片拥有如下特性： 取出的元素数量为：结束位置 - 开始位置； 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取； 当缺省开始位置时，表示从连续区域开头到结束位置； 当缺省结束位置时，表示从开始位置到整个连续区域末尾； 两者同时缺省时，与切片本身等效； 两者同时为 0 时，等效于空切片，一般用于切片复位。 根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。 下面通过实例来熟悉切片的特性。 1) 从指定范围中生成切片切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下： 1234567891011121314var highRiseBuilding [30]intfor i := 0; i &lt; 30; i++ &#123; highRiseBuilding[i] = i + 1&#125;// 区间fmt.Println(highRiseBuilding[10:15])// 中间到尾部的所有元素fmt.Println(highRiseBuilding[20:])// 开头到中间指定位置的所有元素fmt.Println(highRiseBuilding[:2])代码输出如下：[11 12 13 14 15][21 22 23 24 25 26 27 28 29 30][1 2] 代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。 代码说明如下： 第 8 行，尝试出租一个区间楼层。 第 11 行，出租 20 层以上。 第 14 行，出租 2 层以下，一般是商用铺面。 切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。2) 表示原有的切片生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下： 12a := []int&#123;1, 2, 3&#125;fmt.Println(a[:]) a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下： 1[1 2 3] 3) 重置切片，清空拥有的元素把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下： 12a := []int&#123;1, 2, 3&#125;fmt.Println(a[0:0]) 代码输出如下： 1[] 直接声明新的切片除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下： 1var name []Type 其中 name 表示切片的变量名，Type 表示切片对应的元素类型。 下面代码展示了切片声明的使用过程： 1234567891011121314// 声明字符串切片var strList []string// 声明整型切片var numList []int// 声明一个空切片var numListEmpty = []int&#123;&#125;// 输出3个切片fmt.Println(strList, numList, numListEmpty)// 输出3个切片大小fmt.Println(len(strList), len(numList), len(numListEmpty))// 切片判定空的结果fmt.Println(strList == nil)fmt.Println(numList == nil)fmt.Println(numListEmpty == nil) 代码输出结果： 12345[] [] []0 0 0truetruefalse 代码说明如下： 第 2 行，声明一个字符串切片，切片中拥有多个字符串。 第 5 行，声明一个整型切片，切片中拥有多个整型数值。 第 8 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。 第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。 第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。 第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。 第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。 切片是动态结构，只能与 nil 判定相等，不能互相判定相等。 声明新的切片后，可以使用 append() 函数向切片中添加元素。使用 make() 函数构造切片如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：make( []Type, size, cap ) 其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。 示例如下： 1234a := make([]int, 2)b := make([]int, 2, 10)fmt.Println(a, b)fmt.Println(len(a), len(b)) 代码输出如下： 12[0 0] [0 0]2 2 其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。 容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。 温馨提示 使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"9、Go语言 之多为数组","slug":"Golang/9、Go语言 之多为数组","date":"2016-01-08T21:14:28.000Z","updated":"2020-08-07T14:10:11.770Z","comments":true,"path":"2016/01/09/Golang/9、Go语言 之多为数组/","link":"","permalink":"https://www.zackaddy.xin/2016/01/09/Golang/9、Go语言 之多为数组/","excerpt":"","text":"Go语言 之多为数组 多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。 声明多维数组的语法如下所示： 1var array_name [size1][size2]...[sizen] array_type 其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。 二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。 【示例 1】声明二维数组 12345678// 声明一个二维整型数组，两个维度的长度分别是 4 和 2var array [4][2]int// 使用数组字面量来声明并初始化一个二维整型数组array = [4][2]int&#123;&#123;10, 11&#125;, &#123;20, 21&#125;, &#123;30, 31&#125;, &#123;40, 41&#125;&#125;// 声明并初始化数组中索引为 1 和 3 的元素array = [4][2]int&#123;1: &#123;20, 21&#125;, 3: &#123;40, 41&#125;&#125;// 声明并初始化数组中指定的元素array = [4][2]int&#123;1: &#123;0: 20&#125;, 3: &#123;1: 41&#125;&#125; 二维数组及其外层数组和内层数组的值图：二维数组及其外层数组和内层数组的值 为了访问单个元素，需要反复组合使用[ ]方括号，如下所示。 【示例 2】为二维数组的每个元素赋值 1234567// 声明一个 2×2 的二维整型数组var array [2][2]int// 设置每个元素的整型值array[0][0] = 10array[0][1] = 20array[1][0] = 30array[1][1] = 40 只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。 【示例 3】同样类型的多维数组赋值 12345678910// 声明两个二维整型数组var array1 [2][2]intvar array2 [2][2]int// 为array2的每个元素赋值array2[0][0] = 10array2[0][1] = 20array2[1][0] = 30array2[1][1] = 40// 将 array2 的值复制给 array1array1 = array2 因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。 【示例 4】使用索引为多维数组赋值 1234// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里var array3 [2]int = array1[1]// 将数组中指定的整型值复制到新的整型变量里var value int = array1[1][0]","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"8、Go语言 之数组","slug":"Golang/8、Go语言 之数组","date":"2016-01-08T04:52:59.000Z","updated":"2020-08-07T14:10:11.767Z","comments":true,"path":"2016/01/08/Golang/8、Go语言 之数组/","link":"","permalink":"https://www.zackaddy.xin/2016/01/08/Golang/8、Go语言 之数组/","excerpt":"","text":"Go语言 之数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。 Go语言数组的声明数组的声明语法如下： 1var 数组变量名 [元素数量]Type 语法说明如下所示： 数组变量名：数组声明及使用时的变量名。 元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。 Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。 数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。 1234567891011var a [3]int // 定义三个整数的数组fmt.Println(a[0]) // 打印第一个元素fmt.Println(a[len(a)-1]) // 打印最后一个元素// 打印索引和元素for i, v := range a &#123; fmt.Printf(\"%d %d\\n\", i, v)&#125;// 仅打印元素for _, v := range a &#123; fmt.Printf(\"%d\\n\", v)&#125; 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组： 1234var p [3]int = [...]int&#123;1, 2, 3&#125;var q [3]int = [3]int&#123;1, 2, 3&#125;var r [3]int = [3]int&#123;1, 2&#125;fmt.Println(r[2]) // \"0\" 在数组的定义中，如果在数组长度的位置出现“…”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为： 12q := [...]int&#123;1, 2, 3&#125;fmt.Printf(\"%T\\n\", q) // \"[3]int\" 数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 12q := [3]int&#123;1, 2, 3&#125;q = [4]int&#123;1, 2, 3, 4&#125; // 编译错误：无法将 [4]int 赋给 [3]int 比较两个数组是否相等如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（== 和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。 123456a := [2]int&#123;1, 2&#125;b := [...]int&#123;1, 2&#125;c := [2]int&#123;1, 3&#125;fmt.Println(a == b, a == c, b == c) // \"true false false\"d := [3]int&#123;1, 2&#125;fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int 遍历数组——访问每一个数组元素遍历数组也和遍历切片类似，代码如下所示： 1234567var team [3]stringteam[0] = \"hammer\"team[1] = \"soldier\"team[2] = \"mum\"for k, v := range team &#123; fmt.Println(k, v)&#125; 代码输出结果： 1230 hammer1 soldier2 mum 代码说明如下： 第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。 第 7 行，将每个键值打印出来。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"7、Go语言 之字符串和数值类型的相互转换","slug":"Golang/7、Go语言 之字符串和数值类型的相互转换","date":"2016-01-07T03:00:49.000Z","updated":"2020-08-07T14:10:11.764Z","comments":true,"path":"2016/01/07/Golang/7、Go语言 之字符串和数值类型的相互转换/","link":"","permalink":"https://www.zackaddy.xin/2016/01/07/Golang/7、Go语言 之字符串和数值类型的相互转换/","excerpt":"","text":"Go语言 之字符串和数值类型的相互转换 strconv 包为我们提供了字符串和基本数据类型之间的转换功能。 strconv 包中常用的函数包括 Atoi()、Itia()、parse 系列函数、format 系列函数、append 系列函数等，下面就来分别介绍一下。string 与 int 类型之间的转换字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。 Itoa()：整型转字符串Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。func Itoa(i int) string 示例代码如下： 12345func main() &#123; num := 100 str := strconv.Itoa(num) fmt.Printf(\"type:%T value:%#v\\n\", str, str)&#125; 运行结果如下所示： 1type:string value:\"100\" Atoi()：字符串转整型Atoi() 函数用于将字符串类型的整数转换为 int 类型，函数签名如下。func Atoi(s string) (i int, err error) 通过函数签名可以看出 Atoi() 函数有两个返回值，i 为转换成功的整型，err 在转换成功是为空转换失败时为相应的错误信息。 示例代码如下： 12345678910111213141516func main() &#123; str1 := \"110\" str2 := \"s100\" num1, err := strconv.Atoi(str1) if err != nil &#123; fmt.Printf(\"%v 转换失败！\", str1) &#125; else &#123; fmt.Printf(\"type:%T value:%#v\\n\", num1, num1) &#125; num2, err := strconv.Atoi(str2) if err != nil &#123; fmt.Printf(\"%v 转换失败！\", str2) &#125; else &#123; fmt.Printf(\"type:%T value:%#v\\n\", num2, num2) &#125;&#125; 运行结果如下所示： 12type:int value:110s100 转换失败！ Parse 系列函数Parse 系列函数用于将字符串转换为指定类型的值，其中包括 ParseBool()、ParseFloat()、ParseInt()、ParseUint()。 ParseBool()ParseBool() 函数用于将字符串转换为 bool 类型的值，它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误，函数签名如下。func ParseBool(str string) (value bool, err error) 示例代码如下： 12345678910111213141516func main() &#123; str1 := \"110\" boo1, err := strconv.ParseBool(str1) if err != nil &#123; fmt.Printf(\"str1: %v\\n\", err) &#125; else &#123; fmt.Println(boo1) &#125; str2 := \"t\" boo2, err := strconv.ParseBool(str2) if err != nil &#123; fmt.Printf(\"str2: %v\\n\", err) &#125; else &#123; fmt.Println(boo2) &#125;&#125; 运行结果如下： 12str1: strconv.ParseBool: parsing \"110\": invalid syntaxtrue ParseInt()ParseInt() 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下： 1func ParseInt(s string, base int, bitSize int) (i int64, err error) 参数说明： base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。 bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。 返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。 示例代码如下： 123456789func main() &#123; str := \"-11\" num, err := strconv.ParseInt(str, 10, 0) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(num) &#125;&#125; 运行结果如下： 1-11 ParseUnit()ParseUint() 函数的功能类似于 ParseInt() 函数，但 ParseUint() 函数不接受正负号，用于无符号整型，函数签名如下： 1func ParseUint(s string, base int, bitSize int) (n uint64, err error) 示例代码如下： 123456789func main() &#123; str := \"11\" num, err := strconv.ParseUint(str, 10, 0) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(num) &#125;&#125; 运行结果如下： 111 ParseFloat()ParseFloat() 函数用于将一个表示浮点数的字符串转换为 float 类型，函数签名如下。 1func ParseFloat(s string, bitSize int) (f float64, err error) 参数说明： 如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。 bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64； 返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。 示例代码如下： 123456789func main() &#123; str := \"3.1415926\" num, err := strconv.ParseFloat(str, 64) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(num) &#125;&#125; 运行结果如下： 13.1415926 Parse 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。 Format 系列函数 Format 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 FormatBool()、FormatInt()、FormatUint()、FormatFloat()。 FormatBool()FormatBool() 函数可以一个 bool 类型的值转换为对应的字符串类型，函数签名如下。 1func FormatBool(b bool) string 示例代码如下： 12345func main() &#123; num := true str := strconv.FormatBool(num) fmt.Printf(\"type:%T,value:%v\\n \", str, str)&#125; 运行结果如下： 1type:string,value:true FormatInt()FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下： 1func FormatInt(i int64, base int) string 其中，参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。 示例代码如下： 12345func main() &#123; var num int64 = 100 str := strconv.FormatInt(num, 16) fmt.Printf(\"type:%T,value:%v\\n \", str, str)&#125; 运行结果如下： 1type:string,value:64 FormatUint()FormatUint() 函数与 FormatInt() 函数的功能类似，但是参数 i 必须是无符号的 uint64 类型，函数签名如下。 1func FormatUint(i uint64, base int) string 示例代码如下： 12345func main() &#123; var num uint64 = 110 str := strconv.FormatUint(num, 16) fmt.Printf(\"type:%T,value:%v\\n \", str, str)&#125; 运行结果如下： 1type:string,value:6e FormatFloat()FormatFloat() 函数用于将浮点数转换为字符串类型，函数签名如下： 1func FormatFloat(f float64, fmt byte, prec, bitSize int) string 参数说明： bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。 fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。 prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。 示例代码如下： 12345func main() &#123; var num float64 = 3.1415926 str := strconv.FormatFloat(num, 'E', -1, 64) fmt.Printf(\"type:%T,value:%v\\n \", str, str)&#125; 运行结果如下： 1type:string,value:3.1415926E+00 Append 系列函数Append 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 AppendBool()、AppendFloat()、AppendInt()、AppendUint()。 Append 系列函数和 Format 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。 示例代码如下： 12345678910111213141516package mainimport ( \"fmt\" \"strconv\")func main() &#123; // 声明一个slice b10 := []byte(\"int (base 10):\") // 将转换为10进制的string，追加到slice中 b10 = strconv.AppendInt(b10, -42, 10) fmt.Println(string(b10)) b16 := []byte(\"int (base 16):\") b16 = strconv.AppendInt(b16, -42, 16) fmt.Println(string(b16))&#125; 运行结果如下： 12int (base 10):-42int (base 16):-2a","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"6、Go语言 之模拟枚举","slug":"Golang/6、Go语言 之模拟枚举","date":"2016-01-05T17:16:45.000Z","updated":"2020-08-07T14:10:11.761Z","comments":true,"path":"2016/01/06/Golang/6、Go语言 之模拟枚举/","link":"","permalink":"https://www.zackaddy.xin/2016/01/06/Golang/6、Go语言 之模拟枚举/","excerpt":"","text":"Go语言 之模拟枚举12345678910111213type Weapon intconst ( Arrow Weapon = iota // 开始生成枚举值, 默认为0 Shuriken SniperRifle Rifle Blower)// 输出所有枚举值fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)// 使用枚举类型并赋初值var weapon Weapon = Blowerfmt.Println(weapon) 代码输出如下： 120 1 2 3 44 代码说明如下：第 1 行中，将 int 定义为 Weapon 类型，就像枚举类型的本质是一个 int 类型一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。 第 4 行中，将常量 Arrow 的类型标识为 Weapon，这样标识后，const 下方的常量可以使用 Weapon 作为默认类型。该行使用 iota 进行常量值自动生成，iota 的起始值为 0，一般情况下也是建议枚举从 0 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。 一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。 当然，iota 不仅可以生成每次增加 1 的枚举值。还可以利用 iota 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量： 12345678const ( FlagNone = 1 &lt;&lt; iota FlagRed FlagGreen FlagBlue)fmt.Printf(\"%d %d %d\\n\", FlagRed, FlagGreen, FlagBlue)fmt.Printf(\"%b %b %b\\n\", FlagRed, FlagGreen, FlagBlue) 代码输出如下： 122 4 810 100 1000 在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 ioto 自动生成更加方便。 代码说明如下：第 2 行中 iota 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。第 8 行，将 3 个枚举按照常量输出，分别输出 2、4、8，都是将 1 每次左移一位的结果。第 9 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。将枚举值转换为字符串枚举在 C# 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，C# 中 Week 枚举值 Monday 为 1，那么可以通过 Week.Monday.ToString() 函数获得 Monday 字符串。 Go语言中也可以实现这一功能，代码如下所示： 12345678910111213141516171819202122232425转换字符串：package mainimport \"fmt\"// 声明芯片类型type ChipType intconst ( None ChipType = iota CPU // 中央处理器 GPU // 图形处理器)func (c ChipType) String() string &#123; switch c &#123; case None: return \"None\" case CPU: return \"CPU\" case GPU: return \"GPU\" &#125; return \"N/A\"&#125;func main() &#123; // 输出CPU的值并以整型格式显示 fmt.Printf(\"%s %d\", CPU, CPU)&#125; 运行结果： 1CPU 1 代码说明如下： 第 6 行，将 int 声明为 ChipType 芯片类型。 第 9 行，将 const 里定义的常量值设为 ChipType 类型，且从 0 开始，每行值加 1。 第 14 行，定义 ChipType 类型的方法 String()，返回值为字符串类型。 第 15～22 行，使用 switch 语句判断当前的 ChitType 类型的值，返回对应的字符串。 第 30 行，按整型的格式输出 CPU 的值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"5、Go语言 之常量","slug":"Golang/5、Go语言 之常量","date":"2016-01-04T16:01:08.000Z","updated":"2020-08-07T14:10:11.757Z","comments":true,"path":"2016/01/05/Golang/5、Go语言 之常量/","link":"","permalink":"https://www.zackaddy.xin/2016/01/05/Golang/5、Go语言 之常量/","excerpt":"","text":"Go语言 之常量常量的定义格式和变量的声明语法类似：const name [type] = value，例如： 1const pi = 3.14159 // 相当于 math.Pi 的近似值 在Go语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = “abc” 隐式类型定义： const b = “abc” 常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。 正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() 用做值 和变量声明一样，可以批量声明多个常量：纯文本复制 1234const ( e = 2.7182818 pi = 3.1415926) 所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex 和 unsafe.Sizeof。 因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度： 123456const IPv4Len = 4// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).func parseIPv4(s string) IP &#123; var p [IPv4Len]byte // ...&#125; 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，time.Duration 是一个命名类型，底层类型是 int64，time.Minute 是对应类型的常量。下面声明的两个常量都是 time.Duration 类型，可以通过 %T 参数打印类型信息： 12345const noDelay time.Duration = 0const timeout = 5 * time.Minutefmt.Printf(\"%T %[1]v\\n\", noDelay) // \"time.Duration 0\"fmt.Printf(\"%T %[1]v\\n\", timeout) // \"time.Duration 5m0s\"fmt.Printf(\"%T %[1]v\\n\", time.Minute) // \"time.Duration 1m0s\" 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如： 1234567const ( a = 1 b c = 2 d)fmt.Println(a, b, c, d) // \"1 1 2 2\" 如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 iota 常量生成器语法。 iota 常量生成器常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。 【示例 1】首先定义一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始。在其它编程语言中，这种类型一般被称为枚举类型。 12345678910type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday) 周日将对应 0，周一为 1，以此类推。无类型常量Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 int 或 float64，或者是类似 time.Duration 这样的基础类型，但是许多常量并没有一个明确的基础类型。 编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。 【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi 如果 math.Pi 被确定为特定类型，比如 float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要一个明确的强制类型转换： 1234const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \\u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"4、Go语言 之指针","slug":"Golang/4、Go语言 之指针","date":"2016-01-03T21:18:44.000Z","updated":"2020-08-07T14:10:11.754Z","comments":true,"path":"2016/01/04/Golang/4、Go语言 之指针/","link":"","permalink":"https://www.zackaddy.xin/2016/01/04/Golang/4、Go语言 之指针/","excerpt":"","text":"Go语言 之指针认识指针地址和指针类型一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加&amp;操作符（前缀）来获取变量的内存地址（取地址操作），格式如下： 1ptr := &amp;v // v 的类型为 T 其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为T，称做 T 的指针类型，代表指针。 指针实际用法，可以通过下面的例子了解： 123456789package mainimport ( \"fmt\")func main() &#123; var cat int = 1 var str string = \"banana\" fmt.Printf(\"%p %p\", &amp;cat, &amp;str)&#125; 运行结果： 10xc042052088 0xc0420461b0 代码说明如下： 第 8 行，声明整型变量 cat。 第 9 行，声明字符串变量 str。 第 10 行，使用 fmt.Printf 的动词%p打印 cat 和 str 变量的内存地址，指针的值是带有0x十六进制前缀的一组数据。 提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。从指针获取指针指向的值当使用&amp;操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用*操作符，也就是指针取值，代码如下。 1234567891011121314151617181920package mainimport ( \"fmt\")func main() &#123; // 准备一个字符串类型 var house = \"Malibu Point 10880, 90265\" // 对字符串取地址, ptr类型为*string ptr := &amp;house // 打印ptr的类型 fmt.Printf(\"ptr type: %T\\n\", ptr) // 打印ptr的指针地址 fmt.Printf(\"address: %p\\n\", ptr) // 对指针进行取值操作 value := *ptr // 取值后的类型 fmt.Printf(\"value type: %T\\n\", value) // 指针取值后就是指向变量的值 fmt.Printf(\"value: %s\\n\", value)&#125; 运行结果： 1234ptr type: *stringaddress: 0xc0420401b0value type: stringvalue: Malibu Point 10880, 90265 代码说明如下： 第 10 行，准备一个字符串并赋值。 第 13 行，对字符串取地址，将指针保存到变量 ptr 中。 第 16 行，打印变量 ptr 的类型，其类型为 *string。 第 19 行，打印 ptr 的指针地址，地址每次运行都会发生变化。 第 22 行，对 ptr 指针变量进行取值操作，变量 value 的类型为 string。 第 25 行，打印取值后 value 的类型。 第 28 行，打印 value 的值。 取地址操作符&amp;和取值操作符是一对互补操作符，&amp;取出地址，根据地址取出地址指向的值。 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下： 对变量进行取地址操作使用&amp;操作符，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量的值。 使用指针修改值通过指针不仅可以取值，也可以修改值。 前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下： 12345678910111213141516171819package mainimport \"fmt\"// 交换函数func swap(a, b *int) &#123; // 取a指针的值, 赋给临时变量t t := *a // 取b指针的值, 赋给a指针指向的变量 *a = *b // 将a指针的值赋给b指针指向的变量 *b = t&#125;func main() &#123;// 准备两个变量, 赋值1和2 x, y := 1, 2 // 交换变量值 swap(&amp;x, &amp;y) // 输出变量值 fmt.Println(x, y)&#125; 运行结果： 12 1 代码说明如下： 第 6 行，定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。 第 9 行，取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。 第 12 行，取 b 的指针值，赋给指针 a 指向的变量。注意，此时*a的意思不是取 a 指针的值，而是“a 指向的变量”。 第 15 行，将 t 的值赋给指针 b 指向的变量。 第 21 行，准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。 第 24 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。 第 27 行，交换完毕时，输出 x 和 y 的值。 操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。 如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码： 12345678910package mainimport \"fmt\"func swap(a, b *int) &#123; b, a = a, b&#125;func main() &#123; x, y := 1, 2 swap(&amp;x, &amp;y) fmt.Println(x, y)&#125; 运行结果： 11 2 结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。示例：使用指针变量获取命令行的输入信息Go语言内置的 flag 包实现了对命令行参数的解析，flag 包使得开发命令行工具更为简单。 下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 flag 包的解析后即可获取命令行的数据。 【示例】获取命令行输入： 1234567891011121314package main// 导入系统包import ( \"flag\" \"fmt\")// 定义命令行参数var mode = flag.String(\"mode\", \"\", \"process mode\")func main() &#123; // 解析命令行参数 flag.Parse() // 输出命令行参数 fmt.Println(*mode)&#125; 将这段代码命名为 main.go，然后使用如下命令行运行： 1go run main.go --mode=fast 命令行输出结果如下： 1fast 代码说明如下： 第 10 行，通过 flag.String，定义一个 mode 变量，这个变量的类型是 *string。后面 3 个参数分别如下： 参数名称：在命令行输入参数时，使用这个名称。 参数值的默认值：与 flag 所使用的函数创建变量类型对应，String 对应字符串、Int 对应整型、Bool 对应布尔型等。 参数说明：使用 -help 时，会出现在说明中。 第 15 行，解析命令行参数，并将结果写入到变量 mode 中。 第 18 行，打印 mode 指针所指向的变量。 创建指针的另一种方法——new() 函数Go语言还提供了另外一种方法来创建指针变量，格式如下：new(类型) 一般这样写： 123str := new(string)*str = \"Go语言教程\"fmt.Println(*str) new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"3、Go语言 之数据类型转换","slug":"Golang/3、Go语言 之数据类型转换","date":"2016-01-02T20:17:56.000Z","updated":"2020-08-07T14:10:11.751Z","comments":true,"path":"2016/01/03/Golang/3、Go语言 之数据类型转换/","link":"","permalink":"https://www.zackaddy.xin/2016/01/03/Golang/3、Go语言 之数据类型转换/","excerpt":"","text":"Go语言 之数据类型转换 Go语言不存在隐式类型转换，所有的类型转换都必须显式的声明 示例12a := 5.0b := int(a) 类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。 只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"math\")func main() &#123; // 输出各数值范围 fmt.Println(\"int8 range:\", math.MinInt8, math.MaxInt8) fmt.Println(\"int16 range:\", math.MinInt16, math.MaxInt16) fmt.Println(\"int32 range:\", math.MinInt32, math.MaxInt32) fmt.Println(\"int64 range:\", math.MinInt64, math.MaxInt64) // 初始化一个32位整型值 var a int32 = 1047483647 // 输出变量的十六进制形式和十进制值 fmt.Printf(\"int32: 0x%x %d\\n\", a, a) // 将a变量数值转换为十六进制, 发生数值截断 b := int16(a) // 输出变量的十六进制形式和十进制值 fmt.Printf(\"int16: 0x%x %d\\n\", b, b) // 将常量保存为float32类型 var c float32 = math.Pi // 转换为int类型, 浮点发生精度丢失 fmt.Println(int(c))&#125; 代码说明如下： 第 11～14 行，输出几个常见整型类型的数值范围。 第 17 行，声明 int32 类型的变量 a 并初始化。 第 19 行，使用 fmt.Printf 的%x动词将数值以十六进制格式输出，这一行输出 a 在转换前的 32 位的值。 第 22 行，将 a 的值转换为 int16 类型，也就是从 32 位有符号整型转换为 16 位有符号整型，由于 int16 类型的取值范围比 int32 类型的取值范围小，因此数值会进行截断（精度丢失）。 第 24 行，输出转换后的 a 变量值，也就是 b 的值，同样以十六进制和十进制两种方式进行打印。 第 27 行，math.Pi 是 math 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 math.Pi 被赋值到变量 c 中，因此类型为 float32。 第 29 行，将 float32 转换为 int 类型并输出。 代码输出如下： 1234567int8 range: -128 127int16 range: -32768 32767int32 range: -2147483648 2147483647int64 range: -9223372036854775808 9223372036854775807int32: 0x3e6f54ff 1047483647int16: 0x54ff 217593 根据输出结果，16 位有符号整型的范围是 -32768～32767，而变量 a 的值 1047483647 不在这个范围内。1047483647 对应的十六进制为 0x3e6f54ff，转为 int16 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 0x54ff，对应的十进制值为 21759。 浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"2、Go语言 之字符类型（byte和rune）","slug":"Golang/2、Go语言 之字符类型（byte和rune）","date":"2016-01-02T04:00:26.000Z","updated":"2020-08-07T14:10:11.748Z","comments":true,"path":"2016/01/02/Golang/2、Go语言 之字符类型（byte和rune）/","link":"","permalink":"https://www.zackaddy.xin/2016/01/02/Golang/2、Go语言 之字符类型（byte和rune）/","excerpt":"","text":"Go语言 之字符类型（byte和rune）字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。 Go语言的字符有以下两种：一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。 byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题，例如 var ch byte = ‘A’，字符使用单引号括起来。 在 ASCII 码表中，A 的值是 65，使用 16 进制表示则为 41，所以下面的写法是等效的： 1var ch byte = 65 或 var ch byte = '\\x41' //（\\x 总是紧跟着长度为 2 的 16 进制数） 另外一种可能的写法是\\后面紧跟着长度为 3 的八进制数，例如 \\377。 Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。 在书写 Unicode 字符时，需要在 16 进制数之前加上前缀\\u或者\\U。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则使用\\u前缀，如果需要使用到 8 个字节，则使用\\U前缀。 123456789101112var ch int = '\\u0041'var ch2 int = '\\u03B2'var ch3 int = '\\U00101234'fmt.Printf(\"%d - %d - %d\\n\", ch, ch2, ch3) // integerfmt.Printf(\"%c - %c - %c\\n\", ch, ch2, ch3) // characterfmt.Printf(\"%X - %X - %X\\n\", ch, ch2, ch3) // UTF-8 bytesfmt.Printf(\"%U - %U - %U\", ch, ch2, ch3) // UTF-8 code point输出：65 - 946 - 1053236A - β - r41 - 3B2 - 101234U+0041 - U+03B2 - U+101234 格式化说明符%c用于表示字符，当和字符配合使用时，%v或%d会输出用于表示该字符的整数，%U输出格式为 U+hhhh 的字符串。 Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 ch 代表字符）： 判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch)","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"1、Go语言 之变量","slug":"Golang/1、Go语言 之变量","date":"2016-01-01T01:57:08.000Z","updated":"2020-08-07T14:10:11.745Z","comments":true,"path":"2016/01/01/Golang/1、Go语言 之变量/","link":"","permalink":"https://www.zackaddy.xin/2016/01/01/Golang/1、Go语言 之变量/","excerpt":"","text":"Go语言 之变量介绍Go语言的基本类型有： 12345678boolstringint、int8、int16、int32、int64uint、uint8、uint16、uint32、uint64、uintptrbyte // uint8 的别名rune // int32 的别名 代表一个 Unicode 码float32、float64complex64、complex128 当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。 变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。 变量声明12var 变量名 变量类型var name type 变量初始化12var 变量名 类型 = 表达式var hp int = 100 批量声明123456789var ( a int b string c []float32 d func() bool e struct &#123; x int &#125;) 简短声明12345678名字 := 表达式i, j := 0, 1func main() &#123; x:=100 a,s:=1, \"abc\"&#125; 自动类型推导12345var attack = 40var defence = 20var damageRate float32 = 0.17var damage = float32(attack-defence) * damageRatefmt.Println(damage) 多重赋值1234var a int = 100var b int = 200b, a = a, bfmt.Println(a, b) 匿名变量12345678func GetData() (int, int) &#123; return 100, 200&#125;func main()&#123; a, _ := GetData() _, b := GetData() fmt.Println(a, b)&#125; 复数声明复数的语法格式如下所示： 1var name complex128 = complex(x, y) 其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。 上面的声明语句也可以简写为下面的形式： 1name := complex(x, y) 对于一个复数z := complex(x, y)，可以通过Go语言的内置函数real(z) 来获得该复数的实部，也就是 x；通过imag(z) 获得该复数的虚部，也就是 y。 【示例】使用内置的 complex 函数构建复数，并使用 real 和 imag 函数返回复数的实部和虚部： 12345var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y) // \"(-5+10i)\"fmt.Println(real(x*y)) // \"-5\"fmt.Println(imag(x*y)) // \"10\" 布尔类型错误用法 1234var b int = 1if !!b &#123; fmt.Printf(\"%d\\n\", 666)&#125; 字符串拼接123456str := \"Beginning of the string \" +\"second part of the string\"s := \"hel\" + \"lo,\"s += \"world!\"fmt.Println(s) //输出 “hello, world!” 定义多行字符串123456const str = `第一行第二行第三行\\r\\n`fmt.Println(str)","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/tags/Golang/"}],"keywords":[{"name":"Golang","slug":"Golang","permalink":"https://www.zackaddy.xin/categories/Golang/"}]},{"title":"51、js android ios互相调用","slug":"JavaScript/51、js android ios互相调用","date":"2015-06-06T17:11:03.000Z","updated":"2020-08-07T14:10:11.797Z","comments":true,"path":"2015/06/07/JavaScript/51、js android ios互相调用/","link":"","permalink":"https://www.zackaddy.xin/2015/06/07/JavaScript/51、js android ios互相调用/","excerpt":"","text":"js android ios互相调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const u = navigator.userAgent;const isAndroid = u.indexOf('Android') &gt; -1 || u.indexOf('Adr') &gt; -1;export function setupWebViewJavascriptBridge(callback) &#123; if (isAndroid) &#123; if (window.WebViewJavascriptBridge) &#123; callback(WebViewJavascriptBridge) &#125; else &#123; document.addEventListener( 'WebViewJavascriptBridgeReady', function () &#123; callback(WebViewJavascriptBridge) &#125;, false ); &#125; return void 0 &#125; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function () &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;export const webview = &#123; call(name, data, callback) &#123; setupWebViewJavascriptBridge(function (bridge) &#123; bridge.callHandler(name, data, callback); &#125;) &#125;, register(name, callback) &#123; setupWebViewJavascriptBridge(function (bridge) &#123; bridge.registerHandler(name, callback); &#125;) &#125;&#125;//注册原生调起方法//参数1： buttonjs 注册flag 供原生使用，要和原生统一//参数2： data 是原生传给js 的数据//参数3： responseCallback 是js 的回调，可以通过该方法给原生传数据// bridge.registerHandler(\"back\", function (data, responseCallback) &#123;// responseCallback(\"button js callback\");// &#125;);//参数1： pay 注册flag 供原生使用，要和原生统一//参数2： 是调起原生时向原生传递的参数//参数3： 原生调用回调返回的数据// bridge.callHandler('getBlogNameFromObjC', data, function (resp) &#123;&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"50、倒计时","slug":"JavaScript/50、倒计时","date":"2015-06-06T01:58:35.000Z","updated":"2020-08-07T14:10:11.796Z","comments":true,"path":"2015/06/06/JavaScript/50、倒计时/","link":"","permalink":"https://www.zackaddy.xin/2015/06/06/JavaScript/50、倒计时/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243/** * countdown * * @description Fix the problem of pausing after ios lock screen * * @see https://blog.csdn.net/aiwo035/article/details/81708198 * * @param &#123;Number&#125; seconds - countdown seconds * @param &#123;Object&#125; callback - countdown callback * @return &#123;Number&#125; setInterval return * * @since 1.0.0 */export default function countdown(seconds, callback) &#123; if (typeof callback !== 'function') &#123; throw new Error('countDown::argument::callback::should been function') &#125; let count = seconds let num = 0 const beginTime = new Date().getTime() let timer = setInterval(() =&gt; &#123; var newTime = new Date().getTime() num++ var dTime = parseInt((newTime - beginTime) / 1000 - num) if (count &gt; 0 &amp;&amp; count &lt;= seconds) &#123; count-- if (count - parseInt(dTime) &lt;= 0) &#123; count = 0 callback(count, count * 1000) &#125; else &#123; const adjustCount = count - parseInt(dTime) callback(adjustCount, adjustCount * 1000) &#125; &#125; else &#123; clearInterval(timer) num = 0 timer = null &#125; &#125;, 1000) return timer&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"49、判断滚动到底部","slug":"JavaScript/49、判断滚动到底部","date":"2015-06-05T01:32:48.000Z","updated":"2020-08-07T14:10:11.796Z","comments":true,"path":"2015/06/05/JavaScript/49、判断滚动到底部/","link":"","permalink":"https://www.zackaddy.xin/2015/06/05/JavaScript/49、判断滚动到底部/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132//获取滚动条当前的位置 function getScrollTop () &#123; var scrollTop = 0; if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123; scrollTop = document.documentElement.scrollTop; &#125; else if (document.body) &#123; scrollTop = document.body.scrollTop; &#125; return scrollTop;&#125;;//获取当前可是范围的高度 function getClientHeight () &#123; var clientHeight = 0; if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) &#123; clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight); &#125; else &#123; clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight); &#125; return clientHeight;&#125;;//获取文档完整的高度 function getScrollHeight () &#123; return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);&#125;;window.onscroll = function () &#123; if (getScrollTop() + getClientHeight() == getScrollHeight()) &#123; alert(\"到达底部\"); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"48、处理事件的一些兼容写法","slug":"JavaScript/48、处理事件的一些兼容写法","date":"2015-06-04T01:58:21.000Z","updated":"2020-08-07T14:10:11.795Z","comments":true,"path":"2015/06/04/JavaScript/48、处理事件的一些兼容写法/","link":"","permalink":"https://www.zackaddy.xin/2015/06/04/JavaScript/48、处理事件的一些兼容写法/","excerpt":"","text":"绑定事件 123456789101112131415161718192021222324var addEvent = function( obj, type, fn ) &#123; if (obj.addEventListener) obj.addEventListener( type, fn, false ); else if (obj.attachEvent) &#123; obj[\"e\"+type+fn] = fn; obj.attachEvent( \"on\"+type, function() &#123; obj[\"e\"+type+fn](); &#125; ); &#125;&#125;;//另一个实现var addEvent = (function () &#123; if (document.addEventListener) &#123; return function (el, type, fn) &#123; el.addEventListener(type, fn, false); &#125;; &#125; else &#123; return function (el, type, fn) &#123; el.attachEvent('on' + type, function () &#123; return fn.call(el, window.event); &#125;); &#125; &#125; &#125;)(); 绑定onpropertychange事件 123456789//onpropertychange是微软制造的一个事件，它在一个元素的属性发生变化的时候触发，常见的有文本的长度改变，样长改变等，FF大致和它相似的属性为oninput事件，不过它只针对textfield与textarea的value属性。safari，firefox，chrome与opera都支持此属性。var addPropertyChangeEvent = function (obj,fn) &#123; if(window.ActiveXObject)&#123; obj.onpropertychange = fn; &#125;else&#123; obj.addEventListener(\"input\",fn,false); &#125;&#125; 移除事件 12345678var removeEvent = function( obj, type, fn ) &#123; if (obj.removeEventListener) obj.removeEventListener( type, fn, false ); else if (obj.detachEvent) &#123; obj.detachEvent( \"on\"+type, obj[\"e\"+type+fn] ); obj[\"e\"+type+fn] = null; &#125;&#125;; 加载事件 1234567891011var loadEvent = function(fn) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125;else &#123; window.onload = function() &#123; oldonload(); fn(); &#125; &#125;&#125; 阻止事件 1234567891011121314151617181920var stopEvent = function(e)&#123; e = e || window.event; if(e.preventDefault) &#123; e.preventDefault(); e.stopPropagation(); &#125;else&#123; e.returnValue = false; e.cancelBubble = true; &#125; &#125;,//如果仅仅是阻止事件冒泡var stopPropagation = function(e) &#123; e = e || window.event; if (!+\"\\v1\") &#123; e.cancelBubble = true; &#125; else &#123; e.stopPropagation(); &#125;&#125; 取得事件源对象 123456789101112131415161718192021222324252627282930//相当于Prototype.js框架的Event.element(e)var getEvent = function(e)&#123; e = e || window.event; return event.target || event.srcElement&#125;function getEvent() &#123; if (window.event) return window.event; var c = getEvent.caller; while (c.caller) c = c.caller; return c.arguments[0];&#125; var getEvent = function(e) &#123; var e = e || window.event; if (!e) &#123; var c = this.getEvent.caller; while (c) &#123; e = c.arguments[0]; if (e &amp;&amp; (Event == e.constructor || MouseEvent == e.constructor)) &#123; break; &#125; c = c.caller; &#125; &#125; var target = e.srcElement ? e.srcElement : e.target, currentN = target.nodeName.toLowerCase(), parentN = target.parentNode.nodeName.toLowerCase(), grandN = target.parentNode.parentNode.nodeName.toLowerCase(); return [e,target,currentN,parentN,grandN];&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"47、getElementsByClassName兼容","slug":"JavaScript/47、getElementsByClassName兼容","date":"2015-06-02T17:03:38.000Z","updated":"2020-08-07T14:10:11.795Z","comments":true,"path":"2015/06/03/JavaScript/47、getElementsByClassName兼容/","link":"","permalink":"https://www.zackaddy.xin/2015/06/03/JavaScript/47、getElementsByClassName兼容/","excerpt":"","text":"The Ultimate getElementsByClassName方案，作者为Robert Nyman，05年实现，可见老外许多东西在很早以前就走得很远了。 123456789101112131415161718//三个参数都是必需的，查找一网页中5007个类名为“cell”的元素，IE8历时1828 ~ 1844毫秒，//IE6为4610 ~ 6109毫秒，FF3.5为46 ~ 48毫秒，opera10为31 ~ 32毫秒，Chrome为23~ 26毫秒，//safari4为19 ~ 20毫秒function getElementsByClassName(oElm, strTagName, strClassName)&#123; var arrElements = (strTagName == \"*\" &amp;&amp; oElm.all)? oElm.all : oElm.getElementsByTagName(strTagName); var arrReturnElements = new Array(); strClassName = strClassName.replace(/\\-/g, \"\\\\-\"); var oRegExp = new RegExp(\"(^|\\\\s)\" + strClassName + \"(\\\\s|$)\"); var oElement; for(var i=0; i &lt; arrElements.length; i++)&#123; oElement = arrElements[i]; if(oRegExp.test(oElement.className))&#123; arrReturnElements.push(oElement); &#125; &#125; return (arrReturnElements)&#125; 另一个实现，由Dustin Diaz（《JavaScript Design Patterns》的作者）提供，但兼容性不如上面的，不支持IE5。 12345678910111213141516171819//后两参数是可靠的，查找一网页中5007个类名为“cell”的元素，IE8历时78毫秒，IE6历时125~171毫秒//FF3.5为42 ~ 48毫秒，opera10为31 毫秒，Chrome为22~ 25毫秒，safari4为18 ~ 19毫秒var getElementsByClass = function(searchClass,node,tag) &#123; var classElements = new Array(); if ( node == null ) node = document; if ( tag == null ) tag = '*'; var els = node.getElementsByTagName(tag); var elsLen = els.length; var pattern = new RegExp(\"(^|\\\\s)\"+searchClass+\"(\\\\s|$)\"); for (i = 0, j = 0; i &lt; elsLen; i++) &#123; if ( pattern.test(els[i].className) ) &#123; classElements[j] = els[i]; j++; &#125; &#125; return classElements;&#125; 还有个更古老级的，我从prototype.js1.01版本中找到的，它能支持多个类名的查找（上面两个不行）。它不支持IE5，效率一般般，但作为最早的框架之一，它已经做得很好，其他框架还没有想到这个呢！ 123456789101112131415161718//由于这是后期添加的，测试页面已被我删掉，没有做测试……function getElementsByClassName(className, element) &#123; var children = (element || document).getElementsByTagName('*'); var elements = new Array(); for (var i = 0; i &lt; children.length; i++) &#123; var child = children[i]; var classNames = child.className.split(' '); for (var j = 0; j &lt; classNames.length; j++) &#123; if (classNames[j] == className) &#123; elements.push(child); break; &#125; &#125; &#125; return elements;&#125; 使用document.createTreeWalker，这是个比较不常用的二级DOM方法。可惜IE全系列歇菜。 1234567891011121314151617181920212223//查找一网页中5007个类名为“cell”的元素，FF3.5为104 ~ 119毫秒，opera10为230 ~ 265毫秒，//Chrome为119 ~ 128毫秒，safari为28 ~ 32毫秒var getElementsByClassName = function(searchClass) &#123; function acceptNode(node) &#123; if (node.hasAttribute(\"class\")) &#123; var c = \" \" + node.className + \" \"; if (c.indexOf(\" \" + searchClass + \" \") != -1) return NodeFilter.FILTER_ACCEPT; &#125; return NodeFilter.FILTER_SKIP; &#125; var treeWalker = document.createTreeWalker(document.documentElement, NodeFilter.SHOW_ELEMENT, acceptNode, true); var returnElements = []; if (treeWalker) &#123; var node = treeWalker.nextNode(); while (node) &#123; returnElements.push(node); node = treeWalker.nextNode(); &#125; &#125; return returnElements;&#125; 更加新式时髦的技术。取自Prototype.js框架。 123456789101112131415161718192021222324//查找一网页中5007个类名为“cell”的元素，FF3.5为33 ~ 48毫秒，opera10为31 ~ 32毫秒，//Chrome为104 ~ 107毫秒，safari为18 ~ 21毫秒var getElementsByClassName = function(searchClass,node,tag) &#123; node = node || document; tag = tag || '*'; var classes = searchClass.split(\" \"), patterns = \"\", xhtmlNamespace = \"http://www.w3.org/1999/xhtml\", namespaceResolver = (document.documentElement.namespaceURI === xhtmlNamespace)? xhtmlNamespace : null, returnElements = [], elements, _node; for(var j=0, jl=classes.length; j&lt;jl; j+=1)&#123; patterns += \"[contains(concat(' ', @class, ' '), ' \" + classes[j] + \" ')]\"; &#125; try &#123; elements = document.evaluate(\".//\" + tag + patterns, node, namespaceResolver, 0, null); &#125; catch (e) &#123; elements = document.evaluate(\".//\" + tag + patterns, node, null, 0, null); &#125; while ((_node = elements.iterateNext())) returnElements.push(_node); return returnElements;&#125; 兼容IE5，让后面两个参数是可选的，能原生的原生，利用字面量与倒序循环提高效率 12345678910111213141516171819202122//查找一网页中5007个类名为“cell”的元素，IE8历时1828 ~ 1844毫秒，//IE6为125 ~ 172毫秒，IE8为93 ~ 94毫秒，FF3.5为0~1毫秒，opera10为0毫秒，Chrome为1毫秒，//safari4为0毫秒var getElementsByClassName = function(searchClass,node,tag) &#123; if(document.getElementsByClassName)&#123; return document.getElementsByClassName(searchClass) &#125;else&#123; node = node || document; tag = tag || '*'; var returnElements = [] var els = (tag === \"*\" &amp;&amp; node.all)? node.all : node.getElementsByTagName(tag); var i = els.length; searchClass = searchClass.replace(/\\-/g, \"\\\\-\"); var pattern = new RegExp(\"(^|\\\\s)\"+searchClass+\"(\\\\s|$)\"); while(--i &gt;= 0)&#123; if (pattern.test(els[i].className) ) &#123; returnElements.push(els[i]); &#125; &#125; return returnElements; &#125;&#125; 将上方代码完善 如下 123456789101112131415161718192021222324252627282930313233343536373839var getElementsByClassName = function (searchClass, node,tag) &#123; if(document.getElementsByClassName)&#123; var nodes = (node || document).getElementsByClassName(searchClass),result = []; for(var i=0 ;node = nodes[i++];)&#123; if (tag !== undefined &amp;&amp; tag !== null &amp;&amp; tag !== '*') &#123; if(node.tagName === tag.toUpperCase())&#123; result.push(node) &#125; &#125; else &#123; result = nodes; break; &#125; &#125; return result &#125;else&#123; node = node || document; tag = tag || \"*\"; var classes = searchClass.split(\" \"), elements = (tag === \"*\" &amp;&amp; node.all)? node.all : node.getElementsByTagName(tag), patterns = [], current, match,result = []; var i = classes.length; while(--i &gt;= 0)&#123; patterns.push(new RegExp(\"(^|\\\\s)\" + classes[i] + \"(\\\\s|$)\")); &#125; var j = elements.length; while(--j &gt;= 0)&#123; current = elements[j]; match = false; for(var k=0, kl=patterns.length; k&lt;kl; k++)&#123; match = patterns[k].test(current.className); if (!match) break; &#125; if (match) result.push(current); &#125; return result; &#125; &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"46、在线执行与运行代码","slug":"JavaScript/46、在线执行与运行代码","date":"2015-06-02T00:07:32.000Z","updated":"2020-08-07T14:10:11.795Z","comments":true,"path":"2015/06/02/JavaScript/46、在线执行与运行代码/","link":"","permalink":"https://www.zackaddy.xin/2015/06/02/JavaScript/46、在线执行与运行代码/","excerpt":"","text":"1234567891011121314151617181920212223242526var normalizeCode = function(code)&#123; code = code.replace(/&amp;lt;/g,'&lt;'); code = code.replace(/&amp;gt;/g,'&gt;'); code = code.replace(/&amp;amp;/g,'&amp;'); return code;&#125;;var runCode = function(code)&#123; if (code!=\"\")&#123; var newwin = window.open('', \"_blank\", ''); newwin.document.open('text/html', 'replace'); newwin.opener = null; newwin.document.write(code); newwin.document.close(); &#125; &#125;;var evalCode = function(code)&#123; var head = document.getElementsByTagName(\"head\")[0], js = document.createElement(\"script\"); js.type = \"text/javascript\"; js.charset= \"utf-8\"; js.text = code; head.insertBefore(js, head.firstChild); head.removeChild(js);&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"45、移除dom","slug":"JavaScript/45、移除dom","date":"2015-05-31T19:46:42.000Z","updated":"2020-08-07T14:10:11.794Z","comments":true,"path":"2015/06/01/JavaScript/45、移除dom/","link":"","permalink":"https://www.zackaddy.xin/2015/06/01/JavaScript/45、移除dom/","excerpt":"","text":"在IE中移除容器类节点，会引起内存泄露，最好是创建一个新的节点，比如div，然后将要删除的节点放入这个div中，再将div的innerHTML清空。其它的直接removeChild就可以了。 1234567891011121314var removeNode = !+\"\\v1\" ? function()&#123; var d; return function(node)&#123; if(node &amp;&amp; node.tagName != 'BODY')&#123; d = d || document.createElement('DIV'); d.appendChild(node); d.innerHTML = ''; &#125; &#125;&#125;() : function(node)&#123; if(node &amp;&amp; node.parentNode &amp;&amp; node.tagName != 'BODY')&#123; node.parentNode.removeChild(node); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"44、动态添加样式表规则","slug":"JavaScript/44、动态添加样式表规则","date":"2015-05-30T19:31:35.000Z","updated":"2020-08-07T14:10:11.794Z","comments":true,"path":"2015/05/31/JavaScript/44、动态添加样式表规则/","link":"","permalink":"https://www.zackaddy.xin/2015/05/31/JavaScript/44、动态添加样式表规则/","excerpt":"","text":"插入样式表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var addSheet = function()&#123; var doc,cssCode; if(arguments.length == 1)&#123; doc = document; cssCode = arguments[0] &#125;else if(arguments.length == 2)&#123; doc = arguments[0]; cssCode = arguments[1]; &#125;else&#123; alert(\"addSheet函数最多接受两个参数!\"); &#125; if(!+\"\\v1\")&#123;//增加自动转换透明度功能，用户只需输入W3C的透明样式，它会自动转换成IE的透明滤镜 var t = cssCode.match(/opacity:(\\d?\\.\\d+);/); if(t!= null)&#123; cssCode = cssCode.replace(t[0], \"filter:alpha(opacity=\"+ parseFloat(t[1]) * 100+\")\") &#125; &#125; cssCode = cssCode + \"\\n\";//增加末尾的换行符，方便在firebug下的查看。 var headElement = doc.getElementsByTagName(\"head\")[0]; var styleElements = headElement.getElementsByTagName(\"style\"); if(styleElements.length == 0)&#123;//如果不存在style元素则创建 if(doc.createStyleSheet)&#123; //ie doc.createStyleSheet(); &#125;else&#123; var tempStyleElement = doc.createElement('style');//w3c tempStyleElement.setAttribute(\"type\", \"text/css\"); headElement.appendChild(tempStyleElement); &#125; &#125; var styleElement = styleElements[0]; var media = styleElement.getAttribute(\"media\"); if(media != null &amp;&amp; !/screen/.test(media.toLowerCase()) )&#123; styleElement.setAttribute(\"media\",\"screen\"); &#125; if(styleElement.styleSheet)&#123; //ie styleElement.styleSheet.cssText += cssCode; &#125;else if(doc.getBoxObjectFor)&#123; styleElement.innerHTML += cssCode;//火狐支持直接innerHTML添加样式表字串 &#125;else&#123; styleElement.appendChild(doc.createTextNode(cssCode)) &#125;&#125;//使用addSheet(\"\\ .RTE_iframe&#123;width:600px;height:300px;&#125;\\ .RTE_toolbar&#123;width:600px;&#125;\\ .color_result&#123;width:216px;&#125;\\ .color_view&#123;width:110px;height:25px;&#125;\\ .color_code&#123;text-align:center;font-weight:700;color:blue;font-size:16px;&#125;\\ div.table&#123;width:176px;position:absolute;padding:1px;&#125;\\ div.table td&#123;font-size:12px;color:red;text-align:center;&#125;\\\" );*/ 添加样式文件123456789function addSheetFile(path)&#123; var fileref=document.createElement(\"link\") fileref.rel = \"stylesheet\"; fileref.type = \"text/css\"; fileref.href = path; fileref.media=\"screen\"; var headobj = document.getElementsByTagName('head')[0]; headobj.appendChild(fileref);&#125; class操作相关方法123456789101112131415161718192021222324var getClass = function(ele) &#123; var oldArr = ele.className.replace(/\\s+/,' ').split(' '); var newArr = []; for(var id in oldArr) &#123; if(oldArr[id]!=\"\") newArr.push(oldArr[id]); &#125; return newArr;&#125;;var hasClass = function(ele,cls) &#123; return ele.className.match(new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'));&#125;//更快的版本var hasClass =function(ele,cls)&#123; return -1 &lt; (\" \"+ele.className+\" \").indexOf(\" \"+cls+\" \");&#125;var addClass = function(ele,cls) &#123; if (!this.hasClass(ele,cls)) ele.className += \" \"+cls;&#125;var removeClass = function(ele,cls) &#123; if (hasClass(ele,cls)) &#123; var reg = new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)'); ele.className=ele.className.replace(reg,' '); &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"43、左滑删除(滑动删除)","slug":"JavaScript/43、左滑删除(滑动删除)","date":"2015-05-30T03:33:19.000Z","updated":"2020-08-07T14:10:11.794Z","comments":true,"path":"2015/05/30/JavaScript/43、左滑删除(滑动删除)/","link":"","permalink":"https://www.zackaddy.xin/2015/05/30/JavaScript/43、左滑删除(滑动删除)/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import $ from 'jQuery'(function($) &#123; $.fn.touchWipe = function(option) &#123; var defaults = &#123; itemDelete: '.item-delete', //删除元素 &#125;; var opts = $.extend(&#123;&#125;, defaults, option); //配置选项 var delWidth = $(opts.itemDelete).width(); var initX,initY; //触摸位置 var moveY,moveX; //滑动时的位置 var X = 0; //移动距离 var objX = 0; //目标对象位置 var obj = null var lastLeftObj; // 上一个左滑的对象 var valiX = 0,valiY = 0,valiFlag = true $(this).off('touchstart') $(this).off('touchmove') $(this).off('touchend') $(document).off('touchstart', 'body') $(document).on('touchstart', 'body', function()&#123; if(lastLeftObj) &#123; lastLeftObj.style.transition = \"all 0.2s\"; lastLeftObj.style.WebkitTransform = \"translateX(\" + 0 + \"px)\"; lastLeftObj.style.transition = \"all 0\"; &#125; &#125;) $(this).on('touchstart', function(event) &#123; obj = this; initX = event.targetTouches[0].pageX; initY = event.targetTouches[0].pageY; objX = (obj.style.WebkitTransform.replace(/translateX\\(/g, \"\").replace(/px\\)/g, \"\")) * 1; if(objX == 0) &#123; $(this).on('touchmove', function(event) &#123; var obj = this; obj.style.transition = \"all 0s\"; moveX = event.targetTouches[0].pageX; moveY = event.targetTouches[0].pageY; X = moveX - initX; if (valiFlag) &#123; valiFlag = false valiX = Math.abs(initX -moveX) valiY = Math.abs(initY -moveY) &#125; if (Math.abs(valiX) &gt; Math.abs(valiY)) &#123; event.preventDefault() &#125; else &#123; return void 0 &#125; if(X &gt;= 0) &#123; obj.style.WebkitTransform = \"translateX(\" + 0 + \"px)\"; &#125; else if(X &lt; 0) &#123; var l = Math.abs(X); obj.style.WebkitTransform = \"translateX(\" + -l + \"px)\"; if(l &gt; delWidth) &#123; l = delWidth; obj.style.WebkitTransform = \"translateX(\" + -l + \"px)\"; &#125; &#125; &#125;); &#125; else if(objX &lt; 0) &#123; $(this).on('touchmove', function(event) &#123; var obj = this; obj.style.transition = \"all 0s\"; moveX = event.targetTouches[0].pageX; moveY = event.targetTouches[0].pageY; X = moveX - initX; if (valiFlag) &#123; valiFlag = false valiX = Math.abs(initX -moveX) valiY = Math.abs(initY -moveY) &#125; if (Math.abs(valiX) &gt; Math.abs(valiY)) &#123; event.preventDefault() &#125; else &#123; return void 0 &#125; if(X &gt;= 0) &#123; var r = -delWidth + Math.abs(X); obj.style.WebkitTransform = \"translateX(\" + r + \"px)\"; if(r &gt; 0) &#123; r = 0; obj.style.WebkitTransform = \"translateX(\" + r + \"px)\"; &#125; &#125; else &#123; //向左滑动 obj.style.WebkitTransform = \"translateX(\" + -delWidth + \"px)\"; &#125; &#125;); &#125; &#125;) $(this).on('touchend', function(event) &#123; valiFlag = true $(this).unbind('touchmove') var obj = this; objX = (obj.style.WebkitTransform.replace(/translateX\\(/g, \"\").replace(/px\\)/g, \"\")) * 1; if(objX &gt; -delWidth / 2) &#123; obj.style.transition = \"all 0.2s\"; obj.style.WebkitTransform = \"translateX(\" + 0 + \"px)\"; obj.style.transition = \"all 0\"; objX = 0; &#125; else &#123; obj.style.transition = \"all 0.2s\"; obj.style.WebkitTransform = \"translateX(\" + -delWidth + \"px)\"; obj.style.transition = \"all 0\"; objX = -delWidth; lastLeftObj = obj &#125; &#125;) //链式返回 return this; &#125;;&#125;)($);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"42、dom操作","slug":"JavaScript/42、dom操作","date":"2015-05-28T19:06:52.000Z","updated":"2020-08-07T14:10:11.793Z","comments":true,"path":"2015/05/29/JavaScript/42、dom操作/","link":"","permalink":"https://www.zackaddy.xin/2015/05/29/JavaScript/42、dom操作/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/* istanbul ignore next */import Vue from 'vue';const isServer = Vue.prototype.$isServer;const SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;const MOZ_HACK_REGEXP = /^moz([A-Z])/;const ieVersion = isServer ? 0 : Number(document.documentMode);/* istanbul ignore next */const trim = function(string) &#123; return (string || '').replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, '');&#125;;/* istanbul ignore next */const camelCase = function(name) &#123; return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) &#123; return offset ? letter.toUpperCase() : letter; &#125;).replace(MOZ_HACK_REGEXP, 'Moz$1');&#125;;/* istanbul ignore next */export const on = (function() &#123; if (!isServer &amp;&amp; document.addEventListener) &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.addEventListener(event, handler, false); &#125; &#125;; &#125; else &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event &amp;&amp; handler) &#123; element.attachEvent('on' + event, handler); &#125; &#125;; &#125;&#125;)();/* istanbul ignore next */export const off = (function() &#123; if (!isServer &amp;&amp; document.removeEventListener) &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event) &#123; element.removeEventListener(event, handler, false); &#125; &#125;; &#125; else &#123; return function(element, event, handler) &#123; if (element &amp;&amp; event) &#123; element.detachEvent('on' + event, handler); &#125; &#125;; &#125;&#125;)();/* istanbul ignore next */export const once = function(el, event, fn) &#123; var listener = function() &#123; if (fn) &#123; fn.apply(this, arguments); &#125; off(el, event, listener); &#125;; on(el, event, listener);&#125;;/* istanbul ignore next */export function hasClass(el, cls) &#123; if (!el || !cls) return false; if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.'); if (el.classList) &#123; return el.classList.contains(cls); &#125; else &#123; return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') &gt; -1; &#125;&#125;;/* istanbul ignore next */export function addClass(el, cls) &#123; if (!el) return; var curClass = el.className; var classes = (cls || '').split(' '); for (var i = 0, j = classes.length; i &lt; j; i++) &#123; var clsName = classes[i]; if (!clsName) continue; if (el.classList) &#123; el.classList.add(clsName); &#125; else &#123; if (!hasClass(el, clsName)) &#123; curClass += ' ' + clsName; &#125; &#125; &#125; if (!el.classList) &#123; el.className = curClass; &#125;&#125;;/* istanbul ignore next */export function removeClass(el, cls) &#123; if (!el || !cls) return; var classes = cls.split(' '); var curClass = ' ' + el.className + ' '; for (var i = 0, j = classes.length; i &lt; j; i++) &#123; var clsName = classes[i]; if (!clsName) continue; if (el.classList) &#123; el.classList.remove(clsName); &#125; else &#123; if (hasClass(el, clsName)) &#123; curClass = curClass.replace(' ' + clsName + ' ', ' '); &#125; &#125; &#125; if (!el.classList) &#123; el.className = trim(curClass); &#125;&#125;;/* istanbul ignore next */export const getStyle = ieVersion &lt; 9 ? function(element, styleName) &#123; if (isServer) return; if (!element || !styleName) return null; styleName = camelCase(styleName); if (styleName === 'float') &#123; styleName = 'styleFloat'; &#125; try &#123; switch (styleName) &#123; case 'opacity': try &#123; return element.filters.item('alpha').opacity / 100; &#125; catch (e) &#123; return 1.0; &#125; default: return (element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null); &#125; &#125; catch (e) &#123; return element.style[styleName]; &#125;&#125; : function(element, styleName) &#123; if (isServer) return; if (!element || !styleName) return null; styleName = camelCase(styleName); if (styleName === 'float') &#123; styleName = 'cssFloat'; &#125; try &#123; var computed = document.defaultView.getComputedStyle(element, ''); return element.style[styleName] || computed ? computed[styleName] : null; &#125; catch (e) &#123; return element.style[styleName]; &#125;&#125;;/* istanbul ignore next */export function setStyle(element, styleName, value) &#123; if (!element || !styleName) return; if (typeof styleName === 'object') &#123; for (var prop in styleName) &#123; if (styleName.hasOwnProperty(prop)) &#123; setStyle(element, prop, styleName[prop]); &#125; &#125; &#125; else &#123; styleName = camelCase(styleName); if (styleName === 'opacity' &amp;&amp; ieVersion &lt; 9) &#123; element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')'; &#125; else &#123; element.style[styleName] = value; &#125; &#125;&#125;;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"40、获取元素样式宽高","slug":"JavaScript/40、获取元素样式宽高","date":"2015-05-28T02:04:45.000Z","updated":"2020-08-07T14:10:11.793Z","comments":true,"path":"2015/05/28/JavaScript/40、获取元素样式宽高/","link":"","permalink":"https://www.zackaddy.xin/2015/05/28/JavaScript/40、获取元素样式宽高/","excerpt":"","text":"1234567891011function anonymous(el, style) &#123; style.indexOf('-') &gt; -1 &amp;&amp; ( style = style.replace(/-(\\w)/g, function ($_, $1) &#123; return $1.toUpperCase() &#125; ) ); style == 'float' &amp;&amp; (style = 'cssFloat'); return el.style[style] || window.getComputedStyle(el, null)[style] || null;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"39、对象url参数互转","slug":"JavaScript/39、对象url参数互转","date":"2015-05-26T23:38:31.000Z","updated":"2020-08-07T14:10:11.792Z","comments":true,"path":"2015/05/27/JavaScript/39、对象url参数互转/","link":"","permalink":"https://www.zackaddy.xin/2015/05/27/JavaScript/39、对象url参数互转/","excerpt":"","text":"1234567891011121314151617181920212223function parseQuery (query) &#123; var reg = /([^=&amp;\\s]+)[=\\s]*([^&amp;\\s]*)/g; var obj = &#123;&#125;; while (reg.exec(query)) &#123; obj[RegExp.$1] = RegExp.$2; &#125; return obj;&#125;function urlencode (data) &#123; var _result = []; for (var key in data) &#123; var value = data[key]; if (value.constructor == Array) &#123; value.forEach(function (_value) &#123; _result.push(key + \"=\" + _value); &#125;); &#125; else &#123; _result.push(key + '=' + value); &#125; &#125; return _result.join('&amp;');&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"38、ifram加载完成判断","slug":"JavaScript/38、ifram加载完成判断","date":"2015-05-26T00:00:57.000Z","updated":"2020-08-07T14:10:11.792Z","comments":true,"path":"2015/05/26/JavaScript/38、ifram加载完成判断/","link":"","permalink":"https://www.zackaddy.xin/2015/05/26/JavaScript/38、ifram加载完成判断/","excerpt":"","text":"12345678910111213waitIframe () &#123; return new Promise((resolve, reject) =&gt; &#123; let iframe = this.$refs.iframe const loadCallback = () =&gt; &#123; resolve() &#125; if (iframe.attachEvent) &#123; iframe.attachEvent(\"onload\", loadCallback); &#125; else &#123; iframe.onload = loadCallback &#125; &#125;)&#125;,","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"37、判断用户是否安装广告拦截AdBlock","slug":"JavaScript/37、判断用户是否安装广告拦截AdBlock","date":"2015-05-25T03:38:55.000Z","updated":"2020-08-07T14:10:11.791Z","comments":true,"path":"2015/05/25/JavaScript/37、判断用户是否安装广告拦截AdBlock/","link":"","permalink":"https://www.zackaddy.xin/2015/05/25/JavaScript/37、判断用户是否安装广告拦截AdBlock/","excerpt":"","text":"12345678hasAdBlock: function hasAdBlock() &#123; var e = document.createElement('div'); e.className = 'adsbox', document.body.appendChild(e); var t = 'none' === getComputedStyle(e).display; return document.body.removeChild(e), t;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"36、实现简单的mvc","slug":"JavaScript/36、实现简单的mvc","date":"2015-05-23T20:13:27.000Z","updated":"2020-08-07T14:10:11.791Z","comments":true,"path":"2015/05/24/JavaScript/36、实现简单的mvc/","link":"","permalink":"https://www.zackaddy.xin/2015/05/24/JavaScript/36、实现简单的mvc/","excerpt":"","text":"https://www.cnblogs.com/huansky/p/6088772.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"35、使用 generator 模拟 async、await","slug":"JavaScript/35、使用 generator 模拟 async、await","date":"2015-05-22T20:19:25.000Z","updated":"2020-08-07T14:10:11.791Z","comments":true,"path":"2015/05/23/JavaScript/35、使用 generator 模拟 async、await/","link":"","permalink":"https://www.zackaddy.xin/2015/05/23/JavaScript/35、使用 generator 模拟 async、await/","excerpt":"","text":"1234567891011121314151617const wrapAsync = (generatorFn) =&gt; &#123; return (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; const g = generatorFn(...args); function go(result) &#123; if (result.done) &#123; resolve(result.value); return; &#125; return result.value.then(val =&gt; &#123; return go(g.next(val)) &#125;) &#125; go(g.next()) &#125;) &#125;&#125; 1234567891011121314151617const getData = (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('My name is ' + name) &#125;, 100) // 模拟异步获取数据 &#125;)&#125;const run = wrapAsync(function * (lastName) &#123; const data1 = yield getData('Jerry ' + lastName) const data2 = yield getData('Lucy ' + lastName) return [data1, data2]&#125;)run('Green').then((val) =&gt; &#123; console.log(val) // =&gt; [ 'My name is Jerry Green', 'My name is Lucy Green' ]&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"34、（页面状态监听）html5API实现手机后退键监听","slug":"JavaScript/34、（页面状态监听）html5API实现手机后退键监听","date":"2015-05-21T20:38:20.000Z","updated":"2020-08-07T14:10:11.790Z","comments":true,"path":"2015/05/22/JavaScript/34、（页面状态监听）html5API实现手机后退键监听/","link":"","permalink":"https://www.zackaddy.xin/2015/05/22/JavaScript/34、（页面状态监听）html5API实现手机后退键监听/","excerpt":"","text":"普通写法12345678910111213var hiddenProperty = 'hidden' in document ? 'hidden' : 'webkitHidden' in document ? 'webkitHidden' :'mozHidden' in document ? 'mozHidden' :null;var visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange');var onVisibilityChange = function() &#123; if (document[hiddenProperty]) &#123; //页面非激活状态 &#125; else &#123; //页面激活状态 &#125;&#125;document.addEventListener(visibilityChangeEvent, onVisibilityChange) 2.常用写法 123456789101112131415161718192021222324252627282930313233343536373839function getHiddenProp()&#123; var prefixes = ['webkit','moz','ms','o']; // if 'hidden' is natively supported just return it if ('hidden' in document) return 'hidden'; // otherwise loop over all the known prefixes until we find one for (var i = 0; i &lt; prefixes.length; i++)&#123; if ((prefixes[i] + 'Hidden') in document) return prefixes[i] + 'Hidden'; &#125; // otherwise it's not supported return null;&#125;function getVisibilityStateProp() &#123; var prefixes = ['webkit', 'moz', 'ms', 'o']; if ('visibilityState' in document) return 'visibilityState'; for (var i = 0; i &lt; prefixes.length; i++) &#123; if ((prefixes[i] + 'VisibilityState') in document) return prefixes[i] + 'VisibilityState'; &#125; // otherwise it's not supported return null;&#125;function isHidden() &#123; var prop = getHiddenProp(); if (!prop) return false; return document[prop];&#125;// use the property name to generate the prefixed event namevar visProp = getHiddenProp();if (visProp) &#123; var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange'; document.addEventListener(evtname, function () &#123; document.title = document[getVisibilityStateProp()]+\"状态\"; &#125;,false);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"33、js实现图片cover显示","slug":"JavaScript/33、js实现图片cover显示","date":"2015-05-20T19:31:47.000Z","updated":"2020-08-07T14:10:11.777Z","comments":true,"path":"2015/05/21/JavaScript/33、js实现图片cover显示/","link":"","permalink":"https://www.zackaddy.xin/2015/05/21/JavaScript/33、js实现图片cover显示/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354outImgList: ['../../static/images/guide.png', '../../static/images/banner01.png']measureFill() &#123; return this.footHeight&#125;,obtainMeasureWH() &#123; return &#123; width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height: (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) - this.measureFill() &#125;&#125;,mounted() &#123; this.outImgList.forEach((src, index) =&gt; &#123; this.outImgList.forEach((src, index) =&gt; &#123; this.loadImg(src, (width, height, url) =&gt; &#123; let measure = this.obtainMeasureWH() let bratio = measure.width / measure.height let imgratio = width / height let cpwidth = 0, cpheight = 0 if (width &gt;= measure.width) &#123; height = measure.height width = height * imgratio &#125; console.log(cpheight,cpwidth) if (height &gt;= measure.height) &#123; width = measure.width height = width / imgratio &#125; if (width &lt; measure.width) &#123; width = measure.width height = width / imgratio if (height &lt; measure.height) &#123; height = measure.height width = height * imgratio &#125; &#125; else if (height &lt; measure.height) &#123; height = measure.height width = height * imgratio if (width &lt; measure.width) &#123; width = measure.width height = cpwidth * imgratio &#125; &#125; this.$set(this.imgList, index, &#123; src: src, width: width, height: height, mheight: measure.height &#125;) !this.inter &amp;&amp; this.countdown() &#125;) &#125;) &#125;)&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"32、requirejs main.js","slug":"JavaScript/32、requirejs main.js","date":"2015-05-20T04:07:41.000Z","updated":"2020-08-07T14:10:11.777Z","comments":true,"path":"2015/05/20/JavaScript/32、requirejs main.js/","link":"","permalink":"https://www.zackaddy.xin/2015/05/20/JavaScript/32、requirejs main.js/","excerpt":"","text":"css.min.js：使用： css!../../../css/bootstorap 下载地址： https://note.youdao.com/share/?id=fbea115027702b4835e83392dd23d8f9&amp;type=note#/ text：使用：’text!tpl/help.html’ 下载地址：https://note.youdao.com/share/?id=c00153c4306c8ea5b6b0165b10c476f8&amp;type=note#/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 配置页面加载模块参数require.config(&#123; paths: &#123; \"iview\": \"../lib/iview.min\", \"vue\": \"../lib/vue.min\", \"jquery\": \"https://cdn.bootcss.com/jquery/3.3.1/jquery.min\", \"text\": \"../lib/text\", \"underscore\": \"../lib/underscore\", \"backbone\": \"../lib/backbone\" &#125;, map: &#123; '*': &#123; 'css': 'static/js/lib/css.min.js' // or whatever the path to require-css is &#125; &#125;, shim: &#123; iview: &#123; deps: [\"css!../../css/iview\",\"vue\"] &#125;, backbone: &#123; deps: [\"underscore\", \"jquery\"] &#125; &#125;&#125;);require([\"backbone\", \"./router/index\"], function(b, router) &#123; Backbone.emulateJSON = true; var r = new router() Backbone.history.start()&#125;)var SpaViewJsLoadUtils = function()&#123; if(!(this instanceof SpaViewJsLoadUtils))&#123; return new SpaViewJsLoadUtils(); &#125; this.el = null this.hookCurrentPageViewJs();&#125;;/** * name:require script data-hook * value:\"data-hook页面需要加载的js名称\" * 如果加载多个js: data-hook=\"aa,bb,cc\" */SpaViewJsLoadUtils.prototype.getData = function() &#123; var isCheck = false,checkName = ''; var sg = &#123; dataset: function(_self, name) &#123; return _self.el.dataset[name] &#125;, getAttribute: function(_self, name) &#123; return _self.el.getAttribute('data-'+name) &#125;, getAttr: function(_self,name) &#123; var attrs = _self.el.attributes,expense = &#123;&#125;, i, j; for (i = 0, j = attrs.length; i &lt; j; i++) &#123; if(attrs[i].name == ('data-'+name)) &#123; return attrs[i].value; &#125; &#125; &#125; &#125;; return function(name) &#123; if (isCheck) &#123; return sg[checkName](this,name) &#125; if(this.el.dataset) &#123; checkName = \"dataset\" &#125; else if (this.el.getAttribute)&#123; checkName = \"getAttribute\" &#125; else &#123; checkName = \"getAttr\" &#125; isCheck = true; return sg[checkName](this,name) &#125;&#125;.call(this);SpaViewJsLoadUtils.prototype.hookCurrentPageViewJs = function()&#123; var tags = document.getElementsByTagName(\"script\"),hookstr,mainstr; for (var i = 0;i &lt; tags.length;i++) &#123; this.el = tags[i]; mainstr = this.getData(\"main\"); mainstr &amp;&amp; (hookstr = this.getData(\"hook\")); if (mainstr &amp;&amp; hookstr) &#123; require(hookstr.split(\",\")); return void 0 &#125; &#125;&#125;;SpaViewJsLoadUtils();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"31、深拷贝","slug":"JavaScript/31、深拷贝","date":"2015-05-19T00:51:38.000Z","updated":"2020-08-07T14:10:11.777Z","comments":true,"path":"2015/05/19/JavaScript/31、深拷贝/","link":"","permalink":"https://www.zackaddy.xin/2015/05/19/JavaScript/31、深拷贝/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142function getType(obj)&#123; //tostring会返回对应不同的标签的构造函数 var toString = Object.prototype.toString; var map = &#123; '[object Boolean]' : 'boolean', '[object Number]' : 'number', '[object String]' : 'string', '[object Function]' : 'function', '[object Array]' : 'array', '[object Date]' : 'date', '[object RegExp]' : 'regExp', '[object Undefined]': 'undefined', '[object Null]' : 'null', '[object Object]' : 'object' &#125;; if(obj instanceof Element) &#123; return 'element'; &#125; return map[toString.call(obj)];&#125;!Object.deepClone &amp;&amp; (Object.deepClone = function(data) &#123; var type = getType(data); var obj; if(type === 'array')&#123; obj = []; &#125; else if(type === 'object')&#123; obj = &#123;&#125;; &#125; else &#123; //不再具有下一层次 return data; &#125; if(type === 'array')&#123; for(var i = 0, len = data.length; i &lt; len; i++)&#123; obj.push(Object.deepClone(data[i])); &#125; &#125; else if(type === 'object')&#123; for(var key in data)&#123; obj[key] = Object.deepClone(data[key]); &#125; &#125; return obj;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"30、监听div大小变化","slug":"JavaScript/30、监听div大小变化","date":"2015-05-18T01:41:00.000Z","updated":"2020-08-07T14:10:11.776Z","comments":true,"path":"2015/05/18/JavaScript/30、监听div大小变化/","link":"","permalink":"https://www.zackaddy.xin/2015/05/18/JavaScript/30、监听div大小变化/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193function getStyle(el, style) &#123; style.indexOf('-') &gt; -1 &amp;&amp; (style = style.replace(/-(\\w)/g, function($_, $1) &#123; return $1.toUpperCase() &#125;)) style == 'float' &amp;&amp; (style = 'cssFloat') return el.style[style] || window.getComputedStyle(el, null)[style] || null&#125;function getWH(el, name) &#123; var val = name === 'width' ? el.offsetWidth : el.offsetHeight, which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'] // display is none if (val === 0) &#123; return 0 &#125; // 左右或上下两边的都减去 for (var i = 0, a; (a = which[i++]); ) &#123; val -= parseFloat(getStyle(el, 'border' + a + 'Width')).toFixed(1) * 1 || 0 val -= parseFloat(getStyle(el, 'padding' + a)).toFixed(1) * 1 || 0 &#125; return val&#125;const EleResize = &#123; handleResize: function(e) &#123; var ele = e.target || e.srcElement var trigger = ele.$resizeTrigger if (trigger) &#123; var handlers = trigger.$resizeListeners if (handlers) &#123; var size = handlers.length for (var i = 0; i &lt; size; i++) &#123; var h = handlers[i] var handler = h.handler var context = h.context var borderHeight = trigger.offsetHeight - trigger.clientHeight var width = getWH(trigger, 'width'), height = getWH(trigger, 'height'), top = parseFloat(getStyle(trigger, 'padding-top')).toFixed(1) * 1, left = parseFloat(getStyle(trigger, 'padding-left')).toFixed(1) * 1, right = width + left, bottom = height + top, x = left, y = top handler.apply(context, [ &#123; target: trigger, contentRect: e.contentRect ? e.contentRect : &#123; height: height, width: width, top: top, left: left, bottom: bottom, right: right, x: x, y: y &#125; &#125; ]) &#125; &#125; &#125; &#125;, removeHandler: function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (handlers) &#123; var size = handlers.length for (var i = 0; i &lt; size; i++) &#123; var h = handlers[i] if (h.handler === handler &amp;&amp; h.context === context) &#123; handlers.splice(i, 1) return &#125; &#125; &#125; &#125;, createResizeTrigger: function(ele) &#123; var obj = document.createElement('object') obj.setAttribute( 'style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden;opacity: 0; pointer-events: none; z-index: -1;' ) obj.$resizeElement = ele obj.onload = EleResize.handleObjectLoad obj.type = 'text/html' ele.appendChild(obj) obj.data = 'about:blank' return obj &#125;, handleObjectLoad: function(evt) &#123; this.contentDocument.defaultView.$resizeTrigger = this.$resizeElement this.contentDocument.defaultView.addEventListener( 'resize', EleResize.handleResize ) EleResize.handleResize(&#123; target: this.contentDocument.defaultView &#125;) &#125;&#125;if (window.ResizeObserver) &#123; var handlers = [] var ro = new ResizeObserver(entries =&gt; &#123; for (let entry of entries) if (entry.target.onresize) entry.target.onresize(entry) &#125;) EleResize.on = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (!handlers) &#123; handlers = [] ele.$resizeListeners = handlers ele.$resizeTrigger = ele ele.onresize = EleResize.handleResize &#125; handlers.push(&#123; handler: handler, context: context &#125;) ro.observe(ele) &#125; EleResize.off = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (handlers) &#123; EleResize.removeHandler(ele, handler, context) if (handlers.length === 0) &#123; ro.unobserve(ele) delete ele.$resizeListeners &#125; &#125; &#125;&#125; else if (document.attachEvent) &#123; EleResize.on = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (!handlers) &#123; handlers = [] ele.$resizeListeners = handlers ele.$resizeTrigger = ele ele.attachEvent('onresize', EleResize.handleResize) &#125; handlers.push(&#123; handler: handler, context: context &#125;) &#125; EleResize.off = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (handlers) &#123; EleResize.removeHandler(ele, handler, context) if (handlers.length === 0) &#123; ele.detachEvent('onresize', EleResize.handleResize) delete ele.$resizeListeners &#125; &#125; &#125;&#125; else &#123; EleResize.on = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (!handlers) &#123; handlers = [] ele.$resizeListeners = handlers if (getComputedStyle(ele, null).position === 'static') &#123; ele.style.position = 'relative' &#125; EleResize.createResizeTrigger(ele) &#125; handlers.push(&#123; handler: handler, context: context &#125;) &#125; EleResize.off = function(ele, handler, context) &#123; var handlers = ele.$resizeListeners if (handlers) &#123; EleResize.removeHandler(ele, handler, context) if (handlers.length === 0) &#123; var trigger = ele.$resizeTrigger if (trigger) &#123; trigger.contentDocument.defaultView.removeEventListener( 'resize', EleResize.handleResize ) ele.removeChild(trigger) delete ele.$resizeTrigger &#125; delete ele.$resizeListeners &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"29、js下载文件","slug":"JavaScript/29、js下载文件","date":"2015-05-16T18:30:37.000Z","updated":"2020-08-07T14:10:11.776Z","comments":true,"path":"2015/05/17/JavaScript/29、js下载文件/","link":"","permalink":"https://www.zackaddy.xin/2015/05/17/JavaScript/29、js下载文件/","excerpt":"","text":"https://juejin.im/post/5c3c4b3551882524a5420119一般的形式1234567891011//表单方式直接下载文件//url表示要下载的文件路径,如:http://127.0.0.1/test.rarfunction downloadFile(url)&#123; var form=$(\"&lt;form&gt;\");//定义form表单,通过表单发送请求 form.attr(\"style\",\"display:none\");//设置为不显示 form.attr(\"target\",\"\"); form.attr(\"method\",\"get\");//设置请求类型 form.attr(\"action\",url);//设置请求路径 $(\"body\").append(form);//添加表单到页面(body)中 form.submit();//表单提交&#125; 通过a标签12345678910111213141516#FileReader方式var a = document.createElement('a'); if (a.click) &#123; var fr = new FileReader(); fr.onload = function(e) &#123; a.href = e.target.result; a.target = '_parent'; if ('download' in a) &#123; a.download = \"2 654.txt\"; &#125; (document.body || document.documentElement).appendChild(a); a.click(); a.parentNode.removeChild(a); &#125; fr.readAsDataURL(new Blob([\"Hello World!\"],&#123;type:\"text/plain\"&#125;)) &#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"28、创建数组方式","slug":"JavaScript/28、创建数组方式","date":"2015-05-16T00:22:08.000Z","updated":"2020-08-07T14:10:11.776Z","comments":true,"path":"2015/05/16/JavaScript/28、创建数组方式/","link":"","permalink":"https://www.zackaddy.xin/2015/05/16/JavaScript/28、创建数组方式/","excerpt":"","text":"目标1234function createArrayWith(length,value)&#123;...&#125;createArrayWith(2,3) =&gt; [3, 3]createArrayWith(2,&#123;test:2&#125;) =&gt; [&#123;test:2&#125;, &#123;test:2&#125;] 条件: 尽量的简洁 首先想到的是map12345function createArrayWith(length,value)&#123; return new Array(length).map(function()&#123; return value &#125;)&#125; 失败12createArrayWith(2,3) [ , ] 原因1map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values, including undefined. It is not called for missing elements of the array (that is, indexes that have never been set, which have been deleted or which have never been assigned a value). from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map 原来数组中的”空”元素,map(包括foreEach)都是不会去遍历处理的. 而只传一个参数new出来数组,每个元素都是空的 死磕map观察Array 构造函数的接口 12new Array(element0, element1[, ...[, elementN]])new Array(arrayLength) 可以用不定参数的方式来创建 用apply试试123456789function createArrayWith(length,value)&#123; return Array.apply(null,new Array(length)).map(function()&#123; return value &#125;)&#125;// 可行createArrayWith(2,3)[ 3, 3 ] 使用ES6的语法简化下123456function createArrayWith(length,value)&#123; return Array.apply(null,new Array(length)).map(()=&gt;value)&#125;createArrayWith(2,3)[ 3, 3 ] 好像new也可以去掉123456function createArrayWith(length,value)&#123; return Array.apply(null,Array(length)).map(()=&gt;value)&#125;createArrayWith(2,3)[ 3, 3 ] 到了这一步好像是最简洁的实现方式了,但是看起来是在太怪异了. ES6到底在MDN 过Array 方法的时候,发现了居然有这个一个函数 1arr.fill(value[, start = 0[, end = this.length]]) 顿时草泥马奔腾,原来ES6添加了这个新函数. 在ES6的环境下的话,最简洁的方式还是 123456function createArrayWith(length,value)&#123; return new Array(length).fill(value)&#125;createArrayWith(2,3)[ 3, 3 ]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"27、类型判断","slug":"JavaScript/27、类型判断","date":"2015-05-14T23:56:02.000Z","updated":"2020-08-07T14:10:11.776Z","comments":true,"path":"2015/05/15/JavaScript/27、类型判断/","link":"","permalink":"https://www.zackaddy.xin/2015/05/15/JavaScript/27、类型判断/","excerpt":"","text":"isFunction 判断是否是函数123var isFunction = function isFunction( obj ) &#123; return typeof obj === \"function\" &amp;&amp; typeof obj.nodeType !== \"number\"; &#125;; isWindow 判断是否是window对象123var isWindow = function isWindow( obj ) &#123; return obj != null &amp;&amp; obj === obj.window;&#125;; 受欢迎的类型检测1234567891011121314var class2type = &#123;&#125;\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ).forEach(function( i, name ) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();&#125;)function toType( obj ) &#123; if ( obj == null ) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225;+(function() &#123; Date.prototype.format = function(fmt) &#123; var o = &#123; \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) &#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); &#125; for(var k in o) &#123; if(new RegExp(\"(\"+ k +\")\").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); &#125; &#125; return fmt; &#125; Date.prototype.fullCurTime = function() &#123; this.setHours(23,59,59) return this &#125; Array.prototype.forEach = function forEach(callback) &#123; var len = this.length; if(typeof callback != \"function\") &#123; throw new TypeError(); &#125; var thisArg = arguments[1], flag = ''; for(var i = 0; i &lt; len;flag != 'pause'?i++:i) &#123; if(i in this) &#123; flag = callback.call(thisArg, this[i], i, this); &#125; &#125; &#125; !Array.isArray &amp;&amp; (Array.isArray = function(val) &#123; return Object.prototype.toString.call(val) === '[object Array]' &#125;) !Number.isNumber &amp;&amp; (Number.isNumber = function(val) &#123; return Object.prototype.toString.call(val) === '[object Number]' &#125;) Number.prototype.toFixed = function(s) &#123; var times = Math.pow(10,s) var des = this * times + 0.5 des = parseInt(des, 10) / times return des &#125; !String.isString &amp;&amp; (String.isString = function(val) &#123; return Object.prototype.toString.call(val) === '[object String]' &#125;) !Object.isObject &amp;&amp; (Object.isObject = function(val) &#123; return Object.prototype.toString.call(val) === '[object Object]' &#125;) !Function.isFunction &amp;&amp; (Function.isFunction = function(val) &#123; return Object.prototype.toString.call(val) === '[object Function]' &#125;) !Object.isDOM &amp;&amp; ( Object.isDOM = (typeof HTMLElement === 'object' ) ? function(obj)&#123; return obj instanceof HTMLElement; &#125; : function(obj)&#123; return obj &amp;&amp; typeof obj === 'object' &amp;&amp; obj.nodeType === 1 &amp;&amp; typeof obj.nodeName === 'string'; &#125; ) !Function.isFunction &amp;&amp; (Function.isFunction = function(val) &#123; return Object.prototype.toString.call(val) === '[object Function]' &#125;) !Object.isNotEmpty &amp;&amp; (Object.isNotEmpty = function(val) &#123; let ret = true if (String.isString(val) &amp;&amp; val.trim().length == 0) &#123; ret = false &#125; if (String.isString(val) &amp;&amp; val == 'NaN') &#123; ret = false &#125; if (val == undefined) &#123; ret = false &#125; if (val == null) &#123; ret = false &#125; if (Number.isNaN(val)) &#123; ret = false &#125; if (Number.isNumber(val) &amp;&amp; !Number.isFinite(val)) &#123; ret = false &#125; if (Object.isObject(val)) &#123; let f = false for (let i in val) &#123; f = true break &#125; ret = f &#125; if (Array.isArray(val) &amp;&amp; val.length == 0) &#123; ret = false &#125; return ret &#125;) !Object.isEmpty &amp;&amp; (Object.isEmpty = function(val) &#123; let ret = false if (String.isString(val) &amp;&amp; val.trim().length == 0) &#123; ret = true &#125; if (String.isString(val) &amp;&amp; val == 'NaN') &#123; ret = true &#125; if (val == undefined) &#123; ret = true &#125; if (val == null) &#123; ret = true &#125; if (Number.isNaN(val)) &#123; ret = true &#125; if (Number.isNumber(val) &amp;&amp; !Number.isFinite(val)) &#123; ret = true &#125; if (Object.isObject(val)) &#123; let f = true for (let i in val) &#123; f = false break &#125; ret = f &#125; if (Array.isArray(val) &amp;&amp; val.length == 0) &#123; ret = true &#125; return ret &#125;) !Object.rmNull &amp;&amp; (Object.rmNull = function(obj) &#123; for (let i in obj) &#123; if (obj[i] == null) &#123; obj[i] = &#123;&#125; &#125; else if(Object.isObject(obj[i]) || Array.isArray(obj[i]))&#123; Object.rmNull(obj[i]) &#125; &#125; &#125;) // 定义assign方法 !Object.assign &amp;&amp; (Object.defineProperty(Object, 'assign', &#123; enumerable: false, configurable: true, writable: true, value: function(target) &#123; // assign方法的第一个参数 'use strict'; // 第一个参数为空，则抛错 if (target === undefined || target === null) &#123; throw new TypeError('Cannot convert first argument to object'); &#125; var to = Object(target); // 遍历剩余所有参数 for (var i = 1; i &lt; arguments.length; i++) &#123; var nextSource = arguments[i]; // 参数为空，则跳过，继续下一个 if (nextSource === undefined || nextSource === null) &#123; continue; &#125; nextSource = Object(nextSource); // 获取改参数的所有key值，并遍历 var keysArray = Object.keys(nextSource); for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) &#123; var nextKey = keysArray[nextIndex]; var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey); // 如果不为空\b且可枚举，则直接浅拷贝赋值 if (desc !== undefined &amp;&amp; desc.enumerable) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; return to; &#125; &#125;)) function getType(obj)&#123; //tostring会返回对应不同的标签的构造函数 var toString = Object.prototype.toString; var map = &#123; '[object Boolean]' : 'boolean', '[object Number]' : 'number', '[object String]' : 'string', '[object Function]' : 'function', '[object Array]' : 'array', '[object Date]' : 'date', '[object RegExp]' : 'regExp', '[object Undefined]': 'undefined', '[object Null]' : 'null', '[object Object]' : 'object' &#125;; if(obj instanceof Element) &#123; return 'element'; &#125; return map[toString.call(obj)]; &#125; !Object.deepClone &amp;&amp; (Object.deepClone = function(data) &#123; var type = getType(data); var obj; if(type === 'array')&#123; obj = []; &#125; else if(type === 'object')&#123; obj = &#123;&#125;; &#125; else &#123; //不再具有下一层次 return data; &#125; if(type === 'array')&#123; for(var i = 0, len = data.length; i &lt; len; i++)&#123; obj.push(Object.deepClone(data[i])); &#125; &#125; else if(type === 'object')&#123; for(var key in data)&#123; obj[key] = Object.deepClone(data[key]); &#125; &#125; return obj; &#125;)&#125;)();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"26、截取html指定长度文本","slug":"JavaScript/26、截取html指定长度文本","date":"2015-05-13T16:26:23.000Z","updated":"2020-08-07T14:10:11.775Z","comments":true,"path":"2015/05/14/JavaScript/26、截取html指定长度文本/","link":"","permalink":"https://www.zackaddy.xin/2015/05/14/JavaScript/26、截取html指定长度文本/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109! function(e) &#123; if(\"object\" == typeof exports &amp;&amp; \"undefined\" != typeof module) &#123; module.exports = e($ || jQuery, global); &#125; else if(\"function\" == typeof define &amp;&amp; define.amd) &#123; define([\"jquery\"], e); &#125; else &#123; var f; \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self &amp;&amp; (f = self), e($ || jQuery, f) &#125;&#125;(function($, global) &#123; window = \"undefined\" == typeof global ? window : global; var retarr = [], outereg = /(&lt;(:?.|\\s)*?&gt;)((?:.|\\s)*)(&lt;\\/(:?.|\\s)*?&gt;)/im, closereg = /&lt;(img|input)[\\s\\S]*\\/?&gt;/im, maxlen, endtext; function abtainText(node) &#123; var df = document.createDocumentFragment(),child; while(child = node.firstChild) &#123; looptext(child); df.appendChild(child); &#125; return retarr.join(\"\"); &#125; function NodeType() &#123;&#125;; NodeType.El = 1;NodeType.TEXT = 3; looptext.isfor = true;looptext.iselp = false; function looptext(node) &#123; if(node.nodeType === NodeType.El) &#123; var ctag = closereg.exec(node.outerHTML); if(ctag) &#123; var tmt = ctag[0].trim(); var st = tmt.substring(0, tmt.length - 1); var et = ' /&gt;'; retarr.push(st + et); maxlen--; return void(0); &#125; var otag = outereg.exec(node.outerHTML); if(maxlen == 0) &#123; if(looptext.iselp == false) &#123; retarr.push(endtext); looptext.iselp = true &#125; return void 0; &#125; retarr.push(otag[1].trim()) for(var i = 0; i &lt; node.childNodes.length; i++) &#123; if(looptext.isfor) &#123; looptext(node.childNodes[i]); &#125; else &#123; break; &#125; &#125; retarr.push(otag[3].trim()); &#125; if(node.nodeType === NodeType.TEXT) &#123; var nodeval = node.nodeValue.trim(); if(nodeval.length == 0) &#123; return void 0 &#125; if(nodeval.length &gt; maxlen) &#123; if(looptext.iselp == false) &#123; var tpval = [nodeval.substr(0, maxlen), endtext].join(\"\"); looptext.iselp = true &#125; else &#123; var tpval = [nodeval.substr(0, maxlen)].join(\"\"); &#125; retarr.push(tpval); looptext.isfor = false; maxlen = 0; &#125; if(nodeval.length == maxlen) &#123; if(looptext.iselp == false) &#123; var tpval = [nodeval.substr(0, maxlen), endtext].join(\"\"); looptext.iselp = true &#125; else &#123; var tpval = [nodeval.substr(0, maxlen)].join(\"\"); &#125; retarr.push(tpval); maxlen = 0; &#125; if(nodeval.length &lt; maxlen) &#123; maxlen -= nodeval.length retarr.push(nodeval); &#125; &#125; &#125; $.fn.subHtml = function(length, text) &#123; var ret = [], outermatch, html; $(this).each(function(index, item) &#123; endtext = text || \"\", maxlen = length, retarr = [], looptext.isfor = true, looptext.iselp = false, outermatch = outereg.exec(item.outerHTML), html = abtainText(item), $(item).append(html), ret.push([outermatch[1], html, outermatch[3]].join(\"\")); &#125;); return ret &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"25、用于创建函数的库","slug":"JavaScript/25、用于创建函数的库","date":"2015-05-13T00:37:43.000Z","updated":"2020-08-07T14:10:11.775Z","comments":true,"path":"2015/05/13/JavaScript/25、用于创建函数的库/","link":"","permalink":"https://www.zackaddy.xin/2015/05/13/JavaScript/25、用于创建函数的库/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134! function(e) &#123; if(\"object\" == typeof exports &amp;&amp; \"undefined\" != typeof module) &#123; module.exports = e(global); &#125; else if(\"function\" == typeof define &amp;&amp; define.amd) &#123; define([], e); &#125; else &#123; var f; \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self &amp;&amp; (f = self), f.App = e(f) &#125;&#125;(function(global) &#123; window = \"undefined\" == typeof global ? window : global; var DI = (function() &#123; var getFuncParams = function(func) &#123; var matches = func.toString().match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m); if(matches &amp;&amp; matches.length &gt; 1) return matches[1].replace(/\\s+/, '').split(','); return []; &#125;, setFnParams = function(services, params) &#123; for(var i in params) &#123; params[i] = services[params[i]]; &#125; return params; &#125;; function Activitor(services, fn) &#123; var o = &#123;&#125;; fn.apply(o, setFnParams(services, getFuncParams(fn))); return o; &#125; return Activitor &#125;)(); var loader_cache = &#123;&#125;, Loader = function(name) &#123; if (loader_cache[name]) return loader_cache[name]; var moduleSet = &#123;&#125;; var $proxy = function() &#123;&#125;; var loader = &#123; modules: function() &#123; var o = &#123;&#125;; for (var m in moduleSet) &#123; o[m] = function ()&#123; return Loader(\"service\").use(m) &#125; &#125; return o &#125;, define: function(name, dependencies, fn) &#123; if(!moduleSet[name]) &#123; var module = &#123; name: name, dependencies: dependencies, fn: fn &#125;; moduleSet[name] = module; &#125; return moduleSet[name]; &#125;, use: function(name) &#123; var module = moduleSet[name]; if(!module.entity) &#123; var args = []; for(var i = 0; i &lt; module.dependencies.length; i++) &#123; if(moduleSet[module.dependencies[i]].entity) &#123; args.push(moduleSet[module.dependencies[i]].entity); &#125; else &#123; args.push(this.use(module.dependencies[i])); &#125; &#125; module.entity = module.fn.apply($proxy, args); &#125; return module.entity; &#125; &#125;; loader.define.amd = &#123; README: 'YEAH MAN!' &#125;; return loader_cache[name] = loader; &#125;; var App = (function() &#123; var Tpl = function(fn) &#123; var o = DI(Loader(\"service\").modules(), fn); o.init = o.init || function() &#123; throw new Error(\"必须实现init方法\") &#125;; o.init(); return o &#125;, Service = function(name, deps, fn) &#123; return Loader(\"service\").define(name, deps, fn) &#125;; return &#123; controller: function() &#123; return Tpl.apply(window, arguments); &#125;, service: Service &#125; &#125;)(); App.service(\"w\", [], function() &#123; console.log(this, \"this is w service\") return \"w object\" &#125;) App.service(\"ajax\", [], function() &#123; console.log(this, \"this is ajax service\") return \"ajax object\" &#125;) App.service(\"request\", [\"ajax\"], function(ajax) &#123; console.log(ajax) console.log(this, \"this is requestService\") return \"request obj\" &#125;) var a = App.controller(function(request) &#123; this.init = function() &#123; console.log(\"controller init\") console.log(request()) &#125; &#125;) return App;&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"24、公共js的第一种写法","slug":"JavaScript/24、公共js的第一种写法","date":"2015-05-11T23:56:45.000Z","updated":"2020-08-07T14:10:11.775Z","comments":true,"path":"2015/05/12/JavaScript/24、公共js的第一种写法/","link":"","permalink":"https://www.zackaddy.xin/2015/05/12/JavaScript/24、公共js的第一种写法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930! function(e) &#123; if(typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = e(); &#125; else if(\"function\" == typeof define &amp;&amp; define.amd) &#123; define([], e); &#125; else &#123; var f; \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self &amp;&amp; (f = self), f.$cm = e() &#125;&#125;(function()&#123; var indexPage = function() &#123; return &#123; init: function() &#123; &#125; &#125; &#125;.call(this) var loginPage = function() &#123; return &#123; init: function() &#123; &#125; &#125; &#125;.call(this) return &#123; indexPage: indexPage, loginPage: loginPage &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"22、实现双向数据绑定之vue版","slug":"JavaScript/22、实现双向数据绑定之vue版","date":"2015-05-11T02:02:29.000Z","updated":"2020-08-07T14:10:11.775Z","comments":true,"path":"2015/05/11/JavaScript/22、实现双向数据绑定之vue版/","link":"","permalink":"https://www.zackaddy.xin/2015/05/11/JavaScript/22、实现双向数据绑定之vue版/","excerpt":"","text":"进阶版 http://www.51xuediannao.com/javascript/mvvm_diy.html简单版如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 双向数据绑定 */var DataBinder = (function() &#123; function observe(obj, vm) &#123; Object.keys(obj).forEach(function(key) &#123; defineReactive(vm, key, obj[key]); &#125;); &#125; function defineReactive(obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function() &#123; // 添加订阅者watcher到主题对象Dep if(Dep.target) dep.addSub(Dep.target); return val &#125;, set: function(newVal) &#123; if(newVal === val) return val = newVal; // 作为发布者发出通知 dep.notify(); &#125; &#125;); &#125; function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment(); var child; while(child = node.firstChild) &#123; compile(child, vm); flag.appendChild(child); // 将子节点劫持到文档片段中 &#125; return flag; &#125; function compile(node, vm) &#123; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 节点类型为元素 if(node.nodeType === 1) &#123; for(var i = 0; i &lt; node.childNodes.length; i++) &#123; compile(node.childNodes[i], vm) &#125; var attr = node.attributes; // 解析属性 for(var i = 0; i &lt; attr.length; i++) &#123; if(attr[i].nodeName == 'im-model') &#123; var name = attr[i].nodeValue; // 获取v-model绑定的属性名 node.addEventListener('input', function(e) &#123; // 给相应的data属性赋值，进而触发该属性的set方法 vm[name] = e.target.value; &#125;); node.value = vm[name]; // 将data的值赋给该node node.removeAttribute('im-model'); new Watcher(vm, node, name, 'input'); &#125; &#125;; &#125; // 节点类型为text if(node.nodeType === 3) &#123; if(reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); &#125; &#125; &#125; function Watcher(vm, node, name, nodeType) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null; &#125; Watcher.prototype = &#123; update: function() &#123; this.get(); if(this.nodeType == 'text') &#123; this.node.nodeValue = this.value; &#125; if(this.nodeType == 'input') &#123; this.node.value = this.value; &#125; &#125;, // 获取data中的属性值 get: function() &#123; this.value = this.vm[this.name]; // 触发相应属性的get &#125; &#125; function Dep() &#123; this.subs = [] &#125; Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125; &#125;; function DataFactory(options) &#123; this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom = nodeToFragment($(id)[0], this); $(id)[0].appendChild(dom); &#125; return &#123; build: function(options) &#123; return new DataFactory(options); &#125; &#125;&#125;)();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"21、实现双向数据绑定之jquery","slug":"JavaScript/21、实现双向数据绑定之jquery","date":"2015-05-09T18:53:15.000Z","updated":"2020-08-07T14:10:11.774Z","comments":true,"path":"2015/05/10/JavaScript/21、实现双向数据绑定之jquery/","link":"","permalink":"https://www.zackaddy.xin/2015/05/10/JavaScript/21、实现双向数据绑定之jquery/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233function DataBinder( object_id ) &#123; // Use a jQuery object as simple PubSub var pubSub = jQuery(&#123;&#125;); // We expect a `data` element specifying the binding // in the form: data-bind-&lt;object_id&gt;=\"&lt;property_name&gt;\" var data_attr = \"bind-\" + object_id, message = object_id + \":change\"; // Listen to change events on elements with the data-binding attribute and proxy // them to the PubSub, so that the change is \"broadcasted\" to all connected objects jQuery( document ).on( \"change\", \"[data-\" + data_attr + \"]\", function( evt ) &#123; var $input = jQuery( this ); pubSub.trigger( message, [ $input.data( data_attr ), $input.val() ] ); &#125;); // PubSub propagates changes to all bound elements, setting value of // input tags or HTML content of other tags pubSub.on( message, function( evt, prop_name, new_val ) &#123; jQuery( \"[data-\" + data_attr + \"=\" + prop_name + \"]\" ).each( function() &#123; var $bound = jQuery( this ); if ( $bound.is(\"input, textarea, select\") ) &#123; $bound.val( new_val ); &#125; else &#123; $bound.html( new_val ); &#125; &#125;); &#125;); return pubSub;&#125; 12345678910111213141516171819202122232425262728function User( uid ) &#123; var binder = new DataBinder( uid ), user = &#123; attributes: &#123;&#125;, // The attribute setter publish changes using the DataBinder PubSub set: function( attr_name, val ) &#123; this.attributes[ attr_name ] = val; binder.trigger( uid + \":change\", [ attr_name, val, this ] ); &#125;, get: function( attr_name ) &#123; return this.attributes[ attr_name ]; &#125;, _binder: binder &#125;; // Subscribe to the PubSub binder.on( uid + \":change\", function( evt, attr_name, new_val, initiator ) &#123; if ( initiator !== user ) &#123; user.set( attr_name, new_val ); &#125; &#125;); return user;&#125; 123456// javascriptvar user = new User( 123 );user.set( \"name\", \"Wolfgang\" );// html&lt;input type=\"number\" data-bind-123=\"name\" /&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"20、base64编解码","slug":"JavaScript/20、base64编解码","date":"2015-05-08T19:15:28.000Z","updated":"2020-08-07T14:10:11.774Z","comments":true,"path":"2015/05/09/JavaScript/20、base64编解码/","link":"","permalink":"https://www.zackaddy.xin/2015/05/09/JavaScript/20、base64编解码/","excerpt":"","text":"什么是base64 base64是用规定的64种字符来表示任意二进制数据的一种编码格式 而且这64种字符均是可见字符，而之所以要是可见的是因为在不同设备上处理不可见字符时可能发生错误 通常，电子邮件数据、公钥证书会经常使用。 1234567编码规则我们知道单个字符一般用一个字节就可以表示(中文等其他特殊文字除外),而一个字节由8位二进制数构成。那么base64编码中,是将每6位二进制作为一个单位解析后参照字符集的索引就可以得到编码后的字符。举个例子:二进制数据：000001 000011编码后:BD 123456但是我们发现一个问题，就是我们单个字符是8位二进制,而base64编码时需要以6位二进制数位单位进行编码。那么多余的2位怎么去处理呢？看下面的栗子未编码的字符串:B对应的二进制数据: 010000 10对残缺的二进制进行补足:010000 100000 000000 000000编码后:Qg== 通过上面的栗子我们可以发现，base64编码时会将二进制通过在末尾补0的方式使其位数满足24的倍数。这样刚好能够编码出至少4个字符。从上面的栗子中我们可以看到=号的数量刚好是缺少2个字节数的数量，而g则是因为多余的2位二进制数补了4个0后编码成了g。所以我们就可以看到这样的编码了。如果还不理解再举一些栗子 1234567未编码的字符串:BD对应的二进制数据: 010000 100100 0100对残缺的二进制进行补足:010000 100100 010000 000000编码后:QkQ= 关于解码 这里不做详细解释，因为知道编码规则后，反过来就可以实现解码了。 原生JS实现其编码与解码 如果对JS熟悉的同学，可能会想到window对象的atob()和btoa()方法。但是只有在较新的游览器中才能使用，面对老的游览器，我们只能靠原生的JS自己造轮子了。 但是光知道编码原理一定够吗？这里依然存在两个问题: 如何将字符串解析成二进制数据如何对中文字符进行编码JS解析字符串为二进制数 12345678910111213141516#首先在页面中所有的字符串都是基于unicode编码的#然后js的字符串中刚好有charCodeAt()方法#返回指定字符的unicode编码对应的数值#这个数值就是二进制数表示的数值#我们只需要将其转换为二进制即可#熟悉c或者c++的同学可能会想到用不断的除2看余数的方式来求#出这个数的二进制表示#但是在JS已经有现成的方法了。var str = 'ABCD', i, len, result = '';for( i = 0 , len = str.length ; i &lt; len ; i++)&#123; result += str.charCodeAt(i).toString(2)&#125;console.log(result); 123编码中文字符网页中编码格式基本都是UTF-8,然而即便我们用UTF-8格式保存了HTML文件，但是其中的中文字符依然是以UTF-16的形式保存的。所以我们首先要对utf-16的汉字转为utf-8形式保存的汉字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129var Base64 = &#123; // private property _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", // public method for encoding encode: function(input) &#123; var output = \"\"; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i &lt; input.length) &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64; &#125; else if (isNaN(chr3)) &#123; enc4 = 64; &#125; output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); &#125; return output; &#125;, // public method for decoding decode: function(input) &#123; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i &lt; input.length) &#123; enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) &#123; output = output + String.fromCharCode(chr2); &#125; if (enc4 != 64) &#123; output = output + String.fromCharCode(chr3); &#125; &#125; output = Base64._utf8_decode(output); return output; &#125;, // private method for UTF-8 encoding _utf8_encode: function(string) &#123; string = string.replace(/\\r\\n/g, \"\\n\"); var utftext = \"\"; for (var n = 0; n &lt; string.length; n++) &#123; var c = string.charCodeAt(n); if (c &lt; 128) &#123; utftext += String.fromCharCode(c); &#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123; utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; else &#123; utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); &#125; &#125; return utftext; &#125;, // private method for UTF-8 decoding _utf8_decode: function(utftext) &#123; var string = \"\"; var i = 0; var c = c1 = c2 = 0; while (i &lt; utftext.length) &#123; c = utftext.charCodeAt(i); if (c &lt; 128) &#123; string += String.fromCharCode(c); i++; &#125; else if ((c &gt; 191) &amp;&amp; (c &lt; 224)) &#123; c2 = utftext.charCodeAt(i + 1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; &#125; else &#123; c2 = utftext.charCodeAt(i + 1); c3 = utftext.charCodeAt(i + 2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; &#125; &#125; return string; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"18、位移运算符","slug":"JavaScript/18、位移运算符","date":"2015-05-08T03:30:24.000Z","updated":"2020-08-07T14:10:11.774Z","comments":true,"path":"2015/05/08/JavaScript/18、位移运算符/","link":"","permalink":"https://www.zackaddy.xin/2015/05/08/JavaScript/18、位移运算符/","excerpt":"","text":"有符号位移运算符&gt;&gt; &lt;&lt; 12345678910111213141516171819#负数&gt;&gt;十进制: -2二进制: 1111 1111 1111 1111 1111 1111 1111 1110------------------------------------------------位移: -2 &gt;&gt; 1十进制: -1二进制: 1111 1111 1111 1111 1111 1111 1111 1111结果： 高位补1------------------------------------------------#正数&gt;&gt;十进制: 2二进制: 0000 0000 0000 0000 0000 0000 0000 0010-----------------------------------------------位移: 2 &gt;&gt; 1十进制: 1二进制: 0000 0000 0000 0000 0000 0000 0000 0001结果: 高位补0 无符号位移运算符&gt;&gt;&gt; 12345678910111213141516171819#负数&gt;&gt;&gt;十进制: -2二进制: 1111 1111 1111 1111 1111 1111 1111 1110-----------------------------------------------位移: -2 &gt;&gt;&gt; 1十进制: 2147483647二进制: 0111 1111 1111 1111 1111 1111 1111 1111结果： 高位补0------------------------------------------------#正数&gt;&gt;&gt;十进制: 2二进制: 0000 0000 0000 0000 0000 0000 0000 0010-----------------------------------------------位移: 2 &gt;&gt;&gt; 1十进制: 1二进制: 0000 0000 0000 0000 0000 0000 0000 0001结果: 高位补0 ps: 不存在&lt;&lt;&lt;这种运算符因为：在负数的时候（&gt;&gt; 与 &gt;&gt;&gt;）存在高位 补0还是1的情况而&lt;&lt;和&lt;&lt;&lt;都是低位补0","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"17、DataModel之实现java中的bean","slug":"JavaScript/17、DataModel之实现java中的bean","date":"2015-05-07T04:23:20.000Z","updated":"2020-08-07T14:10:11.773Z","comments":true,"path":"2015/05/07/JavaScript/17、DataModel之实现java中的bean/","link":"","permalink":"https://www.zackaddy.xin/2015/05/07/JavaScript/17、DataModel之实现java中的bean/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function ResponseChain(fn)&#123; this.fn = fn; this.success = null;&#125;ResponseChain.prototype.setNext = function(success_fn)&#123; return this.success = success_fn;&#125;;ResponseChain.prototype.transmit = function()&#123; var ret = this.fn.apply(this,arguments); if(ret===\"next\")&#123; return this.success&amp;&amp;this.success.transmit.apply(this.success,arguments); &#125; return ret;&#125;;ResponseChain.prototype.next = function()&#123; return this.success&amp;&amp;this.success.transmit.apply(this.success,arguments)&#125;;var DataModel = (function() &#123; var instance = null; var filedOptions = &#123;&#125;; var nameSpace = null; var isFirstLoad = false; function injectGetSet(filedName, setName, getName) &#123; this[nameSpace][setName] = function(v) &#123; var commonNameSpace = this.__nameSpace__; filedOptions[commonNameSpace][filedName] = v; if (filedOptions.hasOwnProperty('hook') &amp;&amp; filedOptions['hook'].hasOwnProperty('set') &amp;&amp; filedOptions['hook']['set'].hasOwnProperty(commonNameSpace + '$' + filedName)) &#123; filedOptions['hook']['set'][commonNameSpace + '$' + filedName](v); &#125; &#125; this[nameSpace][getName] = function() &#123; var commonNameSpace = this.__nameSpace__; var val = filedOptions[commonNameSpace][filedName]; if (filedOptions.hasOwnProperty('hook') &amp;&amp; filedOptions['hook'].hasOwnProperty('get') &amp;&amp; filedOptions['hook']['get'].hasOwnProperty(commonNameSpace + '$' + filedName)) &#123; filedOptions['hook']['get'][commonNameSpace + '$' + filedName](val); &#125; return val; &#125; &#125; function initGetSet() &#123; for(var field in filedOptions[nameSpace]) &#123; var firstLetter = field.substr(0, 1).toUpperCase(); var surplusLetter = field.substr(1, field.length - 1); var setName = ['set', firstLetter, surplusLetter].join(\"\"); var getName = ['get', firstLetter, surplusLetter].join(\"\"); injectGetSet.call(this, field, setName, getName); &#125; &#125; function initUtilsMethod() &#123; DataModel.getInstance = function() &#123; return instance; &#125;; DataModel.getFileds = function(namespace) &#123; if(!namespace) &#123; return filedOptions; &#125; else &#123; return filedOptions[namespace]; &#125; &#125;; DataModel.getFiledsName = function(namespace) &#123; var filedsName = []; if(!namespace) &#123; for(var i in filedOptions) &#123; filedsName.push(i); &#125; &#125; else &#123; for(var i in filedOptions[namespace]) &#123; filedsName.push(i); &#125; &#125; return filedsName; &#125;; DataModel.getFiledsValue = function(namespace) &#123; var filedsValue = []; if(!namespace) &#123; for(var i in filedOptions) &#123; filedsValue.push(filedOptions[i]); &#125; &#125; else &#123; for(var i in filedOptions[namespace]) &#123; filedsValue.push(filedOptions[namespace][i]); &#125; &#125; return filedsValue; &#125;; DataModel.toString = function(namespace) &#123; if(!namespace) &#123; return JSON.stringify(filedOptions); &#125; else &#123; return JSON.stringify(filedOptions[namespace]); &#125; &#125;; &#125; var validateParam = new ResponseChain(function(namespace,filedMap,t)&#123; if(namespace != null &amp;&amp; namespace != undefined &amp;&amp; !(Object.prototype.toString.call(namespace) === \"[object String]\")) &#123; throw new EvalError('第一个参数namespace,请传String类型.'); &#125; if(namespace == null || namespace == undefined) &#123; namespace = 'default'; &#125; if(filedMap != undefined &amp;&amp; filedMap != null &amp;&amp; !(Object.prototype.toString.call(filedMap) === \"[object Object]\")) &#123; throw new EvalError('第二个参数filedMap,请传Object类型.'); &#125; return this.next(namespace,filedMap,t); &#125;); var validateInstance = new ResponseChain(function(namespace,filedMap,t)&#123; if(!(t instanceof DataModel) &amp;&amp; instance == null) &#123; return new DataModel(namespace, filedMap); &#125; if(instance == null) &#123; instance = t; &#125; nameSpace = namespace; if(!instance.hasOwnProperty(nameSpace)) &#123; instance[nameSpace] = &#123;&#125;; &#125; return \"next\"; &#125;); var filedOptionsHandler = new ResponseChain(function(namespace,filedMap)&#123; if(!filedOptions.hasOwnProperty(nameSpace)) &#123; filedOptions[nameSpace] = &#123;&#125;; &#125; $.extend(true, filedOptions[nameSpace], filedMap); return \"next\"; &#125;); function isFirstLoadModule()&#123; if(!isFirstLoad)&#123; isFirstLoad = true; return true; &#125; return false; &#125; function cacheMethod()&#123; if(!isFirstLoadModule())&#123; return false; &#125; initUtilsMethod(); &#125; return function(namespace, filedMap) &#123; var inst_Space; validateParam.setNext(validateInstance).setNext(filedOptionsHandler); inst_Space = validateParam.transmit(namespace,filedMap,this); if (!!inst_Space) return inst_Space initGetSet.call(instance); instance[nameSpace].__nameSpace__ = nameSpace; cacheMethod(); return instance[nameSpace]; &#125;&#125;)();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"16、跨域之隐藏iframe无刷新提交","slug":"JavaScript/16、跨域之隐藏iframe无刷新提交","date":"2015-05-05T23:42:44.000Z","updated":"2020-08-07T14:10:11.773Z","comments":true,"path":"2015/05/06/JavaScript/16、跨域之隐藏iframe无刷新提交/","link":"","permalink":"https://www.zackaddy.xin/2015/05/06/JavaScript/16、跨域之隐藏iframe无刷新提交/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/* * 使用隐藏的iframe发送表单提交 * 依赖 jQuery或者 Zepto * options参数说明： url : api接口地址 （必填） type : 请求method（选填。默认值为get） data : 发送的data对象。（选填。默认为空） blank : 当前域下blank.html页面的url地址 （选填。默认值为当前页面路径下的blank.html。填写的是绝对路径） form : form表单DOM （选填。需要提交的form表单DOM） success : 表单提交成功后的回调函数，参数为返回的data数据 error : 表单提交失败后的回调函数 * 使用示例： var submitByIframe = PostByIframe.create(&#123; url: 'http://example.com/api', type: 'post', data: &#123; a: 12, b: 32 &#125;, blank: 'http://example.com/blamk.html', success: function(res) &#123; console.log(res); &#125;, error: function() &#123; alert('服务器错误！'); &#125; &#125;); // 发送请求 submitByIframe.submit(); * 注意事项： 1. 一定要有blank.html，且空白页内设置的document.domain 与 当前页的document.domain 一致； 2. 当前页一定要设置 document.domain； 3. 当前组件跨域只适合父域名相同的跨域接口间的访问； 4. 依赖jQuery或者Zepto，可兼容到IE7； */ var PostByIframe = (function (window, document, $) &#123; var PostByIframe = function (options) &#123; options = options || &#123;&#125;; this.options = options; this.data = options.data || &#123;&#125;; this.url = options.url; this.type = options.type || 'GET'; this.$form = options.form ? $(options.form) : null; this.success = options.success; this.error = options.error; this.formId = 'trick_post_form_' + PostByIframe.count; this.iframeId = 'trick_post_hidden_iframe_' + PostByIframe.count; this.blankUrl = 'blank/' &#125; PostByIframe.prototype = &#123; formatIframeHtml: function () &#123; var iframeHtml = '&lt;iframe id=\"' + this.iframeId + '\" name=\"' + this.iframeId + '\" src=\"' + this.blankUrl + '\" style=\"display:none\"&gt;&lt;/iframe&gt;'; return iframeHtml; &#125;, formatFormHtml: function () &#123; var self = this; var formHtml = '', inputHtml = '', data = this.data; formHtml += '&lt;form' + ' target=' + self.iframeId + ' method=' + self.type + ' id=' + self.formId + ' enctype=multipart/form-data' + ' style=\"display: none\"' + '&gt;'; inputHtml += '&lt;input type=\"hidden\" name=\"url\" value=\"' + self.blankUrl + '\"/&gt;'; for (var key in data) &#123; inputHtml += '&lt;input type=\"hidden\" name=\"' + key + '\" value=\"' + data[key] + '\"/&gt;'; &#125; formHtml += inputHtml; formHtml += '&lt;/form&gt;'; return formHtml; &#125;, init: function (cb) &#123; var self = this; // 插入隐藏的iframe和form var $body = $('body'), iframeHtml = self.formatIframeHtml(); $body.append(iframeHtml); self.$iframe = $('#' + self.iframeId); if (!self.$form) &#123; var formHtml = self.formatFormHtml(); $body.append(formHtml); self.$form = $('#' + self.formId); &#125; self.$iframe.unbind('load').on('load', function () &#123; cb &amp;&amp; cb(); &#125;); &#125;, // 从iframe的返回参数中获取返回值 getUrlValue: function (s) &#123; if (s.search(/#/) &gt; 0) &#123; s = s.slice(0, s.search(/#/)); &#125; var r = &#123;&#125;; if (s.search(/\\?/) &lt; 0) &#123; return r; &#125; var p = s.slice(s.search(/\\?/) + 1).split('&amp;'); for (var i = 0, j = p.length; i &lt; j; i++) &#123; var tmp = p[i].split('='); r[tmp[0]] = tmp[1]; &#125; return r; &#125;, // 绑定iframe的加载，获取加载返回值 bindSubmit: function () &#123; var self = this; var $iframe = self.$iframe; $iframe.unbind('load').on('load', function () &#123; var $iframe_text = $iframe.prop('contentWindow').document.getElementsByTagName('body')[0].innerText try &#123; var href = $iframe.prop('contentWindow').location.href; var res = self.getUrlValue(href); if (res) &#123; self.success &amp;&amp; self.success(res, JSON.parse($iframe_text)); &#125; else &#123; self.error &amp;&amp; self.error(); &#125; &#125; catch (err) &#123; self.error &amp;&amp; self.error(); &#125; &#125;); &#125;, // 提交表单 submit: function () &#123; var self = this; if (!self.isInited) &#123; self.init(function () &#123; self.isInited = true; self.bindSubmit(); self.submitForm(); &#125;); &#125; else &#123; self.submitForm(); &#125; &#125;, submitForm: function () &#123; this.$form.attr('action', this.url).submit(); &#125; &#125;; PostByIframe.count = 0; PostByIframe.create = function (options) &#123; var formSubmit = new PostByIframe(options); PostByIframe.count++; return formSubmit; &#125;; return PostByIframe; &#125;)(window, document, $);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"15、跨域之window.postMessage","slug":"JavaScript/15、跨域之window.postMessage","date":"2015-05-05T02:11:44.000Z","updated":"2020-08-07T14:10:11.773Z","comments":true,"path":"2015/05/05/JavaScript/15、跨域之window.postMessage/","link":"","permalink":"https://www.zackaddy.xin/2015/05/05/JavaScript/15、跨域之window.postMessage/","excerpt":"","text":"基本上，它就像是跨域的AJAX，但不是浏览器跟服务器之间交互，而是在两个客户端之间通信。让我们来看一下window.postMessage是如何工作的。除了IE6、IE7之外的所有浏览器都支持这个功能。 数据发送端 首先我们要做的是创建通信发起端，也就是数据源”source”。作为发起端，我们可以open一个新窗口，或创建一个iframe，往新窗口里发送数据，简单起见，我们每6秒钟发送一次，然后创建消息监听器，从目标窗口监听它反馈的信息。 123456789101112131415161718//弹出一个新窗口var domain = 'http://scriptandstyle.com';var myPopup = window.open(domain + '/windowPostMessageListener.html','myWindow');//周期性的发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI myPopup.postMessage(message,domain);&#125;,6000);//监听消息反馈window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://scriptandstyle.com') return; console.log('received response: ',event.data);&#125;,false); 如果是使用iframe，代码应该这样写： 1234567891011//捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); 数据接收端123456//响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); source – 消息源，消息的发送窗口/iframe。 origin – 消息源的URI(可能包含协议、域名和端口)，用来验证数据源。 data – 发送方发送给接收方的数据。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"14、兼容every","slug":"JavaScript/14、兼容every","date":"2015-05-03T19:00:22.000Z","updated":"2020-08-07T14:10:11.772Z","comments":true,"path":"2015/05/04/JavaScript/14、兼容every/","link":"","permalink":"https://www.zackaddy.xin/2015/05/04/JavaScript/14、兼容every/","excerpt":"","text":"every() every() 方法测试数组的所有元素是否都通过了指定函数的测试。every() 不会改变原数组。 语法：arr.every(callback[, thisArg]) 参数： callback ： 在数组每一项上执行的函数，接收三个参数：currentValue（当前项的值）、index（当前项的索引）和array（数组本身）； thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文； every() 方法为数组中的每个元素执行一次 callback 函数。只有所有元素都在callback函数中返回true才返回true，否则返回false。 兼容性：不兼容IE6～8。 根据some()的语法写出兼容IE6～8的写法如下： 1234567891011121314151617if (!Array.prototype.every) &#123; Array.prototype.every = function(callback) &#123; // 获取数组长度 var len = this.length; if(typeof callback != \"function\") &#123; throw new TypeError(); &#125; // thisArg为callback 函数的执行上下文环境 var thisArg = arguments[1]; for(var i = 0; i &lt; len; i++) &#123; if(i in this &amp;&amp; !callback.call(thisArg, this[i], i, this)) &#123; return false; &#125; &#125; return true; &#125;&#125; 调用示例： 123456789var arr = [1, 2, 3, 4, 3, 2, 5];var newArr = arr.every(function(ele, index, array)&#123; if(ele &lt; 3) &#123; return true; &#125;else &#123; return false; &#125;&#125;);alert(newArr); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"13、兼容some","slug":"JavaScript/13、兼容some","date":"2015-05-02T22:19:44.000Z","updated":"2020-08-07T14:10:11.771Z","comments":true,"path":"2015/05/03/JavaScript/13、兼容some/","link":"","permalink":"https://www.zackaddy.xin/2015/05/03/JavaScript/13、兼容some/","excerpt":"","text":"some() some() 方法测试数组中的某些元素是否通过了指定函数的测试。返回布尔值。some() 被调用时不会改变数组。 arr.some(callback[, thisArg]) 参数： callback ： 在数组每一项上执行的函数，接收三个参数：currentValue（当前项的值）、index（当前项的索引）和array（数组本身）； thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文； some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个true 的值。如果找到了这样一个值，some() 将返回 true。否则返回 false。 兼容性：不兼容IE6～8。 根据some()的语法写出兼容IE6～8的写法如下： 1234567891011121314151617if (!Array.prototype.some) &#123; Array.prototype.some = function(callback) &#123; // 获取数组长度 var len = this.length; if(typeof callback != \"function\") &#123; throw new TypeError(); &#125; // thisArg为callback 函数的执行上下文环境 var thisArg = arguments[1]; for(var i = 0; i &lt; len; i++) &#123; if(i in this &amp;&amp; callback.call(thisArg, this[i], i, this)) &#123; return true; &#125; &#125; return false; &#125;&#125; 调用示例： 123456789var arr = [1, 2, 3, 4, 3, 2, 5];var newArr = arr.some(function(ele, index, array)&#123; if(ele &lt; 2) &#123; return true; &#125;else &#123; return false; &#125;&#125;);alert(newArr); // true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"12、兼容filter","slug":"JavaScript/12、兼容filter","date":"2015-05-02T04:38:23.000Z","updated":"2020-08-07T14:10:11.771Z","comments":true,"path":"2015/05/02/JavaScript/12、兼容filter/","link":"","permalink":"https://www.zackaddy.xin/2015/05/02/JavaScript/12、兼容filter/","excerpt":"","text":"filter() filter() 方法利用所有通过指定函数测试的元素创建一个新的数组，并返回。 arr.filter(callback[, thisArg]) callback ： 在数组每一项上执行的函数，接收三个参数：currentValue（当前项的值）、index（当前项的索引）和array（数组本身）； thisArg ：可选参数。用来当作callback 函数内this的值的对象，即callback 函数的执行上下文； filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 “true” 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素只会被跳过，不会被包含在新数组中。filter 不会改变原数组。 兼容性：不兼容IE6～8。 根据filter()的语法写出兼容IE6～8的写法如下： 123456789101112131415161718192021if (!Array.prototype.filter) &#123; Array.prototype.filter = function(callback) &#123; // 获取数组长度 var len = this.length; if(typeof callback != \"function\") &#123; throw new TypeError(); &#125; // 创建新数组，用于承载经回调函数修改后的数组元素 var newArr = new Array(); // thisArg为callback 函数的执行上下文环境 var thisArg = arguments[1]; for(var i = 0; i &lt; len; i++) &#123; if(i in this) &#123; if(callback.call(thisArg, this[i], i, this)) &#123; newArr.push(this[i]); &#125; &#125; &#125; return newArr; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"11、兼容forEach","slug":"JavaScript/11、兼容forEach","date":"2015-05-01T01:05:17.000Z","updated":"2020-08-07T14:10:11.771Z","comments":true,"path":"2015/05/01/JavaScript/11、兼容forEach/","link":"","permalink":"https://www.zackaddy.xin/2015/05/01/JavaScript/11、兼容forEach/","excerpt":"","text":"forEach() forEach() 方法让数组的每一项都执行一次给定的函数。forEach()方法会修改原数组。 123456789101112131415161718if ( !Array.prototype.forEach) &#123; Array.prototype.forEach = function forEach(callback) &#123; // 获取数组长度 var len = this.length; if(typeof callback != \"function\") &#123; throw new TypeError(); &#125; // thisArg为callback 函数的执行上下文环境 var thisArg = arguments[1], flag = ''; for(var i = 0; i &lt; len;flag != 'pause'?i++:i) &#123; if(i in this) &#123; // callback函数接收三个参数：当前项的值、当前项的索引和数组本身 flag = callback.call(thisArg, this[i], i, this); &#125; &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"10、兼容map","slug":"JavaScript/10、兼容map","date":"2015-04-29T21:34:50.000Z","updated":"2020-08-07T14:10:11.771Z","comments":true,"path":"2015/04/30/JavaScript/10、兼容map/","link":"","permalink":"https://www.zackaddy.xin/2015/04/30/JavaScript/10、兼容map/","excerpt":"","text":"map() map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。 12345678910111213Array.prototype扩展可以让IE6-IE8浏览器也支持map方法：if (typeof Array.prototype.map != \"function\") &#123; Array.prototype.map = function (fn, context) &#123; var arr = []; if (typeof fn === \"function\") &#123; for (var k = 0, length = this.length; k &lt; length; k++) &#123; arr.push(fn.call(context, this[k], k, this)); &#125; &#125; return arr; &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"8、获取远程图片宽高","slug":"JavaScript/8、获取远程图片宽高","date":"2015-04-28T17:57:10.000Z","updated":"2020-08-07T14:10:11.798Z","comments":true,"path":"2015/04/29/JavaScript/8、获取远程图片宽高/","link":"","permalink":"https://www.zackaddy.xin/2015/04/29/JavaScript/8、获取远程图片宽高/","excerpt":"","text":"123456789101112loadImg(url, callback) &#123; var img = new Image() img.src = url if (img.complete) &#123; callback(img.width, img.height, url) &#125; else &#123; img.onload = function () &#123; callback(img.width, img.height, url) img.onload = null &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"7、手机端键盘遮挡问题","slug":"JavaScript/7、手机端键盘遮挡问题","date":"2015-04-28T00:33:35.000Z","updated":"2020-08-07T14:10:11.797Z","comments":true,"path":"2015/04/28/JavaScript/7、手机端键盘遮挡问题/","link":"","permalink":"https://www.zackaddy.xin/2015/04/28/JavaScript/7、手机端键盘遮挡问题/","excerpt":"","text":"1234567891011121314var inputFlag = falsevar inputTarget = null$('input').on('click', function () &#123; inputTarget = this; inputFlag = true;&#125;);$(window).on('resize', function()&#123; if (inputFlag) &#123; inputFlag = false inputTarget.scrollIntoView(false) //true为滚动到视图顶部 //false为滚动到视图底部 &#125;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"6、多环境下支持自己的js","slug":"JavaScript/6、多环境下支持自己的js","date":"2015-04-26T22:48:45.000Z","updated":"2020-08-07T14:10:11.797Z","comments":true,"path":"2015/04/27/JavaScript/6、多环境下支持自己的js/","link":"","permalink":"https://www.zackaddy.xin/2015/04/27/JavaScript/6、多环境下支持自己的js/","excerpt":"","text":"1234567891011121314!function(e) &#123; if(\"object\" == typeof exports &amp;&amp; \"undefined\" != typeof module) &#123; module.exports = e(); &#125; else if(\"function\" == typeof define &amp;&amp; define.amd) &#123; define([], e); &#125; else &#123; var f; \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self &amp;&amp; (f = self), f.Promise = e() &#125;&#125;(function() &#123; ...&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"5、加减号（+-）的用法","slug":"JavaScript/5、加减号（+-）的用法","date":"2015-04-26T00:02:07.000Z","updated":"2020-08-07T14:10:11.797Z","comments":true,"path":"2015/04/26/JavaScript/5、加减号（+-）的用法/","link":"","permalink":"https://www.zackaddy.xin/2015/04/26/JavaScript/5、加减号（+-）的用法/","excerpt":"","text":"加号的普通用法 1a = 1 + 2;#a==3 另一种用法,将表达式-右侧隐式转换成整形 1234a = -'':#a == 0a = -'1';#a == -1a = -'s';#a == NaNa = -'3s';#a == NaN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"4、函数的申明与执行","slug":"JavaScript/4、函数的申明与执行","date":"2015-04-24T18:55:10.000Z","updated":"2020-08-07T14:10:11.796Z","comments":true,"path":"2015/04/25/JavaScript/4、函数的申明与执行/","link":"","permalink":"https://www.zackaddy.xin/2015/04/25/JavaScript/4、函数的申明与执行/","excerpt":"","text":"是不是遇到过下面这种情况 12345function fn(val) &#123; console.log(val)&#125;fn()#如何让这种抒写方式更优雅看下面，选一个你喜欢的吧 1234let fn = function(v)&#123; console.log(v); return arguments.callee;&#125;(1) 1234let fn = (function(v)&#123; console.log(v); return arguments.callee;&#125;)(1) 1234function fn(v)&#123; console.log(v);&#125;(1)fn() ??undefined 低版本浏览器不兼容","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"3、float计算精确度解决","slug":"JavaScript/3、float计算精确度解决","date":"2015-04-23T20:34:14.000Z","updated":"2020-08-07T14:10:11.793Z","comments":true,"path":"2015/04/24/JavaScript/3、float计算精确度解决/","link":"","permalink":"https://www.zackaddy.xin/2015/04/24/JavaScript/3、float计算精确度解决/","excerpt":"","text":"12345678910111213141516先看一个实例：0.1 + 0.2 =？0.1 + 0.2 = 0.3？我们先来看一段 JS。console.log( 0.1+ 0.2);输出为 0.30000000000000004。wtf首先，我们要站在计算机的角度思考 0.1 + 0.2 这个看似小儿科的问题。我们知道，能被计算机读懂的是二进制，而不是十进制，所以我们先把 0.1 和 0.2 转换成二进制看看：0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）对于无限循环的小数，计算机会进行舍入处理。进行双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。 1234567// toFixed 修复function toFixed(num, s) &#123; var times = Math.pow(10, s) var des = num * times + 0.5 des = parseInt(des, 10) / times return des + ''&#125; 1234567891011121314151617181920212223242526272829303132//加法 Number.prototype.add = function(arg)&#123; var r1,r2,m; try&#123;r1=this.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (this*m+arg*m)/m &#125; //减法 Number.prototype.sub = function (arg)&#123; return this.add(-arg); &#125; //乘法 Number.prototype.mul = function (arg) &#123; var m=0,s1=this.toString(),s2=arg.toString(); try&#123;m+=s1.split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(\".\")[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(\".\",\"\"))*Number(s2.replace(\".\",\"\"))/Math.pow(10,m) &#125; //除法 Number.prototype.div = function (arg)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=this.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(this.toString().replace(\".\",\"\")) r2=Number(arg.toString().replace(\".\",\"\")) return (r1/r2)*pow(10,t2-t1); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 *** method ** * add / subtract / multiply /divide * * ** explame ** * 0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004） * 0.2 + 0.4 == 0.6000000000000001 （多了 0.0000000000001） * 19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002） * * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */var floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123;times: 1, num: 0&#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + '' var dotPos = strfi.indexOf('.') var len = strfi.substr(dotPos+1).length var times = Math.pow(10, len) var intNum = parseInt(floatNum * times + 0.5, 10) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case 'add': if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case 'subtract': if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case 'multiply': result = (n1 * n2) / (t1 * t2) return result case 'divide': result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, 'add') &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, 'subtract') &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, 'multiply') &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, 'divide') &#125; // exports return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"2、js淡隐淡出轮播图","slug":"JavaScript/2、js淡隐淡出轮播图","date":"2015-04-22T17:57:19.000Z","updated":"2020-08-07T14:10:11.776Z","comments":true,"path":"2015/04/23/JavaScript/2、js淡隐淡出轮播图/","link":"","permalink":"https://www.zackaddy.xin/2015/04/23/JavaScript/2、js淡隐淡出轮播图/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标准轮播图&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt; * &#123; padding: 0; margin: 0; list-style: none; font-family: \"微软雅黑\"; outline: none; &#125; .banner &#123; width: 720px; height: 480px; margin: 50px auto; position: relative; &#125; .img&gt;li &#123; position: absolute; transition: all 1s ease; opacity: 0; &#125; .order &#123; width: 100%; position: absolute; top: 430px; text-align: center; &#125; .order li &#123; display: inline-block; width: 20px; height: 20px; background: white; border-radius: 50%; margin: 0 15px; cursor: pointer; &#125; #img .on &#123; display: block; opacity: 1; &#125; #order .on &#123; background: chocolate; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"banner\" id=\"banner\"&gt; &lt;ul id=\"img\" class=\"img\"&gt; &lt;li class=\"on\"&gt;&lt;img src=\"./banner/banner1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./banner/banner2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./banner/banner3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./banner/banner4.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"order\" class=\"order\"&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var banner = document.getElementById('banner'); var img = document.getElementById('img'); var lis = img.getElementsByTagName('li'); var order = document.getElementById('order'); //根据上面图片的数量创建相应个数的焦点 for(i = 0; i &lt; lis.length; i++) &#123; var creLi = document.createElement('li'); order.appendChild(creLi); &#125; //获取焦点事件源，并将第一个添加类（class=\"on\"） var orderLis = order.getElementsByTagName('li'); orderLis[0].className = 'on'; //前期准备工作结束，开始正式的主要部分，让它动起来 var num = 0; var xh = null; function play(num) &#123; for(i = 0; i &lt; lis.length; i++) &#123; lis[i].className = ''; orderLis[i].className = ''; &#125; lis[num].className = 'on'; orderLis[num].className = 'on'; &#125; function next()&#123; num++; if(num &gt;= lis.length) &#123; num = 0; &#125; play(num); &#125; //自动播放 function autoPlay() &#123; xh = setInterval(function() &#123; next() &#125;, 1000); &#125; autoPlay() //添加鼠标移入暂停，移出继续轮播事件 banner.onmouseover = function() &#123; clearInterval(xh); xh = null; &#125; banner.onmouseout = function() &#123; autoPlay() &#125; for(i = 0; i &lt; orderLis.length; i++) &#123; orderLis[i].index = i; orderLis[i].onmouseover = function() &#123; num = this.index; play(this.index); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"1、js实现无缝滚动轮播图","slug":"JavaScript/1、js实现无缝滚动轮播图","date":"2015-04-22T04:57:42.000Z","updated":"2020-08-07T14:10:11.774Z","comments":true,"path":"2015/04/22/JavaScript/1、js实现无缝滚动轮播图/","link":"","permalink":"https://www.zackaddy.xin/2015/04/22/JavaScript/1、js实现无缝滚动轮播图/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标准轮播图&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 600px; height: 300px; overflow: hidden; margin: 100px auto; position: relative; &#125; img &#123; width: 600px; height: 300px; vertical-align: top; /*取消底边的3px */ &#125; ul &#123; width: 500%; height: 300px; list-style: none; position: absolute; left: 0; top: 0; &#125; ul li &#123; float: left; &#125; .btn span &#123; width: 30px; height: 50px; background: #4a4a4a; display: inline-block; position: absolute; text-align: center; line-height: 50px; font-size: 24px; opacity: 0.4; cursor: pointer; &#125; .btn span:hover &#123; opacity: 1; color: #fff; &#125; .btn .left &#123; left: 0; top: 125px; &#125; .btn .right &#123; right: 0; top: 125px; &#125; ol &#123; position: absolute; bottom: 20px; left: 40%; list-style: none; &#125; ol li &#123; width: 10px; height: 10px; border-radius: 10px; border: 1px solid #fff; float: left; margin: 0 4px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"box\" id=\"box\"&gt; &lt;ul id=\"inner-box\"&gt; &lt;li&gt;&lt;img src=\"banner/banner1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"banner/banner2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"banner/banner3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"banner/banner4.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"banner/banner1.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol id=\"ol\"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=\"btn\"&gt; &lt;span class=\"left\" id=\"left\"&gt;&lt;&lt;/span&gt; &lt;span class=\"right\" id=\"right\"&gt;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var oBox = document.getElementById(\"box\"); var oUl = document.getElementById(\"inner-box\"); var oLeft = document.getElementById(\"left\"); var oRight = document.getElementById(\"right\"); var cur = 0; //定义一个变量用于设置left值 var timer = null; //定义一个计时器 var target = 0; var timer1 = null; var i = 0; timer = setInterval(autoPlay, 2000); // 定义计时器每25毫秒执行一次 function autoPlay() &#123; //执行每次执行函数，left值减1 if(target &lt;= -400) &#123; cur = 0; target = -100; &#125; else &#123; target -= 100; &#125; sport(target); btnBottom(); &#125; oRight.onclick = function(argument) &#123; if(target &lt;= -400) &#123; cur = 0; target = -100; &#125; else &#123; target -= 100; &#125; sport(target); btnBottom(); &#125; oLeft.onclick = function(argument) &#123; if(target &gt; -100) &#123; cur -= 400; target = -300; &#125; else &#123; target += 100; &#125; sport(target); btnBottom(); &#125; // 增加下标显示效果 btnBottom(i) function btnBottom() &#123; i = -(target / 100); i == 4 ? i = 0 : i; var oOl = document.getElementById(\"ol\"); var oLi = oOl.getElementsByTagName(\"li\"); for(j = 0; j &lt; oLi.length; j++) &#123; oLi[j].style.background = ''; &#125; oLi[i].style.background = '#fff'; &#125; // 加点击事件 var oOl = document.getElementById(\"ol\"); var oLi = oOl.getElementsByTagName(\"li\"); for(j = 0; j &lt; oLi.length; j++) &#123; oLi[j].index = j oLi[j].onclick = function() &#123; target = -(this.index * 100); sport(target); btnBottom() &#125; &#125; function sport(tar) &#123; clearInterval(timer1); timer1 = setInterval(autoPlay, 30); //设置定时器每30毫秒执行一次 function autoPlay() &#123; if(cur == tar) &#123; clearInterval(timer1) //大于目标值时，清空计时器 &#125; else &#123; speed = (tar - cur) / 7; //计算速度 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); //取整 cur = cur + speed; oUl.style.left = cur + \"%\"; &#125; &#125; &#125; oBox.onmouseover = function() &#123; //移出时清除计时器 clearInterval(timer); &#125; oBox.onmouseout = function() &#123; //移入时开始计时器 timer = setInterval(autoPlay, 2000); &#125;&lt;/script&gt;&lt;/html&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.zackaddy.xin/categories/JavaScript/"}]},{"title":"22.0、函数对象适配器","slug":"STL/22.0、函数对象适配器","date":"2014-04-19T03:12:04.000Z","updated":"2020-08-07T14:10:11.891Z","comments":true,"path":"2014/04/19/STL/22.0、函数对象适配器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/19/STL/22.0、函数对象适配器/","excerpt":"","text":"绑定适配器 bind1st // 将参数绑定为函数的第一个参数 bind2nd // 将参数绑定为函数的第二个参数 12345678910struct myprint:public binary_function&lt;int, int, void&gt;&#123; void operator()(int v, int val) const &#123; cout &lt;&lt; v + val &lt;&lt; endl; &#125;&#125;;int main() &#123; vector&lt;int&gt; v&#123;12,16,56,98&#125;; for_each(v.begin(), v.end(), bind2nd(myprint(), 100)) return 0;&#125; 取反适配器 not1 对一元谓词取反 not2 对二元谓词取反 12345678910struct myprint:public binary_function&lt;int, int, bool&gt;&#123; bool operator()(int v1, int v2) const &#123; return v1 &gt; v2; &#125;&#125;;int main() &#123; vector&lt;int&gt; v&#123;12,16,56,98&#125;; sort(v.begin(), v.end(), not2(myprint())); return 0;&#125; 查询条件适配器1234567891011struct myprint:public unary_function&lt;int, bool&gt;&#123; bool operator()(int v) const &#123; return v &gt; 5; &#125;&#125;;int main() &#123; vector&lt;int&gt; v&#123;12,16,56,98&#125;; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), not1(myprint()) ); cout &lt;&lt; *it &lt;&lt; endl; return 0;&#125; 函数对象适配器12345void ptr_fun(int v1, int v2) &#123; &#125;vector&lt;int&gt; v&#123;12,16,56,98&#125;;for_each(v.begin(), v.end(), bind2nd(ptr_fun(myprint), 100)) 成员函数适配器 mem_fun // 存放对象指针用这个 mem_fun_ref // 存放对象用这个 1234567891011class Person&#123;public: void show() &#123;&#125;&#125;;vector&lt;Person*&gt; v;v.push_back(new Person())v.push_back(new Person())v.push_back(new Person())for_each(v.begin(), v.end(), mem_fun(&amp;Person::show))mem_fun(&amp;Person::show)(new Person()); 1234567891011class Person&#123;public: void show() &#123;&#125;&#125;;vector&lt;Person&gt; v;v.push_back(Person())v.push_back(Person())for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::show))Person p;mem_fun_ref(&amp;Person::show)(p);","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"21.0、内建函数对象","slug":"STL/21.0、内建函数对象","date":"2014-04-17T22:53:38.000Z","updated":"2020-08-07T14:10:11.891Z","comments":true,"path":"2014/04/18/STL/21.0、内建函数对象/","link":"","permalink":"https://www.zackaddy.xin/2014/04/18/STL/21.0、内建函数对象/","excerpt":"","text":"内建函数对象 使用内建函数对象，需引入头文件#include 算数类函数对象，除了negate是一元运算，其它都是二元运算123456template&lt;class T&gt; T plus&lt;T&gt; // 加法template&lt;class T&gt; T minute&lt;T&gt; // 减法template&lt;class T&gt; T multiplies&lt;T&gt; // 乘法template&lt;class T&gt; T divide&lt;T&gt; // 除法template&lt;class T&gt; T modulus&lt;T&gt; // 取模template&lt;class T&gt; T negate&lt;T&gt; // 取反 关系类函数运算符对象,都是二元运算123456template&lt;class T&gt; bool equal_to&lt;T&gt; // 等于template&lt;class T&gt; bool not_equal_to&lt;T&gt; // 不等于template&lt;class T&gt; bool greater&lt;T&gt; // 大于template&lt;class T&gt; bool greater_equal&lt;T&gt; // 大于等于template&lt;class T&gt; bool less&lt;T&gt; // 小于template&lt;class T&gt; bool less_equal&lt;T&gt; // 小于等于 逻辑类函数运算符对象，除了not都是二元运算123template&lt;class T&gt; bool logical_and&lt;T&gt; // 逻辑与template&lt;class T&gt; bool logical_or&lt;T&gt; // 逻辑或template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"20.0、函数对象","slug":"STL/20.0、函数对象","date":"2014-04-17T03:02:49.000Z","updated":"2020-08-07T14:10:11.891Z","comments":true,"path":"2014/04/17/STL/20.0、函数对象/","link":"","permalink":"https://www.zackaddy.xin/2014/04/17/STL/20.0、函数对象/","excerpt":"","text":"函数对象 如果一个类将()运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。 12345678910111213141516#include &lt;iostream&gt;using namespace std;class CAverage&#123;public: double operator()(int a1, int a2, int a3) &#123; //重载()运算符 return (double)(a1 + a2 + a3) / 3; &#125;&#125;;int main()&#123; CAverage average; //能够求三个整数平均数的函数对象 cout &lt;&lt; average(3, 2, 3); //等价于 cout &lt;&lt; average.operator(3, 2, 3); return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"19.0、容器元素的深拷贝和浅拷贝问题","slug":"STL/19.0、容器元素的深拷贝和浅拷贝问题","date":"2014-04-15T21:36:37.000Z","updated":"2020-08-07T14:10:11.890Z","comments":true,"path":"2014/04/16/STL/19.0、容器元素的深拷贝和浅拷贝问题/","link":"","permalink":"https://www.zackaddy.xin/2014/04/16/STL/19.0、容器元素的深拷贝和浅拷贝问题/","excerpt":"","text":"容器元素的深拷贝和浅拷贝问题STL容器所提供的都是值(value)寓意，而非引用(reference)寓意,也就是说当我们给容器中插入元素的时候容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中,也就说我们提供的元素必须能够被拷贝 ． 看下面的代码： 123456789101112131415161718192021222324252627282930313233//容器元素的深拷贝和浅拷贝问题#include \"pch.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;class CDemo&#123;public: CDemo() :str(NULL) &#123;&#125; ~CDemo() &#123; if (str) &#123; delete[] str; &#125; &#125; char* str; //指针，容易带来浅拷贝的问题&#125;;int main()&#123; CDemo d1; d1.str = new char[32]; strcpy_s(d1.str,strlen(\"trend micro\") + 1,\"trend micro\"); vector&lt;CDemo&gt;* a1 = new vector&lt;CDemo&gt;; a1-&gt;push_back(d1); //只是简单的值拷贝 delete a1; //同一块内存析构了两次 return 0;&#125; 这个程序在退出的时候会出现问题，重复delete同一片内存，程序崩溃。将析构函数修改如下，可以更加清楚的看到问题所在： 12345678910~CDemo()&#123; if (str) &#123; static int i = 0; cout &lt;&lt; \"&amp;CDemo\" &lt;&lt; i++ &lt;&lt; \"=\" &lt;&lt; (int*)this &lt;&lt; \",str = \" &lt;&lt; (int *)str &lt;&lt; endl; delete[] str; &#125; &#125; 也就是说，发生了CDemo类的两次析构，并且两次析构str所指向的同一内存地址空间（两次str的值相同）。问题出在哪里？有人认为vector对象指针能够自动析构，所以不需要调用delete a1，否则会造成两次析构对象。这种理解是不准确的，任何对象如果是通过new操作符申请了空间，必须显示的调用delete来销毁这个对象，所以delete a1这条语句是没有错误的。错误在于：在执行 a1-&gt;push_back(d1); //只是简单的值拷贝这条语句时，会调用CDemo的拷贝构造函数，虽然CDemo类中没有定义拷贝构造函数，但是编译器会为CDemo类构建一个默认的拷贝构造函数(浅拷贝)，正是这里出了问题，a1中的所有CDemo元素的str成员变量没有初始化，只有一个四字节(32位机)指针空间。 a1-&gt;push_back(d1); //只是简单的值拷贝这句话执行完之后，a1里的CDemo元素与d1是不同的对象，但是a1里的CDemo元素的str与d1.str指向的是同一块内存。局部变量“CDemo d1;”在main函数退出时，自动释放所占内存空间，前面已经调用过delete a1，已经把d1.str释放了，main函数退出时，又要释放掉已经释放掉的d1.str内存空间，所以程序最后崩溃。解决办法：给CDemo类添加一个拷贝构造函数即可 12345CDemo(const CDemo &amp;cd)&#123; this-&gt;str = new char[strlen(cd.str) + 1]; strcpy_s(str,strlen(cd.str) + 1,cd.str);&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"18.0、bitset类","slug":"STL/18.0、bitset类","date":"2014-04-14T17:56:18.000Z","updated":"2020-08-07T14:10:11.889Z","comments":true,"path":"2014/04/15/STL/18.0、bitset类/","link":"","permalink":"https://www.zackaddy.xin/2014/04/15/STL/18.0、bitset类/","excerpt":"","text":"bitset类bitset 模板类由若干个位（bit）组成，它提供一些成员函数，使程序员不必通过位运算就能很方便地访问、修改其中的任意一位。bitset 模板类在头文件 中定义如下： 12345template &lt;size_t N&gt;class bitset&#123; ...&#125;; size_t 可看作 unsigned int。将 bitset 实例化时，N 必须是一个整型常数。例如： 1bitset &lt;40&gt; bst; 则 bst 是一个由 40 个位组成的对象，用 bitset 的成员函数可以方便地访问其中任意一位。bitset 中的位从 0 开始编号，第 0 位是最右边的位。 bitset 有许多成员函数，有些成员函数执行的就是类似于位运算的操作。bitset 成员函数列表如下： bitset &amp; operator &amp;= (const bitset &amp; rhs); //和另一个 bitset 对象进行与操作 bitset &amp; operator |= (const bitset &amp; rhs); //和另一个 bitset 对象进行或操作 bitset &amp; operator ^= (const bitset &amp; rhs); //和另一个 bitset 对象进行异或操作 bitset &amp; operator &lt;&lt;= (size_t num); //左移 num 位 bitset &amp; operator &gt;&gt;= (size_t num); //右移 num 位 bitset &amp; set(); //将所有位全部设成 1 bitset &amp; set(size_t pos, bool val = true); //将第 pos 位设为 val bitset &amp; reset(); //将所有位全部设成0 bitset &amp; reset (size_t pos); //将第 pos 位设成 0 bitset &amp; flip(); //将所有位翻转（0变成1，1变成0） bitset &amp; flip(size_t pos); //翻转第 pos 位 reference operator[] (size_t pos); //返回对第 pos 位的引用 bool operator[] (size_t pos) const; //返回第 pos 位的值 reference at(size_t pos); //返回对第 pos 位的引用 bool at (size_t pos) const; //返回第 pos 位的值 unsigned long to_ulong() const; //将对象中的0、1串转换成整数 string to_string () const; //将对象中的0、1串转换成字符串（Visual Studio 支持，Dev C++ 不支持） size_t count() const; //计算 1 的个数 size_t size () const; //返回总位数 bool operator == (const bitset &amp; rhs) const; bool operator != (const bitset &amp; rhs) const; bool test(size_t pos) const; //测试第 pos 位是否为 1 bool any() const; //判断是否有某位为1 bool none() const; //判断是否全部为0 bitset operator &lt;&lt; (size_t pos) const; //返回左移 pos 位后的结果 bitset operator &gt;&gt; (size_t pos) const; //返回右移 pos 位后的结果 bitset operator ~ (); //返回取反后的结果 bitset operator &amp; (const bitset &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行与运算的结果 bitset operator | (const bitset &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行或运算的结果 bitset operator ^ (const bitset &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行异或运算的结果 下面的程序演示了 bitset 的用法。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;bitset&gt;#include &lt;string&gt;using namespace std;int main()&#123; bitset&lt;7&gt; bst1; bitset&lt;7&gt; bst2; cout &lt;&lt; \"1) \" &lt;&lt; bst1 &lt;&lt; endl; //输出 1) 0000000 bst1.set(0,1);//将第0位变成1，bst1变为 0000001 cout &lt;&lt; \"2) \" &lt;&lt; bst1 &lt;&lt; endl; //输出 2) 0000001 bst1 &lt;&lt;= 4; //左移4位，变为 0010000 cout &lt;&lt; \"3) \" &lt;&lt; bst1 &lt;&lt; endl; //输出 3) 0010000 bst2.set(2);//第二位设置为1，bst2变成 0000100 bst2 |=bst1; // bst2变成 0010100 cout &lt;&lt; \"4) \" &lt;&lt; bst2 &lt;&lt; endl; //输出 4) 0010100 cout &lt;&lt; \"5) \" &lt;&lt; bst2.to_ulong () &lt;&lt; endl; //输出 5) 20 bst2.flip(); //每一位都取反，bst2变成 1101011 bst1.set(3); //bst1变成 0011000 bst2.flip(6); //bst2变成 0101011 bitset&lt;7&gt; bst3 = bst2^ bst1;//bst3 变成 0110011 cout &lt;&lt; \"6) \" &lt;&lt; bst3 &lt;&lt; endl; //输出 6) 0110011 cout &lt;&lt; \"7) \" &lt;&lt; bst3[3] &lt;&lt; \",\" &lt;&lt; bst3[4] &lt;&lt; endl; //输出 7) 0,1 return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"17.0、容器使用场景","slug":"STL/17.0、容器使用场景","date":"2014-04-14T03:18:03.000Z","updated":"2020-08-07T14:10:11.889Z","comments":true,"path":"2014/04/14/STL/17.0、容器使用场景/","link":"","permalink":"https://www.zackaddy.xin/2014/04/14/STL/17.0、容器使用场景/","excerpt":"","text":"| vector | deque | list | set | multiset | map | multimap 典型内存结构 | 单端数组 | 双端数组 | 双向列表 | 二叉树 | 二叉树 | 二叉树 | 二叉树可随机存取 | 是 | 是 | 否 | 否 | 否 | 对key而言：是 | 否元素搜寻速度 | 慢 | 慢 | 非常慢 | 快 | 快 | 对key而言：快 | 对key而言：快元素安插移除 | 尾端 | 头尾两端 | 任何位置 | - | - | - | - vector的使用场景 1.例如软件的历史操作存储，不需要删除，只是查看，查看上次、上上次 deque的使用场景 1.例如排队购票，头部快速移除，尾端快速添加 ==vector.at 比 deque.at()的效率高== ==有大量释放操作，vector花的时间更少== set的使用场景 1.例如手机游戏的个人得分记录存储，从高往低 map的使用场景 1.例如按ID存储10万用户","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"16.0、multimap容器","slug":"STL/16.0、multimap容器","date":"2014-04-12T23:13:29.000Z","updated":"2020-08-07T14:10:11.889Z","comments":true,"path":"2014/04/13/STL/16.0、multimap容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/13/STL/16.0、multimap容器/","excerpt":"","text":"multimap容器 multimap 是关联容器的一种，multimap 的每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的，并且允许有多个元素的关键字相同。 注意，不能直接修改 multimap 容器中的关键字。因为 multimap 中的元素是按照关键字排序的，当关键字被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。 multimap 的成员函数成员函数或成员函数模板 | 作 用 iterator find( const Key &amp; val); | 在容器中查找关键字等于 val 的元素，返回其迭代器；如果找不到，返回 end()iterator insert (pair &lt;Key, T&gt; const &amp;p); | 将 pair 对象 p 插入容器中并返回其迭代器void insert(iterator first, iterator last); | 将区间 [first, last) 插入容器int count( const Key &amp; val); | 统计有多少个元素的关键字和 val 相等iterator lower_bound( const Key &amp; val); | 查找一个最大的位置 it，使得 [begin( ), it) 中所有的元素的关键字都比 val 小iterator upper_bound(const Key &amp; val); | 查找一个最小的位置 it，使得 [it, end()) 中所有的元素的关键字都比 val 大pair &lt; iterator, iterator &gt; equal_range (const Key &amp; val); | 同时求得 lower_bound 和 upper_bounditerator erase(iterator it); | 删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）iterator erase(iterator first, iterator last); | 删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样） 代码示例12345678910111213141516171819202122232425262728#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[]) &#123; multimap&lt;int, string&gt; m; //multimap的插入只能用insert()不能用数组 m.insert(pair&lt;int, string&gt;(1, \"apple\")); m.insert(pair&lt;int, string&gt;(1, \"pear\"));//apple和pear的价钱完全有可能是一样的 m.insert(pair&lt;int, string&gt;(2, \"banana\")); //multimap的遍历只能用迭代器方式不能用数组 cout &lt;&lt; \"***************************************\" &lt;&lt; endl; multimap&lt;int, string&gt;::iterator i, iend; iend = m.end(); for (i = m.begin(); i != iend; i++) &#123; cout &lt;&lt; (*i).second &lt;&lt; \"的价钱是\" &lt;&lt; (*i).first &lt;&lt; \"元/斤\"; &#125; system(\"pause\"); return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"15.0、pair对组","slug":"STL/15.0、pair对组","date":"2014-04-12T03:03:30.000Z","updated":"2020-08-07T14:10:11.889Z","comments":true,"path":"2014/04/12/STL/15.0、pair对组/","link":"","permalink":"https://www.zackaddy.xin/2014/04/12/STL/15.0、pair对组/","excerpt":"","text":"类模板：template&lt;class T1,class T2&gt; struct pair 参数：T1是第一个值得数据类型，T2是第二个值的数据类型。 功能：pair将一对值组合成一个值， 这一对值可以具有不同的数据类型（T1和T2）， 两个值可以分别用pair的两个公有函数first和second访问。具体用法： 1.定义（构造）： 12345pair&lt;int ,double&gt; p1;//默认构造函数pair&lt;int ,double&gt; p2(1, 2.4);//用给定值初始化pair&lt;int ,double&gt; p3(p2);//拷贝构造函数 2.访问两个元素（通过first和second）： 123456789pair&lt;int ,double&gt; p1;p1.first = 1;p1.second = 2.5;cout&lt;&lt;p1.first&lt;&lt;' '&lt;&lt;p1.second&lt;&lt;endl;//输出结果：1 2.5 3.赋值operator = ： 1234567（1）利用make_pair:pair&lt;int ,double&gt; p1;p1 = make_pair(1, 1.2);（2）变量间赋值：pair&lt;int , double&gt; p1(1, 1.2);pair&lt;int,double&gt; p1 = p1;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"15.0、STL关联容器","slug":"STL/15.0、STL关联容器","date":"2014-04-11T03:52:18.000Z","updated":"2020-08-07T14:10:11.888Z","comments":true,"path":"2014/04/11/STL/15.0、STL关联容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/11/STL/15.0、STL关联容器/","excerpt":"","text":"STL关联容器关联容器内部的元素都是排好序的，有以下四种。 set：排好序的集合，不允许有相同元素。 multiset：排好序的集合，允许有相同元素。 map：每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的。不允许有多个元素的关键字相同。 multimap：和 map 类似，差别在于元素的关键字可以相同。 不能修改 set 或 multiset容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 set 或 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。 不能修改 map 和 multimap 容器中元素的关键字关联容器内部的元素或关键字之间比较大小可以用&lt;运算符，也可以用自定义的比较器。因为有序，所以在关联容器上进行查找的速度较快。 使用关联容器的目的也就在于快速查找。当一个元素被插入关联容器时，该元素会和已有的元素进行比较，最终被插入一个合适的位置。 在关联容器中查找元素和插入元素的时间复杂度都是 O(log(n))。从 begin() 到 end() 遍历整个关联容器，就是从小到大遍历整个容器。 在排好序的 vector 和 deque 上进行折半查找，时间复杂度也可以是 O(log(n))。但是，对于插入、删除和查询交替进行的情况，使用 vector 和 deque 的效率不高。因为它们上面的插入和删除操作会引起元素的移动，时间复杂度是 O(n)。 关联容器一般是用平衡二叉树实现的。平衡二叉树的原理属于“数据结构”课程的内容，本教程不做介绍。 除了所有容器共有的成员函数外，关联容器还具有以下成员函数： find：查找某个值。 lower_bound：查找某个下界。 upper_bound：查找某个上界。 equal_range：同时查找上界和下界。 count：计算等于某个值的元素个数。 insert：插人一个元素或一个区间。","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"14.0、multiset容器","slug":"STL/14.0、multiset容器","date":"2014-04-10T00:04:11.000Z","updated":"2020-08-07T14:10:11.888Z","comments":true,"path":"2014/04/10/STL/14.0、multiset容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/10/STL/14.0、multiset容器/","excerpt":"","text":"multiset容器 multiset 是关联容器的一种，是排序好的集合（元素已经进行了排序），并且允许有相同的元素。 不能直接修改 multiset 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。 multiset 的成员函数成员函数或成员函数模板 | 作 用 iterator find (const T &amp; val); | 在容器中查找值为 val 的元素，返回其迭代器。如果找不到，返 回 end()iterator insert( const T &amp; val); | 将 val 插入容器中并返回其迭代器void insert(iterator first, iterator last); | 将区间 [first, last) 中的元素插人容器int count( const T &amp; val); | 将 val 统计有多少个元素的值和 val 相等iterator lower_bound( const T &amp; val); | 查找一个最大的位置 it，使得 [begin(), it) 中所有的元素者比 val 小iterator upper_bound( const T &amp; val); | 查找一个最小的位置 it，使得 [it, end()) 中所有的元素都比 val 大pair &lt;iterator, iterator &gt; equal_range (const T &amp; val); | 同时求得 lower_bound 和 upper_bounditerator erase(iterator it); | 删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）iterator erase(iterator first, iterator last); | 删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样） ==&lt;运算符必须经过适当重载，才可以向 multiset 容器中插人元素。== 下面的程序 会编译出错： 1234567#include &lt;set&gt;using namespace std;class A&#123;&#125;;int main()&#123; multiset &lt;A&gt; a; a.insert( A() ); //编译出错，因为不能用“&lt;”运算符比较两个A对象&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"13.0、set容器","slug":"STL/13.0、set容器","date":"2014-04-09T01:10:18.000Z","updated":"2020-08-07T14:10:11.888Z","comments":true,"path":"2014/04/09/STL/13.0、set容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/09/STL/13.0、set容器/","excerpt":"","text":"set容器特性 1.set是关联容器，类似于集合，里面的元素不会重复，而且呈现为有序性 2.默认排序从小到大 改变默认排序1234567class compare&#123;public: bool operator()(int a, int b) &#123; return a &gt; b; &#125;&#125;set&lt;int, compare&gt; s; set容器操作 构造方法 123set&lt;int&gt;(begin, first)set&lt;int&gt; s1(s2)set&lt;int&gt; s1 赋值操作 12=s1.swap(s2) 大小操作 12size()empty() 插入操作 1insert(el) 删除操作 1234clear()erase(pos)erase(begin, end)erase(el) 查找操作 12345678find(key)lower_bound(keyel) // 查找list内第一个&gt;=keyel的元素 返回迭代器upper_bound(keyel)// 查找list内第一个&gt;keyel的元素 返回迭代器pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt; p = s.equal_range(keyel)p.first p.second//返回list内第一个&gt;=keyel的元素 返回迭代器与list内第一个&gt;keyel的元素 返回迭代器 代码示例123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;set&gt; //使用set须包含此文件using namespace std;int main()&#123; typedef set&lt;int&gt;::iterator IT; int a[5] = &#123; 3,4,6,1,2 &#125;; set&lt;int&gt; st(a,a+5); // st里是 1 2 3 4 6 pair&lt; IT,bool&gt; result; result = st.insert(5); // st变成 1 2 3 4 5 6 if(result.second) //插入成功则输出被插入元素 cout &lt;&lt; * result.first &lt;&lt; \" inserted\" &lt;&lt; endl; //输出: 5 inserted if(st.insert(5).second) cout &lt;&lt; * result.first &lt;&lt; endl; else cout &lt;&lt; * result.first &lt;&lt; \" already exists\" &lt;&lt; endl; //输出 5 already exists pair&lt;IT,IT&gt; bounds = st.equal_range(4); cout &lt;&lt; * bounds.first &lt;&lt; \",\" &lt;&lt; * bounds.second ; //输出：4,5 return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"12.0、map容器","slug":"STL/12.0、map容器","date":"2014-04-08T03:13:42.000Z","updated":"2020-08-07T14:10:11.887Z","comments":true,"path":"2014/04/08/STL/12.0、map容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/08/STL/12.0、map容器/","excerpt":"","text":"map容器特性 1.map是关联容器，类似于集合，里面的key不会重复，而且呈现为有序性 2.增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响 3.查找节点很快，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。 4.存储按key值排从小到大存储map排序1234567891011121314151617181920212223class A &#123;public: A(const int id, const string name):id(id), name(name) &#123;&#125; bool operator&lt;(const A&amp; g)const &#123; return this-&gt;id &gt; g.id; &#125;public: int id; string name;&#125;;struct compare&#123; bool operator()(A a, A b)const &#123; return a.id &gt; b.id; &#125; &#125;;//选第一个map&lt;A, int&gt; mm;mm.insert(pair&lt;A, int&gt;(A(6, \"herghost\"), 80));map&lt;A, int&gt;::iterator p = mm.find(A(6, \"herghost\"));cout &lt;&lt; p-&gt;second &lt;&lt; endl; // 80//选第二个map&lt;A, int, compare&gt; map容器操作 构造方法 12map&lt;T1,T2&gt; m;map(const map &amp;mp); 常用赋值操作 123=m1.swap(m2)//交换 大小操作 12size() // 元素个数empty() 插入元素操作 123456789m.insert(pair&lt;int, string&gt;(3, \"xdsdsa\"))m.insert(make_pair(1, \"dasa\"))m.insert(map&lt;int, string&gt;::value_type(1, \"xcz\"))//insert 时，当key存在则不插入，如下pair&lt;map&lt;int, int&gt;::iterator, bool&gt; Insert_Pair;Insert_Pair = m.insert(pair&lt;int, int&gt;(5, 7));cout &lt;&lt; Insert_Pair.first-&gt;first &lt;&lt; \":\" &lt;&lt; Insert_Pair.second &lt;&lt; endl;m[1] = \"54546\" 删除操作 1234clear()erase(pos)erase(begin, end)erase(key) 查找操作 12345find(key)count(key)lower_bound(key)upper_bound(key)equal_range(key)","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"11.0、vector VS. list VS. deque","slug":"STL/11.0、vector VS. list VS. deque","date":"2014-04-06T22:32:41.000Z","updated":"2020-08-07T14:10:11.887Z","comments":true,"path":"2014/04/07/STL/11.0、vector VS. list VS. deque/","link":"","permalink":"https://www.zackaddy.xin/2014/04/07/STL/11.0、vector VS. list VS. deque/","excerpt":"","text":"a、若需要随机访问操作，则选择vector； b、若已经知道需要存储元素的数目，则选择vector； c、若需要随机插入/删除（不仅仅在两端），则选择list d、只有需要在首端进行插入/删除操作的时候，还要兼顾随机访问效率，才选择deque，否则都选择vector。 e、若既需要随机插入/删除，又需要随机访问，则需要在vector与list间做个折中-deque。 f、当要存储的是大型负责类对象时，list要优于vector；当然这时候也可以用vector来存储指向对象的指针，同样会取得较高的效率，但是指针的维护非常容易出错，因此不推荐使用。","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"10.0、list容器","slug":"STL/10.0、list容器","date":"2014-04-06T03:02:33.000Z","updated":"2020-08-07T14:10:11.887Z","comments":true,"path":"2014/04/06/STL/10.0、list容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/06/STL/10.0、list容器/","excerpt":"","text":"list容器特性 1.内存空间是不连续的 优点： (1) 不使用连续内存完成动态操作。 (2) 在内部方便的进行插入和删除操作 (3) 可在两端进行push、pop 缺点： (1) 不能进行内部的随机访问，即不支持[ ]操作符和list.at() (2) 相对于verctor占用内存多 list操作 构造方法 1234list&lt;int&gt;a&#123;1,2,3&#125;list&lt;int&gt;a(n) //声明一个n个元素的列表，每个元素都是0list&lt;int&gt;a(n, m) //声明一个n个元素的列表，每个元素都是mlist&lt;int&gt;a(first, last) //声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素，first和last是迭代器 插入操作 12345678910push_front(el) //容器头部插入一个元素push_back(el)//容器尾部插入一个元素insert(pos, el)//在pos下标插入元素insert(pos, n, el)//在pos下标插入n个元素insert(pos, begin, end)//在pos下标插入迭代器begin与end之间的元素 删除操作 123456789101112pop_back()//删除尾部元素pop_front()//删除头部元素erase(begin, end)//删除迭代器begin与end之间的元素erase(pos)//删除pos位置的元素clear()//删除所有元素remove(el)//删除所有指定的元素 大小操作 12345678size()//容器元素个数empty()//容器是否为空resize(num)//重新指定容器长度resize(num, el)//重新指定容器长度,容器变长用el填充 赋值操作 123456assign(beg,end) //将[beg; end)区间中的数据赋值给list。assign(n,elem) //将n个elem的拷贝赋值给list。l1.swap(l2) //交换容器l1和l2中的所有元素。 元素反转与排序 1234567reverse()sort()bool fn(int a, int b) &#123; return a &gt; b;&#125;list.sort(fn)","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"9.0、priority_queue容器","slug":"STL/9.0、priority_queue容器","date":"2014-04-04T19:36:39.000Z","updated":"2020-08-07T14:10:11.893Z","comments":true,"path":"2014/04/05/STL/9.0、priority_queue容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/05/STL/9.0、priority_queue容器/","excerpt":"","text":"priority_queue容器 priority_queue 是“优先队列”。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行 pop 操作时，删除的总是最大的元素；执行 top 操作时，返回的是最大元素的引用。 priority_queue 可以用 vector 和 deque 实现，默认情况下用 vector 实现。 priority_queue 默认的元素比较器是 less 。也就是说，在默认情况下，要放入 priority_queue 的元素必须是能用“&lt;”运算符进行比较的，而且 priority _queue 保证以下条件总是成立：对于队头的元素 x 和任意非队头的元素 y，表达式“x&lt;y”必为 false。 定义：priority_queue&lt;Type, Container, Functional&gt; Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆 一般是： 123456//升序队列priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） 代码示例123456789101112131415161718192021#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; priority_queue&lt;double&gt; pq1; pq1.push(3.2); pq1.push(9.8); pq1.push(9.8); pq1.push(5.4); while(!pq1.empty()) &#123; cout &lt;&lt; pq1.top() &lt;&lt; \" \"; pq1.pop(); &#125; //上面输出 9.8 9.8 5.4 3.2 cout &lt;&lt; endl; priority_queue&lt;double,vector&lt;double&gt;,greater&lt;double&gt; &gt; pq2; pq2.push(3.2); pq2.push(9.8); pq2.push(9.8); pq2.push(5.4); while(!pq2.empty()) &#123; cout &lt;&lt; pq2.top() &lt;&lt; \" \"; pq2.pop(); &#125; //上面输出 3.2 5.4 9.8 9.8 return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"8.0、queue容器","slug":"STL/8.0、queue容器","date":"2014-04-04T02:24:16.000Z","updated":"2020-08-07T14:10:11.892Z","comments":true,"path":"2014/04/04/STL/8.0、queue容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/04/STL/8.0、queue容器/","excerpt":"","text":"queue容器特性 1.先进先出原则 2.不能遍历，不能随机存取，只能通过top从栈顶获得、删除元素 3.容器为空top会报错，不会抛出异常 queue操作 构造方法 12queue&lt;T&gt; q;queue(const queue &amp;q); 其余操作 1234567891011121314q = q1;// 赋值back()//返回最后一个元素empty()//如果队列空则返回真front()//返回第一个元素pop()//删除第一个元素push()//在末尾加入一个元素size()//返回队列中元素的个数","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"7.0、stack容器","slug":"STL/7.0、stack容器","date":"2014-04-02T19:23:11.000Z","updated":"2020-08-07T14:10:11.892Z","comments":true,"path":"2014/04/03/STL/7.0、stack容器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/03/STL/7.0、stack容器/","excerpt":"","text":"stack容器特性 1.先进后出原则 2.不能遍历，不能随机存取，只能通过top从栈顶获得、删除元素 3.容器为空top会报错，不会抛出异常 stack操作 构造方法 12stack&lt;T&gt; s;stack(const stack &amp;stk); 其余操作 123456789101112s = s1;// 赋值empty()//堆栈为空则返回真pop()//移除栈顶元素push()//在栈顶增加元素size()//返回栈中元素数目top()//返回栈顶元素","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"6.0、容器适配器","slug":"STL/6.0、容器适配器","date":"2014-04-01T17:25:30.000Z","updated":"2020-08-07T14:10:11.892Z","comments":true,"path":"2014/04/02/STL/6.0、容器适配器/","link":"","permalink":"https://www.zackaddy.xin/2014/04/02/STL/6.0、容器适配器/","excerpt":"","text":"容器适配器STL 中的容器适配器有 stack、queue、priority_queue 三种。它们都是在顺序容器的基础上实现的，屏蔽了顺序容器的一部分功能，突出或增加了另外一些功能。 容器适配器都有以下三个成员函数： push：添加一个元素。 top：返回顶部（对 stack 而言）或队头（对 queue、priority_queue 而言）的元素的引用。 pop：删除一个元素。 容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"5.0、deque选手打分例子","slug":"STL/5.0、deque选手打分例子","date":"2014-04-01T03:24:49.000Z","updated":"2020-08-07T14:10:11.892Z","comments":true,"path":"2014/04/01/STL/5.0、deque选手打分例子/","link":"","permalink":"https://www.zackaddy.xin/2014/04/01/STL/5.0、deque选手打分例子/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;time.h&gt; #include &lt;algorithm&gt;using namespace std;class Player &#123;public: Player() &#123;&#125; Player(string name, int score):name(name), score(score) &#123;&#125; void setName(const string name) &#123; this-&gt;name = name; &#125; string getName() const &#123; return this-&gt;name; &#125; void setScore(const int score) &#123; this-&gt;score = score; &#125; int getScore() const &#123; return this-&gt;score; &#125;private: string name; int score;&#125;;void create_player(vector&lt;Player&gt; &amp;v) &#123; string names = \"ABCDE\"; for (int i = 0; i &lt; 5;i++) &#123; Player p(\"选手:\" + names.substr(i, 1), 0); v.push_back(p); &#125;&#125;void set_score(vector&lt;Player&gt; &amp;v) &#123; srand(time(NULL)); for (vector&lt;Player&gt;::iterator it = v.begin(); it &lt; v.end();it++) &#123; deque&lt;int&gt; dscore; for (int i = 0; i &lt; 10; i++) &#123; int score = rand() % 100 + 1; dscore.push_back(score); &#125; sort(dscore.begin(), dscore.end()); dscore.pop_back(); dscore.pop_front(); int totalScore = 0; for (deque&lt;int&gt;::iterator dt = dscore.begin(); dt &lt; dscore.end(); dt++) &#123; totalScore += *dt; &#125; (*it).setScore(totalScore / dscore.size()); &#125;&#125;int sort_rank(Player &amp;p1, Player &amp;p2) &#123; return p1.getScore() &gt; p2.getScore();&#125;void print_rank(vector&lt;Player&gt; &amp;v) &#123; sort(v.begin(), v.end(), sort_rank); for (vector&lt;Player&gt;::iterator it = v.begin(); it &lt; v.end(); it++) &#123;; cout &lt;&lt; (*it).getName() &lt;&lt; \"得分:\" &lt;&lt; (*it).getScore() &lt;&lt; endl; &#125;&#125;int main(int argc, char *argv[]) &#123; vector&lt;Player&gt; vPlist; create_player(vPlist); set_score(vPlist); print_rank(vPlist); system(\"pause\"); return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"4.0、deque容器","slug":"STL/4.0、deque容器","date":"2014-03-30T17:02:59.000Z","updated":"2020-08-07T14:10:11.892Z","comments":true,"path":"2014/03/31/STL/4.0、deque容器/","link":"","permalink":"https://www.zackaddy.xin/2014/03/31/STL/4.0、deque容器/","excerpt":"","text":"deque容器特性 1.两端都能快速安插和删除元素，在中部安插、删除元素的速度较慢 2.元素的存取和迭代器的动作比vector稍慢 3.迭代器需要在不同区块间跳转，所以它非一般指针 4.因为deque使用不止一块内存（而vector必须使用一块连续内存），所以deque的max_size()可能更大 5.不支持对容量和内存重新分配时机的控制。不过deque的内存重分配优于vector，因为其内部结构显示，deque不必在内存重分配时复制所有元素 6.除了头尾两端，在任何地方安插或删除元素，都将导致指向deque元素的所有pointers、references、iterators失效 7.deque与vector组织内存的方式不一样。在底层，deque按“页”（page）或“块”（chunk）来分配存储器，每页包含固定数目的元素。而vector只分配一块连续的内存。例如，一个10M字节的vector使用的是一整块10M字节的内存，而deque可以使用一串更小的内存块，比如10块1M的内存。所以不能将deque的地址（如&amp;deque[0]）传递给传统的C API，因为deque内部所使用的内存不一定会连续 8.迭代器属于random access iterator（随机存取迭代器） 9.如果大多数插入和删除操作发生在序列的头部或尾部时，应该选用deque 优点： (1) 随机访问方便，即支持[ ]操作符和vector.at() (2) 首位方便的进行插入和删除操作 (3) 可在两端进行push、pop 缺点： (1) 占用内存多 (2) 不在首位操作，效率低下 deque操作 构造方法 12345678910deque&lt;type&gt; deq; // 声明一个元素类型为type的双端队列quedeque&lt;type&gt; deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque&lt;type&gt; deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque&lt;type&gt; deq(mydeque); // deq是mydeque的一个副本deque&lt;type&gt; deq(first, last); // 使用迭代器first、last范围内的元素初始化deq 常用赋值操作 123456que.assign(beg,end) //将[beg; end)区间中的数据赋值给que。que.assign(n,elem) //将n个elem的拷贝赋值给que。que.swap(que2) //交换容器que和que2中的所有元素。 大小操作 12que.resize(num) 重新指定队列的长度。que.size() 返回容器中实际数据的个数。 取元素 123456que.back() //返回容器que的最后一个元素的引用。如果que为空，则该操作未定义que.front() //返回容器que的第一个元素的引用。如果que为空，则该操作为空que.at(idx) //传回索引idx所指的数据，如果idx越界，抛出out_of_range。 插入元素 12345678910que.insert(pos,elem) //在pos位置插入一个elem拷贝，传回新数据位置que.insert(pos,n,elem) //在pos（迭代器）位置插入n个elem数据。无返回值que.insert(pos,beg,end) //在pos位置插入在[beg,end)区间的数据。无返回值que.push_back(elem) //在尾部加入一个数据。que.push_front(elem) //在头部插入一个数据。 删除元素 12345678que.erase(pos) //删除pos位置的数据，传回下一个数据的位置。que.erase(beg,end) //删除[beg,end)区间的数据，传回下一个数据的位置。que.pop_back() //删除最后一个数据。que.pop_front() //删除头部数据。","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"3.0、vector容器","slug":"STL/3.0、vector容器","date":"2014-03-29T19:11:05.000Z","updated":"2020-08-07T14:10:11.891Z","comments":true,"path":"2014/03/30/STL/3.0、vector容器/","link":"","permalink":"https://www.zackaddy.xin/2014/03/30/STL/3.0、vector容器/","excerpt":"","text":"vector容器特性vector 是顺序容器的一种。vector 是可变长的动态数组，支持随机访问迭代器，所有 STL 算法都能对 vector 进行操作。要使用 vector，需要包含头文件 vector。 在 vector 容器中，根据下标随机访问某个元素的时间是常数，在尾部添加一个元素的时间大多数情况下也是常数，总体来说速度很快。 在中间插入或删除元素时，因为要移动多个元素，因此速度较慢，平均花费的时间和容器中的元素个数成正比。 在 vector 容器中，用一个动态分配的数组来存放元素，因此根据下标访问某个元素的时间是固定的，与元素个数无关。 vector 容器在实现时，动态分配的存储空间一般都大于存放元素所需的空间。例如，哪怕容器中只有一个元素，也会分配 32 个元素的存储空间。这样做的好处是，在尾部添加一个新元素时不必重新分配空间，直接将新元素写入适当位置即可。在这种情况下，添加新元素的时间也是常数。 但是，如果不断添加新元素，多出来的空间就会用完，此时再添加新元素，就不得不重新分配内存空间，把原有内容复制过去后再添加新的元素。碰到这种情况，添加新元素所花的时间就不是常数，而是和数组中的元素个数成正比。 至于在中间插入或删除元素，必然涉及元素的移动，因此时间不是固定的，而是和元素个数有关。 vector中常用的成员函数成员函数 | 作 用 vector() | 无参构造函数，将容器初始化为空vector(int n) | 将容器初始化为有 n 个元素vector(int n, const T &amp; val) | 假定元素的类型是 T，此构造函数将容器初始化为有 n 个元素，每 个元素的值都是 valvector(iterator first, iterator last) | first 和 last 可以是其他容器的迭代器。一般来说，本构造函数初始化的结果就是将 vector 容器的内容变成与其他容器上的区间 [first, last) —致void clear() | 删除所有元素bool empty() | 判断容器是否为空void pop_back() | 删除容器末尾的元素void push_back( const T &amp; val) | 将 val 添加到容器末尾int size() | 返回容器中元素的个数T &amp; front() | 返回容器中第一个元素的引用T &amp; back() | 返回容器中最后一个元素的引用iterator insert(iterator i, const T &amp; val) | 将 val 插入迭代器 i 指向的位置，返回 iiterator insert( iterator i, iterator first, iterator last) | 将其他容器上的区间 [first, last) 中的元素插入迭代器 i 指向的位置iterator erase(iterator i) | 删除迭代器 i 指向的元素，返回值是被删元素后面的元素的迭代器iterator erase(iterator first, iterator last) | 删除容器中的区间 [first, last)void swap( vector &amp; v) | 将容器自身的内容和另一个同类型的容器 v 互换 vector的操作 构造方法 1234567vector&lt;T&gt; v; // 空容器vector&lt;T&gt; vv(v.begin(), v.end()); // 将v.begin(), v.end()之间的元素拷贝到本身vector&lt;T&gt; vv(n, el) // 将n个el元素拷贝到本身vector&lt;T&gt; vv(const vector &amp;vec)int arr[] = &#123;2,3,1,4,6,9&#125;vector&lt;T&gt; vv(arr, sizeof(arr) / sizeof(int)); 常用赋值操作 123vv.assign(v.begin(), v.end()) // 将v.begin(), v.end()之间的元素拷贝到本身vv.assign(n, el) // 将n个el元素拷贝到本身vv.swap(v) // v与vv元素互换 大小操作 12345size() // 元素个数capacity() // 容器容量resize(len) // 重新指定容器长度为len，容器变长填充默认值，变短删除多余元素resize(len, el) // 指定el元素填充reserve(len) // 容器预留元素长度为len，预留位置不初始化,元素不可访问 vector的遍历 12345678void printVector(int a) &#123; cout &lt;&lt; a &lt;&lt; endl;&#125;for_each(v.begin(), v.end(), printVector);for (vector&lt;int&gt;::iterator vv = v.begin(); i &lt; v.end(); i++) &#123; //*i&#125; 取元素操作 1234v.at(index)v[index]v.front() // 首元素v.back() // 最后一个元素 插入元素操作 12345678void push_back(const T&amp; x)// 尾部增加一个元素Xiterator insert(iterator it,const T&amp; x)// 迭代器指向元素前增加一个元素xiterator insert(iterator it,int n,const T&amp; x)// 迭代器指向元素前增加n个相同的元素xiterator insert(iterator it,const_iterator first,const_iterator last)// 迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 删除元素操作 12345678iterator erase(iterator it)// 删除迭代器指向元素iterator erase(iterator first,iterator last)// 删除[first,last)中元素void pop_back()// 删除最后一个元素void clear()// 清空所有元素 基本用法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt; //使用vector需要包含此头文件using namespace std;template &lt;class T&gt;void PrintVector(const vector &lt;T&gt; &amp; v)&#123; //用于输出vector容器的全部元素的函数模板 typename vector &lt;T&gt;::const_iterator i; //typename 用来说明 vector &lt;T&gt;::const_iterator 是一个类型，在 Visual Studio 中不写也可以 for (i = v.begin(); i != v.end(); ++i) cout &lt;&lt; *i &lt;&lt; \" \"; cout &lt;&lt; endl;&#125;int main()&#123; int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; vector &lt;int&gt; v(a, a + 5); //将数组a的内容放入v cout &lt;&lt; \"1) \" &lt;&lt; v.end() - v.begin() &lt;&lt; endl; //两个随机迭代器可以相减，输出：1)5 cout &lt;&lt; \"2)\"; PrintVector(v); //输出：2)1 2 3 4 5 v.insert(v.begin() + 2, 13); //在 begin()+2 位置插人 13 cout &lt;&lt; \"3)\"; PrintVector(v); //输出：3)1 2 13 3 4 5 v.erase(v.begin() + 2); //删除位于 begin()+2 位置的元素 cout &lt;&lt; \"4)\"; PrintVector(v); //输出：4)1 2 3 4 5 vector&lt;int&gt; v2(4, 100); //v2 有 4 个元素，都是 100 v2.insert(v2.begin(), v.begin() + 1, v.begin() + 3); //将v的一段插入v2开头 cout &lt;&lt; \"5)v2:\"; PrintVector(v2); //输出：5)v2:2 3 100 100 100 100 v.erase(v.begin() + 1, v.begin() + 3); //删除 v 上的一个区间，即 [2,3) cout &lt;&lt; \"6)\"; PrintVector(v); //输出：6)1 4 5 return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"2.0、string容器","slug":"STL/2.0、string容器","date":"2014-03-29T00:13:50.000Z","updated":"2020-08-07T14:10:11.890Z","comments":true,"path":"2014/03/29/STL/2.0、string容器/","link":"","permalink":"https://www.zackaddy.xin/2014/03/29/STL/2.0、string容器/","excerpt":"","text":"string容器 char是一个指针，string是一个类，string封装了char string类封装了许多成员方法，如：find，copy，delete，replace，insert 不用考虑内存释放与越界 字符串的操作构造方法123456789101112131415string s;//调用默认构造函数，s为一个空字符串string s(string);//等价于string s = str;调用拷贝构造函数，s是str的备份string s(string,index);//将字符串string内始于index位置到结尾当作s的初始值string s(string,index,length); //将字符串string由index位置起始且长度为length的部分当做s的初值//如果length大于最大长度，则只截取字符串最大长度string.assign(string)string.assign(string,index)string.assign(string,index,length)//这三种与上面的构造方法赋值一样string s(char*);//将char*字符串作为s的初值string s(char*, length);//将char*字符串的length长度部分作为s的初值string s(length, char);//生成一个字符串，包含length个char字符 1234string s1(); // si = \"\"string s2(\"Hello\"); // s2 = \"Hello\"string s3(4, 'K'); // s3 = \"KKKK\"string s4(\"12345\", 1, 3); //s4 = \"234\"，即 \"12345\" 的从下标 1 开始，长度为 3 的子串 string 类没有接收一个整型参数或一个字符型参数的构造函数。下面的两种写法是错误的： 12string s1('K');string s2(123); 为string 对象赋值123456789string s1;s1 = \"Hello\"; // s1 = \"Hello\"s2 = 'K'; // s2 = \"K”string s1(\"12345\"), s2;s3.assign(s1); // s3 = s1s2.assign(s1, 1, 2); // s2 = \"23\"，即 s1 的子串(1, 2)s2.assign(4, 'K'); // s2 = \"KKKK\"s2.assign(\"abcde\", 2, 3); // s2 = \"cde\"，即 \"abcde\" 的子串(2, 3) 求字符串的长度 length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。 字符串交换12345678string s1 = \"hello\";string s2 = \"world\";swap(s1, s2);//s1 world//s2 hellostring s1(\"West”), s2(\"East\");s1.swap(s2); // s1 = \"East\"，s2 = \"West\" 字符的追加123456789string s1 = \"hello\";string s2 = \" world\";s1 += s2;s1 +=\"world\";string s1(\"123\"), s2(\"abc\");s1.append(s2); // s1 = \"123abc\"s1.append(s2, 1, 2); // s1 = \"123abcbc\"s1.append(3, 'K'); // s1 = \"123abcbcKKK\"s1.append(\"ABCDE\", 2, 3); // s1 = \"123abcbcKKKCDE\"，添加 \"ABCDE\" 的子串(2, 3) string对象的比较 除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值： 小于 0 表示当前的字符串小； 等于 0 表示两个字符串相等； 大于 0 表示另一个字符串小。 1234567string s1(\"hello\"), s2(\"hello, world\");int n = s1.compare(s2);n = s1.compare(1, 2, s2, 0, 3); //比较s1的子串 (1,2) 和s2的子串 (0,3)n = s1.compare(0, 2, s2); // 比较s1的子串 (0,2) 和 s2n = s1.compare(\"Hello\");n = s1.compare(1, 2, \"Hello\"); //比较 s1 的子串(1,2)和\"Hello”n = s1.compare(1, 2, \"Hello\", 1, 2); //比较 s1 的子串(1,2)和 \"Hello\" 的子串(1,2) 字符串的插入123456789101112131415161718string &amp;insert(int p0, const char *s);string &amp;insert(int p0, const char *s, int n);string &amp;insert(int p0,const string &amp;s);string &amp;insert(int p0,const string &amp;s, int pos, int n);//前4个函数在p0位置插入字符串s中pos开始的前n个字符string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符citerator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符void insert(iterator it, int n, char c);//在it处插入n个字符cstring s1(\"Limitless\"), s2(\"00\");s1.insert(2, \"123\"); //在下标 2 处插入字符串\"123\"，s1 = \"Li123mitless\"s1.insert(3, s2); //在下标 2 处插入 s2 , s1 = \"Li10023mitless\"s1.insert(3, 5, 'X'); //在下标 3 处插入 5 个 'X'，s1 = \"Li1XXXXX0023mitless\" 字符串的删除1234567891011121314151617181920212223iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串 string str(\"This is an example phrase.\");string::iterator it;//迭代器str.erase(str.begin()+5,str.end()-7);//删除两个参数之间的所有字符，str=\"This phrase.\"it = str.begin();//迭代器位置为0str.erase(it);//删除迭代器位置为0的字符str.erase(10,8)string s1(\"Real Steel\");s1.erase(1, 3); //删除子串(1, 3)，此后 s1 = \"R Steel\"s1.erase(5); //删除下标5及其后面的所有字符，此后 s1 = \"R Ste\" 字符串的截取12string substr(int pos = 0, int n = npos) const; // 返回pos开始的n个字符组成的字符串 123string s1 = \"this is ok\";string s2 = s1.substr(2, 4); // s2 = \"is i\"s2 = s1.substr(2); // s2 = \"is is ok\" string 对象作为流处理 使用流对象 istringstream 和 ostringstream，可以将 string 对象当作一个流进行输入输出。使用这两个类需要包含头文件 sstream。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string src(\"Avatar 123 5.2 Titanic K\"); istringstream istrStream(src); //建立src到istrStream的联系 string s1, s2; int n; double d; char c; istrStream &gt;&gt; s1 &gt;&gt; n &gt;&gt; d &gt;&gt; s2 &gt;&gt; c; //把src的内容当做输入流进行读取 ostringstream ostrStream; ostrStream &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; endl &lt;&lt; n &lt;&lt; endl &lt;&lt; d &lt;&lt; endl &lt;&lt; c &lt;&lt;endl; cout &lt;&lt; ostrStream.str(); return 0;&#125;程序的输出结果是：AvatarTitanic1235.2K 用 STL 算法操作 string 对象12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s(\"afgcbed\"); string::iterator p = find(s.begin(), s.end(), 'c'); if (p!= s.end()) cout &lt;&lt; p - s.begin() &lt;&lt; endl; //输出 3 sort(s.begin(), s.end()); cout &lt;&lt; s &lt;&lt; endl; //输出 abcdefg next_permutation(s.begin(), s.end()); cout &lt;&lt; s &lt;&lt; endl; //输出 abcdegf return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"2、算法的时间复杂度","slug":"数据结构/2、算法的时间复杂度","date":"2014-03-28T21:11:15.000Z","updated":"2020-08-07T14:10:11.896Z","comments":true,"path":"2014/03/29/数据结构/2、算法的时间复杂度/","link":"","permalink":"https://www.zackaddy.xin/2014/03/29/数据结构/2、算法的时间复杂度/","excerpt":"","text":"算法的时间复杂度 只关注最高次项 时间复杂度是指最坏时间复杂度 只有常数项记做1 我们假设计算机运行一行基础代码需要执行一次运算。 1234int aFunc(void) &#123; printf(\"Hello, World!\\n\"); // 需要执行 1 次 return 0; // 需要执行 1 次&#125; 那么上面这个方法需要执行 2 次运算 123456int aFunc(int n) &#123; for(int i = 0; i&lt;n; i++) &#123; // 需要执行 (n + 1) 次 printf(\"Hello, World!\\n\"); // 需要执行 n 次 &#125; return 0; // 需要执行 1 次&#125; 这个方法需要 (n + 1 + n + 1) = 2n + 2 次运算。 我们把 算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) 。此时为了 估算算法需要的运行时间 和 简化算法分析，我们引入时间复杂度的概念。 定义：存在常数 c 和函数 f(N)，使得当 N &gt;= c 时 T(N) &lt;= f(N)，表示为 T(n) = O(f(n)) 。如图： 当 N &gt;= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。 因为f(n) 的增长速度是大于或者等于 T(n) 的，即T(n) = O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。 显然如果 T(n) = n^2，那么 T(n) = O(n^2)，T(n) = O(n^3)，T(n) = O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。 那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？ 我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。 123比如第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。T(n) = n + 29，此时时间复杂度为 O(n)。 我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。 12比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 12比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。 综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。 由此可见，由执行次数 T(n) 得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。 对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。12345void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n printf(\"Hello, World!\\n\"); // 循环体时间复杂度为 O(1) &#125;&#125; 此时时间复杂度为 O(n × 1)，即 O(n)。 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。1234567void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n for(int j = 0; j &lt; n; j++) &#123; // 循环次数为 n printf(\"Hello, World!\\n\"); // 循环体时间复杂度为 O(1) &#125; &#125;&#125; 此时时间复杂度为 O(n × n × 1)，即 O(n^2)。 对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。123456789101112void aFunc(int n) &#123; // 第一部分时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf(\"Hello, World!\\n\"); &#125; &#125; // 第二部分时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf(\"Hello, World!\\n\"); &#125;&#125; 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。 对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。123456789101112131415void aFunc(int n) &#123; if (n &gt;= 0) &#123; // 第一条路径时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf(\"输入数据大于等于零\\n\"); &#125; &#125; &#125; else &#123; // 第二条路径时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf(\"输入数据小于零\\n\"); &#125; &#125;&#125; 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。 时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。 最后，我们来练习一下 一. 基础题求该方法的时间复杂度 1234567void aFunc(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; printf(\"Hello World\\n\"); &#125; &#125;&#125; 参考答案： 当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。 二. 进阶题求该方法的时间复杂度 123456void aFunc(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; i *= 2; printf(\"%i\\n\", i); &#125;&#125; 参考答案： 假设循环次数为 t，则循环条件满足 2^t &lt; n。可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。 三. 再次进阶求该方法的时间复杂度 1234567long aFunc(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 参考答案： 显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。 显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。 所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。 可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/categories/数据结构/"}]},{"title":"40、delete与delete[]区别","slug":"Cpp/40、delete与delete[]区别","date":"2014-03-27T22:40:49.000Z","updated":"2020-08-07T14:10:11.724Z","comments":true,"path":"2014/03/28/Cpp/40、delete与delete[]区别/","link":"","permalink":"https://www.zackaddy.xin/2014/03/28/Cpp/40、delete与delete[]区别/","excerpt":"","text":"delete 和 delete[] 的区别 delete 释放new分配的单个对象指针指向的内存 delete[] 释放new分配的对象数组指针指向的内存 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可 如： 123int *a = new int[10];delete a; //方式1delete [] a; //方式2 ++此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间(在分配过程中 系统会记录分配内存的大小等信息，此信息保存在结构体_CrtMemBlockHeader中，具体情况可参看VC安装目录下CRTSRCDBGDEL.cpp)++ 通过下列方式分配一个类对象数组： 123456789101112class A&#123;private: char *m_cBuffer; int m_nLen;public: A()&#123; m_cBuffer = new char[m_nLen]; &#125; ~A() &#123; delete [] m_cBuffer; &#125;&#125;;A *a = new A[10];delete a; //仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏delete [] a; //调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空 ==在用这些类生成对象数组的时候，用delete[]来释放它们。== ==而用delete来释放也许不会出问题，也许后果很严重，具体要看类的代码了.==","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"1.0、stl helloworld","slug":"STL/1.0、stl helloworld","date":"2014-03-27T22:35:06.000Z","updated":"2020-08-07T14:10:11.887Z","comments":true,"path":"2014/03/28/STL/1.0、stl helloworld/","link":"","permalink":"https://www.zackaddy.xin/2014/03/28/STL/1.0、stl helloworld/","excerpt":"","text":"12345678910111213141516171819202122232425#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;void printVector(int a) &#123; cout &lt;&lt; a &lt;&lt; \":\" &lt;&lt; \"\" &lt;&lt; endl;&#125;int main(int argc, char *argv[]) &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(15); v.push_back(17); v.push_back(19); //第一种打印方式 for (vector&lt;int&gt;::iterator i = v.begin(); i &lt; v.end(); i++) &#123; cout &lt;&lt; *i &lt;&lt; endl; &#125; //第二种打印方式 for_each(v.begin(), v.end(), printVector); system(\"pause\"); return 0;&#125;","categories":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/tags/STL/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://www.zackaddy.xin/categories/STL/"}]},{"title":"1、数据结构概念","slug":"数据结构/1、数据结构概念","date":"2014-03-27T16:53:11.000Z","updated":"2020-08-07T14:10:11.896Z","comments":true,"path":"2014/03/28/数据结构/1、数据结构概念/","link":"","permalink":"https://www.zackaddy.xin/2014/03/28/数据结构/1、数据结构概念/","excerpt":"","text":"算法和数据结构的区别 算法是为了解决实际问题 数据结构是算法需要处理的问题载体 数据结构与算法相辅相成 算法特性 输入：0或多个 输入：1或多个 有穷性：算法在有限的步骤之后自动结束不会无限循环 确定性：算法中的每一步都有确定的含义 可行性：算法的每一步都是可行的 算法推导理论 算法最终编译成具体的计算机指令 每一个指令，在具体的计算机上运行速度固定 通过具体的步骤，就可以推导出算法的复杂度 判断算法效率 判断一个算法的效率时，往往==只需要关注操作数量的最高次数项，其它次要项和常数项可以忽略== 在没有特殊说明时，我们所分析的==算法的时间复杂度都是指最坏的时间复杂度== 只有常数项记做1 操作数量的估算可以作为时间复杂度的估算","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/tags/数据结构/"}],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.zackaddy.xin/categories/数据结构/"}]},{"title":"39、C++实现可变参数","slug":"Cpp/39、C++实现可变参数","date":"2014-03-26T21:14:57.000Z","updated":"2020-08-07T14:10:11.723Z","comments":true,"path":"2014/03/27/Cpp/39、C++实现可变参数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/27/Cpp/39、C++实现可变参数/","excerpt":"","text":"https://www.cnblogs.com/findumars/p/5615727.html","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"38、C++使用可变参数函数","slug":"Cpp/38、C++使用可变参数函数","date":"2014-03-26T00:27:29.000Z","updated":"2020-08-07T14:10:11.715Z","comments":true,"path":"2014/03/26/Cpp/38、C++使用可变参数函数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/26/Cpp/38、C++使用可变参数函数/","excerpt":"","text":"123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int initializerSum(initializer_list&lt;int&gt; il) &#123; int sum = 0; for (auto ptr = il.begin(); ptr != il.end(); ptr++) //类似于容器的操作 &#123; sum += *ptr; &#125; return sum;&#125;int main()&#123; cout &lt;&lt; initializerSum(&#123;5,6,7,8&#125;) &lt;&lt; endl;; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"37、函数对象","slug":"Cpp/37、函数对象","date":"2014-03-25T02:49:40.000Z","updated":"2020-08-07T14:10:11.715Z","comments":true,"path":"2014/03/25/Cpp/37、函数对象/","link":"","permalink":"https://www.zackaddy.xin/2014/03/25/Cpp/37、函数对象/","excerpt":"","text":"计算遍历次数123456789101112131415161718struct myjs &#123;public: myjs():num(0) &#123;&#125; void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; endl; this-&gt;num++; &#125;public: int num;&#125;;int main(int argc, char *argv[]) &#123; vector&lt;int&gt; v&#123; 50,60,13,25 &#125;; myjs m; m = for_each(v.begin(), v.end(), m); cout &lt;&lt; m.num &lt;&lt; endl; system(\"pause\"); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"35、命名空间","slug":"Cpp/35、命名空间","date":"2014-03-23T18:15:01.000Z","updated":"2020-08-07T14:10:11.715Z","comments":true,"path":"2014/03/24/Cpp/35、命名空间/","link":"","permalink":"https://www.zackaddy.xin/2014/03/24/Cpp/35、命名空间/","excerpt":"","text":"定义命名空间123namespace namespace_name &#123; // 代码声明&#125; 使用命名空间123456789101112131415namespace first_space&#123; void func()&#123; cout &lt;&lt; \"Inside first_space\" &lt;&lt; endl; &#125;&#125;//方式1first_space::func();//方式2using namespace first_space;func();//方式3using first_space::func;func();//推荐使用方式1 嵌套命名空间1234567891011121314namespace first_space&#123; void funcx()&#123; cout &lt;&lt; \"Inside first_space\" &lt;&lt; endl; &#125; // 第二个命名空间 namespace second_space&#123; void func()&#123; cout &lt;&lt; \"Inside second_space\" &lt;&lt; endl; &#125; &#125;&#125;using namespace first_space::second_space; func();//funcx所在命名空间first_space没有被使用所以不能调用funcx()","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"34、explicit关键字强制显式调用构造函数","slug":"Cpp/34、explicit关键字强制显式调用构造函数","date":"2014-03-23T03:23:00.000Z","updated":"2020-08-07T14:10:11.714Z","comments":true,"path":"2014/03/23/Cpp/34、explicit关键字强制显式调用构造函数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/23/Cpp/34、explicit关键字强制显式调用构造函数/","excerpt":"","text":"1.对构造器使用 2.表示显示的调用构造器 3.与之相反的是implicit关键字12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"A()\" &lt;&lt; endl; &#125; explicit A(const A &amp;a) &#123; cout &lt;&lt; \"A(const A &amp;a)\" &lt;&lt; endl; &#125; A(int id) :id(id) &#123; cout &lt;&lt; \"A(int id):id(id)\" &lt;&lt; endl; &#125; A(string name) :name(name) &#123; cout &lt;&lt; \"A(string name) :name(name)\" &lt;&lt; endl; &#125;private: int id; int age; string name;&#125;;int main(int argc, char **argv) &#123; A a; A b(a); system(\"pause\"); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"33、cout、cin操作","slug":"Cpp/33、cout、cin操作","date":"2014-03-22T01:54:52.000Z","updated":"2020-08-07T14:10:11.714Z","comments":true,"path":"2014/03/22/Cpp/33、cout、cin操作/","link":"","permalink":"https://www.zackaddy.xin/2014/03/22/Cpp/33、cout、cin操作/","excerpt":"","text":"","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"32、c++的文件操作","slug":"Cpp/32、c++的文件操作","date":"2014-03-20T21:04:42.000Z","updated":"2020-08-07T14:10:11.710Z","comments":true,"path":"2014/03/21/Cpp/32、c++的文件操作/","link":"","permalink":"https://www.zackaddy.xin/2014/03/21/Cpp/32、c++的文件操作/","excerpt":"","text":"C++ 通过以下几个类支持文件的输入输出： ofstream: 写操作（输出）的文件类 (由ostream引申而来) ifstream: 读操作（输入）的文件类(由istream引申而来) fstream: 可同时读写操作的文件类 (由iostream引申而来) 打开文件 void open (const char * filename, openmode mode); 标识 描述 ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 这些标识符可以被组合使用，通过| 12ofstream file;file.open (\"example.bin\", ios::out | ios::app | ios::binary); 默认的打开方式如下 类 参数的默认方式 ofstream ios::out | ios::trunc ifstream ios::in fstream ios::in | ios::out 文件是否打开bool is_open(); 关闭文件句柄void close (); 12345678910111213// writing on a text file#include int main () &#123; ofstream examplefile (\"example.txt\"); if (examplefile.is_open()) &#123; examplefile &lt;&lt; \"This is a line.\\n\"; examplefile &lt;&lt; \"This is another line.\\n\"; examplefile.close(); &#125; return 0;&#125; eof()是否读文件到达文件末尾 tellg()获得下一个将被读取的元素 tellp()获得下一个将被写入元素的位置 seekg() 和seekp()改变流指针get 和put的位置 seekg ( pos_type position ); seekp ( pos_type position ); seekg ( off_type offset, seekdir direction ); seekp ( off_type offset, seekdir direction ); seekdir标识如下 标识 描述 ios::beg 从流开始位置计算的位移 ios::cur 从流指针当前位置开始计算的位移 ios::end 从流末尾处开始计算的位移 1234567891011121314//获取文件大小const char * filename = \"example.txt\";int main () &#123; long l,m; ifstream file (filename, ios::in|ios::binary); l = file.tellg(); file.seekg (0, ios::end); m = file.tellg(); file.close(); cout &lt;&lt; \"size of \" &lt;&lt; filename; cout &lt;&lt; \" is \" &lt;&lt; (m-l) &lt;&lt; \" bytes.\\n\"; return 0;&#125; 二进制文件读写 write ( char * buffer, streamsize size ); read ( char * buffer, streamsize size ); 123456789101112131415161718//读const char * filename = \"example.txt\";int main () &#123; char * buffer; long size; ifstream file (filename, ios::in|ios::binary|ios::ate); size = file.tellg(); file.seekg (0, ios::beg); buffer = new char [size]; file.read (buffer, size); file.close(); cout &lt;&lt; \"the complete file is in a buffer\"; delete[] buffer; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"31、类型转换","slug":"Cpp/31、类型转换","date":"2014-03-20T00:03:22.000Z","updated":"2020-08-07T14:10:11.710Z","comments":true,"path":"2014/03/20/Cpp/31、类型转换/","link":"","permalink":"https://www.zackaddy.xin/2014/03/20/Cpp/31、类型转换/","excerpt":"","text":"函数 描述 static_cast 一般的转换 dynamic_cast 通常在基类与派生类之间转换 const_cast 主要针对const的转换 reinterpret_cast 用于没有任何关联直接的转换，如字符指针转为整数 static_cast 1.无法转换无关联的指针类型 2.可以转换具有继承关系的类指针 3.可以转换具有继承关系的类引用 4.可以转换普通数据类型12int a = 10;char b = static_cast&lt;char&gt;(a); dynamic_cast 1.可以转换具有继承关系的类指针 2.可以转换具有继承关系的类引用 3.转换时会进行类型检查，如父类转为子类不安全 4.不可以转换普通类型 const_cast 1.指针 2.引用 3.增加、取出变量的const 4.具有继承关系类对象指针12int *p = NULL;int *q = const_cast&lt;int*&gt;(p); reinterpret_cast 1.所有类型转换，包括函数指针","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"30、对右值（如数字）取引用","slug":"Cpp/30、对右值（如数字）取引用","date":"2014-03-18T23:24:54.000Z","updated":"2020-08-07T14:10:11.710Z","comments":true,"path":"2014/03/19/Cpp/30、对右值（如数字）取引用/","link":"","permalink":"https://www.zackaddy.xin/2014/03/19/Cpp/30、对右值（如数字）取引用/","excerpt":"","text":"1234void say(int &amp;&amp;a) &#123; &#125;say(10);","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"29、类、友元类模板","slug":"Cpp/29、类、友元类模板","date":"2014-03-18T00:15:05.000Z","updated":"2020-08-07T14:10:11.710Z","comments":true,"path":"2014/03/18/Cpp/29、类、友元类模板/","link":"","permalink":"https://www.zackaddy.xin/2014/03/18/Cpp/29、类、友元类模板/","excerpt":"","text":"1.类模板调用时必须显示指定类型 2.类模板的派生类，需指定父类模板类型(T或指定类型)123456789101112131415161718192021222324//1template&lt;class T&gt;class A &#123;public: A(T id, Tage) &#123; &#125;public: T id; T age;&#125;;A&lt;int&gt; a(10, 30);//2class B:public A&lt;int&gt; &#123; &#125;;template&lt;class T&gt;class B:public A&lt;T&gt; &#123; &#125;;B&lt;int&gt; b; 注意友元的声明123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; class A;template&lt;class T&gt; void say(A&lt;T&gt; &amp;a);template&lt;class T&gt;class A &#123;public: A(T id, T age) &#123; this-&gt;id = id; this-&gt;age = age; &#125; friend void say&lt;T&gt;(A&lt;T&gt; &amp;a);public: T id; T age;&#125;;template&lt;class T&gt;void say(A&lt;T&gt; &amp;a) &#123; cout &lt;&lt; a.id &lt;&lt; endl;&#125;int main()&#123; A&lt;int&gt; a(1, 2); say(a); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"28、模板函数与普通函数区别、规则","slug":"Cpp/28、模板函数与普通函数区别、规则","date":"2014-03-16T22:02:35.000Z","updated":"2020-08-07T14:10:11.709Z","comments":true,"path":"2014/03/17/Cpp/28、模板函数与普通函数区别、规则/","link":"","permalink":"https://www.zackaddy.xin/2014/03/17/Cpp/28、模板函数与普通函数区别、规则/","excerpt":"","text":"模板函数与普通函数 普通函数可以自动类型转换 函数模板必须严格类型匹配 模板函数与普通函数名相同，优先查询相匹配的普通函数 c++编译器优先考虑普通函数 不想匹配普通函数只需，函数名&lt;&gt;()的方式调用即可排除普通函数转而调用对应的模板; 模板函数可以像普通函数被重载","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"27、函数模版基本语法","slug":"Cpp/27、函数模版基本语法","date":"2014-03-16T04:43:45.000Z","updated":"2020-08-07T14:10:11.709Z","comments":true,"path":"2014/03/16/Cpp/27、函数模版基本语法/","link":"","permalink":"https://www.zackaddy.xin/2014/03/16/Cpp/27、函数模版基本语法/","excerpt":"","text":"函数模板 类型参数化 写代码可以忽略类型 template//template template是为了让编译器区分普通函数与模板函数 template 在模板上class与typename的作用完全相同 函数模板不允许自动类型转换 普通函数能够进行自动类型转换 代码复用1234567891011121314template&lt;class T&gt;//template&lt;typename T&gt;void swap(T &amp;a, T &amp;b) &#123; T temp = a; a = b; b = temp;&#125;int main() &#123; int a = 10; int b = 20; swap(a, b); //类型会自动推导 swap&lt;int&gt;(10, 20); //指定类型 return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"26.0、typename和class的区别介绍","slug":"Cpp/26.0、typename和class的区别介绍","date":"2014-03-15T00:45:06.000Z","updated":"2020-08-07T14:10:11.705Z","comments":true,"path":"2014/03/15/Cpp/26.0、typename和class的区别介绍/","link":"","permalink":"https://www.zackaddy.xin/2014/03/15/Cpp/26.0、typename和class的区别介绍/","excerpt":"","text":"typename和class的区别介绍 相信学习C++的人对class这个关键字都非常明白， class用于定义类。在模板引入c++后， 最初定义模板的方法为： template…… 在这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入了typename这个关键字。它的作用同class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了： template…… 在模板定义语法中关键字class与typename的作用完全一样。 typename难道仅仅在模板定义中起作用吗？其实不是这样，typename另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示： 1234567891011121314class MyArray &#123; public： typedef int LengthType; .....&#125; template&lt;class T&gt;void MyMethod( T myarr ) &#123; typedef typename T::LengthType LengthType; LengthType length = myarr.GetLength; &#125; 这个时候typename的作用就是告诉c++编译器，typename后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有typename，编译器没有任何办法知道T::LengthType是一个类型还是一个成员名称（静态数据成员或者静态函数），所以编译不能够通过。 12345678910111213141516171819202122232425template&lt;typename T&gt;class Test &#123;public: typedef size_t size_type; int age;&#125;;template&lt;typename S&gt;class Sub&#123;public: typedef typename Test&lt;S&gt;::size_type ss_1; //success,加上typename时编译器会当Test类模板中size_type是类型不是变量 typedef Test&lt;S&gt;::size_type ss_2; // error 编译器不知道Test类模板中size_type是变量还是类型 typedef Test&lt;int&gt;::size_type ss_3; //success,加上int时编译器会当你已经确认Test类模板中size_type是类型不是变量 Sub() &#123;//在方法中不检查 typedef Test&lt;S&gt;::size_type ss_4; //success typedef typename Test&lt;S&gt;::size_type ss_5; //success typedef Test&lt;S&gt;::age ss_6; //编译不报错，运行时检查 &#125;&#125;;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"26、纯虚函数与抽象类","slug":"Cpp/26、纯虚函数与抽象类","date":"2014-03-13T20:49:42.000Z","updated":"2020-08-07T14:10:11.709Z","comments":true,"path":"2014/03/14/Cpp/26、纯虚函数与抽象类/","link":"","permalink":"https://www.zackaddy.xin/2014/03/14/Cpp/26、纯虚函数与抽象类/","excerpt":"","text":"纯虚函数和抽象类纯虚函数语法 virtual 类型 函数名 （参数） = 0; 一个具有纯虚函数的基类称为抽象类 抽象类不能被实例化 继承一个抽象类，则派生类必须重写基类纯虚函数，否则派生类依然为抽象类","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"25、验证vptr指针存在","slug":"Cpp/25、验证vptr指针存在","date":"2014-03-12T17:04:31.000Z","updated":"2020-08-07T14:10:11.705Z","comments":true,"path":"2014/03/13/Cpp/25、验证vptr指针存在/","link":"","permalink":"https://www.zackaddy.xin/2014/03/13/Cpp/25、验证vptr指针存在/","excerpt":"","text":"验证vptr指针的存在12345678910111213141516class A &#123;public: int a; virtual void say() &#123;&#125;&#125;class B &#123;public: int a; void say() &#123;&#125;&#125;int main() &#123; A a; B b; cout &lt;&lt; sizeof(a) &lt;&lt; endl; //8 cout &lt;&lt; sizeof(b) &lt;&lt; endl; //4&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"24、多态实现原理","slug":"Cpp/24、多态实现原理","date":"2014-03-12T03:00:39.000Z","updated":"2020-08-07T14:10:11.705Z","comments":true,"path":"2014/03/12/Cpp/24、多态实现原理/","link":"","permalink":"https://www.zackaddy.xin/2014/03/12/Cpp/24、多态实现原理/","excerpt":"","text":"多态实现原理虚函数 当类中声明虚函数时，编译器会在类中生成一个虚函数表 虚函数表是一个存储 类成员函数指针的数据结构 虚函数表是由编译器自动生成与维护的 存在虚函数时，每个对象中都有一个指向虚函数表的指针(vptr指针) 说明 通过虚函数表指针vptr调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。==而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。== 出于效率考虑，没有必要将所有成员函数都声明为虚函数。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"23.1、静态与动态联编","slug":"Cpp/23.1、静态与动态联编","date":"2014-03-10T16:01:01.000Z","updated":"2020-08-07T14:10:11.705Z","comments":true,"path":"2014/03/11/Cpp/23.1、静态与动态联编/","link":"","permalink":"https://www.zackaddy.xin/2014/03/11/Cpp/23.1、静态与动态联编/","excerpt":"","text":"静态与动态联编 联编是指一个程序模块、代码之间互相关联d的过程 静态联编 是程序的匹配、连接在编译阶段实现，也称为早期匹配。重载函数使用静态联编。 动态联编 是程序联编推迟到运行时进行，所以又称为晚期联编（迟绑定）。switch语句和if语句是动态联编的例子。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"23.0、多态虚函数","slug":"Cpp/23.0、多态虚函数","date":"2014-03-09T20:02:33.000Z","updated":"2020-08-07T14:10:11.704Z","comments":true,"path":"2014/03/10/Cpp/23.0、多态虚函数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/10/Cpp/23.0、多态虚函数/","excerpt":"","text":"多态三个必要条件 1.要有继承 2.要有虚函数重写 3.父类指针或引用指向子类对象 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void say() &#123; cout &lt;&lt; \"A say\" &lt;&lt; endl; &#125; virtual ~A() &#123; //对于父类指针，多态中析构函数一定加上virtual不然delete A时不会触发子类的析构函数 //对于父类引用则不会发生 &#125;&#125;;class B:public A&#123;public: void say() &#123; cout &lt;&lt; \"B say\" &lt;&lt; endl; &#125;&#125;;int main() &#123; B b; A &amp;a = b; a.say();//B say return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"22、多继承与虚继承","slug":"Cpp/22、多继承与虚继承","date":"2014-03-09T00:24:41.000Z","updated":"2020-08-07T14:10:11.704Z","comments":true,"path":"2014/03/09/Cpp/22、多继承与虚继承/","link":"","permalink":"https://www.zackaddy.xin/2014/03/09/Cpp/22、多继承与虚继承/","excerpt":"","text":"1.多继承的类调用成员与其它语言不同，必须要明确指定 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class A &#123;public: void say() &#123; cout &lt;&lt; \"A SAY\" &lt;&lt; endl; &#125;&#125;;class B &#123;public: void say() &#123; cout &lt;&lt; \"B SAY\" &lt;&lt; endl; &#125;&#125;;class C:public A,public B &#123;public: void eat() &#123; A::say(); &#125;&#125;;int main() &#123; C c; c.A::say(); return 0;&#125; 1.爷爷有money， 儿子继承爷爷👴，孙子多继承儿子，那么孙子要指定是是哪个儿子的money 2.爷爷有money， 儿子虚继承爷爷👴，孙子多继承儿子，那么孙子不需要指定是哪个儿子的money 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class A&#123;public: int a;&#125;;class B:virtual public A&#123;public: void say() &#123; a = 10; &#125;&#125;;class C:virtual public A&#123;public: void say() &#123; a = 11; &#125;&#125;;class D:public B,public C&#123;public: void say() &#123; /*say 是儿子独有的需要指定*/ /*a是儿子虚继承的，是共有的，不需要指定*/ B::say(); C::say(); cout &lt;&lt; a &lt;&lt; endl;//11 &#125;&#125;;int main() &#123; D d; d.say(); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"21、类的继承方式","slug":"Cpp/21、类的继承方式","date":"2014-03-07T22:56:24.000Z","updated":"2020-08-07T14:10:11.704Z","comments":true,"path":"2014/03/08/Cpp/21、类的继承方式/","link":"","permalink":"https://www.zackaddy.xin/2014/03/08/Cpp/21、类的继承方式/","excerpt":"","text":"继承方式 父类public 父类protected 父类private public public（内外都可访问） protected（内可访问） private（内外都不可访问） protected protected protected private private protected protected private","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"20、自定义string类","slug":"Cpp/20、自定义string类","date":"2014-03-07T00:54:47.000Z","updated":"2020-08-07T14:10:11.704Z","comments":true,"path":"2014/03/07/Cpp/20、自定义string类/","link":"","permalink":"https://www.zackaddy.xin/2014/03/07/Cpp/20、自定义string类/","excerpt":"","text":"","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"19、string类用法","slug":"Cpp/19、string类用法","date":"2014-03-06T03:10:03.000Z","updated":"2020-08-07T14:10:11.703Z","comments":true,"path":"2014/03/06/Cpp/19、string类用法/","link":"","permalink":"https://www.zackaddy.xin/2014/03/06/Cpp/19、string类用法/","excerpt":"","text":"函数名 描述 begin 得到指向字符串开头的Iterator end 得到指向字符串结尾的Iterator rbegin 得到指向反向字符串开头的Iterator rend 得到指向反向字符串结尾的Iterator size 得到字符串的大小 length 和size函数功能相同 max_size 字符串可能的最大大小 capacity 在不重新分配内存的情况下，字符串可能的大小 empty 判断是否为空 operator[] 取第几个元素，相当于数组 c_str 取得C风格的const char* 字符串 data 取得字符串内容地址 operator= 赋值操作符 reserve 预留空间 swap 交换函数 insert 插入字符 append 追加字符 push_back 追加字符 operator+= += 操作符 erase 删除字符串 clear 清空字符容器中所有内容 resize 重新分配空间 assign 和赋值操作符一样 replace 替代 copy 字符串到空间 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置 substr 得到字串 compare 比较字符串 operator+ 字符串链接 operator== 判断是否相等 operator!= 判断是否不等于 operator&lt; 判断是否小于 operator&gt;&gt; 从输入流中读入字符串 operator&lt;&lt; 字符串写入输出流 getline 从输入流中读入一行","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"18、操作符重载规则","slug":"Cpp/18、操作符重载规则","date":"2014-03-05T04:17:50.000Z","updated":"2020-08-07T14:10:11.703Z","comments":true,"path":"2014/03/05/Cpp/18、操作符重载规则/","link":"","permalink":"https://www.zackaddy.xin/2014/03/05/Cpp/18、操作符重载规则/","excerpt":"","text":"1.C++不允许自定义操作符 2.C++运行重载的操作符 1 2 3 4 5 6 7 / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |= &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ – , -&gt;* -&gt; () [] 3.()———–&gt;函数调用操作符 4.[]下标操作符 5.不能重载的操作符（. .* :: ?:） = &amp;不建议重载","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"17、操作符重载基本语法","slug":"Cpp/17、操作符重载基本语法","date":"2014-03-04T00:01:06.000Z","updated":"2020-08-07T14:10:11.703Z","comments":true,"path":"2014/03/04/Cpp/17、操作符重载基本语法/","link":"","permalink":"https://www.zackaddy.xin/2014/03/04/Cpp/17、操作符重载基本语法/","excerpt":"","text":"写在类中 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"default\" &lt;&lt; endl; &#125; A(int a, int b) &#123; this-&gt;a = a; this-&gt;b = b; cout &lt;&lt; \"int a, int b\" &lt;&lt; endl; &#125; A(const A &amp;a) &#123; this-&gt;a = a.a; this-&gt;b = a.b; cout &lt;&lt; \"const A &amp;a\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; void printme() &#123; cout &lt;&lt; this-&gt;a &lt;&lt; this-&gt;b &lt;&lt; endl; &#125; A operator+(A &amp;anthor) &#123; A a(this-&gt;a + anthor.a, this-&gt;b + anthor.b); return a; &#125; int a; int b;private:&#125;;int main(int argc, char *argv[]) &#123; A a(10, 20); A b(50, 60); A c = a + b; c.printme(); system(\"pause\"); return 0;&#125; 写在类外 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"default\" &lt;&lt; endl; &#125; A(int a, int b) &#123; this-&gt;a = a; this-&gt;b = b; cout &lt;&lt; \"int a, int b\" &lt;&lt; endl; &#125; A(const A &amp;a) &#123; this-&gt;a = a.a; this-&gt;b = a.b; cout &lt;&lt; \"const A &amp;a\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; void printme() &#123; cout &lt;&lt; this-&gt;a &lt;&lt; this-&gt;b &lt;&lt; endl; &#125; int a; int b;private:&#125;;A operator+(A &amp;one, A &amp;anthor) &#123; A a(one.a + anthor.a, one.b + anthor.b); return a;&#125;int main(int argc, char *argv[]) &#123; A a(10, 20); A b(50, 60); A c = a + b; c.printme(); system(\"pause\"); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"16、友元函数","slug":"Cpp/16、友元函数","date":"2014-03-02T23:55:17.000Z","updated":"2020-08-07T14:10:11.702Z","comments":true,"path":"2014/03/03/Cpp/16、友元函数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/03/Cpp/16、友元函数/","excerpt":"","text":"友元函数 在一个函数内需要调用某类的函数得到指定的私有属性 这个函数经常被调用，那么某类中的函数也经常被调用 会带来压桟出栈等额外开销 这时可以声明友元函数，使此函数具有访问某类的私有属性权限 友元函数可声明在类中public、private等任意地方 减少get set函数带来的开销 破坏了类的封装性、隐藏性 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"default\" &lt;&lt; endl; &#125; A(int a, int b) &#123; cout &lt;&lt; \"int a, int b\" &lt;&lt; endl; &#125; A(char a, char b) &#123; cout &lt;&lt; \"char a, char b\" &lt;&lt; endl; &#125; A(const A &amp;a) &#123; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; void eat() const &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; friend void CalcDistance(A &amp;a);private: int a = 5;&#125;;void CalcDistance(A &amp;a) &#123; cout &lt;&lt; a.a &lt;&lt; endl;&#125;int main(int argc, char *argv[]) &#123; A a; CalcDistance(a); system(\"pause\"); return 0;&#125; 友元类 友元关系单项，没有交换性 不具有交换性，B是A的友元，C是B的友元，C不是A的友元 friend class B;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"15、this","slug":"Cpp/15、this","date":"2014-03-01T22:55:04.000Z","updated":"2020-08-07T14:10:11.702Z","comments":true,"path":"2014/03/02/Cpp/15、this/","link":"","permalink":"https://www.zackaddy.xin/2014/03/02/Cpp/15、this/","excerpt":"","text":"类成员函数尾部出现const 表示(const 类名 *const) this是类的指针123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"default\" &lt;&lt; endl; &#125; A(int a, int b) &#123; cout &lt;&lt; \"int a, int b\" &lt;&lt; endl; &#125; A(char a, char b) &#123; cout &lt;&lt; \"char a, char b\" &lt;&lt; endl; &#125; A(const A &amp;a) &#123; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; void eat() const &#123; cout &lt;&lt; this-&gt;a &lt;&lt; endl; &#125; int a = 5;private:&#125;;int main(int argc, char *argv[]) &#123; A a; a.eat(); system(\"pause\"); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"14、static修饰类成员变量与函数","slug":"Cpp/14、static修饰类成员变量与函数","date":"2014-03-01T00:54:19.000Z","updated":"2020-08-07T14:10:11.702Z","comments":true,"path":"2014/03/01/Cpp/14、static修饰类成员变量与函数/","link":"","permalink":"https://www.zackaddy.xin/2014/03/01/Cpp/14、static修饰类成员变量与函数/","excerpt":"","text":"修饰类成员变量 修饰类变量12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"default\" &lt;&lt; endl; &#125; A(int a, int b) &#123; cout &lt;&lt; \"int a, int b\" &lt;&lt; endl; &#125; A(char a, char b) &#123; cout &lt;&lt; \"char a, char b\" &lt;&lt; endl; &#125; A(const A &amp;a) &#123; &#125; ~A() &#123; cout &lt;&lt; \"~A()\" &lt;&lt; endl; &#125; static void say() &#123; cout &lt;&lt; \"hello world\" &lt;&lt; endl; &#125; static int age;private:&#125;;int A::age = 100;int main(int argc, char *argv[]) &#123; cout &lt;&lt; A::age &lt;&lt; endl; A::say(); system(\"pause\"); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"13、new与delete","slug":"Cpp/13、new与delete","date":"2014-02-27T19:51:35.000Z","updated":"2020-08-07T14:10:11.702Z","comments":true,"path":"2014/02/28/Cpp/13、new与delete/","link":"","permalink":"https://www.zackaddy.xin/2014/02/28/Cpp/13、new与delete/","excerpt":"","text":"new 在堆上开辟空间,和malloc一样 delete 会调用对象析构函数，free不会 delete 后指针地址被改变，free不会 普通 123456int *p = new int;*p = 10;if (p != NULL) &#123; delete p; p = NULL;&#125; 数组 123456int *p = new int[10];p[0] = 10;if (p != NULL) &#123; delete[] p; p = NULL;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"12、拷贝构造函数","slug":"Cpp/12、拷贝构造函数","date":"2014-02-26T18:34:46.000Z","updated":"2020-08-07T14:10:11.688Z","comments":true,"path":"2014/02/27/Cpp/12、拷贝构造函数/","link":"","permalink":"https://www.zackaddy.xin/2014/02/27/Cpp/12、拷贝构造函数/","excerpt":"","text":"123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class TestA &#123;public: int age; TestA(int a = 10) &#123; cout &lt;&lt; 55 &lt;&lt; endl; &#125; TestA(TestA &amp;t) &#123; cout &lt;&lt; \"copy\" &lt;&lt; endl; &#125; ~TestA() &#123; cout &lt;&lt; 77 &lt;&lt; endl; &#125;&#125;;int main() &#123; TestA t; TestA a = t; // a = t 这种是操作符运算，必须如上定义时赋值才行 //TestA a(t); 这种当然也是有效的 return 0;&#125; 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class TestA &#123;public: TestA(int a) &#123; age = a; cout &lt;&lt; 55 &lt;&lt; endl; &#125; TestA(TestA &amp;t) &#123; cout &lt;&lt; \"copy\" &lt;&lt; endl; &#125; ~TestA() &#123; cout &lt;&lt; 77 &lt;&lt; endl; &#125; void getA() &#123; cout &lt;&lt; age &lt;&lt; endl; &#125;private: int age;&#125;;void ss(TestA t) &#123;//这里会触发copy构造函数&#125;int main() &#123; TestA t1(10); ss(t1); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"11、构造函数中的初始化列表初始化字段","slug":"Cpp/11、构造函数中的初始化列表初始化字段","date":"2014-02-26T00:57:01.000Z","updated":"2020-08-07T14:10:11.688Z","comments":true,"path":"2014/02/26/Cpp/11、构造函数中的初始化列表初始化字段/","link":"","permalink":"https://www.zackaddy.xin/2014/02/26/Cpp/11、构造函数中的初始化列表初始化字段/","excerpt":"","text":"只能用在构造函数右侧 :字段(值) 如果字段是class类型，则触发此类的拷贝构造函数，而不是operator=操作符函数1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; class Line&#123; public: void setLength( double len ); double getLength( void ); Line(double len); // 这是构造函数 private: double length;&#125;; // 成员函数定义，包括构造函数Line::Line( double len):length(len)&#123; cout &lt;&lt; \"Object is being created, length = \" &lt;&lt; len &lt;&lt; endl; length = len;&#125; void Line::setLength( double len )&#123; length = len;&#125; double Line::getLength( void )&#123; return length;&#125;// 程序的主函数int main( )&#123; Line line(10.0); // 获取默认设置的长度 cout &lt;&lt; \"Length of line : \" &lt;&lt; line.getLength() &lt;&lt;endl; // 再次设置长度 line.setLength(6.0); cout &lt;&lt; \"Length of line : \" &lt;&lt; line.getLength() &lt;&lt;endl; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"10、无参构造函数与析构函数","slug":"Cpp/10、无参构造函数与析构函数","date":"2014-02-25T03:33:57.000Z","updated":"2020-08-07T14:10:11.688Z","comments":true,"path":"2014/02/25/Cpp/10、无参构造函数与析构函数/","link":"","permalink":"https://www.zackaddy.xin/2014/02/25/Cpp/10、无参构造函数与析构函数/","excerpt":"","text":"构造函数 如果一个类没有提供构造函数，那么编译编译器会为你自动合成一个不带参数的构造函数，如果提供任何一个，编译器不再为你合成。 析构函数 1.函数名是在类名前加上~，无参数且无返回值。 2.一个类只能有且有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数（合成析构函数）。 3.析构函数不能重载。每有一次构造函数的调用就会有一次析构函数的调用。 4.析构函数必须定义在public内 5.析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源 谁先构造谁后析构123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class TestA &#123;public: TestA()&#123; cout &lt;&lt; 55 &lt;&lt; endl; &#125; void say() &#123; cout &lt;&lt; 66 &lt;&lt; endl; &#125; ~TestA() &#123; cout &lt;&lt; 77 &lt;&lt; endl; &#125;private:&#125;;int main() &#123; TestA t = TestA(); // 55 TestA t; //55 TestA t(); // 调用无参构造不支持这种声明 TestA *t = new TestA();//55 这种方式定义必须配合delete 析构函数才能调用 t-&gt;say();//66 delete t; // 77 return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"9.1、类与类之间的关系","slug":"Cpp/9.1、类与类之间的关系","date":"2014-02-24T02:02:56.000Z","updated":"2020-08-07T14:10:11.726Z","comments":true,"path":"2014/02/24/Cpp/9.1、类与类之间的关系/","link":"","permalink":"https://www.zackaddy.xin/2014/02/24/Cpp/9.1、类与类之间的关系/","excerpt":"","text":"简介 C++中代码可重用性是通过继承来实现的 父类为基类、子类为派生类 类与类之间的关系 类与类之间存在三种关系 has-A 一个类中的数据成员是另外一个类 uses-A 一个类中的成员方法实参是另外一个类 is-A 一个类继承另外一个类 代码示例1.has-A示例 B has A 123456789101112131415#include &lt;iostream&gt;using namespace std;class A &#123;&#125;;class B &#123;public: A a;&#125;;int main(int argc, char *argv[]) &#123; return 0;&#125; 2.uses-A示例 B uses A 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class A &#123;&#125;;class B &#123;public: void say(A *a) &#123; &#125;&#125;;int main(int argc, char *argv[]) &#123; return 0;&#125; 3.is-A示例 B is A 12345678910111213#include &lt;iostream&gt;using namespace std;class A &#123;&#125;;class B: public A &#123;&#125;;int main(int argc, char *argv[]) &#123; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"9.0、函数重载","slug":"Cpp/9.0、函数重载","date":"2014-02-23T03:04:24.000Z","updated":"2020-08-07T14:10:11.726Z","comments":true,"path":"2014/02/23/Cpp/9.0、函数重载/","link":"","permalink":"https://www.zackaddy.xin/2014/02/23/Cpp/9.0、函数重载/","excerpt":"","text":"函数名相同 参数列表不同 参数类型不同 ==返回值类型不能构成重载== 不要使用默认参数避免冲突123456789101112131415#include &lt;iostream&gt;using namespace std;void say(int i, int b)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;void say(int i = 0)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;int main() &#123; say(1); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"8、函数参数默认值","slug":"Cpp/8、函数参数默认值","date":"2014-02-22T02:37:06.000Z","updated":"2020-08-07T14:10:11.726Z","comments":true,"path":"2014/02/22/Cpp/8、函数参数默认值/","link":"","permalink":"https://www.zackaddy.xin/2014/02/22/Cpp/8、函数参数默认值/","excerpt":"","text":"12345678910111213#include &lt;iostream&gt;using namespace std;void say(int i = 0, int b = 0)&#123; cout &lt;&lt; i &lt;&lt; endl;&#125;int main() &#123; say(1); return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"7、内联函数","slug":"Cpp/7、内联函数","date":"2014-02-21T00:02:25.000Z","updated":"2020-08-07T14:10:11.725Z","comments":true,"path":"2014/02/21/Cpp/7、内联函数/","link":"","permalink":"https://www.zackaddy.xin/2014/02/21/Cpp/7、内联函数/","excerpt":"","text":"c/c++都支持 inline函数编译歩骤 1、将inline函数体复制到inline函数调用点处； 2、为所用inline函数中的局部变量分配内存； 3、将inline函数的的输入参数和返回值映射到调用方法的局部变量空间中； 4、如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支（使用GOTO）。 优点 没有普通函数调用的开销（压桟、跳转、返回） 缺点 1、代码膨胀。如果inline函数体过大且编译器还让它inline成功，那么你最终的程序会代码膨胀，从而造成设备缓冲命中率低，引起较多的页面错误，读写硬盘的次数增多，这样程序的性能就下降了！建议：inline函数体一般不要超过5行，不包括循环，不包括递归调用。 2、inline函数内部不要有static变量。inline函数的定义几乎总是放在头文件（.h）里，这允许多个实现文件（.cpp）得以引用。我们知道编译器是分别编译的，所以这个时候，在多个实现文件里就会有多个inline函数的展开，也就是说有个多个static变量，这恐怕不是我们期望的！ 3、inline函数无法随着函数库升级而升级。如果f是函数库中的一个inline函数，使用它的用户会将f函数实体编译到他们的程序中。一旦函数库实现者改变f，所有用到f的程序都必须重新编译。如果f是non-inline的，用户程序只需重新连接即可。如果函数库采用的是动态连接，那这一升级的f函数可以不知不觉的被程序使用。 4、不要获取inline函数的地址。如果要取得一个inline函数的地址，编译器就必须为此函数产生一个函数实体，无论如何，编译器无法交出一个“不存在函数”的指针。注意，有些编译器可能会使用类的constructors和destructors的函数指针，用以构造和析构一个class对象的数组。另外类的constructors和destructors可能简单，但是其父类的类的constructors和destructors可能是复杂的，所以类的constructors和destructors往往不是inline函数的最佳选择！ 5、inline虚函数往往是无效的。虚函数往往是运行时确定的，而inline是在编译时进行的，所以inline虚函数往往无效。当然如果直接用类的对象来使用虚函数，那么对有的编译器而言，也可起到优化的作用。 6、inline函数无法调试。原因请参见上面编译器将函数inline的步骤。所以请在项目后期，对程序进行profile后，再决定将那些函数inline化。 inline前1234567891011121314int test()&#123; int a = 6; ...... // 此处省略代码未对a经行修改 int b = inline_func(b); ...... // 此处省略代码未对b经行修改 int c = b + 1; ...... &#125; inline int inline_func(int q) &#123; if (q &gt; 10) return -1; else if (q &gt; 0) return (1 &lt;&lt; q) - 1; else return 0; &#125; inline后12345678910111213141516int test() &#123; int a = 6; ...... // 此处省略代码未对a经行修改 int b; &#123; int _temp_q = 6; int _temp; if (_temp_q &gt; 10) _temp = -1; else if (_temp_q &gt; 0) _temp = (1 &lt;&lt; q) - 1; else _temp = 0; b = _temp; &#125; ...... // 此处省略代码未对b经行修改 int c = b + 1; ...... &#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"6、引用类型","slug":"Cpp/6、引用类型","date":"2014-02-19T20:52:04.000Z","updated":"2020-08-07T14:10:11.725Z","comments":true,"path":"2014/02/20/Cpp/6、引用类型/","link":"","permalink":"https://www.zackaddy.xin/2014/02/20/Cpp/6、引用类型/","excerpt":"","text":"给变量起别名 申明后不可改变 定义同时必须赋值 作为函数形参12int a = 10;int &amp;re = a; // re是a的引用 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; int a = 10; int &amp;re = a; re = 50; cout &lt;&lt; a &lt;&lt; endl;//50 return 0;&#125; 12345678910111213#include &lt;iostream&gt;using namespace std;void say(int &amp;re) &#123; re = 50;&#125;int main() &#123; int a = 10; say(a); cout &lt;&lt; a &lt;&lt; endl; // 50 return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"5、枚举的增强","slug":"Cpp/5、枚举的增强","date":"2014-02-18T21:21:34.000Z","updated":"2020-08-07T14:10:11.725Z","comments":true,"path":"2014/02/19/Cpp/5、枚举的增强/","link":"","permalink":"https://www.zackaddy.xin/2014/02/19/Cpp/5、枚举的增强/","excerpt":"","text":"c++12345enum color &#123; red, pink&#125; c;c = 1; //c++不可以c = pink;//必须这种形式","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"4、const增强","slug":"Cpp/4、const增强","date":"2014-02-17T19:58:13.000Z","updated":"2020-08-07T14:10:11.724Z","comments":true,"path":"2014/02/18/Cpp/4、const增强/","link":"","permalink":"https://www.zackaddy.xin/2014/02/18/Cpp/4、const增强/","excerpt":"","text":"c++12345const int a = 10;int *p = &amp;a; //编译器临时创建一个地址赋值给p，不是a的地址*p = 20;cout &lt;&lt; *p &lt;&lt; a &lt;&lt; endl;//20 10","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"3、三目运算符增强","slug":"Cpp/3、三目运算符增强","date":"2014-02-17T02:25:20.000Z","updated":"2020-08-07T14:10:11.724Z","comments":true,"path":"2014/02/17/Cpp/3、三目运算符增强/","link":"","permalink":"https://www.zackaddy.xin/2014/02/17/Cpp/3、三目运算符增强/","excerpt":"","text":"当成左值c中 123int a = 10;int b = 20;*(a &lt; b ? &amp;a : &amp;b) = 50; 当成左值c++中 123int a = 10;int b = 20;((a &lt; b) ? a : b) = 50;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"2.1、宽字符类型","slug":"Cpp/2.1、宽字符类型","date":"2014-02-15T21:29:31.000Z","updated":"2020-08-07T14:10:11.703Z","comments":true,"path":"2014/02/16/Cpp/2.1、宽字符类型/","link":"","permalink":"https://www.zackaddy.xin/2014/02/16/Cpp/2.1、宽字符类型/","excerpt":"","text":"老版c++宽字符，wchar_t;要在常量值前加L; c++11，char16_t常量前加u char32_t常量前加U 宽字符使用cout直接输出整数值，使用wcout也只能输出整数值，不能输出中文。","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"2、bool类型","slug":"Cpp/2、bool类型","date":"2014-02-15T00:39:47.000Z","updated":"2020-08-07T14:10:11.710Z","comments":true,"path":"2014/02/15/Cpp/2、bool类型/","link":"","permalink":"https://www.zackaddy.xin/2014/02/15/Cpp/2、bool类型/","excerpt":"","text":"12345bool a = true;a == 1a = 50;//1a = -50;//0","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"1.1、头文件命名约定","slug":"Cpp/1.1、头文件命名约定","date":"2014-02-14T01:53:43.000Z","updated":"2020-08-07T14:10:11.688Z","comments":true,"path":"2014/02/14/Cpp/1.1、头文件命名约定/","link":"","permalink":"https://www.zackaddy.xin/2014/02/14/Cpp/1.1、头文件命名约定/","excerpt":"","text":"头文件命名约定 使用.hpp、.hxx作为c++头文件扩展名是有道理的ANSI/ISO委员会也这样认为，问题在于使用哪种扩展名，最终他们一致同意不使用扩展名 头文件类型 约定 示例 说明 C旧式风格 以.h结尾 math.h C、C++程序可以使用 C++旧式风格 以.h结尾 iostream.h C++程序可以使用 C++新式风格 没有扩展名 iostream C++程序可以使用，使用namespace std 转换后的C 加上前缀c，没有扩展名 cmath C++程序可以使用，可以使用不是C的特性如namespace std","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"1.0、HelloWorld与命名空间","slug":"Cpp/1.0、HelloWorld与命名空间","date":"2014-02-12T17:15:26.000Z","updated":"2020-08-07T14:10:11.688Z","comments":true,"path":"2014/02/13/Cpp/1.0、HelloWorld与命名空间/","link":"","permalink":"https://www.zackaddy.xin/2014/02/13/Cpp/1.0、HelloWorld与命名空间/","excerpt":"","text":"123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;namespace spaceA &#123; int a = 10;&#125;namespace spaceB &#123; int b = 10;&#125;using namespace spaceA;using namespace spaceB;int main() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;namespace spaceA &#123; int a = 10; namespace spaceB &#123; int b = 14; &#125;&#125;using namespace spaceA;using namespace spaceB;int main() &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;namespace spaceA &#123; int a = 10; namespace spaceB &#123; int b = 14; &#125;&#125;using namespace spaceA::spaceB;int main() &#123; cout &lt;&lt; a &lt;&lt; endl; //error cout &lt;&lt; b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/tags/Cpp/"}],"keywords":[{"name":"Cpp","slug":"Cpp","permalink":"https://www.zackaddy.xin/categories/Cpp/"}]},{"title":"18、计算机网络 之数据链路层 CSMA、CD 协议","slug":"计算机网络/18、计算机网络 之数据链路层 CSMA、CD 协议","date":"2013-09-08T06:00:00.000Z","updated":"2020-08-07T14:10:11.898Z","comments":true,"path":"2013/09/08/计算机网络/18、计算机网络 之数据链路层 CSMA、CD 协议/","link":"","permalink":"https://www.zackaddy.xin/2013/09/08/计算机网络/18、计算机网络 之数据链路层 CSMA、CD 协议/","excerpt":"","text":"计算机网络 之数据链路层 CSMA、CD 协议简介CSMA/CD 含义：载波监听多点接入 / 碰撞检测 (Carrier Sense Multiple Access with Collision Detection) 。 “多点接入”表示许多计算机以多点接入的方式连接在一根总线上。 “载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。 其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。 在具有广播特性的总线上实现了一对一的通信。 碰撞检测由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。 B 若在 A 发送的信息到达 B 之前发送自己的帧 (因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。 碰撞的结果是两个帧都变得无用。 所以需要在发送期间进行碰撞检测，以检测冲突。 “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表示产生了碰撞。所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测” 检测到碰撞后 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机的时间后再次发送 碰撞检测工作过程 准备发送。但在发送之前，必须先检测信道。 检测信道。若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔），就发送这个帧。 检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里只有两种可能性： 发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。 发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 (2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"17、计算机网络 之数据链路层以太网特点","slug":"计算机网络/17、计算机网络 之数据链路层以太网特点","date":"2013-09-08T05:00:00.000Z","updated":"2020-08-07T14:10:11.898Z","comments":true,"path":"2013/09/08/计算机网络/17、计算机网络 之数据链路层以太网特点/","link":"","permalink":"https://www.zackaddy.xin/2013/09/08/计算机网络/17、计算机网络 之数据链路层以太网特点/","excerpt":"","text":"计算机网络 之数据链路层以太网特点局域网的特点与优点局域网最主要的特点是：网络为一个单位所拥有，且地理范围和结点数目均有限。 局域网具有如下的一些主要优点。 具有广播功能，从一个站点可以很方便的访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐的演变，各设备的位置可灵活调整和改变。 提高了系统的可靠性、可用性和生存性。 最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。 共享通信媒体静态信道划分 频分复用 时分复用 波分复用 码分复用 动态媒体接入控制（多点接入） 随机接入（主要被以太网采用！） 受控接入，如多点线路探寻（polling），或轮询。（目前已不被采用） 适配器（网卡）作用网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或“网卡”。适配器的重要功能： 进行串行/并行转换。 对数据进行缓存。 在计算机的操作系统安装设备驱动程序。 实现以太网协议。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"16、计算机网络 之数据链路层PPP协议","slug":"计算机网络/16、计算机网络 之数据链路层PPP协议","date":"2013-09-07T09:00:00.000Z","updated":"2020-08-07T14:10:11.898Z","comments":true,"path":"2013/09/07/计算机网络/16、计算机网络 之数据链路层PPP协议/","link":"","permalink":"https://www.zackaddy.xin/2013/09/07/计算机网络/16、计算机网络 之数据链路层PPP协议/","excerpt":"","text":"计算机网络 之数据链路层PPP协议简介数据链路使用的信道主要有以下两种类型，一种是广播，一种就是点对点。 对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。 用户使用拨号电话线接入互联网时， 用户计算机和 ISP 进行通信时所使用的数据链路层协议就是 PPP 协议。 PPP 协议有三个组成部分： 一个将 IP 数据报封装到串行链路的方法。 链路控制协议 LCP (Link Control Protocol)。 网络控制协议 NCP (Network Control Protocol)。 PPP协议帧的格式PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。 标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 控制字段 C 通常置为 0x03。 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。 PPP协议透明传输的问题PPP协议也是要解决透明传输的问题，来确保我们的帧的定界。 当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。 字符填充 将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D, 0x5E)。 若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列 (0x7D, 0x5D)。 若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。 零比特填充 PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。 在发送端，只要发现有 5 个连续 1，则立即填入一个 0。 接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除 PPP不提供使用序号和确认的可靠传输 在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。 在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。 帧检验序列 FCS 字段可保证无差错接受。 PPP工作状态 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。 PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。 这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。 通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。 可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"15、计算机网络 之数据链路层三个基本问题","slug":"计算机网络/15、计算机网络 之数据链路层三个基本问题","date":"2013-09-07T08:00:00.000Z","updated":"2020-08-07T14:10:11.898Z","comments":true,"path":"2013/09/07/计算机网络/15、计算机网络 之数据链路层三个基本问题/","link":"","permalink":"https://www.zackaddy.xin/2013/09/07/计算机网络/15、计算机网络 之数据链路层三个基本问题/","excerpt":"","text":"计算机网络 之数据链路层三个基本问题封装成帧封装成帧 (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧 首部和尾部的一个重要作用就是进行帧定界。 对于定界而言，我们可以使用控制字符进行帧定界 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。 例子： 控制字符 SOH (Start Of Header) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT (End Of Transmission) 表示帧的结束。 透明传输当然了，我们有可能会想到当我们的首部和尾部在数据中就已经出现的时候，那么我们的帧怎么定界呢？？？ 解决方法：字节填充 (byte stuffing) 或字符填充 (character stuffing)。 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC” (其十六进制编码是 1B)。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 差错检测在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate) 误码率与信噪比有很大的关系 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 循环冗余检验在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在发送端，先把数据划分为组。假定每组 k 个比特。 假设待传送的一组数据 M = 101001（现在 k = 6）。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。 用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。 得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位。 将余数 R 作为冗余码拼接在数据 M 后面发送出去。 1234567891011例子：现在 k = 6, M = 101001。设 n = 3, 除数 P = 1101，被除数是 (2^n) * M = 101001000。模 2 运算的结果是：商 Q = 110101，余数 R = 001。把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2nM + R 。即：101001001，共 (k + n) 位。 接收端对收到的每一帧进行 CRC 检验 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。 若余数 R != 0，则判定这个帧有差错，就丢弃。 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 帧检验序列 FCS在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。 循环冗余检验 CRC 和帧检验序列 FCS 并不等同。 CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 差错检测只是保证在传输过程中帧无差错 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受 (accept)。 “无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错” 在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。 要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"14、计算机网络 之数据链路层概念","slug":"计算机网络/14、计算机网络 之数据链路层概念","date":"2013-09-06T08:00:00.000Z","updated":"2020-08-07T14:10:11.897Z","comments":true,"path":"2013/09/06/计算机网络/14、计算机网络 之数据链路层概念/","link":"","permalink":"https://www.zackaddy.xin/2013/09/06/计算机网络/14、计算机网络 之数据链路层概念/","excerpt":"","text":"计算机网络 之数据链路层概念数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 数据链路层只关注数据在链路层流通的情况： 数据链路和帧 链路（link）是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路 (data link)除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。 物理链路就是上面所说的链路。 逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。 数据链路层传送的是帧 数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"13、计算机网络 之物理层宽带接入技术","slug":"计算机网络/13、计算机网络 之物理层宽带接入技术","date":"2013-09-06T07:00:00.000Z","updated":"2020-08-07T14:10:11.897Z","comments":true,"path":"2013/09/06/计算机网络/13、计算机网络 之物理层宽带接入技术/","link":"","permalink":"https://www.zackaddy.xin/2013/09/06/计算机网络/13、计算机网络 之物理层宽带接入技术/","excerpt":"","text":"计算机网络 之物理层宽带接入技术xDSL技术（一般了解）DSL 就是数字用户线(Digital Subscriber Line)的缩写。而 DSL 的前缀 x 则表示在数字用户线上实现的不同宽带方案。xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 虽然标准模拟电话信号的频带被限制在 3003400 kHz 的范围内，但用户线本身实际可通过的信号频率仍然超过 1 MHz。xDSL 技术就把 04 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 xDSL 的几种类型 ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线，非对称指 下行（从ISP到用户）带宽远远大于上行带宽 HDSL (High speed DSL)：高速数字用户线 SDSL (Single-line DSL)：1 对线的数字用户线 VDSL (Very high speed DSL)：甚高速数字用户线 DSL ：ISDN 用户线。 RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率） ADSL 的极限传输距离ADSL 的极限传输距离与数据率以及用户线的线径都有很大的关系（用户线越细，信号传输时的衰减就越大），而所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。 例如，0.5 毫米线径的用户线，传输速率为 1.5 ~ 2.0 Mb/s 时可传送 5.5 公里，但当传输速率提高到 6.1 Mb/s 时，传输距离就缩短为 3.7 公里。 如果把用户线的线径减小到0.4毫米，那么在6.1 Mb/s的传输速率下就只能传送2.7公里 ADSL 的特点上行和下行带宽做成不对称的上行指从用户到 ISP，而下行指从 ISP 到用户ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。 DMT 技术DMT 调制技术采用频分复用的方法，把 40 kHz 以上一直到 1.1 MHz 的高端频谱划分为许多的子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。每个子信道占据 4 kHz 带宽（严格讲是 4.3125 kHz），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。 ADSL 的数据率由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），因此 ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率。当 ADSL 启动时，用户线两端的 ADSL 调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。ADSL 不能保证固定的数据率。对于质量很差的用户线甚至无法开通 ADSL。通常下行数据率在 32 kb/s 到 6.4 Mb/s 之间，而上行数据率在 32 kb/s 到 640 kb/s 之间。 光纤接入技术光纤同轴混合网HFC (Hybrid Fiber Coax) HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。 HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。 HFC网的主干线路采用光纤； HFC 网采用结点体系结构 ； HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能 ； FTTx 技术FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。 光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。 光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"12、计算机网络 之物理层数字传输系统","slug":"计算机网络/12、计算机网络 之物理层数字传输系统","date":"2013-09-05T07:00:00.000Z","updated":"2020-08-07T14:10:11.897Z","comments":true,"path":"2013/09/05/计算机网络/12、计算机网络 之物理层数字传输系统/","link":"","permalink":"https://www.zackaddy.xin/2013/09/05/计算机网络/12、计算机网络 之物理层数字传输系统/","excerpt":"","text":"计算机网络 之物理层数字传输系统简介现在的数字传输系统都是采用脉码调制（Pulse Code Modulation） 体制。PCM最初并非传输计算机数据用的，而是使交换机之间有一条中继线不是只传送一条电话信号。PCM有两个标准即E1和T1。我国采用的是欧洲的E1标准。T1的速率是1.544Mbit/s,E1的速率是2.048Mbit/s。 PCM编码PCM就是把一个时间连续，取值连续的模拟信号变换成时间离散，取值离散的数字信号后在信道中传输。简而言之PCM就是对模拟信号先抽样，再对样值幅度量化，编码的过程。例如听到的声音就是模拟信号，然后对声音采样，量化，编码产生数字信号。相对自然界声音信号，任何音频编码都是有损的，在计算机应用中，能达到高保真的就是PCM编码，因此PCM约定成俗成了无损编码，对于声音而言，我们通常采用PCM编码。 采样率，单位时间内采样次数，采样率越高，音质越好，人耳听觉范围大致在20HZ-20KHZ，采样频率超过信号带宽2倍不会产生混迭，例如常用的规范采用44.1kHZ作为标准采样率，大于20kHZ两倍，所以44.1kHZ采样率足够用。 采样大小，存储空间常见的有8bit，16bit，32bit，64bit等，每个采样数据记录的是振幅，采样精度取决于空间大小，采样率和采样大小值越大，音质越好。 声道，常见的有单声道，双声道，双声道数据量比单声道大一倍。 例如 “44.1kHZ，16bit, 2channel” 格式，速率就是 44100 * 16 * 2 = 1411200 kpbs，如果pcm文件大小为10M，则播放时长 10 * 1024 * 1024 * 8 / 1411200 = 59.5s","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"11、计算机网络 之物理层信道复用","slug":"计算机网络/11、计算机网络 之物理层信道复用","date":"2013-09-05T06:00:00.000Z","updated":"2020-08-07T14:10:11.896Z","comments":true,"path":"2013/09/05/计算机网络/11、计算机网络 之物理层信道复用/","link":"","permalink":"https://www.zackaddy.xin/2013/09/05/计算机网络/11、计算机网络 之物理层信道复用/","excerpt":"","text":"计算机网络 之物理层信道复用简介“复用”是一种将若干个彼此独立的信号，合并为一个可在同一信道上同时传输的复合信号的方法 如下是复用的示意图： 复用技术常见以下几种： 频分复用 时分复用（统计时分复用） 波分复用 码分复用 频分复用 FDM（Frequency Division Multiplexing）这种方法就是将不同频率的数据合成在同一信道发送，在接收端再将其分开。 频分复用是指一条线路给多个用户共同使用，按照频率分割给各个用户，收音机就是个例子，你在调台时候就是调节接受的频率，所有的信号共用“无线”这个载体。 时分复用（TDM）TDM帧：将传输时间划分为多个等长的时间段（TDM帧） 时隙：每个TDM帧划分成更小的时间段（时隙），每个用户在每个TDM帧中占用固定的时隙进行通信。类似分时OS的时间片概念。 当采用时分复用时，所有用户在不同的时间占用同样的频带宽度（分时不分频）。 时分复用可能会造成线路资源的浪费 统计时分复用 (Statistic TDM)集中器：连接低速用户，集中数据传输。 STDM帧 不等长，时隙数小于所连接的用户数 不是固定分配时隙，而是按需分配时隙，可提高线路的利用率。 增加地址信息 由于STDM帧中的时隙不是固定地分配给某个用户，因此在每个时隙中还必须有用户的地址信息，这将产生额外开销。 波分复用WDM波分复用WDM(Wavelength Division Multiplexing)是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术 波分复用就是光的频分复用，原理与频分复用大致相同 码分复用(CDM)常用的名词是码分多址 CDMA (Code Division Multiple Access)。 码分复用CDM（Code Division Multiplexing）是各用户使用经过特殊挑选的不同码型，在同样的时间使用同样的频带进行通信，但彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 在CDMA中，每一个比特时间划分为 m 个短的间隔，称为码片(chip)。通常m的值是64或者128。 每个站被指派一个惟一的 m bit 码片序列(chip sequence) 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 每一个站分配的码片序列不仅必须各不相同，并且还必须相互正交（内积为0）。 例如，S 站的 8 bit 码片序列是 00011011。 发送比特 1 时，就发送序列 00011011，发送比特 0 时，就发送序列 11100100。 为了方便，接惯例将码片中的0写为-1，将1写为+1，S 站的码片序列： 1(–1 –1 –1 +1 +1 –1 +1 +1) 若S站信息发送率为b（b/s），则实际数据发送率为mb（Baud），同时S站所占用的频带宽度也提高到原来的m倍。 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量，m bit。 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积(inner product)都是 0： 任何一个码片向量和该码片向量自己的规格化内积都是1 。 例如S为 （+1,+1,-1）,则 1(1/3) * 3 = 1 一个码片向量和该码片反码的向量的规格化内积值是 –1。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"10、计算机网络 之物理层下面的传输媒体","slug":"计算机网络/10、计算机网络 之物理层下面的传输媒体","date":"2013-09-05T05:00:00.000Z","updated":"2020-08-07T14:10:11.896Z","comments":true,"path":"2013/09/05/计算机网络/10、计算机网络 之物理层下面的传输媒体/","link":"","permalink":"https://www.zackaddy.xin/2013/09/05/计算机网络/10、计算机网络 之物理层下面的传输媒体/","excerpt":"","text":"计算机网络 之物理层下面的传输媒体简介传输媒体也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。 传输媒体可分为两类： 导引型传输媒体 非导引型传输媒体（自由空间） 导引型传输媒体导引型传输媒体中，电磁波沿着固体m媒体传播。 双绞线 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆 50欧同轴电缆 用于数字传输，由于多用于基带传输，也叫基带同轴电缆 75欧同轴电缆 用于模拟传输，即宽带同轴电缆 光缆 双绞线 双绞线也成为双扭线。把两根互相绝缘的铜导线并排放在一起，然后用规则的方法绞合（twist）起来就构成了双绞线。绞合可减少对相邻导线的电磁干扰。几乎所有的电话都用双绞线连接到电话交换机。 模拟传输和数字传输都可以使用双绞线。但距离太长时，对于模拟传输，就要加放大器以便将衰减了的信号放大到合适的数值；对于数字传输，就要加上中继器以便将失真了的数字信号进行整形。双绞线的导线越粗，其通信距离就越远，其价格也越高，由于其价格便宜且性能也不错，因此使用十分广泛。 为了提高双绞线的抗电磁干扰能力，可以在双绞线的外面再加上一层用金属丝编织成屏蔽层，这就是屏蔽双绞线。无论是那种像，衰减都随频率的升高而增大。使用更粗的导线可以降低衰减，但却增加了导线的价格和重量。 同轴电缆 同轴电缆由内导体铜质芯线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。但随着技术的进步，在局域网领域基本上都是采用双绞线作为传输媒体。目前同轴电缆主要用在有线电视网的居民小区中。同轴电缆的宽带取决于电缆的质量。 光缆 光缆通信就是利用光导纤维传递光脉冲来进行通信。有光脉冲相当于1，而无光脉冲相当于0。由于可见光的频率非常高，约为MHz的量级，因此一个光纤通信系统的传输宽带远大于目前其它各种传输媒体的宽带。 光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲，在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。 光纤通常由非常长透明的石英玻璃拉成细丝，主要由纤芯和包层构成双层通信圆柱体。 单模光纤指只能传输一种电磁模式，多模光纤只可以传输多个电磁波模式，实际上单模光纤和多模光前之分，也就是纤芯的直径之分。单模光纤系，多模光纤粗。在有线电视网络中使用的光纤全是单模光纤，其传播性好，带宽可达10GHZ，可以在一根光纤中传输60套PAL-D电视节目。 非导引型传输媒体","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"9、计算机网络 之物理层奈氏准则与香农定理","slug":"计算机网络/9、计算机网络 之物理层奈氏准则与香农定理","date":"2013-09-05T04:00:00.000Z","updated":"2020-08-07T14:10:11.900Z","comments":true,"path":"2013/09/05/计算机网络/9、计算机网络 之物理层奈氏准则与香农定理/","link":"","permalink":"https://www.zackaddy.xin/2013/09/05/计算机网络/9、计算机网络 之物理层奈氏准则与香农定理/","excerpt":"","text":"计算机网络 之物理层奈氏准则与香农定理简介在计算机通信中，想要完全准确无误地传输信息几乎是不可能的，很多因素都要影响信息传递的效果，为了应对这些问题，人们通常用奈氏准则与香农定理来描述信息传递中的一些情况，尤其是速率。 计算机通信中出现信号的失真是目前人类无法避免的一个问题，引起失真的因素有很多，码元传输速率、信号传输距离、传输中的噪声干扰以及传输媒介的性质都有可能对信号的传递带来麻烦。 何为带宽信道的一个重要指标就是带宽。何为带宽，其实就是一个信道内允许通过的信号的最高频率与最低频率之差。频率就是信号传输的快慢，即单位时间内信源发送的码元数。 打个比方：我让小明守在学校门口，交代他一会儿有一帮人要进学校，你看看到底有多少人进来，其中有没有你熟人。过了一会儿果然有一大帮人以复兴号一般的速度“嗖”地一下从小明眼前飞过，所以小明根本看不清到底有多少人，更辨别不出来里面有没有熟人了。 波特与Bit的区别 奈氏定理为了避免码间串扰，奈奎斯特同志在1924年推导出了著名的奈氏定理：在理想低通（无噪声且带宽受限）的情况下，为了避免码间串扰，极限码元传输速率为：2w(baud)。w指的是信道的带宽，单位是Hz（请注意这里把它和我们平时看见的bit/s区分）。 基于奈氏定理的理想低通信道数据传输速率：2w* log2（V） 。单位为b/s（公式1）。其中w是信道的带宽，V是传输过程中码元的数量。 举例无噪低通信道带宽3kHz，有四个信号相位，每种相位有四种调制，则最大传输速率是多少？ 由题意可得：这个信道需要传输4*4=16中码元（信传过程中码元种数计算见第二节），带宽3kHz，则根据公式1可求出最大传输速率v为： 1V = 2w * log2(V) =2*3000* log2(16) =24kb/s（k代表千） 香农公式香农公式是在奈氏定理的基础之上发展起来的，它相比于奈氏定理的不同之处在于增加了信道内噪声的考虑。 噪声是随机产生的，对于信息传输的影响也是相对的。所以香农引入了信噪比的概念。 1信噪比 = 信息平均功率 / 噪声平均功率 = s/n 为了更形象的表示信噪比，这里引入一个信噪比的度量值：分贝（dB） 1dB = 10 * log2(s/n) （公式2） 据此式引出香农定理：在带宽受限且有噪声的信道上，为了不产生误差，信息传输速率是有上限的。 1V = w * log2(1+s/n) ，单位为（b/s） 举例某信道带宽3000Hz，信噪比30dB，求其极限传输速率。 1v = 3000 * log2(1001) 从功能上来说，奈氏定理是在无噪的条件下，为了避免码间串扰而对码元的极限传输速率做出了一个规范，是针对“码元”的。 而香农公式则是在奈氏定理的基础之上考虑了噪声干扰而对数据传输速率指定的规范，是针对“速率”的。 这也就直接导致了定义公式的不同。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"8、计算机网络 之物理层数据通信基础知识","slug":"计算机网络/8、计算机网络 之物理层数据通信基础知识","date":"2013-09-04T04:00:00.000Z","updated":"2020-08-07T14:10:11.900Z","comments":true,"path":"2013/09/04/计算机网络/8、计算机网络 之物理层数据通信基础知识/","link":"","permalink":"https://www.zackaddy.xin/2013/09/04/计算机网络/8、计算机网络 之物理层数据通信基础知识/","excerpt":"","text":"计算机网络 之物理层数据通信基础知识基本术语 数据(data)——运送消息的实体。 信号(signal)——数据的电气的或电磁的表现。 “模拟的”(analogous)——代表消息的参数的取值是连续的。 “数字的”(digital)——代表消息的参数的取值是离散的。 码元(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 基本概念 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 基带信号和带通信号 基带信号（即基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。 带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 调制方法 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制(modulation)。 最基本的二元制调制方法有以下几种： 调幅(AM)：载波的振幅随基带数字信号而变化。 调频(FM)：载波的频率随基带数字信号而变化。 调相(PM) ：载波的初始相位随基带数字信号而变化。 常用编码 单极性不归零编码 只使用一个电压值，用高电平表示1，没电压表示0 双极性不归零编码 用正电平和负电平分别表示二进制数据的1和0，正负幅值相等。 双极性归零编码 正负零三个电平，信号本身携带同步信息。 曼切斯特编码 差分曼切斯特编码","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"7、计算机网络 之物理层概念","slug":"计算机网络/7、计算机网络 之物理层概念","date":"2013-09-03T04:00:00.000Z","updated":"2020-08-07T14:10:11.900Z","comments":true,"path":"2013/09/03/计算机网络/7、计算机网络 之物理层概念/","link":"","permalink":"https://www.zackaddy.xin/2013/09/03/计算机网络/7、计算机网络 之物理层概念/","excerpt":"","text":"计算机网络 之物理层概念简介物理层考虑的是怎样才能在连接各种计算机的传输媒体（介）上传输数据比特流，而不是指具体的传输媒体（介）。 物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。 用于物理层的协议也常称为物理层规程 (procedure)。 物理层规程也称为物理层协议 物理层主要任务确定与传输媒体接口的一些特性 机械特性：例如接口形状，大小，引线数目 电气特性：例如规定电压范围（-5V到+5V） 功能特性：例如规定-5V表示0，+5V表示1 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"6、计算机网络 之体系结构与OSI参考模型","slug":"计算机网络/6、计算机网络 之体系结构与OSI参考模型","date":"2013-09-02T04:00:00.000Z","updated":"2020-08-07T14:10:11.900Z","comments":true,"path":"2013/09/02/计算机网络/6、计算机网络 之体系结构与OSI参考模型/","link":"","permalink":"https://www.zackaddy.xin/2013/09/02/计算机网络/6、计算机网络 之体系结构与OSI参考模型/","excerpt":"","text":"计算机网络 之体系结构与OSI参考模型简介计算机网络体系结构是网络协议的层次划分与各层协议的集合，同一层中的协议根据该层所要实现的功能来确定。 各对等层之间的协议功能由相应的底层提供服务完成。 基本概念 ISO 国际标准化组织 OSI 互联网法律上的国际标准 TCP/IP Suite 因特网上的国际标准 Network Protocols 数据交换遵守的规则、标准或约定网络体系结构 计算机网络各层及其协议的集合 实体 交换信息的硬件或软件进程 协议 控制两个对等实体通信的规则 服务 下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能 服务访问点 相邻两层实体间 交换信息的地方 OSI的七层协议 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特。 数据链路层：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。 网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 TCP/IP的四层协议 网络接口层：对应着OSI的物理层和数据链路层，负责通过网络发送和接收IP数据报。 网际层：也称互联层、网间网层，主要功能是处理来自传输层的分组，将分组形成数据包（IP数据包），并为该数据包进行路径选择，最终将数据包从源主机发送到目的主机。常用的协议是网际协议IP协议。 运输层：又称为主机至主机层，与OSI传输层类似，负责主机到主机之间的端到端通信，使用传输控制协议TCP协议和用户数据包协议UDP协议。 应用层：与OSI模型中的高三层任务相同，用于提供网络服务。 五层协议 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 数据链路层：使用专门的链路层协议，在两个相邻节点传输数据。数据链路层将网络层交下来的IP数据报组装成帧，每一帧包括数据和必要的控制信息（同步信息、地址信息、差错控制等）。 网络层：为主机之间提供数据传输服务，而像运输层协议那样是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。由于使用IP协议，因此分组也叫IP数据报 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 应用层：应用层协议定义的是应用进程间通信和交互规则。应用程序提供数据传输服务，应用层协议有很多，例如 HTTP、DNS 等。数据单位为报文。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"5、计算机网络 之性能指标","slug":"计算机网络/5、计算机网络 之性能指标","date":"2013-09-01T08:00:00.000Z","updated":"2020-08-07T14:10:11.899Z","comments":true,"path":"2013/09/01/计算机网络/5、计算机网络 之性能指标/","link":"","permalink":"https://www.zackaddy.xin/2013/09/01/计算机网络/5、计算机网络 之性能指标/","excerpt":"","text":"计算机网络 之性能指标速率在数据传输中，两个设备之间数据流动的物理速度成为传输速率，单位为bps。 连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为data rate 或 bit rate 单位是b/s ,kb/s,Mb/s,Gb/s 比如我们使用16Mbps的网线，这个16Mbps表示的是bit，而平时我们下载东西看到的速率是以字节为单位的。1字节=8bit，所以实际最高速度只有16/8Mbps = 2MB/s。 数字信道：比如一台计算机与Internet。计算机在线看电影Internet中为发送端，计算机为接收端，这就是一个信道。看电影的同时，计算机还从Internet下载文件，又形成一个信道。说信道的时候不是说总的，而是某两个特定点流量传输的速度。比如看电影信道2M带宽，下载4M带宽，我们不能说计算机上网的信道是6M带宽。这是两个信道，一个信道的速率指的是一个发送端，一个接收端传输数据的速率 带宽数据通信领域中，数字信道所能传送的最高数据率 单位b/s，kb/s，Mb/s，Gb/s 吞吐量实际的数据量(受网络拥堵程度等影响),即单位时间内通过某个网络的数据量； 单位b/s，kb/s，Mb/s，Gb/s 时延 发送时延1发送时延 = 数据块长度（比特）/ 信道带宽（比特/秒） 传播时延即传输指定距离所用的时间。 1传播时延 = 信道长度（米）/ 信号在信道上的传播速率（米/秒） 处理时延网络节点存储转发处理时间。 排队时延当多个数据传输到结点A时要进行排队处理。 时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 1时延带宽积 = 传播时延 * 带宽 往返时间RTT（Round-Trip Time） 从发送方发送数据开始，到发送方收到接收方确认的时间。可以通过ping命令测试往返时间。 信道利用率信道利用率是指发送时延除以发送时延加上往返传输时延 123信道利用率 = 有数据通过时间 / （有+无）数据通过时间信道利用率 = 发送时延 / (发送时延 + 往返传播时延) 假设信道的长度为10km，往返传输时延为10ms,传输数据长度为2048bit，发送端的发送速率为1Mbps，在其他时延忽略的情况下，求信道利用率。 发送时延：2048 / (1 * 1000 * 1000) = 2.048ms 信道利用率：2.048 / (2.048 + 10) = 17% 时延与信道利用率的关系 D0表示网络空闲时间 D表示网络当前时延 U表示信道利用率 1D = D0 / (1 - U)","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"4、计算机网络 之计算机网络的类别","slug":"计算机网络/4、计算机网络 之计算机网络的类别","date":"2013-09-01T07:31:35.000Z","updated":"2020-08-07T14:10:11.899Z","comments":true,"path":"2013/09/01/计算机网络/4、计算机网络 之计算机网络的类别/","link":"","permalink":"https://www.zackaddy.xin/2013/09/01/计算机网络/4、计算机网络 之计算机网络的类别/","excerpt":"","text":"计算机网络 之计算机网络的类别按作用范围分类 广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里。 城域网 MAN (Metropolitan Area Network)：作用距离约为 5 ~ 50 公里。 局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右）。 个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右。 按照网络的使用者进行分类 公用网 (public network) 按规定交纳费用的人都可以使用的网络。因此也可称为公众网。 专用网 (private network)为特殊业务工作的需要而建造的网络。 用来把用户接入到互联网的网络 接入网 AN (Access Network)，它又称为本地接入网或居民接入网。接入网是一类比较特殊的计算机网络，用于将用户接入互联网。是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"3、计算机网络 之互联网的组成","slug":"计算机网络/3、计算机网络 之互联网的组成","date":"2013-09-01T06:31:35.000Z","updated":"2020-08-07T14:10:11.899Z","comments":true,"path":"2013/09/01/计算机网络/3、计算机网络 之互联网的组成/","link":"","permalink":"https://www.zackaddy.xin/2013/09/01/计算机网络/3、计算机网络 之互联网的组成/","excerpt":"","text":"计算机网络 之互联网的组成从互联网的工作方式上看，可以划分为两大块： 边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。这些主机又称为端系统 (end system)。 核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。 边缘部分“主机A与主机B进行通信”实际上指：运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信。 端系统（主机）之间的通信方式通常可划分为两大类： 客户-服务器方式（C/S方式） 对等方式（P2P方式） 客户-服务器方式(C/S方式)客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。 客户-服务器方式所描述的是进程之间服务和被服务的关系。 客户软件的特点：被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。 客户是服务的请求方，服务器是服务的提供方。 服务请求方和服务提供方都要使用网络核心部分所提供的服务。 对等方式(P2P方式)对等连接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。 只要两个主机都运行了对等连接软件 (P2P 软件) ，它们就可以进行平等的、对等连接通信。 双方都可以下载对方已经存储在硬盘中的共享文档。 对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又是服务器。 对等连接工作方式可支持大量对等用户（如上百万个）同时工作。 互联网的核心部分网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器 (router)。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。 电路交换 应用实例:电话机(从电话发明至今) 过程:建立连接(占用通信资源)—&gt;通话(一直占用通信资源)—&gt;释放连接(归还通信资源) 特点:在通话的全部时间内,通话的两个用户始终占用端到端的通信资源分析:电路交换主要应用在电话机网络,而不适用于计算机网络.因为电路交换需要独占一整条线路,会导致线路堵塞,体现在打电话的时候第三方无法呼入,由于电话机使用的低频性(不可能一整天都是通话状态),所以这个缺点可以接受(一般过会儿再呼叫就行),而且,由于是独占了端到端的通信资源,所以延迟率很低,可以保证实时对话,这一点尤为重要.但是,如果是用来传送计算机数据,其线路的传输效率往往很低(计算机往往要一直维持连接状态,但是真正用于数据传输的时间占比很低,如果不一直维持连接状态,则需要频繁建立和释放连接,同样消耗资源且效率低) 优点:通信双方延时小 缺点:网络传输易堵塞,浪费资源 适用范围:连续传输大量数据,且传送时间远大于连接建立时间 报文交换 应用实例:电报(20世纪40年代,现在报文交换已不使用) 过程:客户发送电报—-&gt;电报中心接受整份电报—&gt;电报中心存储,等待,转发电报—&gt;客户接收电报 原理:存储转发 分析:不需要预先分配传输带宽,故传输突发数据时可提高整个网络的信道利用率.(想发送的时候直接发送就行,不发送的时候不会占用通信资源),但也因此,在同时有多个用户发送数据时,会造成拥堵,此时需要电报中心先存储起接受到的数据,形成一条队列,再进行转发,因为是以每份报文为单位的,需要易一整份报文都接受和存储,故延时较长(几分钟到几小时) 优点:网络信道利用率较高 缺点:延时长,对转发中心要求高(需占用较大存储空间) 适用范围:现已不使用 分组交换 应用实例:计算机网络 过程:将要发送的整块数据(报文)划分成多个等长小数据段—&gt;每个分组(包)在网络上独立传输—&gt;在目标主机组合还原成报文 原理:存储转发 分析:具有报文转发的优点,同时缩小报文转发的缺点.因为每个包的传输过程都是独立的,故具有并行的优点.简单的例子是有10条线路,发送一个100M的文件采用报文交换只能利用到其中一条线路,耗时10分钟,而用分组交换分成10个10M的包进行- 传输,则第一个包占用一条线路后,其他的包会避开拥堵,选用其他的线路,故只需要1分钟.不过实际上利用率远没有这么高,每个包都需要独立传输,在目标主机还需要组合,故需要附带必要的控制信息(首部). 优点: 高效 在分组传输的过程中动态分配传输带宽,对通信链路是逐段占用 灵活 为每一个分组独立地选择最合适的转发路由 迅速 以分组作为传送单位,不需先建立连接 可靠 保证可靠性的网络协议;分布式多路由的分组交换网,使网络有很好的生存性 缺点:对传输的各个包来说,仍需面临拥堵排队问题,且因为分组使得每个包都需要独立携带传输信息,带来更大的开销. 比较电路交换独占了信道(需预先分配传输带宽),可直达.使用存储转发的报文交换和分组交换则共用信道(不需预先分配连接带宽),需转发.分组交换把整块的数据切分,比报文交换更灵活,高效,迅速","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"2、计算机网络 之互联网概述","slug":"计算机网络/2、计算机网络 之互联网概述","date":"2013-09-01T05:31:35.000Z","updated":"2020-08-07T14:10:11.899Z","comments":true,"path":"2013/09/01/计算机网络/2、计算机网络 之互联网概述/","link":"","permalink":"https://www.zackaddy.xin/2013/09/01/计算机网络/2、计算机网络 之互联网概述/","excerpt":"","text":"计算机网络 之互联网概述网络之间可以通过路由器连接起来，形成覆盖范围更大的计算机网络。这样的网络称作“互连网”(internet)。习惯上，与网络相连的计算机常称为主机 (host)。 internet与Internet区别internet是一个通用名词，泛指由多个计算机网络互连而成的计算机网络。 Internet指当前全球最大的、开放的、由众多网络互相连接而成的特定互连网，采用TCP/IP协议族作为通信规则。 Internet具有两个重要特点：连通性 (connectivity) 和共享 (Sharing) 互联网服务提供者 ISP 互连网目前发展到第三阶段，出现了互联网服务提供者 ISP (Internet Service Provider)，逐渐形成了多层次ISP结构的互联网。 根据提供服务的覆盖面积大小以及所拥有的 IP 地址数目的不同，ISP分为：主干 ISP、地区 ISP 和 本地 ISP。 ISP可以从互联网管理机构申请到很多IP地址，同时拥有通信线路以及路由器等联网设备，因此任何机构和个人只要向某个ISP交纳规定的费用，就可以从改ISP获取所需IP地址的使用权，并可通过该ISP接入到互联网 我们所谓的所谓“上网”就是指“（通过某ISP获得的IP地址）接入到互联网”。 我国主要ISP有电信、联通、移动等， 它们在各个地方埋网线，有自己的主机、 我们出钱连入他们的网络，就能访问上网了。 有一些网站站点放在电信机房中，我们电信网去访问，就会比较快，因为通往主机那边的地址的方式很多，如果电信网访问放在联通主机房中的网址，则相对会受到影响。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"1、计算机网络 之基本术语","slug":"计算机网络/1、计算机网络 之基本术语","date":"2013-09-01T04:31:35.000Z","updated":"2020-08-07T14:10:11.899Z","comments":true,"path":"2013/09/01/计算机网络/1、计算机网络 之基本术语/","link":"","permalink":"https://www.zackaddy.xin/2013/09/01/计算机网络/1、计算机网络 之基本术语/","excerpt":"","text":"计算机网络 之基本术语节点与结点区别节点被认为是一个实体，有处理能力，比如说网络上的一台计算机； 结点则只是一个交叉点，像“结绳记事”，打个结，做个标记，仅此而已。一般算法 中点都是结点。 那么复杂网络理论中所谈到的点应该是“节点”了。 节点 （node）网络中的结点可以是计算机，集线器，交换机或路由器等。 链路（link ）从一个节点到相邻节点的一段物理线路，而中间没有任何其他的交换节点。 通信链路（communication link）网络中两个节点之间的物理通道称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波。 主机（host）连接在因特网上的计算机. ISP（Internet Service Provider）因特网服务提供者（提供商）. IXP（Internet eXchange Point）互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。. RFC(Request For Comments)意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。 广域网WAN（Wide Area Network）任务是通过长距离运送主机发送的数据 城域网MAN（Metropolitan Area Network）用来将多个局域网进行互连 局域网LAN（Local Area Network）学校或企业大多拥有多个互连的局域网 个人区域网PAN（Personal Area Network）在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 端系统（end system）处在因特网边缘的部分即是连接在因特网上的所有的主机. 分组（packet ）因特网中传送的数据单元。 由首部header和数据段组成。分组又称为包，首部可称为包头。 分组交换（packet switching）最初的通信是一台计算机独占一条线路，另一台计算机要想通信必须等第一台通信完成。 分组交换就是每台计算机通信时把数据包进行分组打包只要在头部附上本机的信息和组号就可以多台计算机共用一条通信线路，这样就提高了通信线路的利用率。 分组交换过程中发送端计算机发送给路由器，路由器会缓存这部分数据然后再转发给目标计算机。路由器不一定按照队列先进先出然后再发出去，也有可能优先发出一些特殊的数据。 存储转发（store and forward ）路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。 传输速率（bits per second）在数据传输中，两个设备之间数据流动的物理速度成为传输速率，单位为bps。 带宽（band width）带宽（band width）又叫频宽 定义：计算机网络中的主机在数字信道上，单位时间内从一段传送到另一端的最大数据量，即最大速率。 类比：一个供水管，假设管子中有流动的水，这里的水为数据。单位时间内，从管子的某个横截面就是速率，即单位时间内传送的数据量。当管子充满水的时候，管子的某个横截面就是最大速率，即带宽计算：单位同速率一样，为bps 宽带带宽是量词，指的是网速的大小。 宽带是名词，说明网络的传输速率速很高 。 宽带是一种相对的描述方式，包含带宽的概念，频率的范围愈大，也就是带宽愈高时，能够发送的数据也相对增加。 宽带是描述信号或者电子线路包含或能够同时处理较宽的频率范围，带宽是标识总线和内存性能的指标之一。 吞吐量（throughput ）主机之间实际的传输速率，被称为吞吐量，不仅仅衡量带宽，还衡量CPU的处理能力，网络拥堵程度及报文中数据字段的占有份额。说的通俗一点，就是单位时间内某个（信道。端口）实际的数据量，可以理解为实际的带宽。 所以通常我们看到的ISP声称2M宽带的，实际上理论能达到250KB/S的下载速率，但是因为受到计算机性能，网络设备质量，资源使用情况，网站能力，信号衰减等影响，那么实际的传输速率为80-20KB/S 频带频带就是指频率范围， 频带: 通俗的说，对信道而言，频带就是允许传送的信号的最高频率与允许传送的信号的最低频率这之间的频率范围(当然要考虑衰减必须在一定范围内)。若两者差别很大，可以认为频带就等于允许传送的信号的最高频率。 对信号而言，频带就是信号包含的最高频率与最低频率这之间的频率范围(当然频率分量必须大于一定的值)。若两者差别很大，可以粗略地认为频带就等于信号的最高频率。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/tags/计算机网络/"}],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.zackaddy.xin/categories/计算机网络/"}]},{"title":"39、8086汇编 之直接定址表","slug":"8086汇编/39、8086汇编 之直接定址表","date":"2013-04-08T20:55:36.000Z","updated":"2020-08-07T14:10:11.656Z","comments":true,"path":"2013/04/09/8086汇编/39、8086汇编 之直接定址表/","link":"","permalink":"https://www.zackaddy.xin/2013/04/09/8086汇编/39、8086汇编 之直接定址表/","excerpt":"","text":"8086 之直接定址表 我们可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。如123 a:db 1,2,3,4,5,6,7,8 改写为 a db 1,2,3,4,5,6,7,8 b:dw 0 改变为 b dw 0 使用不带“：”的标号，它们是同时描述内存地址和单元长度的标号。这种标号包含了对单元长度的描述，所以，在指令中，它可以代表一个段中的内存单元。 使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。以后，我们将这种标号称为数据标号，它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。 在其他段中使用数据标号 一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。 注意，在后面加有“:”的地址标号，只能在代码段中使用，不能再其他段中使用。 注意，如果想在代码段中直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。我们在程序中还要使用指令对段寄存器进行设置。 可以将标号当做数据来定义，此时，编译器将标号所表示的地址当做数据的值。 seg操作符，功能为取得某一标号的段地址。 计算sin(x)的程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354assume cs:code code segment start: mov al,60 call showsin mov ax,4c00h int 21h showsin: jmp short show table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180 ag0 db '0',0 ag30 db '0.5', 0 ag60 db '0.866', 0 ag90 db '1',0 ag120 db '0.866',0 ag150 db '0.5',0 ag180 db '0',0 show : push bx push es push si mov bx,0b800h mov es,bx mov ah,0 mov bl,30 div bl mov bl,al ;角度/30作为table偏移，商al放到bl中 mov bh,0 add bx ,bx ;因为dw每个占2字节，0-1,,1-2 ... mov bx,table[bx] mov si,160*23+40*2shows: mov ah,cs:[bx] cmp ah,0 ;ah是否为0，是则跳转至showret je showret mov es:[si],ah inc bx add si,2 jmp shows showret: pop si pop es pop bx ret code endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"38、8086汇编 之端口读写","slug":"8086汇编/38、8086汇编 之端口读写","date":"2013-04-08T00:03:29.000Z","updated":"2020-08-07T14:10:11.656Z","comments":true,"path":"2013/04/08/8086汇编/38、8086汇编 之端口读写/","link":"","permalink":"https://www.zackaddy.xin/2013/04/08/8086汇编/38、8086汇编 之端口读写/","excerpt":"","text":"8086 之端口读写CPU可以读取3个地方的数据 CPU内部寄存器 内存单元 端口 端口读写指令：in 读取 out 写入,注意：在in ,out 指令中，只能通过ax和al来存放端口的数据和把数据写入端口，访问8位端口用al,16位用ax 8086对应的是外设端口，外设提供端口给CPU访问，通过访问端口来操作外设 例子： 12in al,60h 从60h端口中读取一个字节数据到al中out 60h,al 向60h端口写入一个字节数据al COMS RAM芯片其中包含一个实时钟和一个有128存储单元的RAM存储器，在128字节的RAM中，内部实时钟占0-0dh单元保存时间信息，其余大部分分单元用于保存系统配置信息，供系统启动BIOS程序读取 BIOS提供了相关程序，使我们开机时配置COSRAM中的系统信息 RAM芯片内部有2个端口，端口地址为70h和71h通过这两个端口读写CMOSRAM， 70H为地址端口，存放CMOS RAM的单元地址 71H为数据端口，存放从选定的CMOS RAM单元中读取的数据或者要写入的数据 CPU对ＣＭＯS RAM读写分两步 例如：读取CMOS RAM2号单元的数据 将2送入单元70h地址端口 从71h数据端口读出2号单元的内容 shl指令shl指令：逻辑左移指令，功能： 将一个寄存器或内存单元中的数据向左移位 将最后移出的一位写入CF中 将最低位用0补充 如果移动的位数大于1，把移动的位数放入cl中 例子 ： 1234567mov al,10010001shl al,1将al左移1位mov cl,3shl al,cl将al左移3位 shr指令：逻辑右移指令和左移动指令shl相反","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"38、8086汇编 之外中断","slug":"8086汇编/38、8086汇编 之外中断","date":"2013-04-07T03:23:36.000Z","updated":"2020-08-07T14:10:11.656Z","comments":true,"path":"2013/04/07/8086汇编/38、8086汇编 之外中断/","link":"","permalink":"https://www.zackaddy.xin/2013/04/07/8086汇编/38、8086汇编 之外中断/","excerpt":"","text":"8086 之外中断 内中断由CPU内部引发的中断信息 外中断由CPU外部设备引发的中断信息，例如键盘 外中断源有两类：1 可屏蔽中断，2 不可屏蔽中断 可屏蔽中断：可屏蔽中断CPU可以屏蔽，CPU通过IF标志位是判断是否响应中断，IF=1，CPU响应中断，IF=0，不响应可屏蔽中断所引发的中断过程，出来和在第一步实现方式上和内中断不同，其他基本和内中断中断过程相同，因为外中断的中断类型码是由数据总线送入CPU的，而内中断的中断类型码是由CPU内部产生的 不可屏蔽中断：不可屏蔽中断是CPU不可屏蔽，必须执行，固定的中断类型码是2，所以不需要取中断类型码，其他步骤和内中断一样 设置IF的指令：sti(把IF设置为1)cli（把IF设置为0） 键盘外中断过程：由键盘产生的外中断（可屏蔽中断） 键盘芯片产生扫描码 扫描码送入60h端口 一旦侦测到60h端口有动静，引发9号中断 CPU执行9号中断例程，处理键盘输入 注意：前三步是硬件系统自动完成的，能修改只有第4步，修改中断程序 按F1可以让背景色和前景色改变123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172assume cs:codestack segment db 128 dup (0)stack endscode segmentstart: mov ax, stack mov ss, ax mov sp, 128 push cs pop ds;安装中断例程 mov ax, 0 mov es, ax mov si, offset int9 mov di, 204h mov cx, offset int9end - offset int9 cld rep movsb;把原本的int9号中断例程入口地址放到0:200处即新中断例程的最开始四个字节 push es:[9 * 4] pop es:[200h] push es:[9 * 4 + 2] pop es:[202h];把新中断例程的入口地址放入int9中断例程在中断向量表中的位置上 cli mov word ptr es:[9 * 4], 204h mov word ptr es:[9 * 4 + 2], 0 sti mov ax, 4c00h int 21hint9: push ax push bx push cx push es in al, 60h ;模拟int指令执行旧int9中断 pushf call dword ptr cs:[200h] cmp al, 3bh jne int9ret mov ax, 0b800h mov es, ax mov bx, 1 mov cx, 2000s: inc byte ptr es:[bx] add bx, 2 loop s int9ret: pop es pop cx pop bx pop ax iret int9end: nopcode endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"37、8086汇编 之int中断","slug":"8086汇编/37、8086汇编 之int中断","date":"2013-04-05T19:16:35.000Z","updated":"2020-08-07T14:10:11.655Z","comments":true,"path":"2013/04/06/8086汇编/37、8086汇编 之int中断/","link":"","permalink":"https://www.zackaddy.xin/2013/04/06/8086汇编/37、8086汇编 之int中断/","excerpt":"","text":"int中断 一种软件中断，通过AH里的值来确定具体执行什么中断子程序，这个中断的编号是21 int格式： int n，n为中断类型码。它的功能是引发中断过程。 CPU 执行int n指令，相当于引发一个 n号中断的中断过程 取中段类型码n； 标志寄存器入栈； CS、IP 入栈 (IP) = (n*4) (CS) = (n*4+2)。 使用方法例如：需要键盘输入，并且回显。AH的值需要查表取得，表在下面 12指令：MOV AH,01 INT 21H 通过这样两条指令，输入的字符就会被存储在AL中。 表：DOS系统功能调INT 21HAH | 功能 | 调用参数 | 返回参数–|–|–|–00 | 程序终止(同INT 20H) | CS=程序段前缀 |01 | 键盘输入并回显 | | AL=输入字符02 | 显示输出 | DL=输出字符 |03 | 异步通迅输入 | | AL=输入数据04 | 异步通迅输出 | DL=输出数据 |05 | 打印机输出 | DL=输出字符 |06 | 直接控制台I/O | DL=FF(输入) DL=字符(输出) | AL=输入字符07 | 键盘输入(无回显) | | AL=输入字符08 | 键盘输入(无回显) 检测Ctrl-Break | | AL=输入字符09 | 显示字符串 | DS:DX=串地址 ‘$’结束字符串 |0A | 键盘输入到缓冲区 | DS:DX=缓冲区首地址 | (DS:DX)=缓冲区最大字符数 (DS:DX+1)=实际输入的字符数0B | 检验键盘状态 | | AL=00 有输入 AL=FF 无输入0C | 清除输入缓冲区并 请求指定的输入功能 | AL=输入功能号 (1,6,7,8,A) |0D | 磁盘复位 | | 清除文件缓冲区0E | 指定当前缺省的磁盘驱动器 | DL=驱动器号 0=A,1=B,… | AL=驱动器数0F | 打开文件 | DS:DX=FCB首地址 | AL=00 文件找到 AL=FF 文件未找到10 | 关闭文件 | DS:DX=FCB首地址 | AL=00 目录修改成功 AL=FF 目录中未找到文件11 | 查找第一个目录项 | DS:DX=FCB首地址 | AL=00 找到 AL=FF 未找到12 | 查找下一个目录项 | DS:DX=FCB首地址(文件中带有或?) | AL=00 找到 AL=FF 未找到13 | 删除文件 | DS:DX=FCB首地址 | AL=00 删除成功 AL=FF 未找到14 | 顺序读 | DS:DX=FCB首地址 | AL=00 读成功 =01 文件结束,记录中无数据 =02 DTA空间不够 =03 文件结束,记录不完整15 | 顺序写 | DS:DX=FCB首地址 | AL=00 写成功 =01 盘满 =02 DTA空间不够16 | 建文件 | DS:DX=FCB首地址 | AL=00 建立成功 =FF 无磁盘空间17 | 文件改名 | DS:DX=FCB首地址 (DS:DX+1)=旧文件名 (DS:DX+17)=新文件名 | AL=00 成功 AL=FF 未成功19 | 取当前缺省磁盘驱动器 | | AL=缺省的驱动器号 0=A,1=B,2=C,…1A | 置DTA地址 | DS:DX=DTA地址 |1B | 取缺省驱动器FAT信息 | | AL=每簇的扇区数 DS:BX=FAT标识字节 CX=物理扇区大小 DX=缺省驱动器的簇数1C | 取任一驱动器FAT信息 | DL=驱动器号 | 同上21 | 随机读 | DS:DX=FCB首地址 | AL=00 读成功 =01 文件结束 =02 缓冲区溢出 =03 缓冲区不满 22 | 随机写 | DS:DX=FCB首地址 | AL=00 写成功 =01 盘满 =02 缓冲区溢出23 | 测定文件大小 | DS:DX=FCB首地址 | AL=00 成功(文件长度填入FCB) AL=FF 未找到24 | 设置随机记录号 | DS:DX=FCB首地址 |25 | 设置中断向量 | DS:DX=中断向量 AL=中断类型号 |26 | 建立程序段前缀 | DX=新的程序段前缀 |27 | 随机分块读 | DS:DX=FCB首地址 CX=记录数 | AL=00 读成功 =01 文件结束 =02 缓冲区太小,传输结束 =03 缓冲区不满28 | 随机分块写 | DS:DX=FCB首地址 | CX=记录数 | AL=00 写成功 =01 盘满 =02 缓冲区溢出29 | 分析文件名 | ES:DI=FCB首地址 DS:SI=ASCIIZ串 AL=控制分析标志 | AL=00 标准文件 =01 多义文件 =02 非法盘符2A | 取日期 | | CX=年 DH:DL=月:日(二进制)2B | 设置日期 | CX:DH:DL=年:月:日 | AL=00 成功 =FF 无效2C | 取时间 | | CH:CL=时:分 DH:DL=秒:1/100秒2D | 设置时间 | CH:CL=时:分 DH:DL=秒:1/100秒 | AL=00 成功 =FF 无效2E | 置磁盘自动读写标志 | AL=00 关闭标志 AL=01 打开标志 |2F | 取磁盘缓冲区的首址 | | ES:BX=缓冲区首址30 | 取DOS版本号 | | AH=发行号,AL=版本31 | 结束并驻留 | AL=返回码 DX=驻留区大小 |33 | Ctrl-Break检测 | AL=00 取状态 =01 置状态(DL) DL=00 关闭检测 =01 打开检测 | DL=00 关闭Ctrl-Break检测 =01 打开Ctrl-Break检测35 | 取中断向量 | AL=中断类型 | ES:BX=中断向量36 | 取空闲磁盘空间 | DL=驱动器号 0=缺省,1=A,2=B,… | 成功:AX=每簇扇区数 BX=有效簇数 CX=每扇区字节数 DX=总簇数 失败:AX=FFFF38 | 置/取国家信息 | DS:DX=信息区首地址 | BX=国家码(国际电话前缀码) AX=错误码39 | 建立子目录(MKDIR) | DS:DX=ASCIIZ串地址 | AX=错误码3A | 删除子目录（RMDIR） | DS:DX=ASCIIZ串地址 | AX=错误码3B | 改变当前目录(CHDIR) | DS:DX=ASCIIZ串地址 | AX=错误码3C | 建立文件 | DS:DX=ASCIIZ串地址 CX=文件属性 | 成功:AX=文件代号 错误:AX=错误码3D | 打开文件 | DS:DX=ASCIIZ串地址 AL=0 读 =1 写 =3 读/写 | 成功:AX=文件代号 错误:AX=错误码3E | 关闭文件 | BX=文件代号 | 失败:AX=错误码3F | 读文件或设备 | DS:DX=数据缓冲区地址 BX=文件代号 CX=读取的字节数 | 读成功: AX=实际读入的字节数 AX=0 已到文件尾 读出错:AX=错误码40 | 写文件或设备 | DS:DX=数据缓冲区地址 BX=文件代号 CX=写入的字节数 | 写成功: AX=实际写入的字节数 写出错:AX=错误码41 | 删除文件 | DS:DX=ASCIIZ串地址 | 成功:AX=00 出错:AX=错误码(2,5)42 | 移动文件指针 | BX=文件代号 CX:DX=位移量 AL=移动方式(0:从文件头绝对位移,1:从当前位置相对移动,2:从文件尾绝对位移) | 成功:DX:AX=新文件指针位置 出错:AX=错误码43 | 置/取文件属性 | DS:DX=ASCIIZ串地址 AL=0 取文件属性 AL=1 置文件属性 CX=文件属性 | 成功:CX=文件属性 失败:CX=错误码44 | 设备文件I/O控制 | BX=文件代号 AL=0 取状态 =1 置状态DX =2 读数据 =3 写数据 =6 取输入状态 =7 取输出状态 | DX=设备信息45 | 复制文件代号 | BX=文件代号1 | 成功:AX=文件代号2 失败:AX=错误码46 | 人工复制文件代号 | BX=文件代号1 CX=文件代号2 | 失败:AX=错误码47 | 取当前目录路径名 | DL=驱动器号 DS:SI=ASCIIZ串地址 | (DS:SI)=ASCIIZ串 失败:AX=出错码48 | 分配内存空间 | BX=申请内存容量 | 成功:AX=分配内存首地 失败:BX=最大可用内存49 | 释放内容空间 | ES=内存起始段地址 | 失败:AX=错误码4A | 调整已分配的存储块 | ES=原内存起始地址 BX=再申请的容量 | 失败:BX=最大可用空间 AX=错误码4B | 装配/执行程序 | DS:DX=ASCIIZ串地址 ES:BX=参数区首地址 AL=0 装入执行 AL=3 装入不执行 | 失败:AX=错误码4C | 带返回码结束 | AL=返回码 |4D | 取返回代码 | | AX=返回代码4E | 查找第一个匹配文件 | DS:DX=ASCIIZ串地址 CX=属性 | AX=出错代码(02,18)4F | 查找下一个匹配文件 | DS:DX=ASCIIZ串地址(文件名中带有?或) | AX=出错代码(18)54 | 取盘自动读写标志 | | AL=当前标志值56 | 文件改名 | DS:DX=ASCIIZ串(旧) ES:DI=ASCIIZ串(新) | AX=出错码(03,05,17)57 | 置/取文件日期和时间 | BX=文件代号 AL=0 读取 AL=1 设置(DX:CX) | DX:CX=日期和时间 失败:AX=错误码58 | 取/置分配策略码 | AL=0 取码 AL=1 置码(BX) | 成功:AX=策略码 失败:AX=错误码59 | 取扩充错误码 | | AX=扩充错误码 BH=错误类型 BL=建议的操作 CH=错误场所5A | 建立临时文件 | CX=文件属性 DS:DX=ASCIIZ串地址 | 成功:AX=文件代号 失败:AX=错误码5B | 建立新文件 | CX=文件属性 DS:DX=ASCIIZ串地址 | 成功:AX=文件代号 失败:AX=错误码5C | 控制文件存取 | AL=00封锁 =01开启 BX=文件代号 CX:DX=文件位移 SI:DI=文件长度 | 失败:AX=错误码62 | 取程序段前缀 | | BX=PSP地址","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"36、8086汇编 之内中断","slug":"8086汇编/36、8086汇编 之内中断","date":"2013-04-05T04:19:53.000Z","updated":"2020-08-07T14:10:11.655Z","comments":true,"path":"2013/04/05/8086汇编/36、8086汇编 之内中断/","link":"","permalink":"https://www.zackaddy.xin/2013/04/05/8086汇编/36、8086汇编 之内中断/","excerpt":"","text":"内中断内中断: 是CPU内部发生情况后而产生的中断信息，于是CPU便放下手中的活来处理中断例程 8086CPU会产生主要这么几种内中断: 除法溢出(0号中断) 单步中断(1号中断) 执行into指令产生的中断(不清楚) 执行int指令产生的中断(常见的int 21就是属于这种) 首先，理解清楚什么是中断例程, 中断向量，中断向量表，中断信息，中断类型码等概念 中断类型码是一个8位的数，也就是0-255的范围，一共256个中断类型码，每一个号码对应一个中断向量 中断向量里面包含中断例程的入口地址(CS:IP)，其中cs是16位段寄存器，ip也是16位的所以一共4字节 中断向量表是一张表存储着256个中断向量，而每一个向量存储着一个中断例程的地址，也就是说总共最多会有256个中断例程 中断信息包含很多信息最重要的就是中断类型码，该码号指出了中断例程的在内存中的置位 中断例程又称为中断处理程序，是CPU在接收到中断信息后所执行的程序，该程序的入口位于中断向量表中的中断向量里 总结一下: 首先中断例程就可以看做程序，这种程序最多只能有256个，这些程序在发生中断后会被CPU调用，每个程序都有一个相对于的入口地址 这些地址被存放在一张表里叫做中断向量表，因为中断例程最多有256个，所以中断向量表最多也就是256项，而中断向量的地址是如何确定的呢？因为我们只有通过中断向量表才能找到中断例程来处理中断信息 中断向量表在8086CPU中的位置是固定的，位于0000:0000~0000:03ff这1024字节中，然而我们知道一条中断向量是4字节大小，那中断向量表就有1024 / 4 = 256条中断向量 当发生中断时，CPU就会就收到中断信息，中断信息里有很多东西， 其中就包括了中断类型码，这是一种8位的码，正好也一共有256个完全覆盖中断向量表，假设我们收到的中断类型码是8的话， 那么我们通过[8 * 4]和[8 *4 + 2]来确定一条中断向量即其cs:ip， 为何是这样? 首先第八号中断类型码，由于中断类型码是从0开始到255，所以第八号实际处于第九个的置位，而每一条中断向量是4个字节，所以要4 * 8这个地址才是第九个位置的开头即cs的置位，因为cs是16位即2字节所以ip就处在4 * 8 + 2这个地方。 整个过程可以变为:取得终端类型码N-&gt;pushf-&gt;TF和IF置零(为了防止外中断和单步中断的产生)-&gt;push cs push ip-&gt;把cs设置成0000:[8 * 4],ip设置成0000:[8 * 4 + 2]即达到了中断例程的入口执行中断处理程序-&gt;使用iret返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051assume cs:codeCOMMENT !由于中断例程不可能到达256个那么多，所以中断向量表中还有很多是空的比如0000:0200~0000:02FF这256个字节，所以便把中断例程放置在这个位置!code segmentstart:;安装中断例程 mov ax, 0 mov es, ax mov di, 200h ;目的地址es:di 即0000:0200, mov ax, cs mov ds, ax ;源地址ds:si 即do0的偏移地址，也就是中断处理程序 mov si, offset do0 mov cx, offset do0end - offset do0 ;中断处理程序的字节数,也就是要转移的数量 cld rep movsb ;把中断处理程序安装至0000:0200 mov ax, 0 mov es, ax;将中断例程的入口地址放置到中断向量表中 mov word ptr es:[0 * 4], 200h ;将中断处理程序的入口放在0号中断向量中 mov word ptr es:[0 * 4 + 2], 0 mov ax, 4c00h int 21h;中断处理程序do0: ;为了防止字符串被覆盖所以将其放在中断例程里 jmp short do0start db 'Divide overflow!', 0do0start: mov ax, 0b800h ;显存段地址 mov es, ax mov di, 160 * 12 + 36 * 2 ;第13行中间位置 mov ax, cs mov ds, ax mov si, 202h ;字符串的偏移地址 mov cx, 10h ;字符串数目s: mov bl, [si] mov es:[di], bl mov es:[di + 1], 2 inc si add di, 2 loop s iret ;返回do0end: nopcode endsend start 以上是0号中断即除法溢出 下面说说1号中断即单步中断，单步中断与TF标志位密切相关，如果TF = 1代表开启单步中断，单步中断是什么? 举个例子用debug.exe程序用t指令观察指令执行时寄存器数值变化时，程序停了下来，原因就是单步中断 那么如果是这样有一个问题就是TF= 1那进入中断处理程序时不也会一直中断吗？即中断里面中断的循环，实际上这是不会的，因为: 取得终端类型码N-&gt;pushf-&gt;TF和IF置零(为了防止外中断和单步中断的产生)-&gt;push cs push ip-&gt;把cs设置成0000:[8 * 4],ip设置成0000:[8 * 4 + 2]即达到了中断例程的入口执行中断处理程序-&gt;使用iret返回 当单步中断产生时候即得到中断类型码1，把标志寄存器入栈后随即将TF置零，前面直到TF = 1时候单步中断才开启，这样进入单步中断处理程序后就不会再有中断产生了。 最后为何在设置ss:sp即栈段的时候中间不能够夹杂其他代码? 12345mov ss, FC00hint ? ;发生了某个中断;取得终端类型码N-&gt;pushf-&gt;TF和IF置零(为了防止外中断和单步中断的产生)-&gt;push cs push ip;所以改变了栈顶指针的位置使其指向错误位置mov sp, 10h 这就是原因","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"35、8086汇编 之DF标志位与传送指令","slug":"8086汇编/35、8086汇编 之DF标志位与传送指令","date":"2013-04-04T01:13:00.000Z","updated":"2020-08-07T14:10:11.655Z","comments":true,"path":"2013/04/04/8086汇编/35、8086汇编 之DF标志位与传送指令/","link":"","permalink":"https://www.zackaddy.xin/2013/04/04/8086汇编/35、8086汇编 之DF标志位与传送指令/","excerpt":"","text":"DF标志位与传送指令flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。 DF = 0：每次操作后si，di递增； DF = 1：每次操作后si，di递减。 movsb功能：（以字节为单位传送） ((es)×16 + (di)) = ((ds) ×16 + (si)) 如果DF = 0则 (si) = (si) + 1 (di) = (di) + 1 如果DF = 1则 (si) = (si) - 1 (di) = (di) - 1 movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di中，然后根据标志寄存器DF位的值，将 si和di递增或递减。 movsw功能：（以字为单位传送） 将 ds:si指向的内存字单元中word送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。 movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都和rep配合使用，格式如下： rep movsb rep的作用是根据cx的值，重复执行后面的串传送指令。 由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现(cx)个字符的传送。 由于flag的DF位决定着串传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对DF位进行设置，从而使程序员能够决定传送的方向。8086CPU提供下而两条指令对DF位进行设置： cld指令：将标志寄存器的DF位置0 std指令：将标志寄存器的DF位置1 1234567891011121314151617181920212223assume cs:codedata segment db 'Welcome to masm!' db 16 dup (0)data endscode segmentstart: mov ax,data mov ds,ax mov si,0 ;ds:si指向data:0 mov es,ax mov di,16 ;es:di指向data:16 mov cx,16 ;(cx)=16，rep循环16次 cld ;设置DF=0，正向传送 rep movsb mov ax, 4c00h int 21hcode endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"34、8086汇编 之跳转指令对照表","slug":"8086汇编/34、8086汇编 之跳转指令对照表","date":"2013-04-03T03:03:54.000Z","updated":"2020-08-07T14:10:11.655Z","comments":true,"path":"2013/04/03/8086汇编/34、8086汇编 之跳转指令对照表/","link":"","permalink":"https://www.zackaddy.xin/2013/04/03/8086汇编/34、8086汇编 之跳转指令对照表/","excerpt":"","text":"跳转指令对照表名称|功能|操作数|操作码|标志位|REG1|REG2或内存|位移量|立即数|符号|方向|芯片型号|16位|32位 JO| 溢出跳转| 短| $70| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNO|不溢出跳转| 短| $71| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JB| 低于跳转| 短| $72| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNB|不低于跳转| 短| $73| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JE| 相等跳转| 短| $74| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNE|不等跳转| 短| $75| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JBE|不高于跳转| 短| $76| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JA| 高于跳转| 短| $77| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JS| 负号跳转| 短| $78| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNS|非负跳转| 短| $79| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JP| 奇偶跳转| 短| $7A| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNP|非奇偶跳转| 短| $7B| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JL|小于跳转| 短| $7C| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNL|不小于跳转| 短| $7D| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JNG|不大于跳转| 短| $7E| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JG|大于跳转| 短| $7F| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JO|溢出跳转| 近| $0F80| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNO|不溢出跳转| 近| $0F81| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JB|低于跳转| 近| $0F82| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNB|不低于跳转| 近| $0F83| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JE|相等跳转| 近| $0F84| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNE|不等跳转| 近| $0F85| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JBE|不高于跳转| 近| $0F86| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JA|高于跳转| 近| $0F87| CF=0,ZF=0| 无| 无| 无| 10| 无| 无| 386| 无| $66JS|负号跳转| 近| $0F88| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNS|非负跳转| 近| $0F89| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JP|奇偶跳转| 近| $0F8A| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNP|非奇偶跳转| 近| $0F8B| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JL|小于跳转| 近| $0F8C| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNL|不小于跳转| 近| $0F8D| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JNG|不大于跳转| 近| $0F8E| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JG|大于跳转| 近| $0F8F| 无| 无| 无| 无| 10| 无| 无| 386| 无| $66JO|溢出跳转| 近| $0F80| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JNO|不溢出跳转| 近| $0F81| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JB|低于跳转| 近| $0F82| CF=1| 无| 无| 无| 10| 无| 无| 386| $66|无JNB|不低于跳转| 近| $0F83| CF=0| 无| 无| 无| 10| 无| 无| 386| $66|无JE|相等跳转| 近| $0F84| ZF=1| 无| 无| 无| 10| 无| 无| 386| $66|无JNE|不等跳转| 近| $0F85| ZF=0| 无| 无| 无| 10| 无| 无| 386| $66|无JBE|不高于跳转| 近| $0F86| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JA|高于跳转| 近| $0F87| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JS|负号跳转| 近| $0F88| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JNS|非负跳转| 近| $0F89| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JP|奇偶跳转| 近| $0F8A| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JNP|非奇偶跳转| 近| $0F8B| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JL|小于跳转| 近| $0F8C| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JNL|不小于跳转| 近| $0F8D| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JNG|不大于跳转| 近| $0F8E| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JG|大于跳转| 近| $0F8F| 无| 无| 无| 无| 10| 无| 无| 386| $66|无JCXZ|计数一六零跳转|位移8| $E3|无| 无| 无| 无| 10| 无| 无| 8086| 无| $67JECXZ|计数三二零跳转|位移8| $E3|无| 无| 无| 无| 10| 无| 无| 386| $67| 无JMP|跳转| 寄16| $FF| 11| 100| 3| 无| 无| 无| 无| 8086| 无| $66JMP|跳转| 寄32| $FF| 11| 100| 3| 无| 无| 无| 无| 386| $66| 无JMP|跳转| 16[寄16]| $FF| 00| 100| 5| 无| 无| 无| 无| 8086| 无| $6766JMP|跳转| 32[寄16]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $66| $67JMP|跳转| 16[寄32]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $67| $66JMP|跳转| 32[寄32]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $6766| 无JMP|跳转| 16[寄16+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 32[寄16+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 16[寄32+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 32[寄32+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 16[寄16+位移16]| $FF| 10| 100| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 32[寄16+位移16]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 16[寄32+位移32]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 32[寄32+位移32]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 近16[寄16]| $FF| 00| 100| 5| 无| 无| 无| 无| 8086| 无| $6766JMP|跳转| 近32[寄16]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $66| $67JMP|跳转| 近16[寄32]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $67| $66JMP|跳转| 近32[寄32]| $FF| 00| 100| 5| 无| 无| 无| 无| 386| $6766| 无JMP|跳转| 近16[寄16+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 近32[寄16+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 近16[寄32+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 近32[寄32+位移8]| $FF| 01| 100| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 近16[寄16+位移16]| $FF| 10| 100| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 近32[寄16+位移16]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 近16[寄32+位移32]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 近32[寄32+位移32]| $FF| 10| 100| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 远16[寄16]| $FF| 00| 101| 5| 无| 无| 无| 无| 8086| 无| $6766JMP|跳转| 远32[寄16]| $FF| 00| 101| 5| 无| 无| 无| 无| 386| $66| $67JMP|跳转| 远16[寄32]| $FF| 00| 101| 5| 无| 无| 无| 无| 386| $67| $66JMP|跳转| 远32[寄32]| $FF| 00| 101| 5| 无| 无| 无| 无| 386| $6766| 无JMP|跳转| 远16[寄16+位移8]| $FF| 01| 101| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 远32[寄16+位移8]| $FF| 01| 101| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 远16[寄32+位移8]| $FF| 01| 101| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 远32[寄32+位移8]| $FF| 01| 101| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 远16[寄16+位移16]| $FF| 10| 101| 5| 9| 无| 无| 无| 8086| 无| $6766JMP|跳转| 远32[寄16+位移16]| $FF| 10| 101| 5| 9| 无| 无| 无| 386| $66| $67JMP|跳转| 远16[寄32+位移32]| $FF| 10| 101| 5| 9| 无| 无| 无| 386| $67| $66JMP|跳转| 远32[寄32+位移32]| $FF| 10| 101| 5| 9| 无| 无| 无| 386| $6766| 无JMP|跳转| 短| $EB| 无| 无| 无| 无| 10| 无| 无| 8086| 无| 无JMP|跳转| 位移16| $E9| 无| 无| 无| 无| 10| 无| 无| 8086| 无| $66JMP|跳转| 位移32| $E9| 无| 无| 无| 无| 10| 无| 无| 386| $66| 无JMP|跳转| 近| $E9| 无| 无| 无| 无| 10| 无| 无| 8086| 无| $66|JMP|跳转| 近| $E9| 无| 无| 无| 无| 10| 无| 无| 386| $66| 无JMP|跳转| 远(数段址:)偏移16| $EA| 无| 无| 无| 无| 10| 无| 无| 8086| 无| $66JMP|跳转| 远(数段址:)偏移32| $EA| 无| 无| 无| 无| 10| 无| 无| 386| $66| 无JMP|跳转| 数段址:偏移16| $EA| 无| 无| 无| 无| 12| 无| 无| 8086| 无| $66JMP|跳转| 数段址:偏移32| $EA| 无| 无| 无| 无| 12| 无| 无| 386| $66| 无JMPE|跳转扩展| 寄16| $0F00| 11| 110| 3| 无| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 寄32| $0F00| 11| 110| 3| 无| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄16]| $0F00| 00| 110| 5| 无| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄16]| $0F00| 00| 110| 5| 无| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄32]| $0F00| 00| 110| 5| 无| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄32]| $0F00| 00| 110| 5| 无| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄16+位移8]| $0F00| 01| 110| 5| 9| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄16+位移8]| $0F00| 01| 110| 5| 9| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄32+位移8]| $0F00| 01| 110| 5| 9| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄32+位移8]| $0F00| 01| 110| 5| 9| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄16+位移16]| $0F00| 10| 110| 5| 9| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄16+位移16]| $0F00| 10| 110| 5| 9| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 16[寄32+位移32]| $0F00| 10| 110| 5| 9| 无| 无| 无| IA64| 无| $66JMPE|跳转扩展| 32[寄32+位移32]| $0F00| 10| 110| 5| 9| 无| 无| 无| IA64| $66| 无JMPE|跳转扩展| 位移16| $0FB8| 无| 无| 无| 无| 10| 无| 无| IA64| 无| $66JMPE|跳转扩展| 位移32| $0FB8| 无| 无| 无| 无| 10| 无| 无| IA64| $66| 无","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"33、8086汇编 之cmp指令","slug":"8086汇编/33、8086汇编 之cmp指令","date":"2013-04-01T23:52:46.000Z","updated":"2020-08-07T14:10:11.655Z","comments":true,"path":"2013/04/02/8086汇编/33、8086汇编 之cmp指令/","link":"","permalink":"https://www.zackaddy.xin/2013/04/02/8086汇编/33、8086汇编 之cmp指令/","excerpt":"","text":"cmp指令 格式：cmp 操作对象1,操作对象2 功能：计算操作对象1–操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。 比如：cmp ax,ax 做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。12345ZF=1，PF=1，SF=0，CF=0，OF=0。 1234567891011mov ax,8mov bx,3cmp ax,bx执行后： (ax) = 8ZF=0，PF=1，SF=0，CF=0，OF=0。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"32、8086汇编 之adc、sbb指令","slug":"8086汇编/32、8086汇编 之adc、sbb指令","date":"2013-04-01T01:45:43.000Z","updated":"2020-08-07T14:10:11.654Z","comments":true,"path":"2013/04/01/8086汇编/32、8086汇编 之adc、sbb指令/","link":"","permalink":"https://www.zackaddy.xin/2013/04/01/8086汇编/32、8086汇编 之adc、sbb指令/","excerpt":"","text":"adc、sbb指令adc指令 adc是带进位加法指令 ，它利用了CF位上记录的进位值。 格式： adc 操作对象1,操作对象2 功能： 操作对象1=操作对象1+操作对象2+CF 比如：adc ax,bx 实现的功能是： (ax)=(ax)+(bx)+CF 123456789mov ax,2mov bx,1sub bx,axadc ax,l执行后，(ax)=4。 adc执行时，相当于计算： (ax)+1+CF=2+1+1=4。 在执行 adc 指令的时候加上的 CF 的值的含义，由 adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么指令设置的。 如果CF 的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值。 sbb指令 sbb是带错位减法指令，它利用了CF位上记录的借位值。 格式：sbb 操作对象1,操作对象2 功能： 操作对象1=操作对象1–操作对象2–CF 比如：sbb ax,bx实现功能： (ax) = (ax) – (bx) – CF","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"31、8086汇编 之ZF、PF、SF、CF、AC、OF、TF、IF、DF标志位","slug":"8086汇编/31、8086汇编 之ZF、PF、SF、CF、AC、OF、TF、IF、DF标志位","date":"2013-03-30T16:53:20.000Z","updated":"2020-08-07T14:10:11.654Z","comments":true,"path":"2013/03/31/8086汇编/31、8086汇编 之ZF、PF、SF、CF、AC、OF、TF、IF、DF标志位/","link":"","permalink":"https://www.zackaddy.xin/2013/03/31/8086汇编/31、8086汇编 之ZF、PF、SF、CF、AC、OF、TF、IF、DF标志位/","excerpt":"","text":"ZF、PF、SF、CF、AC、OF标志位ZF零标志位 结果为0 ，ZF = 1 结果不为0，ZF = 0123mov ax,1sub ax,1 指令执行后，结果为0，则ZF = 1 PF奇偶标志位指令执行后，结果的所有二进制位中1的个数： 为偶数，PF = 1； 为奇数，PF = 0。123mov al,1add al,10执行后，结果为00001011B，其中有3（奇数）个1，则PF=0； SF符号标志位 结果为负，SF = 1； 结果为正，SF = 0。 CF进位标志位针对加法 12345678mov al, 0FFHadd al, 1 AL: 00 CF: 1mov ax, 00FFHadd ax, 1 AL: 0100h CF: 0mov ax, 0FFFFHadd ax, 1 AL: 0000 CF: 1 针对减法 12mov al, 1sub al, 2 AL: FFH CF: 1 INC和DEC不会影响进位标志位，非零操作数上应用NEG指令总是会将进位标志位置1 AC辅助进位标志位该位表示当进行加法或减法运算时，低半字节向高半字节是否有进位或借位； 当AC=1时，表示低半字节向高半字节有进位或借位； 当AC=0时，表示低半字节向高半字节没有进位或借位； OF溢出标志位 两个正数相加为负数 两个负数相加为正数 TF调试标志位当TF=1时，处理器每次只执行一条指令，即单步执行; IF中断允许标志位位它用来控制8086是否允许接收外部中断请求。若IF=1，8086能响应外部中断，反之则屏蔽外部中断; DF方向标志位在串处理指令中，每次操作后，如果DF=0，si、di递增，如果DF=1，si、di递减；注意此处DF的值是由程序员进行设定的 cld命令是将DF设置为0，std命令是将DF设置为1；","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"30、8086汇编 之call和ret指令","slug":"8086汇编/30、8086汇编 之call和ret指令","date":"2013-03-30T03:31:39.000Z","updated":"2020-08-07T14:10:11.654Z","comments":true,"path":"2013/03/30/8086汇编/30、8086汇编 之call和ret指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/30/8086汇编/30、8086汇编 之call和ret指令/","excerpt":"","text":"call和ret指令ret和retf指令ret指令用栈中的数据来修改IP的内容，从而实现近转移。CPU执行ret指令时： (IP)=((SS)*16+(SP))，指向栈顶 (SP)=(SP)+2 retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。 CPU执行retf指令时，进行下面两步操作： (IP)=((SS)*16+(SP)) (SP)=(SP)+2 (CS)=((SS)*16+(SP)) (SP)=(SP)+2 用汇编的语法来解释ret和retf指令： CPU执行ret指令相当于进行 POP IP CPU执行retf指令相当于进行 POP IP和POP CS call 指令 call 标号 1功能：下一条指令IP入栈，跳转到标号处。 call far ptr 标号 12功能：下一条指令CS入栈、IP入栈，跳转标好处。PS：call 标号与ret、call far ptr 标号与retf配合使用可实现子程序的编写 call word ptr 内存单元地址 123456789汇编语法解释：push IPjmp word ptr 内存单元地址比如下面的指令： mov sp,10h mov ax,0123h mov ds:[0],ax call word ptr ds:[0] call dword ptr 内存单元地址 1234567891011汇编语法解释：push CSpush IPjmp dword ptr 内存单元地址比如，下面的指令：mov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0] 12345678910111213141516171819202122232425262728assume cs:code,ss:stackstack segment dw 8 dup(0)stack endscode segmentstart: mov ax,stack mov ss,ax mov sp,10h mov ax,4240h mov dx,0fh mov cx,0ah call divdw mov ax,4c00h int 21hdivdw: ;子程序定义开始 push ax ;低16位先保存 mov ax,dx ;ax这时候的值是高16位了 mov dx,0 ;dx置0是为了不影响下边余数位，使得高16位为0 div cx ;H/N mov bx,ax ;ax,bx的值为（int）H/N ，dx的值为(rem)H/N pop ax ;ax的值现在是L div cx ;L/N，注意，16位除法的时候默认被除数DX为高16位，AX为低16位 mov cx,dx mov dx,bx ret ;子程序定义结束code endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"29、8086汇编 之jcxz指令","slug":"8086汇编/29、8086汇编 之jcxz指令","date":"2013-03-28T20:59:03.000Z","updated":"2020-08-07T14:10:11.653Z","comments":true,"path":"2013/03/29/8086汇编/29、8086汇编 之jcxz指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/29/8086汇编/29、8086汇编 之jcxz指令/","excerpt":"","text":"jcxz指令 jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。 指令格式：jcxz 标号（如果(cx)=0，则转移到标号处执行。） jcxz 标号 指令操作： 当(cx)=0时，(IP)=(IP)+8位位移） 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址； 8位位移的范围为-128~127，用补码表示； 8位位移由编译程序在编译时算出。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"28、8086汇编 之jmp指令","slug":"8086汇编/28、8086汇编 之jmp指令","date":"2013-03-27T20:22:00.000Z","updated":"2020-08-07T14:10:11.653Z","comments":true,"path":"2013/03/28/8086汇编/28、8086汇编 之jmp指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/28/8086汇编/28、8086汇编 之jmp指令/","excerpt":"","text":"jmp指令 jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP； jmp指令要给出两种信息： 转移的目的地址 转移的距离（段间转移、段内短转移，段内近转移） jmp short 标号（转到标号处执行指令） 这种格式的 jmp 指令实现的是段内短转移，它对IP的修改范围为 -128~127，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。 jmp near ptr 标号 实现的是段内近转移(IP)=(IP)+16位位移。 指令 “jmp far ptr 标号” 实现的是段间转移，又称为远转移。 (CS)=标号所在段的段地址； (IP)=标号所在段中的偏移地址。 far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。 另外常见的jmp指令还有 jmp [16位寄存器]（如 jmp ax），该指令功能是将IP修改为16位寄存器的值。Jmp word ptr 段寄存器:[偏移]如（jmp word ptr ds:[0]），该指令的功能是将IP修改为内存单元中所存的一个16位字","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"27、8086汇编 之offset指令","slug":"8086汇编/27、8086汇编 之offset指令","date":"2013-03-26T18:56:49.000Z","updated":"2020-08-07T14:10:11.653Z","comments":true,"path":"2013/03/27/8086汇编/27、8086汇编 之offset指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/27/8086汇编/27、8086汇编 之offset指令/","excerpt":"","text":"offset指令操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。 比如下面的程序： 1234567assume cs:codesgcodeseg segment start:mov ax,offset start ; 相当于 mov ax,0 s:mov ax,offset s ; 相当于mov ax,3codesg endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"26、8086汇编 之div、dd、dup指令","slug":"8086汇编/26、8086汇编 之div、dd、dup指令","date":"2013-03-25T19:29:40.000Z","updated":"2020-08-07T14:10:11.653Z","comments":true,"path":"2013/03/26/8086汇编/26、8086汇编 之div、dd、dup指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/26/8086汇编/26、8086汇编 之div、dd、dup指令/","excerpt":"","text":"div、dd、dup指令div指令div指令格式： div reg div 内存单元 div是除法指令(division)，使用div作除法的时候： 除数：8位或16位，在寄存器或内存单元中 被除数：（默认）放在AX 或 DX和AX中1234567除数 被除数 8位 16位(AX)16位 32位(DX+AX)结果： 运算 8位 16位商 AL AX余数 AH DX 利用除法指令计算100001/100。（程序） 1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001mov bx,100div bx 程序执行后，(ax)=03E8H（即1000），(dx)=1（余数为1）。 伪指令 dddd是用来定义dword （double word双字）型数据的。 在data段中定义了三个数据： 12345data segment db 1 dw 1 dd 1data ends 第一个数据为01H，在data:0处，占1个字节； 第二个数据为0001H，在data:1处，占1个字； 第三个数据为00000001H，在data:3处，占2个字节； dup dup是一个操作符，在汇编语言中同db、dw、dd 等一样，也是由编译器识别处理的符号。 它是和db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。 dup的使用格式如下： db 重复的次数 dup （重复的字节型数据） dw 重复的次数 dup （重复的字型数据） dd 重复的次数 dup （重复的双字数据） 123db 3 dup (0) 定义了3个字节，它们的值都是0，相当于 db 0,0,0 1234db 3 dup (0,1,2) 定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于 db 0,1,2,0,1,2,0,1,2 1234db 3 dup (‘abc’,’ABC’) 定义了18个字节，它们是‘abcABCabcABCabcABC’，相当于db ‘abcABCabcABCabcABC’","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"25、8086汇编 之数据尺寸","slug":"8086汇编/25、8086汇编 之数据尺寸","date":"2013-03-25T03:33:52.000Z","updated":"2020-08-07T14:10:11.653Z","comments":true,"path":"2013/03/25/8086汇编/25、8086汇编 之数据尺寸/","link":"","permalink":"https://www.zackaddy.xin/2013/03/25/8086汇编/25、8086汇编 之数据尺寸/","excerpt":"","text":"数据尺寸8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。 下面寄存器指明了指令进行的是字操作 123456mov ax,1mov bx,ds:[0]mov ds,axmov ds:[0],axinc axadd ax,1000 下面寄存器指明了指令进行的是字节操作 123456mov al,1mov al,blmov al,ds:[0]mov ds:[0],alinc aladd al,100 下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元： 1234mov word ptr ds:[0],1inc word ptr [bx]inc word ptr ds:[0]add word ptr [bx],2 下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元： 1234mov byte ptr ds:[0],1inc byte ptr [bx]inc byte ptr ds:[0]add byte ptr [bx],2 在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度是很必要的。 否则，CPU无法得知所要访问的单元是字单元，还是字节单元。 有些指令默认了访问的是字单元还是字节单元 比如：push [1000H]就不用指明访问的是字单元还是字节单元， 因为push指令只进行字操作。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"24、8086汇编 之（重点）数据处理","slug":"8086汇编/24、8086汇编 之（重点）数据处理","date":"2013-03-23T19:27:58.000Z","updated":"2020-08-07T14:10:11.652Z","comments":true,"path":"2013/03/24/8086汇编/24、8086汇编 之（重点）数据处理/","link":"","permalink":"https://www.zackaddy.xin/2013/03/24/8086汇编/24、8086汇编 之（重点）数据处理/","excerpt":"","text":"数据处理reg与sreg reg来表示一个寄存器，用sreg表示一个段寄存器 reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di； sreg的集合包括：ds、ss、cs、es。 bx、si、di、bp 在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中来进行内存单元的寻址。 错误的指令1234mov ax,[cx]mov ax,[ax]mov ax,[dx]mov ax,[ds] 正确的指令123456mov ax,[bx]mov ax,[bx+si]mov ax,[bx+di]mov ax,[bp]mov ax,[bp+si]mov ax,[bp+di] 在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现： bx和si、bx和di、bp和si、bp和di 错误的用法12mov ax,[bx+bp]mov ax,[si+di] 正确的用法12345678910111213mov ax,[bx]mov ax,[si]mov ax,[di]mov ax,[bp]mov ax,[bx+si]mov ax,[bx+di]mov ax,[bp+si]mov ax,[bp+di]mov ax,[bx+si+idata]mov ax,[bx+di+idata]mov ax,[bp+si+idata]mov ax,[bp+di+idata] 只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中。1234mov ax,[bp] 含义： (ax)=((ss)*16+(bp))mov ax,[bp+idata] 含义：(ax)=((ss)*16+(bp)+idata)mov ax,[bp+si] 含义：(ax)=((ss)*16+(bp)+(si))mov ax,[bp+si+idata] 含义：(ax)=((ss)*16+(bp)+(si)+idata) 汇编语言中用三个概念来表达数据的位置。 立即数（idata） 寄存器 段地址（SA）和偏移地址（EA）","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"23、8086汇编 之更灵活定位内存地址","slug":"8086汇编/23、8086汇编 之更灵活定位内存地址","date":"2013-03-23T03:24:39.000Z","updated":"2020-08-07T14:10:11.652Z","comments":true,"path":"2013/03/23/8086汇编/23、8086汇编 之更灵活定位内存地址/","link":"","permalink":"https://www.zackaddy.xin/2013/03/23/8086汇编/23、8086汇编 之更灵活定位内存地址/","excerpt":"","text":"更灵活定位内存地址[bx+idata]在前面，我们用 [bx] 的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata (bx 中的数值加上 idata)。 我们看一下指令 mov ax,[bx+200] 的含义： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。 数学化描述为：(ax)=((ds)*16 + (bx) + 200) 该指令也可以写成如下格式（常用）： 12345 mov ax,[200+bx] mov ax,200[bx] mov ax,[bx].200 SI 和 DI si 和 di 是 8086CPU 中和 bx 功能相近的寄存器，si 和 di 不能够分成两个 8 位寄存器来使用。下面的 3 组指令实现了相同的功能。 12345678910111213141516171819202122232425 （1）mov bx,0 mov ax,[bx] （2）mov si,0 mov ax,[si] （3）mov di,0 mov ax,[di] 下面的 3 组指令也实现了相同的功能 （1）mov bx,0 mov ax,[bx+123] （2）mov si,0 mov ax,[si+123] （3）mov di,0 mov ax,[di+123] [bx+si] 和 [bx+di] 在前面，我们用[bx(si 或 di)]和[bx(si 或 di)+idata]的方式来指明一个内存单元，我们还可以用更灵活的方式：[bx+si] 和 [bx+di]。 [bx+si] 和 [bx+di] 的含义相似，我们以[bx+si]为例进行详解。 [bx+si] 表示一个内存单元，它的偏移地址为 (bx)+(si) (即 bx 中的数值加上 si 中的数值)。 指令 mov ax,[bx+si] 的含义如下： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 si 中的数值，段地址在 ds 中。 数学化描述为：(ax)=((ds)*16+(bx)+(si))。 该指令也可以写成如下格式（常用）： mov ax,[bx][si] [bx+si+idata] 和 [bx+di+idata] [bx+si+idata] 和 [bx+di+idata] 的含义相似，我们以 [bx+si+idata] 为例进行详解。 [bx+si+idata] 表示一个内存单元，它的偏移地址为 (bx)+(si)+idata(即 bx 中的数值加上 si 中的数值 再加上 idata)。 指令 mov ax,[bx+si+idata] 的含义如下： 将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 si 中的数值再加上 idata，段地址在 ds 中。 数学化描述为：(ax)=((ds)*16+(bx)+(si)+idata) 该指令也可以写成如下格式（常用）： mov ax,[bx+200+si] mov ax,[200+bx+si] mov ax,200[bx][si] mvo ax,[bx].200[si] mov ax,[bx][si].200 不同的寻址方式的灵活应用 如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现： （1）[idata] 用一个常量来表示地址，可用于直接定位一个内存单元； （2）[bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元； （3）[bx+idata] 用一个变量和一个常量来表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元； （4）[bx+si] 用两个变量表示地址； （5）[bx+si+idata] 用两个变量和一个常量表示地址。 可以看到，从[idata]一直到[bx+si+idata]，我们可以用更加灵活的方式来定位一个单元的地址。这使我们可以从更加结构化的角度来看待要处理的数据。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"22、8086汇编 之and与or指令","slug":"8086汇编/22、8086汇编 之and与or指令","date":"2013-03-22T04:34:35.000Z","updated":"2020-08-07T14:10:11.652Z","comments":true,"path":"2013/03/22/8086汇编/22、8086汇编 之and与or指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/22/8086汇编/22、8086汇编 之and与or指令/","excerpt":"","text":"and与or指令and指令 逻辑与指令，按位进行与运算 1234mov al,01100011Band al,00111011Bal为00100011B or指令 逻辑或指令，按位进行或运算 1234mov al,01100011Bor al,00111011Bal为01111011","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"21、8086汇编 之包含多个段的程序","slug":"8086汇编/21、8086汇编 之包含多个段的程序","date":"2013-03-21T04:28:38.000Z","updated":"2020-08-07T14:10:11.652Z","comments":true,"path":"2013/03/21/8086汇编/21、8086汇编 之包含多个段的程序/","link":"","permalink":"https://www.zackaddy.xin/2013/03/21/8086汇编/21、8086汇编 之包含多个段的程序/","excerpt":"","text":"包含多个段的程序 dw伪指令：即“define word”，告诉编译器接下来定义字型数据类似的， db伪指令，即“define Byte”，用于定义字节型数据 示例1234567891011121314151617181920212223242526assume cs:code, ds:data, ss:stackdata segment dw 0123H, 0456Hdata endsstack segment dw 0, 0stack ends code segmentstart: mov ax, stack mov ss, ax mov sp, 16 mov ax, data mov ds, ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax, 4c00h int 21hcode endsend start","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"20、8086汇编 之[bx]、cs、loop","slug":"8086汇编/20、8086汇编 之[bx]、cs、loop","date":"2013-03-20T00:17:15.000Z","updated":"2020-08-07T14:10:11.652Z","comments":true,"path":"2013/03/20/8086汇编/20、8086汇编 之[bx]、cs、loop/","link":"","permalink":"https://www.zackaddy.xin/2013/03/20/8086汇编/20、8086汇编 之[bx]、cs、loop/","excerpt":"","text":"[bx]、cs、loop[bx] 用[0]表示一个内存单元时,0表示单元的偏移地址，段地址默认在ds中 用[bx]代替[n]在编辑器中编辑并通过masm编译后，这种[n]形式的都会被编译器解析为值 eg：mov ax,[2]会被解析为mov ax,2 但是并不是说必须用[bx]的形式，只是[n]的形式必须配合”段地址寄存器:[n]”的形式一起使用 1234mov ax,[0] //对MASM来说错误mov ax,ds:[0] //正确mov ax,ds:[bx] //正确mov ax,[bx] //正确 cs和loop1234567891011assume cs:codesegcodeseg segment mov cx,16 ;循环16次 mov ax,1 addNumber: inc ax loop addNumber ;条件(CX)减1 int 21Hcodeseg endsend","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"19、8086汇编 之编译与连接","slug":"8086汇编/19、8086汇编 之编译与连接","date":"2013-03-18T17:24:49.000Z","updated":"2020-08-07T14:10:11.651Z","comments":true,"path":"2013/03/19/8086汇编/19、8086汇编 之编译与连接/","link":"","permalink":"https://www.zackaddy.xin/2013/03/19/8086汇编/19、8086汇编 之编译与连接/","excerpt":"","text":"编译与连接一个汇编语言程序从写出到最终执行的简要过程 编写 -&gt; 编译连接 -&gt; 执行 使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件； 再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。可执行文件中包含两部分内容： 程序（从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据） 相关的描述信息（比如：程序有多大、要占多少内存空间等） 在操作系统中，执行可执行文件程序。 操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由CPU执行程序 汇编指令 有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行 伪指令 没有对应的机器码的指令，最终不被CPU所执行。 谁来执行伪指令呢？ 伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作 定义一个段 一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。 一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。 如果程序写完了，要在结尾处加上伪指令end 。否则，编译器在编译程序时，无法知道程序在何处结束。 assume：含义为“假设”。 它假设某一段寄存器和程序中的某一个用 segment … ends 定义的段相关联。 通过assume说明这种关联，在需要的情况下 ，编译程序可以将段寄存器和某一个具体的段相联系。 。 标号 一个标号指代了一个地址。 codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。 连接的作用有以下几个： 当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件； 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件； 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这此内容处理为最终的可执行信息。 所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。 可执行文件中的程序装入内存并运行的原理 在DOS中，可执行文件中的程序P1若要运行，必须有一个正在运行的程序P2 ，将 P1 从可执行文件中加载入内存，将CPU的控制权交给它，P1才能得以运行； 当P1运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P2。 操作系统是由多个功能模块组成的庞大 、复杂的软件系统。任何通用的操作系统 ，都要提供一个称为shell（外壳）的程序 ，用户（操作人员）使用这个程序来操作计算机系统工作。 DOS中有一个程序 command. com ，这个程序在 DOS 中称为命令解释器，也就是DOS系统的shell。 我们在DOS中直接执行 1.exe 时，是正在运行的command将1.exe中的程序加载入内存。 command设置CPU的CS:IP指向程序的第一条指令（即程序的入口），从而使程序得以运行。 程序运行结束后，返回到command中，CPU继续运行command。 程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则程序所在的内存区的地址为：ds:0； 这个内存区的前256 个字节中存放的是PSP，dos用来和程序进行通信。从 256字节处向后的空间存放的是程序。 所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为 0，则物理地址为SA×16+0。 因为PSP占256（100H）字节，所以程序的物理地址是： SA×16+0+256= SA×16+16×16=（SA+16）×16+0 可用段地址和偏移地址表示为：SA+100:0。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"18、8086汇编 之push与pop指令","slug":"8086汇编/18、8086汇编 之push与pop指令","date":"2013-03-17T22:24:07.000Z","updated":"2020-08-07T14:10:11.651Z","comments":true,"path":"2013/03/18/8086汇编/18、8086汇编 之push与pop指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/18/8086汇编/18、8086汇编 之push与pop指令/","excerpt":"","text":"push与pop指令 push和pop指令是可以在寄存器和内存之间传送数据的。 push和pop指令的格式 push 寄存器：将一个寄存器中的数据入栈 pop寄存器：出栈，用一个寄存器接收出栈的数据例如 12push axpop bx push 段寄存器：将一个段寄存器中的数据入栈 pop段寄存器：出栈，用一个段寄存器接收出栈的数据例如 12push dspop es push内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位） pop 内存单元：出栈，用一个内存字单元接收出栈的数据例如 12push [0]pop [2] push、pop 等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"17、8086汇编 之栈","slug":"8086汇编/17、8086汇编 之栈","date":"2013-03-16T23:50:14.000Z","updated":"2020-08-07T14:10:11.651Z","comments":true,"path":"2013/03/17/8086汇编/17、8086汇编 之栈/","link":"","permalink":"https://www.zackaddy.xin/2013/03/17/8086汇编/17、8086汇编 之栈/","excerpt":"","text":"栈 它的特殊性就在于，最后进入这个空间的数据，最先出去。 栈有两个基本的操作 入栈和出栈 入栈：将一个新的元素放到栈顶； 出栈：从栈顶取出一个元素。 栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。 任意时刻，SS:SP指向栈顶元素。 CPU如何指导当前要执行的指令所在的位置答：寄存器CS和IP中存放着当前指令的段地址和偏移地址。 push ax SP=SP–2； 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。 pop ax 将SS:SP指向的内存单元处的数据送入ax中； SP = SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 注意 出栈后，SS:SP指向新的栈顶 1000EH，pop操作前的栈顶元素，1000CH 处的2266H 依然存在 ，但是，它已不在栈中。 当再次执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，它将被覆盖。 栈顶超界的问题 当栈满的时候再使用push指令入栈，栈空的时候再使用pop指令出栈， 都将发生栈顶超界问题。 栈顶超界是危险的。 因为我们既然将一段空间安排为栈 ，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己的程序中的，也可能是别的程序中的。（毕竟一个计算机系统并不是只有我们自己的程序在运行） 比如说在CPU中有记录栈顶上限和下限的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围 ，然后 ，CPU 在执行push指令的时候靠检测栈顶上限寄存器，在执行pop 指令的时候靠检测栈顶下限寄存器保证不会超界。 实际情况：8086CPU中并没有这样的寄存器。 栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"16、8086汇编 之mov寻址方式","slug":"8086汇编/16、8086汇编 之mov寻址方式","date":"2013-03-15T23:17:30.000Z","updated":"2020-08-07T14:10:11.650Z","comments":true,"path":"2013/03/16/8086汇编/16、8086汇编 之mov寻址方式/","link":"","permalink":"https://www.zackaddy.xin/2013/03/16/8086汇编/16、8086汇编 之mov寻址方式/","excerpt":"","text":"mov寻址方式1.寄存器寻址：寄存器来保存操作数 例如，MOV BX,AX 2.立即数寻址：操作数为常数 例如，MOV AX,08H 3.直接寻址：指定内存的地址，操作数为内存地址，DS:操作数寻址 例如，MOV AL,[10H] ;将DS:10H中的内容传送到AL 4.寄存器间接寻址：寄存器中保存的是操作数的内存地址，DS+BX/SI/DI或者SS+SP/BP 例如，MOV AL,[SI] ;若SI=10H，将DS:10H的内容传送到AL 例如，MOV AL,[BP] ;若BP=10H，将SS:10H的内容传送到AL 5.基址相对寻址：BX/BP基址寄存器，连同偏移量寻址，DS+BX+偏移量或者SS+BP+偏移量 例如，MOV AL,[BX]+10H ;将DS:BX+10H处的内容传送到AL。 例如，MOV AL,[BP]+10H ;将SS:BP+10H出的内容传送到AL。 6.索引相对寻址：SI/DI索引寄存器，连同偏移量寻址，同“5.基址相对寻址” 7.基址索引相对寻址：将BX/BP和SI/DI组合起来寻址 例如，MOV AL,[BX][SI]+10H ;将DS:BX+SI+10H处的内容传送到AL。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"15、8086汇编 之mov、and、sub指令","slug":"8086汇编/15、8086汇编 之mov、and、sub指令","date":"2013-03-14T17:33:49.000Z","updated":"2020-08-07T14:10:11.650Z","comments":true,"path":"2013/03/15/8086汇编/15、8086汇编 之mov、and、sub指令/","link":"","permalink":"https://www.zackaddy.xin/2013/03/15/8086汇编/15、8086汇编 之mov、and、sub指令/","excerpt":"","text":"mov、and、sub指令mov指令 mov 寄存器，数据 比如：mov ax,8 mov 寄存器，寄存器 比如：mov ax,bx mov 寄存器，内存单元 比如：mov ax,[0] mov 内存单元，寄存器 比如：mov [0],ax mov 段寄存器，寄存器 比如：mov ds,ax mov 寄存器，段寄存器 比如：mov ax,ds mov 内存单元，段寄存器 比如：mov [0],ds add指令 add 寄存器，数据 比如：add ax,8 add 寄存器，寄存器 比如：add ax,bx add 寄存器，内存单元 比如：add ax,[0] add 内存单元，寄存器 比如：add [0],ax sub指令 sub 寄存器，数据 比如：sub ax,8 sub 寄存器，寄存器 比如：sub ax,bx sub 寄存器，内存单元 比如：sub ax,[0] sub 内存单元，寄存器 比如：sub [0],ax add与sub不能对段寄存器操作","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"14、8086汇编 之DS和[address]","slug":"8086汇编/14、8086汇编 之DS和[address]","date":"2013-03-14T04:34:36.000Z","updated":"2020-08-07T14:10:11.650Z","comments":true,"path":"2013/03/14/8086汇编/14、8086汇编 之DS和[address]/","link":"","permalink":"https://www.zackaddy.xin/2013/03/14/8086汇编/14、8086汇编 之DS和[address]/","excerpt":"","text":"DS和[address] CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址； 在8086PC中，内存地址由段地址和偏移地址组成。 8086CPU中有一个 DS寄存器，通常用来存放要访问的数据的段地址。 示例例如：我们要读取10000H单元的内容可以用如下程序段进行： 123mov bx,1000Hmov ds,bxmov al,[0] 上面三条指令将10000H（1000:0）中的数据读到al中。 如何把1000H送入ds传送指令 mov ax,1相似的方式 mov ds,1000H? 8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题） mov ds,1000H 是非法的。 结论： 123mov bx,1000Hmov ds,bxmov [0],al","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"13、8086汇编 之段寄存器之CS和IP","slug":"8086汇编/13、8086汇编 之段寄存器之CS和IP","date":"2013-03-13T02:56:49.000Z","updated":"2020-08-07T14:10:11.649Z","comments":true,"path":"2013/03/13/8086汇编/13、8086汇编 之段寄存器之CS和IP/","link":"","permalink":"https://www.zackaddy.xin/2013/03/13/8086汇编/13、8086汇编 之段寄存器之CS和IP/","excerpt":"","text":"段寄存器之CS和IP段寄存器就是提供段地址的。 8086CPU有4个段寄存器： CS、DS、SS、ES 当8086CPU要访问内存时，由这4个段寄存器提供内存单元的段地址。 CS和IPCS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。 CS为代码段寄存器； IP为指令指针寄存器。 8086PC工作过程的简要描述在 8086CPU 加电启动或复位后（ 即 CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H。 即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令执行。 FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。 在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。 内存中的一段信息曾被CPU执行过，那么，它所在的内存单元必然被CS:IP指向过。 可以通过改变寄存器中的内容实现对CPU的控制。 CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。 修改CS、IP的指令1234jmp 2000:20000 //同时修改了段地址和偏移地址，那么下一条将要执行的指令就从2000:2000开始jmp 1000 //只修改了IP偏移地址mov ax,2000jmp ax //jmp借助通用寄存器修改IP也是可以的 注意： 可以通过jmp修改CS和IP(jmp直接用值修改CS:IP或只修改IP) 可以通过”mov cs,ax/bx/cx/dx”修改CS(mov借助通用寄存器修改) 不能通过”mov cs,FFFF”修改CS(mov不能直接用值修改CS)， 不能通过mov修改IP(无论是借助通用寄存器，还是直接用mov修改)。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"12、8086汇编 之段的概念","slug":"8086汇编/12、8086汇编 之段的概念","date":"2013-03-11T19:44:07.000Z","updated":"2020-08-07T14:10:11.649Z","comments":true,"path":"2013/03/12/8086汇编/12、8086汇编 之段的概念/","link":"","permalink":"https://www.zackaddy.xin/2013/03/12/8086汇编/12、8086汇编 之段的概念/","excerpt":"","text":"段的概念内存并没有分段，段的划分来自于CPU，由于8086CPU用“（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。 段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数； 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。 CPU可以用不同的段地址和偏移地址形成同一个物理地址。 物理地址 | 段地址 | 偏移地址 21F60H | 2000H | 1F60H | 2100H | 0F60H 如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可以定位多少内存单元？ 结论：偏移地址16位，变化范围为0~FFFFH，仅用偏移地址来寻址最多可寻64K个内存单元。 比如：给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H~1FFFFH。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"11、8086汇编 之物理地址","slug":"8086汇编/11、8086汇编 之物理地址","date":"2013-03-10T16:14:53.000Z","updated":"2020-08-07T14:10:11.649Z","comments":true,"path":"2013/03/11/8086汇编/11、8086汇编 之物理地址/","link":"","permalink":"https://www.zackaddy.xin/2013/03/11/8086汇编/11、8086汇编 之物理地址/","excerpt":"","text":"物理地址CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。我们将这个唯一的地址称为物理地址 16位结构的CPU 运算器一次最多可以处理16位的数据。 寄存器的最大宽度为16位。 寄存器和运算器之间的通路是16位的。 8086有20位地址总线，可传送20位地址，寻址能力为1M。 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K(2^16)。 8086CPU如何用内部16位的数据转换成20位的地址呢？答：8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址~地址加法器合成物理地址的方法： 1物理地址=段地址×16+偏移地址 “段地址×16”有一个更为常用的说法就是数据左移4位。（二进制位）","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"10、8086汇编 之通用寄存器","slug":"8086汇编/10、8086汇编 之通用寄存器","date":"2013-03-10T01:28:21.000Z","updated":"2020-08-07T14:10:11.649Z","comments":true,"path":"2013/03/10/8086汇编/10、8086汇编 之通用寄存器/","link":"","permalink":"https://www.zackaddy.xin/2013/03/10/8086汇编/10、8086汇编 之通用寄存器/","excerpt":"","text":"通用寄存器8086CPU有14个寄存器 它们的名称为： 123AX、BX、CX、DX、SI、DI、SP、BPIP、CS、SS、DS、ES、PSW 8086/8088内部的寄存器组分成8个通用寄存器4个段寄存器1个标志寄存器1个指令指针寄存器（一共14个寄存器，分为专用与通用）它们均为16位 通用寄存器有： 数据寄存器(AX,BX,CX,DX)； 指针寄存器：堆栈指针寄存器SP； 基址指针寄存器BP； 变址寄存器：源变址寄存器SI； 目标变址寄存器DI； 专用寄存器有： 控制寄存器：指令指针IP； 标志寄存器FLAGS; 段寄存器：代码段寄存器CS； 堆栈段寄存器SS； 数据段寄存器DS; 附加段寄存器ES; 栈顶的段地址存放在段寄存器SS中，而对于栈顶的偏移地址，其则是存放在 SP 寄存器中的 。在任何时刻，SS:SP 都是指向栈顶元素 。 8086上一代CPU中的寄存器都是8位的；为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。 AX可以分为AH和AL； BX可以分为BH和BL； CX可以分为CH和CL； DX可以分为DH和DL。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"9、8086汇编 之内存地址空间","slug":"8086汇编/9、8086汇编 之内存地址空间","date":"2013-03-09T04:14:40.000Z","updated":"2020-08-07T14:10:11.658Z","comments":true,"path":"2013/03/09/8086汇编/9、8086汇编 之内存地址空间/","link":"","permalink":"https://www.zackaddy.xin/2013/03/09/8086汇编/9、8086汇编 之内存地址空间/","excerpt":"","text":"前提知识主板 在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件。 这些器件通过总线（地址总线、数据总线、控制总线）相连。接口卡 计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。 CPU对外部设备不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。各类存储芯片 从读写属性上看分为两类： 随机存储器（RAM）和只读存储器（ROM） 从功能和连接上分类： 随机存储器RAM 装有BIOS的ROM 接口卡上的RAM 装有BIOS的ROM BIOS：Basic Input/Output System，基本输入输出系统。 BIOS是由主板和各类接口卡（如：显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM内存地址空间 什么是内存地址空间呢？ 一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间 上述的那些存储器在物理上是独立的器件。 但是它们在以下两点上相同： 都和CPU的总线相连。 CPU对它们进行读或写的时候都通过控制线发出内存读写命令 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器； 每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间； CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。 内存地址空间： 最终运行程序的是CPU，必须要从CPU角度考虑问题。 对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"8、8086汇编 之控制总线","slug":"8086汇编/8、8086汇编 之控制总线","date":"2013-03-08T02:54:55.000Z","updated":"2020-08-07T14:10:11.658Z","comments":true,"path":"2013/03/08/8086汇编/8、8086汇编 之控制总线/","link":"","permalink":"https://www.zackaddy.xin/2013/03/08/8086汇编/8、8086汇编 之控制总线/","excerpt":"","text":"控制总线 CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。 有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"7、8086汇编 之数据总线","slug":"8086汇编/7、8086汇编 之数据总线","date":"2013-03-06T16:00:11.000Z","updated":"2020-08-07T14:10:11.657Z","comments":true,"path":"2013/03/07/8086汇编/7、8086汇编 之数据总线/","link":"","permalink":"https://www.zackaddy.xin/2013/03/07/8086汇编/7、8086汇编 之数据总线/","excerpt":"","text":"数据总线 CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。 数据总线的宽度决定了CPU和外界的数据传送速度。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"6、8086汇编 之地址总线","slug":"8086汇编/6、8086汇编 之地址总线","date":"2013-03-05T23:13:45.000Z","updated":"2020-08-07T14:10:11.657Z","comments":true,"path":"2013/03/06/8086汇编/6、8086汇编 之地址总线/","link":"","permalink":"https://www.zackaddy.xin/2013/03/06/8086汇编/6、8086汇编 之地址总线/","excerpt":"","text":"地址总线 CPU是通过地址总线来指定存储单元的。 地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N。 这样的CPU最多可以寻找２的N次方个内存单元。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"5、8086汇编 之存储单元","slug":"8086汇编/5、8086汇编 之存储单元","date":"2013-03-05T03:59:49.000Z","updated":"2020-08-07T14:10:11.657Z","comments":true,"path":"2013/03/05/8086汇编/5、8086汇编 之存储单元/","link":"","permalink":"https://www.zackaddy.xin/2013/03/05/8086汇编/5、8086汇编 之存储单元/","excerpt":"","text":"存储单元 存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号； 一个存储器有128个存储单元，编号从0~127 对于大容量的存储器一般还用以下单位来计量容量（以下用B来代表Byte）： 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB 磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。 CPU对存储器读写 CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互： 存储单元的地址（地址信息） 器件的选择，读或写命令（控制信息） 读或写的数据（数据信息） 那么CPU是通过什么将地址、数据和控制信息传到存储芯片中的呢？ 电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。 在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。 物理上：一根根导线的集合； 逻辑上划分为： 地址总线 数据总线 控制总线 对于8086CPU，下面的机器码能够完成从3号单元读数据： 机器码： 101000000000001100000000 含义：从3号单元读取数据送入寄存器AX CPU接收这条机器码后将完成上面所述的读写工作。","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"4、8086汇编 之指令和数据","slug":"8086汇编/4、8086汇编 之指令和数据","date":"2013-03-03T19:14:12.000Z","updated":"2020-08-07T14:10:11.657Z","comments":true,"path":"2013/03/04/8086汇编/4、8086汇编 之指令和数据/","link":"","permalink":"https://www.zackaddy.xin/2013/03/04/8086汇编/4、8086汇编 之指令和数据/","excerpt":"","text":"指令和数据 指令和数据是应用上的概念。 在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。 二进制信息：12341000100111011000 ─&gt; 89D8H （数据）1000100111011000 ─&gt; MOV AX,BX （程序）","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"3、8086汇编 之存储器","slug":"8086汇编/3、8086汇编 之存储器","date":"2013-03-02T17:51:08.000Z","updated":"2020-08-07T14:10:11.657Z","comments":true,"path":"2013/03/03/8086汇编/3、8086汇编 之存储器/","link":"","permalink":"https://www.zackaddy.xin/2013/03/03/8086汇编/3、8086汇编 之存储器/","excerpt":"","text":"存储器 CPU 是计算机的核心部件．它控制整个计算机的运作并进行运算，要想让一个CPU 工作，就必须向它提供指令和数据。 指令和数据在存储器中存放，也就是平时所说的内存 在一台PC机中内存的作用仅次于CPU。 离开了内存，性能再好的CPU也无法工作。 磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU 使用","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"2、8086汇编 之汇编语言组成","slug":"8086汇编/2、8086汇编 之汇编语言组成","date":"2013-03-02T00:41:47.000Z","updated":"2020-08-07T14:10:11.654Z","comments":true,"path":"2013/03/02/8086汇编/2、8086汇编 之汇编语言组成/","link":"","permalink":"https://www.zackaddy.xin/2013/03/02/8086汇编/2、8086汇编 之汇编语言组成/","excerpt":"","text":"汇编语言组成 汇编语言的核心是汇编指令，它决定了汇编语言的特性汇编语言由下面三类组成 汇编指令（机器码的助记符） 伪指令 （由编译器执行） 其它符号（由编译器识别）","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"1、8086汇编 之机器语言","slug":"8086汇编/1、8086汇编 之机器语言","date":"2013-02-28T23:37:43.000Z","updated":"2020-08-07T14:10:11.651Z","comments":true,"path":"2013/03/01/8086汇编/1、8086汇编 之机器语言/","link":"","permalink":"https://www.zackaddy.xin/2013/03/01/8086汇编/1、8086汇编 之机器语言/","excerpt":"","text":"机器语言 机器语言是机器指令的集合。 机器指令展开来讲就是一台机器可以正确执行的命令 指令：01010000 (PUSH AX) 汇编语言产生原因 请找出下面机器语言错误处 111101000010101010101010 语言晦涩，需要对照指令表查找错误，所以出现了汇编语言 机器指令： 1000100111011000 操作：寄存器 BX的内容送到AX中 汇编指令：MOV AX,BX 这样的写法与人类语言接近，便于阅读和记忆","categories":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}],"tags":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/tags/8086汇编/"}],"keywords":[{"name":"8086汇编","slug":"8086汇编","permalink":"https://www.zackaddy.xin/categories/8086汇编/"}]},{"title":"72.0、可变参数","slug":"C/72.0、可变参数","date":"2012-11-21T17:40:29.000Z","updated":"2020-08-07T14:10:11.674Z","comments":true,"path":"2012/11/22/C/72.0、可变参数/","link":"","permalink":"https://www.zackaddy.xin/2012/11/22/C/72.0、可变参数/","excerpt":"","text":"定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;double average(int num,...)&#123; va_list valist; double sum = 0.0; int i; /* 为 num 个参数初始化 valist */ va_start(valist, num); /* 访问所有赋给 valist 的参数 */ for (i = 0; i &lt; num; i++) &#123; sum += va_arg(valist, int); &#125; /* 清理为 valist 保留的内存 */ va_end(valist); return sum/num;&#125;int main()&#123; printf(\"Average of 2, 3, 4, 5 = %f\\n\", average(4, 2,3,4,5)); printf(\"Average of 5, 10, 15 = %f\\n\", average(3, 5,10,15));&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"71.0、静态链接库和动态链接库的生成和使用","slug":"C/71.0、静态链接库和动态链接库的生成和使用","date":"2012-11-20T18:40:35.000Z","updated":"2020-08-07T14:10:11.673Z","comments":true,"path":"2012/11/21/C/71.0、静态链接库和动态链接库的生成和使用/","link":"","permalink":"https://www.zackaddy.xin/2012/11/21/C/71.0、静态链接库和动态链接库的生成和使用/","excerpt":"","text":"https://blog.csdn.net/youmingyu/article/details/53322490","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"70.0、回调函数","slug":"C/70.0、回调函数","date":"2012-11-19T17:03:00.000Z","updated":"2020-08-07T14:10:11.673Z","comments":true,"path":"2012/11/20/C/70.0、回调函数/","link":"","permalink":"https://www.zackaddy.xin/2012/11/20/C/70.0、回调函数/","excerpt":"","text":"12345678910111213141516171819#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef int (*FUN)(int value);int fun(int value, FUN callback) &#123; callback(value);&#125;int eat(int a) &#123; &#125;int main(int argc, char *argv[]) &#123; fun(66, eat); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"69.0、函数指针数组","slug":"C/69.0、函数指针数组","date":"2012-11-19T00:29:37.000Z","updated":"2020-08-07T14:10:11.673Z","comments":true,"path":"2012/11/19/C/69.0、函数指针数组/","link":"","permalink":"https://www.zackaddy.xin/2012/11/19/C/69.0、函数指针数组/","excerpt":"","text":"123456789101112131415161718#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef int (*FUN)(int value);int fun(int value) &#123; printf(\"%d\", value);&#125;int main(int argc, char *argv[]) &#123; int (*p[3])(int value) = &#123;fun&#125;; p[0](7); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"68.0、函数指针","slug":"C/68.0、函数指针","date":"2012-11-17T18:55:28.000Z","updated":"2020-08-07T14:10:11.672Z","comments":true,"path":"2012/11/18/C/68.0、函数指针/","link":"","permalink":"https://www.zackaddy.xin/2012/11/18/C/68.0、函数指针/","excerpt":"","text":"第一种 1234567891011121314151617181920#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef int FUN(int value);int fun(int value) &#123; printf(\"%d\", value);&#125;int main(int argc, char *argv[]) &#123; FUN *f = NULL; //f = &amp;fun;不推荐 f = fun; f(5); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 第二种 常用 123456789101112131415161718#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef int (*FUN)(int value);int fun(int value) &#123; printf(\"%d\", value);&#125;int main(int argc, char *argv[]) &#123; FUN f = fun; f(5); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 第三种 常用 123456789101112131415161718#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef int (*FUN)(int value);int fun(int value) &#123; printf(\"%d\", value);&#125;int main(int argc, char *argv[]) &#123; int (*p)(int value) = fun; p(7); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 特别的用法 1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int s(int age) &#123; printf(\"%d\\n\", age); return 0;&#125;int (*say(int age, char *name))(int) &#123; printf(\"%d, %s\\n\", age, name); return s;&#125;int main(int argc, char *argv[]) &#123; printf(\"%d\",say(5, \"herghost\")(6)); printf(\"\\n\"); system(\"pause\"); return 0;&#125; 1234567891011121314typedef void (*Sigfunc)(int);void a1(int age) &#123; cout &lt;&lt; age &lt;&lt; endl;&#125;void (*s(int age))(int) &#123; cout &lt;&lt; \"s:\" &lt;&lt; age &lt;&lt; endl; return a1;&#125;Sigfunc s(int age) &#123; cout &lt;&lt; \"s:\" &lt;&lt; age &lt;&lt; endl; return a1;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"67.0、链表","slug":"C/67.0、链表","date":"2012-11-16T18:02:36.000Z","updated":"2020-08-07T14:10:11.672Z","comments":true,"path":"2012/11/17/C/67.0、链表/","link":"","permalink":"https://www.zackaddy.xin/2012/11/17/C/67.0、链表/","excerpt":"","text":"链表 优点 不需要连续的存储区域 删除插入效率高 缺点 随机访问效率低 数组 优点 随机访问效率高 缺点 需要连续的存储区域 删除插入效率低 静态链表1234567891011121314151617181920212223242526272829#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Student &#123; int id; char name[100]; struct Student *next;&#125; Student;int main(int argc, char *argv[]) &#123; Student s1 = &#123; 1, \"mike\", NULL &#125;; Student s2 = &#123; 2, \"herghost\", NULL &#125;; Student s3 = &#123; 3, \"phantom\", NULL &#125;; s1.next = &amp;s2; s2.next = &amp;s3; s3.next = NULL; Student *s = &amp;s1; while (s != NULL) &#123; printf(\"%d, %s\\n\", s-&gt;id, s-&gt;name); s = s-&gt;next; &#125; printf(\"\\n\"); system(\"pause\"); return 0;&#125; 动态列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; int id; struct Node *next;&#125; Node;//根据用户输入数值创建链表Node *slist_create() &#123; Node *head = NULL; head = (Node *)malloc(sizeof(Node)); if (head == NULL) &#123; return NULL; &#125; head-&gt;id = -1; head-&gt;next = NULL; Node *pCur = head; Node *pNew = NULL; int data; while (1) &#123; printf(\"please input data:\"); scanf(\"%d\", &amp;data); if (data == -1) &#123; break; &#125; pNew = (Node *)malloc(sizeof(Node)); if (pNew == NULL) &#123; printf(\"==alloc fails!!,please input data again==\\n\"); continue; &#125; pNew-&gt;id = data; pNew-&gt;next = NULL; pCur-&gt;next = pNew; pCur = pNew; &#125; return head;&#125;//输出所有链表元素int slist_print(Node *head) &#123; if (head == NULL) &#123; return -1; &#125; Node *pCur = head-&gt;next; while (pCur != NULL) &#123; printf(\"id-&gt;%d\\n\", pCur-&gt;id); pCur = pCur-&gt;next; &#125; return 0;&#125;//指定元素前插入节点int slist_insert(Node *head, int x, int y) &#123; if (head == NULL) &#123; return -1; &#125; Node *pPre = head; Node *pCur = head-&gt;next; while (pCur != NULL) &#123; if (pCur-&gt;id == x) &#123; break; &#125; pPre = pCur; pCur = pCur-&gt;next; &#125; Node *pNew = (Node *)malloc(sizeof(Node)); if (pNew == NULL) &#123; return -2; &#125; pNew-&gt;id = y; pNew-&gt;next = NULL; pPre-&gt;next = pNew; pNew-&gt;next = pCur; return 0;&#125;//链表结尾追加节点int slist_push(Node *head, int value) &#123; if (head == NULL) &#123; return -1; &#125; Node *pPre = head; Node *pCur = head-&gt;next; while (pCur != NULL) &#123; pPre = pCur; pCur = pCur-&gt;next; &#125; Node *pNew = (Node *)malloc(sizeof(Node)); if (pNew == NULL) &#123; return -2; &#125; pNew-&gt;id = value; pNew-&gt;next = NULL; pPre-&gt;next = pNew; pNew-&gt;next = pCur; return 0;&#125;//删除指定数值链表int slist_del(Node *head, int value) &#123; if (head == NULL) &#123; return -1; &#125; Node *pPre = head; Node *pCur = head-&gt;next; while (pCur != NULL) &#123; if (pCur-&gt;id == value) &#123; break; &#125; pPre = pCur; pCur = pCur-&gt;next; &#125; if (pCur == NULL) &#123; return -1; &#125; pPre-&gt;next = pCur-&gt;next; free(pCur); return 0;&#125;//释放所有链表int slist_free(Node **head) &#123; if (*head == NULL) &#123; return -1; &#125; Node *tmp = NULL; while (*head != NULL) &#123; tmp = (*head)-&gt;next; free(*head); *head = tmp; &#125; *head = NULL; return 0;&#125;int main(int argc, char *argv[]) &#123; Node *head = slist_create(); slist_push(head, 88); slist_del(head, 5); slist_print(head); slist_free(&amp;head); printf(\"\\n\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"66.0、一维二维数组与指针","slug":"C/66.0、一维二维数组与指针","date":"2012-11-15T16:15:36.000Z","updated":"2020-08-07T14:10:11.672Z","comments":true,"path":"2012/11/16/C/66.0、一维二维数组与指针/","link":"","permalink":"https://www.zackaddy.xin/2012/11/16/C/66.0、一维二维数组与指针/","excerpt":"","text":"123456789101112131415161718//一维数组与一维数组指针char a[] = &#123;2,3,4,5,6&#125;;char *p = a//一维数组与二维数组指针char a[] = &#123; 47,2,3,4,5,6,7&#125;;char (*p)[4] = a;printf(\"%d\", b[1][2]); //7//二维数组与二维数组指针char a[][4] = &#123; 47,2,3,4,5,6,7,0&#125;;char (*p)[4] = a;printf(\"%d\", b[1][2]); //7 //typedef 修饰二维数组指针typedef char (*size_1t)[4];char a[] = &#123; 47,2,3,4,5,6,7,0&#125;;size_1t b = a;printf(\"%d\", b[1][2]); //7","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"65.0、字符串的赋值","slug":"C/65.0、字符串的赋值","date":"2012-11-14T18:15:10.000Z","updated":"2020-08-07T14:10:11.672Z","comments":true,"path":"2012/11/15/C/65.0、字符串的赋值/","link":"","permalink":"https://www.zackaddy.xin/2012/11/15/C/65.0、字符串的赋值/","excerpt":"","text":"123456789101112131415161718192021222324252627//不指定长度，没有0结束符char buf[] = &#123;'a', 'b', 'c'&#125;;//指定长度，自动补0char buf[100] = &#123;'a', 'b', 'c'&#125;;//分两步//1. 所有元素赋值0//2. 第一个元素赋值为1char buf[100] = &#123;1&#125;;//数组越界char buf[2] = &#123;'a', 'b', 'c'&#125;;//结果为abchar buf[] = &#123;'a', 'b', '\\0', c'&#125;;//结果为abchar buf[] = &#123;'a', 'b', 0, c'&#125;;//结果为ab0cchar buf[] = &#123;'a', 'b', '0', c'&#125;;//常用char buff[] = \"dsddfdsfdfsdfdfs\";char *p = \"sadsadsdasad\";","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"64.0、指针做参数时的输入与输出（主调函数与被调函数）","slug":"C/64.0、指针做参数时的输入与输出（主调函数与被调函数）","date":"2012-11-14T02:37:18.000Z","updated":"2020-08-07T14:10:11.671Z","comments":true,"path":"2012/11/14/C/64.0、指针做参数时的输入与输出（主调函数与被调函数）/","link":"","permalink":"https://www.zackaddy.xin/2012/11/14/C/64.0、指针做参数时的输入与输出（主调函数与被调函数）/","excerpt":"","text":"1）主调函数与被调函数 主调函数可把堆区、栈区、全局数据内存地址传给被调用函数 被调用函数只能返回堆区、全局数据（没有桟区：函数执行完桟区释放，可以返回桟区指针，但是绝对不要） 2）内存分配方式 指针做函数参数，是有输入和输出特性的。 输入：主调函数分配内存 输出：被调函数分配内存 输入： 12345678910void fun(char *s) &#123; strcpy(s, \"abcdefg\");&#125;int main(int argc, char **argv) &#123; char buf[10] = &#123;0&#125;; fun(buf); system(\"pause\"); return 0;&#125; 输出： 12345678910111213void fun(char **s) &#123; char *tmp = malloc(sizeof(char) * 100); strcpy(tmp, \"abcdefg\"); *s = tmp;&#125;int main(int argc, char **argv) &#123; char *p = NULL; fun(&amp;p); printf(\"%s\", p); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"63.0、数组作为实参","slug":"C/63.0、数组作为实参","date":"2012-11-13T02:43:05.000Z","updated":"2020-08-07T14:10:11.671Z","comments":true,"path":"2012/11/13/C/63.0、数组作为实参/","link":"","permalink":"https://www.zackaddy.xin/2012/11/13/C/63.0、数组作为实参/","excerpt":"","text":"数组作为实参传入函数，数组形参实为指针12345678910void say(char p[]) &#123; printf(\"%d\", sizeof s / sizeof *s); //此时不是数组的长度，sizeof s为4 //sizeof *s为1&#125;int main(int argc, char **char) &#123; char buf[] = \"xxxxxxx\"; say(buf); returnn 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"62.0、头文件声明说明","slug":"C/62.0、头文件声明说明","date":"2012-11-12T04:58:59.000Z","updated":"2020-08-07T14:10:11.671Z","comments":true,"path":"2012/11/12/C/62.0、头文件声明说明/","link":"","permalink":"https://www.zackaddy.xin/2012/11/12/C/62.0、头文件声明说明/","excerpt":"","text":"123456789101112131415161718192021222324252627//防止头文件重复包含#pragma once//兼容c++编译器//如果是c++编译器，按c标准编译#ifdef __cplusplusextern \"C\"&#123;#endif//内容... 事例如下 //初始化socket客户端 int socketclient_init(void **handle); //发送信息 int socketclient_send(void *handle, char *buf, int len); //接受信息 int socketclient_recv(void *handle, char *buf, int *len); //释放资源 int socketclient_destory(void *handle);#ifdef __cplusplus&#125;#endif","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"61.0、fflush刷新缓冲区","slug":"C/61.0、fflush刷新缓冲区","date":"2012-11-11T02:45:12.000Z","updated":"2020-08-07T14:10:11.671Z","comments":true,"path":"2012/11/11/C/61.0、fflush刷新缓冲区/","link":"","permalink":"https://www.zackaddy.xin/2012/11/11/C/61.0、fflush刷新缓冲区/","excerpt":"","text":"fflushint fflush(FILE *stream)刷新流 stream 的输出缓冲区。 1234567891011121314151617181920212223242526272829#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Student &#123; int age; char name[100];&#125; Student;int main()&#123; char buff[1024]; memset(buff, '\\0', sizeof(buff)); fprintf(stdout, \"启用全缓冲\\n\"); setvbuf(stdout, buff, _IOFBF, 1024); fprintf(stdout, \"这里是xxx\\n\"); fprintf(stdout, \"该输出将保存到 buff\\n\"); fflush(stdout); fprintf(stdout, \"你是看不到我的\\n\"); system(\"pause\"); return(0);&#125; 123启用全缓冲这里是xxx该输出将保存到 buff","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"60.0、光标操作","slug":"C/60.0、光标操作","date":"2012-11-09T20:48:01.000Z","updated":"2020-08-07T14:10:11.670Z","comments":true,"path":"2012/11/10/C/60.0、光标操作/","link":"","permalink":"https://www.zackaddy.xin/2012/11/10/C/60.0、光标操作/","excerpt":"","text":"光标操作 fseekint fseek(FILE *stream, long int offset, int whence) stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。 offset – 这是相对 whence 的偏移量，以字节为单位。 whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一： SEEK_SET 文件的开头 SEEK_CUR 文件指针的当前位置 SEEK_END 文件的末尾 如果成功，则该函数返回零，否则返回非零值。 123456789101112131415#include &lt;stdio.h&gt;int main ()&#123; FILE *fp; fp = fopen(\"file.txt\",\"w+\"); fputs(\"This is runoob.com\", fp); fseek( fp, 7, SEEK_SET ); fputs(\" C Programming Langauge\", fp); fclose(fp); return(0);&#125; 1This is C Programming Langauge ftelllong int ftell(FILE *stream)返回给定流 stream 的当前文件光标位置。 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main ()&#123; FILE *fp; int len; fp = fopen(\"file.txt\", \"r\"); if( fp == NULL ) &#123; perror (\"打开文件错误\"); return(-1); &#125; fseek(fp, 0, SEEK_END); len = ftell(fp); fclose(fp); printf(\"file.txt 的总大小 = %d 字节\\n\", len); return(0);&#125; rewind()void rewind(FILE *stream)设置文件位置为给定流 stream 的文件的开头。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int main()&#123; char str[] = \"This is runoob.com\"; FILE *fp; int ch; /* 首先让我们在文件中写入一些内容 */ fp = fopen( \"file.txt\" , \"w\" ); fwrite(str , 1 , sizeof(str) , fp ); fclose(fp); fp = fopen( \"file.txt\" , \"r\" ); while(1) &#123; ch = fgetc(fp); if( feof(fp) ) &#123; break ; &#125; printf(\"%c\", ch); &#125; rewind(fp); printf(\"\\n\"); while(1) &#123; ch = fgetc(fp); if( feof(fp) ) &#123; break ; &#125; printf(\"%c\", ch); &#125; fclose(fp); return(0);&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"59.0、fread、fwrite","slug":"C/59.0、fread、fwrite","date":"2012-11-09T03:29:03.000Z","updated":"2020-08-07T14:10:11.670Z","comments":true,"path":"2012/11/09/C/59.0、fread、fwrite/","link":"","permalink":"https://www.zackaddy.xin/2012/11/09/C/59.0、fread、fwrite/","excerpt":"","text":"fread size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) ptr – 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。 size – 这是要读取的每个元素的大小，以字节为单位。 nmemb – 这是元素的个数，每个元素的大小为 size 字节。 stream – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。 成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main()&#123; FILE *fp; char c[] = \"This is runoob\"; char buffer[20]; /* 打开文件用于读写 */ fp = fopen(\"file.txt\", \"w+\"); /* 写入数据到文件 */ fwrite(c, strlen(c) + 1, 1, fp); /* 查找文件的开头 */ fseek(fp, SEEK_SET, 0); /* 读取并显示数据 */ fread(buffer, strlen(c)+1, 1, fp); printf(\"%s\\n\", buffer); fclose(fp); return(0);&#125; fwrite() size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) 1234567891011121314#include&lt;stdio.h&gt; int main ()&#123; FILE *fp; char str[] = \"This is runoob.com\"; fp = fopen( \"file.txt\" , \"w\" ); fwrite(str, sizeof(str) , 1, fp ); fclose(fp); return(0);&#125; 将结构体写入文件1234567891011121314151617181920212223242526272829303132#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Student &#123; int age; char name[100];&#125; Student;int main()&#123; Student ss[2] = &#123; 12, \"hh\", 26, \"bb\" &#125;; Student dd[10]; FILE *fp; /* 打开文件用于读写 */ fp = fopen(\"file.txt\", \"rb\");//读取时需要以二进制读 //fwrite(&amp;ss, sizeof(Student), 2, fp); fread(&amp;dd[0], sizeof(Student), 2, fp); for (int i = 0; i &lt; 2; i++) &#123; printf(\"name:%s,age:%d\\n\", dd[i].name, dd[i].age); &#125; fclose(fp); system(\"pause\"); return(0);&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"58.0、时间与格式化","slug":"C/58.0、时间与格式化","date":"2012-11-07T22:15:26.000Z","updated":"2020-08-07T14:10:11.670Z","comments":true,"path":"2012/11/08/C/58.0、时间与格式化/","link":"","permalink":"https://www.zackaddy.xin/2012/11/08/C/58.0、时间与格式化/","excerpt":"","text":"tm结构体 1234567891011struct tm &#123; int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月份，范围从 0 到 11 */ int tm_year; /* 自 1900 起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ &#125;; localtime取得本地的tm结构体用strftime格式化当前日期123456789101112131415161718192021#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;int main(int argc, char** argv) &#123; time_t rawtime; struct tm * timeinfo; char buffer[128]; time(&amp;rawtime); printf(\"%ld\\n\", rawtime); timeinfo = localtime(&amp;rawtime); strftime(buffer, sizeof(buffer), \"Now is %Y/%m/%d %H:%M:%S\", timeinfo); printf(\"%s\\n\", buffer); system(\"pause\"); return 0;&#125; strftime格式化说明2. gmtime取得UTC的tm结构体手动取得年月日 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;time.h&gt;#define BST (+1)#define CCT (+8)int main ()&#123; time_t rawtime; struct tm *info; time(&amp;rawtime); /* 获取 GMT 时间 */ info = gmtime(&amp;rawtime ); printf(\"当前的世界时钟：\\n\"); printf(\"伦敦：%2d:%02d\\n\", (info-&gt;tm_hour+BST)%24, info-&gt;tm_min); printf(\"中国：%2d:%02d\\n\", (info-&gt;tm_hour+CCT)%24, info-&gt;tm_min); return(0);&#125; windows下字符串转时间戳 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; long GetTick(char *str_time) &#123; struct tm stm; int iY, iM, iD, iH, iMin, iS; memset(&amp;stm,0,sizeof(stm)); iY = atoi(str_time); iM = atoi(str_time+5); iD = atoi(str_time+8); iH = atoi(str_time+11); iMin = atoi(str_time+14); iS = atoi(str_time+17); stm.tm_year=iY-1900; stm.tm_mon=iM-1; stm.tm_mday=iD; stm.tm_hour=iH; stm.tm_min=iMin; stm.tm_sec=iS; /*printf(\"%d-%0d-%0d %0d:%0d:%0d\\n\", iY, iM, iD, iH, iMin, iS);*/ return mktime(&amp;stm); &#125; int main() &#123; char str_time[19]; printf(\"请输入时间:\"); /*(格式:2011-12-31 11:43:07)*/ gets(str_time); printf(\"%ld\\n\", GetTick(str_time)); return 0; &#125; unix 下字符串转时间戳 123456789101112#include &lt;stdio.h&gt; #include &lt;time.h&gt; int main(int argc, const char * argv[]) &#123; struct tm* tmp_time = (struct tm*)malloc(sizeof(struct tm)); strptime(\"20131120\",\"%Y%m%d\",tmp_time); time_t t = mktime(tmp_time); printf(\"%ld\\n\",t); free(tmp_time); return 0; &#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"57.0、stat()函数：获取文件状态","slug":"C/57.0、stat()函数：获取文件状态","date":"2012-11-07T01:48:23.000Z","updated":"2020-08-07T14:10:11.670Z","comments":true,"path":"2012/11/07/C/57.0、stat()函数：获取文件状态/","link":"","permalink":"https://www.zackaddy.xin/2012/11/07/C/57.0、stat()函数：获取文件状态/","excerpt":"","text":"stat()函数：获取文件状态相关函数：fstat, lstat, chmod, chown, readlink, utime 头文件：#include&lt;sys/stat.h&gt; #include&lt;uninstd.h&gt; 定义函数：int stat(const char * file_name, struct stat *buf); 函数说明：stat()用来将参数file_name 所指的文件状态, 复制到参数buf 所指的结构中。 下面是struct stat 内各参数的说明： 123456789101112131415struct stat &#123; dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. u nsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、 utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、 utime 和write 时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新 &#125;; 先前所描述的st_mode 则定义了下列数种情况： 12345678910111213141516171819202122232425261、S_IFMT 0170000 文件类型的位遮罩 2、S_IFSOCK 0140000 scoket3、S_IFLNK 0120000 符号连接 4、S_IFREG 0100000 一般文件 5、S_IFBLK 0060000 区块装置 6、S_IFDIR 0040000 目录 7、S_IFCHR 0020000 字符装置 8、S_IFIFO 0010000 先进先出 9、S_ISUID 04000 文件的 (set user-id on execution)位 10、S_ISGID 02000 文件的 (set group-id on execution)位 11、S_ISVTX 01000 文件的sticky 位 12、S_IRUSR (S_IREAD) 00400 文件所有者具可读取权限 13、S_IWUSR (S_IWRITE)00200 文件所有者具可写入权限 14、S_IXUSR (S_IEXEC) 00100 文件所有者具可执行权限 15、S_IRGRP 00040 用户组具可读取权限 16、S_IWGRP 00020 用户组具可写入权限 17、S_IXGRP 00010 用户组具可执行权限 18、S_IROTH 00004 其他用户具可读取权限 19、S_IWOTH 00002 其他用户具可写入权限 20、S_IXOTH 00001 其他用户具可执行权限上述的文件类型在 POSIX 中定义了检查这些类型的宏定义 21、S_ISLNK (st_mode) 判断是否为符号连接 22、S_ISREG (st_mode) 是否为一般文件 23、S_ISDIR (st_mode) 是否为目录 24、S_ISCHR (st_mode) 是否为字符装置文件 25、S_ISBLK (s3e) 是否为先进先出 26、S_ISSOCK (st_mode) 是否为socket 若一目录具有sticky 位 (S_ISVTX), 则表示在此目录下的文件只能 被该文件所有者、此目录所有者或root 来删除或改名. 返回值：执行成功则返回0，失败返回-1，错误代码存于errno。 错误代码： 12345671、ENOENT 参数file_name 指定的文件不存在 2、ENOTDIR 路径中的目录存在但却非真正的目录 3、ELOOP 欲打开的文件有过多符号连接问题, 上限为16 符号连接 4、EFAULT 参数buf 为无效指针, 指向无法存在的内存空间 5、EACCESS 存取文件时被拒绝 6、ENOMEM 核心内存不足 7、ENAMETOOLONG 参数file_name 的路径名称太长 范例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;time.h&gt;int mfstat(const char* filename) &#123; /*struct stat &#123; _dev_t st_dev; _ino_t st_ino; unsigned short st_mode; short st_nlink; short st_uid; short st_gid; _dev_t st_rdev; _off_t st_size; time_t st_atime; time_t st_mtime; time_t st_ctime; &#125;;*/ struct stat buf; int state = stat(filename, &amp;buf); if (-1 == state) &#123; perror(\"stat\"); return -1; &#125; char s[100]; printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file device num: %d\\n\", buf.st_dev); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file inode num: %d\\n\", buf.st_ino); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file mode num: %p\\n\", buf.st_mode); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file link num: %d\\n\", buf.st_nlink); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file uid num: %d\\n\", buf.st_uid); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file gid num: %d\\n\", buf.st_gid); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file rdev num: %d\\n\", buf.st_rdev); printf(\"--------------------------------------------------------------------------------\\n\"); printf(\"file size num: %dBytes\\n\", buf.st_size); printf(\"--------------------------------------------------------------------------------\\n\"); strftime(s, sizeof(s), \"%Y/%m/%d %H:%M:%S\", localtime(&amp;buf.st_atime)); printf(\"file atime num: %s\\n\", s); printf(\"—%s\\n\", \"文件最近一次被存取或被执行的时间mknod、 utime、read、write 与tructate\"); printf(\"--------------------------------------------------------------------------------\\n\"); strftime(s, sizeof(s), \"%Y/%m/%d %H:%M:%S\", localtime(&amp;buf.st_mtime)); printf(\"file mtime num: %s\\n\", s); printf(\"—%s\\n\", \"文件最后一次被修改的时间, mknod、 utime 、write \"); printf(\"--------------------------------------------------------------------------------\\n\"); strftime(s, sizeof(s), \"%Y/%m/%d %H:%M:%S\", localtime(&amp;buf.st_ctime)); printf(\"file ctime num: %s\\n\", s); printf(\"—%s\\n\", \"最近一次被更改的时间, 此参数会在文件所有者、组、 权限被更改时更新 \"); printf(\"--------------------------------------------------------------------------------\\n\"); return 0;&#125;int main(int argc, char** argv) &#123; mfstat(\"123.txt\"); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"56.0、getc和putc函数","slug":"C/56.0、getc和putc函数","date":"2012-11-05T19:35:15.000Z","updated":"2020-08-07T14:10:11.669Z","comments":true,"path":"2012/11/06/C/56.0、getc和putc函数/","link":"","permalink":"https://www.zackaddy.xin/2012/11/06/C/56.0、getc和putc函数/","excerpt":"","text":"getc和putc函数int getc(FILE *stream); getc的参数是fopen成功打开文件后返回的指针，getc的返回值是一个char getc的功能是以字节位单位读取文件内容 文本文件的最后结束标示是-1，也就是一个宏EOF #define EOF -1 int putc(int c, FILE *stream); 第一个参数是要写入的char，第二个参数是fopen返回的文件指针 读 1234567891011int main()&#123; FILE *fp = fopen(\"a.txt\", \"r\"); char c; while ((c = getc(fp)) != EOF) &#123; printf(\"%c\", c); &#125; fclose(fp); return 0;&#125; 写 123456789101112int main()&#123; FILE *fp = fopen(\"a.txt\", \"w\"); const char *s = \"hello world\"; int i; for (i = 0; i &lt; strlen(s); i++) &#123; putc(s[i], fp); &#125; fclose(fp); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"55.0、fopen","slug":"C/55.0、fopen","date":"2012-11-04T23:36:30.000Z","updated":"2020-08-07T14:10:11.669Z","comments":true,"path":"2012/11/05/C/55.0、fopen/","link":"","permalink":"https://www.zackaddy.xin/2012/11/05/C/55.0、fopen/","excerpt":"","text":"fopenFILE *fopen(const char *path, const char *mode); Fopen打开文件成功，返回有效FILE的有效地址，失败返回NULL Path就是指定打开文件的路径，可以是相对路径，也可以是绝对路径，mode有以下几个值： r 以只读方式打开文件，该文件必须存在，文件必须是可读的。 r+ 以可读写方式打开文件，该文件必须存在。 rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。 w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留） a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"54.0、fscanf","slug":"C/54.0、fscanf","date":"2012-11-03T17:22:34.000Z","updated":"2020-08-07T14:10:11.669Z","comments":true,"path":"2012/11/04/C/54.0、fscanf/","link":"","permalink":"https://www.zackaddy.xin/2012/11/04/C/54.0、fscanf/","excerpt":"","text":"int fscanf(FILE *stream, const char *format, …)返回值如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char str1[10], str2[10], str3[10]; int year; FILE * fp; fp = fopen (\"file.txt\", \"w+\"); fputs(\"We are in 2014\", fp); rewind(fp); fscanf(fp, \"%s %s %s %d\", str1, str2, str3, &amp;year); printf(\"Read String1 |%s|\\n\", str1 ); printf(\"Read String2 |%s|\\n\", str2 ); printf(\"Read String3 |%s|\\n\", str3 ); printf(\"Read Integer |%d|\\n\", year ); fclose(fp); return(0);&#125; 1234Read String1 |We|Read String2 |are|Read String3 |in|Read Integer |2014|","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"53.0、fprintf","slug":"C/53.0、fprintf","date":"2012-11-02T22:37:00.000Z","updated":"2020-08-07T14:10:11.669Z","comments":true,"path":"2012/11/03/C/53.0、fprintf/","link":"","permalink":"https://www.zackaddy.xin/2012/11/03/C/53.0、fprintf/","excerpt":"","text":"int fprintf(FILE *stream, const char *format, …) 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; FILE * fp; fp = fopen (\"file.txt\", \"w+\"); fprintf(fp, \"%s %s %s %d\", \"We\", \"are\", \"in\", 2014); fclose(fp); return(0);&#125; 1We are in 2014","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"52.0、EOF feof()文件结尾判断","slug":"C/52.0、EOF feof()文件结尾判断","date":"2012-11-01T20:34:16.000Z","updated":"2020-08-07T14:10:11.669Z","comments":true,"path":"2012/11/02/C/52.0、EOF feof()文件结尾判断/","link":"","permalink":"https://www.zackaddy.xin/2012/11/02/C/52.0、EOF feof()文件结尾判断/","excerpt":"","text":"文本文件，通过-1（EOF）判断 二进制文件，不能通过-1（EOF）判断 feof()判断文件结尾，任何文件都能判断 1234FILE *fp;if (feof(fp) &#123; break;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"51.0、typedef","slug":"C/51.0、typedef","date":"2012-10-31T23:08:21.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/11/01/C/51.0、typedef/","link":"","permalink":"https://www.zackaddy.xin/2012/11/01/C/51.0、typedef/","excerpt":"","text":"给类型起别名 不能创建一个新的类型12345678910111213typedef struct Student &#123; int age;&#125; Student;typedef struct Student size_s;int main(int argc, char* argv[]) &#123; Student d = &#123; 19 &#125;; size_s a = &#123; 18 &#125;; printf(\"%d\", a.age); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"50.0、枚举","slug":"C/50.0、枚举","date":"2012-10-30T22:50:28.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/10/31/C/50.0、枚举/","link":"","permalink":"https://www.zackaddy.xin/2012/10/31/C/50.0、枚举/","excerpt":"","text":"123456789101112enum Color&#123; red = 5, pink = 8, orange&#125;;int main(int argc, char* argv[]) &#123; printf(\"%d\", red);//5 enum Color c; c = pink; printf(\"%d\", c);//8 printf(\"%d\", orange);//9 system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"49.0、共用体（联合体）","slug":"C/49.0、共用体（联合体）","date":"2012-10-30T04:34:06.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/10/30/C/49.0、共用体（联合体）/","link":"","permalink":"https://www.zackaddy.xin/2012/10/30/C/49.0、共用体（联合体）/","excerpt":"","text":"公用一块内存地址1234567891011union Test &#123; int a; char b;&#125;;int main(int argc, char* argv[]) &#123; union Test t; t.a = 0x22334455; printf(\"%p, %p\", t.a, t.b);//0x22334455 0x00000055 system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"48.0、结构体","slug":"C/48.0、结构体","date":"2012-10-28T21:37:58.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/10/29/C/48.0、结构体/","link":"","permalink":"https://www.zackaddy.xin/2012/10/29/C/48.0、结构体/","excerpt":"","text":"定义12345678910struct Student &#123; int age;&#125;;struct Student s = &#123;59&#125;;s.age = 19;struct Student *p = &amp;s;p-&gt;age = 18;(*p).age = 18;p[0].age = 18; 1234struct Student &#123; int age;&#125; stu = &#123;50&#125;, *p = &amp;stu;//非常不推荐 stu = &#123;50&#125;, *p = &amp;stu 123struct &#123; int age;&#125; stu; 赋值123456789struct Student&#123; char name[50]; int age;&#125; stu = &#123;\"herghost\", 28&#125;, *p = &amp;stu;int main(int argc, char** argv) &#123; struct Student s = stu; //不可以 system(\"pause\"); return 0;&#125; 12345678910struct Student&#123; char name[50]; int age;&#125; stu = &#123;\"herghost\", 28&#125;, *p = &amp;stu;int main(int argc, char** argv) &#123; struct Student s1 = &#123;\"aa\", 20&#125;; struct Student s2 = s1; //可以，这样赋值与普通变量赋值一样，赋的是值不是地址 system(\"pause\"); return 0;&#125; 12345678910struct Student&#123; char name[50]; int age;&#125; stu = &#123;\"hh\", 20&#125;;int main(int argc, char** argv) &#123; struct Student s1; s1 = &#123; \"aa\", 20 &#125;; //不可以 system(\"pause\"); return 0;&#125; 123456789struct Student&#123; char name[50]; int age;&#125; stu = &#123;\"hh\", 20&#125;;int main(int argc, char** argv) &#123; struct Student s1 = &#123; \"aa\", 20 &#125;;//可以 system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"47.0、malloc分配内存空间","slug":"C/47.0、malloc分配内存空间","date":"2012-10-27T20:07:45.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/10/28/C/47.0、malloc分配内存空间/","link":"","permalink":"https://www.zackaddy.xin/2012/10/28/C/47.0、malloc分配内存空间/","excerpt":"","text":"void *malloc(size_t size) size – 内存块的大小，以字节为单位。12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char *str; /* 最初的内存分配 */ str = (char *) malloc(15); strcpy(str, \"runoob\"); printf(\"String = %s, Address = %u\\n\", str, str); /* 重新分配内存 */ str = (char *) realloc(str, 25); strcat(str, \".com\"); printf(\"String = %s, Address = %u\\n\", str, str); free(str); return(0);&#125; 12String = runoob, Address = 3662685808String = runoob.com, Address = 3662685808","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"46.0、memcmp内存元素比较大小","slug":"C/46.0、memcmp内存元素比较大小","date":"2012-10-26T16:38:06.000Z","updated":"2020-08-07T14:10:11.667Z","comments":true,"path":"2012/10/27/C/46.0、memcmp内存元素比较大小/","link":"","permalink":"https://www.zackaddy.xin/2012/10/27/C/46.0、memcmp内存元素比较大小/","excerpt":"","text":"12345678910int a[2] = &#123;1,2&#125;;int b[2] = &#123;2,2&#125;;int flag = memcmp(a, b, sizeof(int) * 10);if (flag &lt; 0) &#123; //a &lt; b&#125; else if (flag &gt; 0) &#123; //a &gt; b&#125; else &#123; //a == b&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"45.0、memmove防止memcpy内存重叠","slug":"C/45.0、memmove防止memcpy内存重叠","date":"2012-10-25T19:35:09.000Z","updated":"2020-08-07T14:10:11.667Z","comments":true,"path":"2012/10/26/C/45.0、memmove防止memcpy内存重叠/","link":"","permalink":"https://www.zackaddy.xin/2012/10/26/C/45.0、memmove防止memcpy内存重叠/","excerpt":"","text":"12345int a[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;memcpy(&amp;a[2], a, sizeof(a)) // 产生内存重叠使用下面的memmovememmove(&amp;a[2], a, sizeof(a))","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"44.0、memcpy赋值","slug":"C/44.0、memcpy赋值","date":"2012-10-24T23:24:35.000Z","updated":"2020-08-07T14:10:11.667Z","comments":true,"path":"2012/10/25/C/44.0、memcpy赋值/","link":"","permalink":"https://www.zackaddy.xin/2012/10/25/C/44.0、memcpy赋值/","excerpt":"","text":"123456789int main(int argc, char** argv) &#123; char p[] = \"hello\"; char buffer[100]; memcpy(buffer, p, sizeof(p)); printf(\"%s\", buffer); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"43.0、memset内存空间初始化","slug":"C/43.0、memset内存空间初始化","date":"2012-10-23T19:49:59.000Z","updated":"2020-08-07T14:10:11.667Z","comments":true,"path":"2012/10/24/C/43.0、memset内存空间初始化/","link":"","permalink":"https://www.zackaddy.xin/2012/10/24/C/43.0、memset内存空间初始化/","excerpt":"","text":"功能：将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作。 用法：void *memset(void *s, char ch, unsigned n); 程序： 123456789101112#include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;memory.h&gt; int main(void) &#123; char buffer[] = \"Hello world/n\"; printf(\"Buffer before memset: %s/n\", buffer); memset(buffer, '*', strlen(buffer) ); printf(\"Buffer after memset: %s/n\", buffer); return 0; &#125; 输出结果： Buffer before memset: Hello world Buffer after memset: ***","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"42.0、内存分区介绍","slug":"C/42.0、内存分区介绍","date":"2012-10-22T18:34:22.000Z","updated":"2020-08-07T14:10:11.667Z","comments":true,"path":"2012/10/23/C/42.0、内存分区介绍/","link":"","permalink":"https://www.zackaddy.xin/2012/10/23/C/42.0、内存分区介绍/","excerpt":"","text":"在程序没有执行前，有几个内存分区已经确定，分区虽然确定，但未加载到内存，程序运行时才会加载到内存 text（代码区）：只读，函数 data（全局初始化数据区/静态数据区）：初始化数据，全局变量，static变量，文字常量区（只读） bss（未初始化数据区）：未初始化的数据，全局变量，static变量 程序运行额外加载2个区 stack（桟区）：函数参数，返回地址，调用上下文、普通局部变量，自动管理内存 heap（堆区）：手动申请内存，手动释放，整个程序结束系统自动回收 程序可执行代码存放于.text 段 静态存储区通常指程序中的.bss 和.data 段 动态空间为堆中的空间 局部变量所占空间为栈上的空间 桟区递减，桟区数组递增 堆区递增，堆区数组递增","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"41.0、作用域、生命周期总结","slug":"C/41.0、作用域、生命周期总结","date":"2012-10-22T01:14:11.000Z","updated":"2020-08-07T14:10:11.666Z","comments":true,"path":"2012/10/22/C/41.0、作用域、生命周期总结/","link":"","permalink":"https://www.zackaddy.xin/2012/10/22/C/41.0、作用域、生命周期总结/","excerpt":"","text":"类型 作用域 生命周期 auto变量 一对｛｝内 当前函数 static局部变量 一对｛｝内 整个程序运行期 extern变量 整个程序 整个程序运行期 static全局变量 当前文件 整个程序运行期 extern函数 整个程序 整个程序运行期 static 函数 当前文件 整个程序运行期 register变量 一对｛｝内 当前函数","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"40.0、全局变量","slug":"C/40.0、全局变量","date":"2012-10-20T17:15:38.000Z","updated":"2020-08-07T14:10:11.666Z","comments":true,"path":"2012/10/21/C/40.0、全局变量/","link":"","permalink":"https://www.zackaddy.xin/2012/10/21/C/40.0、全局变量/","excerpt":"","text":"普通全局变量 全局变量不初始化，默认值为0 在函数外定义的变量为全局变量 可以定义多次，可以声明多次 程序运行就分配空间 不同文件只能定义一次，可以声明多次","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"39.0、static修饰符","slug":"C/39.0、static修饰符","date":"2012-10-19T18:30:09.000Z","updated":"2020-08-07T14:10:11.666Z","comments":true,"path":"2012/10/20/C/39.0、static修饰符/","link":"","permalink":"https://www.zackaddy.xin/2012/10/20/C/39.0、static修饰符/","excerpt":"","text":"static 局部变量 在｛｝内部定义的变量就是局部变量 static局部变量，在函数没被调用前就分配空间了，程序结束才会释放 局部变量作用在｛｝，离开｛｝无法使用此变量 如果static局部变量不初始化，值默认0 static局部变量初始化只会执行一次，但可以多次赋值1234567891011void say() &#123; static int i = 0; i++; printf(\"%d\\n\", i);&#125;int main() &#123; say(); say(); say(); return 0;&#125; static 静态全局变量 文件作用域","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"38.0、去除字符串首位空格","slug":"C/38.0、去除字符串首位空格","date":"2012-10-18T23:16:45.000Z","updated":"2020-08-07T14:10:11.665Z","comments":true,"path":"2012/10/19/C/38.0、去除字符串首位空格/","link":"","permalink":"https://www.zackaddy.xin/2012/10/19/C/38.0、去除字符串首位空格/","excerpt":"","text":"12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;memory.h&gt; char* strtrim(char *dest, const char *src) &#123; char *start = src; char *end = src + strlen(src) - 1; int src_strlen = 0; while (*start == ' ' &amp;&amp; *start != '\\0') &#123; start++; &#125; while (*end == ' ' &amp;&amp; end != src) &#123; end--; &#125; src_strlen = end - start + 1; strncpy_s(dest, src_strlen+1, start, src_strlen); dest[src_strlen] = 0; return dest;&#125;int main(int argc, char** argv) &#123; char *src = \" hello world \"; char dest[100]; printf(\"%s\\n\", strtrim(dest, src)); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"37.0、统计字符字符串出现次数","slug":"C/37.0、统计字符字符串出现次数","date":"2012-10-17T18:48:41.000Z","updated":"2020-08-07T14:10:11.665Z","comments":true,"path":"2012/10/18/C/37.0、统计字符字符串出现次数/","link":"","permalink":"https://www.zackaddy.xin/2012/10/18/C/37.0、统计字符字符串出现次数/","excerpt":"","text":"123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int strcount(const char *src, const char * const dest) &#123; char *tmp = NULL; int i = 0; while (1) &#123; tmp = strstr(src, dest); if (NULL != tmp &amp;&amp; ++i) &#123; src = tmp + strlen(dest); &#125; else &#123; break; &#125; &#125; return i;&#125;int main(int argc, char** argv) &#123; char *src = \"hello world\"; char *dest = \"ll\"; printf(\"%d\\n\", strcount(src, dest)); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"36.0、main形参","slug":"C/36.0、main形参","date":"2012-10-16T22:13:05.000Z","updated":"2020-08-07T14:10:11.665Z","comments":true,"path":"2012/10/17/C/36.0、main形参/","link":"","permalink":"https://www.zackaddy.xin/2012/10/17/C/36.0、main形参/","excerpt":"","text":"cmd: xx.exe hello world 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void s(char** argv) &#123; printf(\"%s\", *argv);&#125;int main(int argc, char** argv) &#123; //printf(\"%d\\n\", argc); 参数个数 //printf(\"%s\\n\", *(argv+1)); hello char *p[] = &#123; \"hello world\", \"xxx\" &#125;; s(p); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"35.0、strcpy字符串复制","slug":"C/35.0、strcpy字符串复制","date":"2012-10-16T03:11:17.000Z","updated":"2020-08-07T14:10:11.665Z","comments":true,"path":"2012/10/16/C/35.0、strcpy字符串复制/","link":"","permalink":"https://www.zackaddy.xin/2012/10/16/C/35.0、strcpy字符串复制/","excerpt":"","text":"char *strcpy(char *dest, const char *src) 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char src[40]; char dest[100]; memset(dest, '\\0', sizeof(dest)); strcpy(src, \"This is runoob.com\"); strcpy(dest, src); printf(\"最终的目标字符串： %s\\n\", dest); return(0);&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"34.0、文字常量","slug":"C/34.0、文字常量","date":"2012-10-15T04:18:36.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/10/15/C/34.0、文字常量/","link":"","permalink":"https://www.zackaddy.xin/2012/10/15/C/34.0、文字常量/","excerpt":"","text":"12char* p = \"hello world\";//p指向文字常量区，不能修改char p[] = \"hello world\";//可以为修改","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"33.0、数组时&p与p相同的疑问","slug":"C/33.0、数组时&p与p相同的疑问","date":"2012-10-13T17:04:20.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/10/14/C/33.0、数组时&p与p相同的疑问/","link":"","permalink":"https://www.zackaddy.xin/2012/10/14/C/33.0、数组时&p与p相同的疑问/","excerpt":"","text":"123int p[] = &#123; 8,10,6 &#125;;printf(\"%p,%p\", p, &amp;p); //相同//注意，虽然相同但代表的意义不同 p 的值是数组内首元素的地址 &amp;p ==比较特殊，代表的不是自身所在地址==，代表的是整个int型数组首地址","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"32.0、数组的指针表达 解惑","slug":"C/32.0、数组的指针表达 解惑","date":"2012-10-13T00:45:41.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/10/13/C/32.0、数组的指针表达 解惑/","link":"","permalink":"https://www.zackaddy.xin/2012/10/13/C/32.0、数组的指针表达 解惑/","excerpt":"","text":"==int **p 与int *p[]不一样== 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"people.h\"#define MAX(a, b) a&gt;b?a:b int main(int argc, char** argv) &#123; int a[] = &#123;101,105&#125;; int b[] = &#123;202,303&#125;; //int * p2[] = &#123; a,b &#125;; //printf(\"%d\", **p2); 101 //int * p2 = &#123; a &#125;;//&#123;a&#125;相当于int * p2 = a; //printf(\"%d\", *p2); 101 //int ** p2 = &#123; a &#125;;//&#123;a&#125;相当于int ** p2 = a; //printf(\"%d\", *p2); 101 system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"31.0、判断数组长度","slug":"C/31.0、判断数组长度","date":"2012-10-11T19:44:45.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/10/12/C/31.0、判断数组长度/","link":"","permalink":"https://www.zackaddy.xin/2012/10/12/C/31.0、判断数组长度/","excerpt":"","text":"1int len = sizeof a / sizeof *a;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"30.0、指针与数组","slug":"C/30.0、指针与数组","date":"2012-10-10T20:52:56.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/10/11/C/30.0、指针与数组/","link":"","permalink":"https://www.zackaddy.xin/2012/10/11/C/30.0、指针与数组/","excerpt":"","text":"1234int a[10];a = 1; //error 类似于int * const pprintf(\"%p\", a, &amp;a[0])","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"29.0、const修饰指针变量","slug":"C/29.0、const修饰指针变量","date":"2012-10-09T18:41:22.000Z","updated":"2020-08-07T14:10:11.663Z","comments":true,"path":"2012/10/10/C/29.0、const修饰指针变量/","link":"","permalink":"https://www.zackaddy.xin/2012/10/10/C/29.0、const修饰指针变量/","excerpt":"","text":"const int *p int const *p 以上const修饰的是*p *p值不能被修改123int a = 10;const int* p = &amp;a;*p = 20; //错误的 1234int a = 10;int* p1 = &amp;a;const int** p = &amp;p1;**p = 20;//错误的 int * const p 以上修饰的是p p所存地址不能被修改","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"28.0、野指针 空指针 指针大小","slug":"C/28.0、野指针 空指针 指针大小","date":"2012-10-08T21:47:35.000Z","updated":"2020-08-07T14:10:11.663Z","comments":true,"path":"2012/10/09/C/28.0、野指针 空指针 指针大小/","link":"","permalink":"https://www.zackaddy.xin/2012/10/09/C/28.0、野指针 空指针 指针大小/","excerpt":"","text":"1234567野指针：这个指针类型的变量保存了一个没有意义的地址int main(int argc, char** argv) &#123; int* p; //系统分配的指针地址 *p = 100; return 0;&#125; 12空指针：指针地址为0int* p = NULL //自己分配的空指针地址 12//32位编译器用32位大小（4字节）保存地址//64位编译器用64位大小（8字节）保存地址","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"27.0、头文件包含一次声明","slug":"C/27.0、头文件包含一次声明","date":"2012-10-07T22:55:11.000Z","updated":"2020-08-07T14:10:11.663Z","comments":true,"path":"2012/10/08/C/27.0、头文件包含一次声明/","link":"","permalink":"https://www.zackaddy.xin/2012/10/08/C/27.0、头文件包含一次声明/","excerpt":"","text":"第一种 123456#ifndef _MY_H#define _MY_H#endif 第二种 1#pragma once","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"26.0、extern","slug":"C/26.0、extern","date":"2012-10-06T16:48:25.000Z","updated":"2020-08-07T14:10:11.663Z","comments":true,"path":"2012/10/07/C/26.0、extern/","link":"","permalink":"https://www.zackaddy.xin/2012/10/07/C/26.0、extern/","excerpt":"","text":"extern声明的变量必须是全局变量 123456789101112main.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"people.h\"int main(int argc, char** argv) &#123; say(); printf(\"%s\", name); system(\"pause\"); return 0;&#125; 12345people.h#pragma onceextern void say();extern char name[100]; 123456789people.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;char name[100] = \"herghost\";void say() &#123; printf(\"%s\", \"xxx\");&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"25.0、atoi字符串转数字","slug":"C/25.0、atoi字符串转数字","date":"2012-10-05T21:43:01.000Z","updated":"2020-08-07T14:10:11.663Z","comments":true,"path":"2012/10/06/C/25.0、atoi字符串转数字/","link":"","permalink":"https://www.zackaddy.xin/2012/10/06/C/25.0、atoi字符串转数字/","excerpt":"","text":"遇到字符串立即结束返回NULL atoi字符串转为整形 atof字符串转为浮点型 atol字符串转为long型","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"24.0、strtok分割字符串","slug":"C/24.0、strtok分割字符串","date":"2012-10-04T22:02:32.000Z","updated":"2020-08-07T14:10:11.662Z","comments":true,"path":"2012/10/05/C/24.0、strtok分割字符串/","link":"","permalink":"https://www.zackaddy.xin/2012/10/05/C/24.0、strtok分割字符串/","excerpt":"","text":"1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//strtok会破坏原有结构int main(int argc, char** argv) &#123; char buf[] = \"aa,bb,cc,dd\"; char *next_token = NULL; char * p = strtok_s(buf, \",\", &amp;next_token); //调用strtok_s后 buf变为aa while (NULL != p) &#123; printf(\"%s\\n\", p); p = strtok_s(NULL, \",\", &amp;next_token); &#125; printf(\"%s\", buf); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"23.0、strstr strchr查询字符串字符地址","slug":"C/23.0、strstr strchr查询字符串字符地址","date":"2012-10-03T18:57:05.000Z","updated":"2020-08-07T14:10:11.662Z","comments":true,"path":"2012/10/04/C/23.0、strstr strchr查询字符串字符地址/","link":"","permalink":"https://www.zackaddy.xin/2012/10/04/C/23.0、strstr strchr查询字符串字符地址/","excerpt":"","text":"123char buf[] = \"hello world\";char *p = strstr(buf, \"or\");printf(\"%s\", p); 123char buf[] = \"hello world\";char *p = strchr(buf, \"o\");printf(\"%s\", p);","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"22.0、sscanf按指定格式赋值(拆包)","slug":"C/22.0、sscanf按指定格式赋值(拆包)","date":"2012-10-02T20:54:12.000Z","updated":"2020-08-07T14:10:11.662Z","comments":true,"path":"2012/10/03/C/22.0、sscanf按指定格式赋值(拆包)/","link":"","permalink":"https://www.zackaddy.xin/2012/10/03/C/22.0、sscanf按指定格式赋值(拆包)/","excerpt":"","text":"1234567int main() &#123; char buf[] = \"1 2 3\"; int a,b,c; sscanf(buf, \"%d %d %d\", &amp;a, &amp;b, &amp;c); printf(\"%s\", buf); return 0&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"21.0、sprintf格式化字符串到指定数组(组包)","slug":"C/21.0、sprintf格式化字符串到指定数组(组包)","date":"2012-10-01T19:47:04.000Z","updated":"2020-08-07T14:10:11.661Z","comments":true,"path":"2012/10/02/C/21.0、sprintf格式化字符串到指定数组(组包)/","link":"","permalink":"https://www.zackaddy.xin/2012/10/02/C/21.0、sprintf格式化字符串到指定数组(组包)/","excerpt":"","text":"int sprintf(char *str, const char *format, …) 1234567891011121314格式化用法与printf一样#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123; char str[80]; sprintf(str, \"Pi 的值 = %f\", M_PI); puts(str); return(0);&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"20.0、strcat字符串追加","slug":"C/20.0、strcat字符串追加","date":"2012-10-01T04:44:24.000Z","updated":"2020-08-07T14:10:11.661Z","comments":true,"path":"2012/10/01/C/20.0、strcat字符串追加/","link":"","permalink":"https://www.zackaddy.xin/2012/10/01/C/20.0、strcat字符串追加/","excerpt":"","text":"1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main ()&#123; char str[80]; strcpy (str,\"these \"); strcat (str,\"strings \"); strcat (str,\"are \"); strcat (str,\"concatenated.\"); puts (str); return 0;&#125;输出结果：these strings are concatenated.","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"19.0、strcmp字符串大小比较","slug":"C/19.0、strcmp字符串大小比较","date":"2012-09-29T23:33:43.000Z","updated":"2020-08-07T14:10:11.661Z","comments":true,"path":"2012/09/30/C/19.0、strcmp字符串大小比较/","link":"","permalink":"https://www.zackaddy.xin/2012/09/30/C/19.0、strcmp字符串大小比较/","excerpt":"","text":"1234567891011121314151617#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) &#123; char str_1[] = \"abc\"; char str_2[] = \"abc\"; char str_3[] = \"ABC\"; if (strcmp(str_1, str_2) == 0) printf(\"str_1 is equal to str_2. \\n\"); else printf(\"str_1 is not equal to str_2. \\n\"); if (strcmp(str_1, str_3) == 0) printf(\"str_1 is equal to str_3．\\n\"); else printf(\"str_1 is not equal to str_3．\\n\"); return 0; &#125; 123456789101112strcmp()函数有两个参数，即要比较的两个字符串。strcmp()函数对两个字符串进行大小写敏感的(case-sensitiVe)和字典式的(lexicographic)比较，并返回下列值之一：---------------------------------------------------- 返 回 值 意 义---------------------------------------------------- &lt;0 第一个字符串小于第二个字符串 =0 两个字符串相等 · &gt;0 第一个字符串大于第二个字符串 ----------------------------------------------------. 12345678910----------------------------------------------------------------- 函 数 名 作 用----------------------------------------------------------------- strcmp() 对两个字符串进行大小写敏感的比较 strcmpi() 对两个字符串进行大小写不敏感的比较 stricmp() 同strcmpi() strncmp() 对两个字符串的一部分进行大小写敏感的比较 strnicmp() 对两个字符串的一部分进行大小写不敏感的比较-----------------------------------------------------------------.在前面的例子中，如果用strcmpi()函数代替strcmp()函数，则程序将认为字符串“ABC”等于“abc”。","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"17.0、gets、fgets","slug":"C/17.0、gets、fgets","date":"2012-09-28T21:49:03.000Z","updated":"2020-08-07T14:10:11.661Z","comments":true,"path":"2012/09/29/C/17.0、gets、fgets/","link":"","permalink":"https://www.zackaddy.xin/2012/09/29/C/17.0、gets、fgets/","excerpt":"","text":"12345678//越界检查，截取//会把换行符也读进去char buf[100];fgets(buf, sizeof buf, stdin);printf(\"%s\", buf)//gets允许有空格，但不做越界检查gets(buf)","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"16.0、printf格式化字符","slug":"C/16.0、printf格式化字符","date":"2012-09-28T04:04:01.000Z","updated":"2020-08-07T14:10:11.660Z","comments":true,"path":"2012/09/28/C/16.0、printf格式化字符/","link":"","permalink":"https://www.zackaddy.xin/2012/09/28/C/16.0、printf格式化字符/","excerpt":"","text":"打印格式 对应数据类型 含义 %d int 接受整数值并将它表示为有符号的十进制数 %hd short int 短整型 %hu unsigned short 无符号短整形 %o unsigned int 无符号8进制整数 %u unsigned int 无符号10进制整数 %x,%X unsigned int 无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF %f float 单精度浮点数 %lf double 双精度浮点数 %e,%E double 科学计数法表示的数，此处“e”的大小写代表在输出时用的“e”的大小写 %c char 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 %s char * 字符串。输出字符串中字符直到（字符串以\\0结尾） %p void * 以16进制输出指针 %% % 输出一个百分号 %限定符|长度|打印格式 （默认右对其） 12345限定符 0、-0：空补0-：左对齐0、-不能同时使用","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"15.0、register优化内存速度","slug":"C/15.0、register优化内存速度","date":"2012-09-26T19:45:41.000Z","updated":"2020-08-07T14:10:11.660Z","comments":true,"path":"2012/09/27/C/15.0、register优化内存速度/","link":"","permalink":"https://www.zackaddy.xin/2012/09/27/C/15.0、register优化内存速度/","excerpt":"","text":"register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度 12345678void memcpy (d, s, l) &#123; register char *d; register char *s; register int i; while (i--) *d++ = *s++;&#125; ==使用register 修饰符的注意点== register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 因为register变量可能不存放在内存中，所以不能用“&amp;”来获取register变量的地址。 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销 随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"14.0、volatile防止编译器优化","slug":"C/14.0、volatile防止编译器优化","date":"2012-09-26T00:22:58.000Z","updated":"2020-08-07T14:10:11.660Z","comments":true,"path":"2012/09/26/C/14.0、volatile防止编译器优化/","link":"","permalink":"https://www.zackaddy.xin/2012/09/26/C/14.0、volatile防止编译器优化/","excerpt":"","text":"12345678910111213141516int a;a = 1;a = 2;a = 3;a = 4;编译器会优化成int a = 4;加上volatile就不会被优化volatile int a;a = 1;a = 2;a = 3;a = 4;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"13.0、转义字符","slug":"C/13.0、转义字符","date":"2012-09-24T23:56:21.000Z","updated":"2020-08-07T14:10:11.660Z","comments":true,"path":"2012/09/25/C/13.0、转义字符/","link":"","permalink":"https://www.zackaddy.xin/2012/09/25/C/13.0、转义字符/","excerpt":"","text":"转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符’’&#39; 092 \\‘ 代表一个单引号（撇号）字符 039 \\“ 代表一个双引号字符 034 \\? 代表一个问号 063 \\0 空字符(NULL) 000 \\ooo 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 1到2位十六进制所代表的任意字符 二位十六进制","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"12.0、有符号无符号整形取值范围","slug":"C/12.0、有符号无符号整形取值范围","date":"2012-09-23T17:06:55.000Z","updated":"2020-08-07T14:10:11.659Z","comments":true,"path":"2012/09/24/C/12.0、有符号无符号整形取值范围/","link":"","permalink":"https://www.zackaddy.xin/2012/09/24/C/12.0、有符号无符号整形取值范围/","excerpt":"","text":"数据类型 占用空间 取值范围 short 2字节 -32768 到 32767 int 4字节 -2147483647 到 2147483647 long 4字节 -2147483647 到 2147483647 unsigned short 2字节 0 到 65535 unsigned int 2字节 0 到 4294967295 unsigned long 2字节 0 到 4294967295","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"11.0、sizeof","slug":"C/11.0、sizeof","date":"2012-09-23T00:00:44.000Z","updated":"2020-08-07T14:10:11.659Z","comments":true,"path":"2012/09/23/C/11.0、sizeof/","link":"","permalink":"https://www.zackaddy.xin/2012/09/23/C/11.0、sizeof/","excerpt":"","text":"sizeof计算的是在栈中分配的内存大小（sizeof是运算符 不是函数）。 sizeof不计算static变量占得内存； 指针的大小一定是4个字节，而不管是什么类型的指针； char型占1个字节，int占4个字节，shortint占2个字节longint占4个字节，float占4字节，double占48字节，string占4字节一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节 数组的长度：若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）若没有指定长度，则按实际元素个数类确定Ps：若是字符数组，则应考虑末尾的空字符 结构体对象的长度在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。 unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsignedint）=4 自定义类型的sizeof取值等于它的类型原型取sizeof 对函数使用sizeof，在编译阶段会被函数的返回值的类型代替 sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸。","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"10.0、有符号、无符号","slug":"C/10.0、有符号、无符号","date":"2012-09-22T01:47:30.000Z","updated":"2020-08-07T14:10:11.659Z","comments":true,"path":"2012/09/22/C/10.0、有符号、无符号/","link":"","permalink":"https://www.zackaddy.xin/2012/09/22/C/10.0、有符号、无符号/","excerpt":"","text":"-3有符号打印：-3无符号打印：4294967293（3的补码） int有符号范围 123451000 0000 0000 0000 0000 0000 0000 0000-0111 1111 1111 1111 1111 1111 1111 1111[-2147483648，2147483647] int无符号范围 123450 0000 0000 0000 0000 0000 0000 0000 0000-0 1111 1111 1111 1111 1111 1111 1111 1111[0, 4294967295] char: 12有符号： -128 - 127 （127 + 2 越界后 值为 -127）无符号： 0 - 255 （255 + 2 越界后 值为 1）","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"9.0、原码、反码和补码","slug":"C/9.0、原码、反码和补码","date":"2012-09-21T01:44:05.000Z","updated":"2020-08-07T14:10:11.674Z","comments":true,"path":"2012/09/21/C/9.0、原码、反码和补码/","link":"","permalink":"https://www.zackaddy.xin/2012/09/21/C/9.0、原码、反码和补码/","excerpt":"","text":"原码、反码和补码1).数据在内存中存储的时候都是以二进制的形式存储的. int num = 10; 原码、反码、补码都是二进制.只不过是二进制的不同的表现形式. 数据是以补码的二进制存储的. 2). 1个int类型的变量.在内存中占据4个字节, 32位. 00000000 00000000 00000000 00000000 在不考虑正负的情况下.1个int类型的变量可以表示接近43e种数据. 为了可以表示正负性.使用最高为来表示这个数的正负性. 如果最高为是0 那么表示这个数是1个正数 如果最高为是1 那么表示这个数是1个负数. 所以,来表示数据的只有31位. 所以,1个int类型的变量. 最小值是: -2147483648 最大值是:2147483647 3). 原码 最高位表示符号位. 剩下的位数.是这个数的绝对值的二进制. 10的原码. 00000000 00000000 00000000 00001010 -8的原码. 10000000 00000000 00000000 00001000 绝对值: 正数的绝对值是自己,负数的绝对值去掉负号. -20. 10000000 00000000 00000000 00010100 4). 反码 正数的反码就是其原码. 负数的反码就是在其原码的基础之上 符号位不变,其他位取反. 10的反码: 10的原码:00000000 00000000 00000000 00001010 10的反码:00000000 00000000 00000000 00001010 -8 -8的原码:10000000 00000000 00000000 00001000 -8的反码:11111111 11111111 11111111 111101115). 补码 正数的补码就是其原码. 负数的补码就是在其反码的基础之上+1 10. 10的原码:00000000 00000000 00000000 00001010 10的反码:00000000 00000000 00000000 00001010 10的补码:00000000 00000000 00000000 00001010 -8 -8的原码:10000000 00000000 00000000 00001000 -8的反码:11111111 11111111 11111111 11110111 -8的补码:11111111 11111111 11111111 11111000 6). 任何数据都是以其二进制的补码形式存储在内存中的. int num = -8; 7). 为什么数据要以补码的形式存储呢? 计算机中只有加法没有减法.为了更加低成本的计算出结果,所以使用补码来存储数据. 3 + 2; 3 - 2; 这个减法运算对于计算机而言它的理解是 3 + (-2); 1 使用原码计算. 3的原码 00000000 00000000 00000000 00000011 -2的原码 10000000 00000000 00000000 00000010 ---------------------------------------------------- 10000000 00000000 00000000 00000101 结果是1个负数明显是不对的 使用反码计算. 3 的反码: 00000000 00000000 00000000 00000011 -2的反码: 11111111 11111111 11111111 11111101 -------------------------------------------------- 00000000 00000000 00000000 00000000 0 使用补码计算 3 的补码: 00000000 00000000 00000000 00000011 -2的补码: 11111111 11111111 11111111 11111110 ------------------------------------------------- 00000000 00000000 00000000 00000001 1 注:使用补码来做运算效率是最高的.","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"8.0、关键字","slug":"C/8.0、关键字","date":"2012-09-20T00:55:05.000Z","updated":"2020-08-07T14:10:11.674Z","comments":true,"path":"2012/09/20/C/8.0、关键字/","link":"","permalink":"https://www.zackaddy.xin/2012/09/20/C/8.0、关键字/","excerpt":"","text":"c89 | - | - | -|char | short | int | unsignedlong | float | double | structunion | void| enum| signedconst | volatile| typedef| autoregister | static| extern| breakcase | continue| default| doelse| for| goto| ifreturn| switch| while| sizeof c99 | - | - | -| -|||||_Alignas| _Alignof| _Atomic |_Generic |_Noreturn| _Static_assert|_Thread_local","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"7.0、vs2015查看反汇编代码","slug":"C/7.0、vs2015查看反汇编代码","date":"2012-09-18T18:46:22.000Z","updated":"2020-08-07T14:10:11.673Z","comments":true,"path":"2012/09/19/C/7.0、vs2015查看反汇编代码/","link":"","permalink":"https://www.zackaddy.xin/2012/09/19/C/7.0、vs2015查看反汇编代码/","excerpt":"","text":"打断点 F5进入调试模式 vs2015界面工具条-调试-窗口-反汇编","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"6.0、插入汇编代码","slug":"C/6.0、插入汇编代码","date":"2012-09-18T03:22:12.000Z","updated":"2020-08-07T14:10:11.670Z","comments":true,"path":"2012/09/18/C/6.0、插入汇编代码/","link":"","permalink":"https://www.zackaddy.xin/2012/09/18/C/6.0、插入汇编代码/","excerpt":"","text":"12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char ** argv) &#123; int a, b, c; /*__asm &#123; mov a,3 mov b,4 mov eax, a add eax, b mov c, eax &#125;*/ a = 3; b = 4; c = a + b; printf(\"%d\\n\", c); system(\"pause\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"5.0、gcc编译过程","slug":"C/5.0、gcc编译过程","date":"2012-09-16T23:19:13.000Z","updated":"2020-08-07T14:10:11.668Z","comments":true,"path":"2012/09/17/C/5.0、gcc编译过程/","link":"","permalink":"https://www.zackaddy.xin/2012/09/17/C/5.0、gcc编译过程/","excerpt":"","text":"预处理-合并头文件 编译-转为汇编 汇编-转为机器码 链接-将汇编生成的OBJ文件、系统库的OBJ文件、库文件链接起来，最终生成可以在特定平台运行的可执行程序","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"4.0、system","slug":"C/4.0、system","date":"2012-09-15T17:40:26.000Z","updated":"2020-08-07T14:10:11.666Z","comments":true,"path":"2012/09/16/C/4.0、system/","link":"","permalink":"https://www.zackaddy.xin/2012/09/16/C/4.0、system/","excerpt":"","text":"C中system()函数的用法 c语言中的system（）函数主要用于发出一个DOS命令,该函数已经收录在标准c库中，可以直接调用。 12345678#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void) &#123; printf(\"About to spawn command.com and run a DOS command\\n\"); system(\"dir\"); return 0; &#125; 上面的程序相当于在DOS下运行dir命令，可以得到当前目录中的所有文件。 又如： system(“pause”)可以实现冻结屏幕 system(“CLS”)可以实现清屏操作 system(“color 0A”) color后面的0是背景色代号，A是前景色代号。各颜色代号如下： 0=黑色 1=蓝色 2=绿色 3=湖绿色 4=红色 5=紫色 6=黄色 7=白色 8=灰色 9=淡蓝色 A=淡绿色 B=淡浅绿色 C=淡红色 D=淡紫色 E=淡黄色 F=亮白色 demo1：c语言调用DOS命令实现定时关机 1234567891011121314151617181920212223242526272829303132333435363738 #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; int print() &#123; printf(\" ╪╪╪╪╪╪╧╧╧╧╧╧╧╧╪╪╪╪╪╪\\n\"); printf(\"╔═══╧╧ C语言 关机程序 ╧╧═══╗\\n\"); printf(\"║※1.实现10分钟内的定时关闭计算机 ║\\n\"); printf(\"║※2.立即关闭计算机 ║\\n\"); printf(\"║※3.注销计算机 ║\\n\"); printf(\"║※0.退出系统 ║\\n\"); printf(\"╚═══════════════════╝\\n\"); return 0; &#125; void main() &#123; system(\"title C语言关机程序\");//设置cmd窗口标题 system(\"mode con cols=48 lines=25\");//窗口宽度高度 system(\"color 0B\"); system(\"date /T\"); system(\"TIME /T\"); char cmd[20]=\"shutdown -s -t \"; char t[5]=\"0\"; print(); int c; scanf(\"%d\",&amp;c); getchar(); switch(c) &#123; case 1:printf(\"您想在多少秒后自动关闭计算机？（0~600）\\n\");scanf(\"%s\",t);system(strcat(cmd,t));break; case 2:system(\"shutdown -p\");break; case 3:system(\"shutdown -l\");break; case 0:break; default:printf(\"Error!\\n\"); &#125; system(\"pause\"); exit(0); &#125; demo2：用c语言删除文件，例如文件的位置是：d：\\123.txt 1234567#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void) &#123; system(\"del d:\\123.txt\"); return 0; &#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"3.0、getchar","slug":"C/3.0、getchar","date":"2012-09-15T04:16:38.000Z","updated":"2020-08-07T14:10:11.664Z","comments":true,"path":"2012/09/15/C/3.0、getchar/","link":"","permalink":"https://www.zackaddy.xin/2012/09/15/C/3.0、getchar/","excerpt":"","text":"实际上getchar函数是从缓冲区读取数据的,而不是从你的屏幕上读取数据. 键盘负责往缓冲区写入数据,而getchar函数负责读取数据. getchar函数不会关心你实际输入的是什么,它只负责从缓冲区读取数据,而且每次读取一个字符. 你点击键盘的时候,实际上是往缓冲区输入: 你按下a,则缓冲区中保存了一个字符a 你按下b,则缓冲区中又保存了一个字符b 你按下c,则缓冲区中又保存了一个字符c 你按下1,则缓冲区中又保存了一个字符1 你按下backspace删除键,则缓冲区中删除了一个字符(最后保存的那个1) 除非你按下Enter,不然你其实就是在往缓冲区中塞数据.关键点来了:当你按下Enter的时候,发生了两个动作.首先是往缓冲区保存了一个’\\n’字符,然后才执行刷新 刷新其实就是告诉getchar(或者任何需要读取这个缓冲区的函数，比如scanf),现在你可以开始读取我保存的数据了 于是现在缓冲区中保存的数据是[a,b,c,’\\n’] ,注意缓冲区的最后会有一个换行符(因为你敲了Enter键). 好,现在开始读取数据: 第一次调用getchar,则读取缓冲区中的第一个数据a 第二次调用getchar,将会读取缓冲区中的第二个数据b 第三次调用getchar,将会读取缓冲区中的第三个数据c 第四次调用getchar,将会读取缓冲区中的最后一个数据’\\n’,也就是换行符. 如果你while循环来调用n次getchar(),就会按顺序读取缓冲区n次,就好像是按顺序读取数组一样. 如果getchar()发现缓冲区中没数据了,也就是说缓冲区的数据已经被读完了,没数据可读了.那么getchar函数会等你再次输入数据并且按下Enter执行刷新. 如果缓冲区有8个字符,你却只调用了5次getchar,那么缓冲区会剩下3个字符.因为你只读了5个字符. 为什么要使用缓冲区呢? 基本的设计考虑是节约时间,提高资源利用率.并且还附带一个额外功能:可以修改缓冲区的数据,修正错误的输入.","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"2.0、进制转换","slug":"C/2.0、进制转换","date":"2012-09-13T20:25:02.000Z","updated":"2020-08-07T14:10:11.661Z","comments":true,"path":"2012/09/14/C/2.0、进制转换/","link":"","permalink":"https://www.zackaddy.xin/2012/09/14/C/2.0、进制转换/","excerpt":"","text":"二进制转十进制： 121101.01（2）=1*2^0+0*2^1+1*2^2+1*2^3+0*2^-1+1*2^-2=1+0+4+8+0+0.25=13.25 十进制转二进制： 12345610 = 1010#计算如下10 / 2 = 5'''''''''''''05 / 2 = 2'''''''''''''12 / 2 = 1'''''''''''''01 / 2 = 0'''''''''''''1 十进制小数转二进制： 12345670.8125 = 0.1101#计算如下0.8125x2=1.625 取整1,小数部分是0.6250.625x2=1.25 取整1,小数部分是0.250.25x2=0.5 取整0,小数部分是0.50.5x2=1.0 取整1,小数部分是0，结束#所以0.8125的二进制是0.1101 任何进制转十进制 12345一个数的每一位都有一个权值,例如十进制数2039它可以表示为:2*10^3+0*10^2+3*10^1+9*10^0那么任何进制的数都一样#例如16进制数8A30E#8*16^4+10*16^3+3*16^2+0*16^1+14*16^0 = 566030","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]},{"title":"1.0、HelloWorld","slug":"C/1.0、HelloWorld","date":"2012-09-12T19:01:04.000Z","updated":"2020-08-07T14:10:11.658Z","comments":true,"path":"2012/09/13/C/1.0、HelloWorld/","link":"","permalink":"https://www.zackaddy.xin/2012/09/13/C/1.0、HelloWorld/","excerpt":"","text":"下载vstudio 新建项目-win32控制台程序 新建hello.c 输入以下代码 12345#include&lt;stdio.h&gt;int main() &#123; printf(\"Hello world\\n\"); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/tags/C/"}],"keywords":[{"name":"C","slug":"C","permalink":"https://www.zackaddy.xin/categories/C/"}]}]}